-- --
An Introduction to the C shell
William Joy (revised for 4.3BSD by Mark Seiden)
Computer Science Division Department of Electrical Engineering and Computer Science
University of California, Berkeley Berkeley, California 94720
ABSTRACT
Csh is a new command language interpreter for UNIX systems. It incorporates good features of other shells and a history mechanism similar to the redo of INTERLISP. While incorporating many features of other shells which make writing shell programs (shell scripts) easier, most of the features unique to csh are designed more for the interactive UNIX user.
UNIX users who have read a general introduction to the system will nd a valuable basic explanation of the shell here. Simple terminal interaction with csh is possible after reading just the rst section of this document. The second section describes the shell's capabilities which you can explore after you have begun to become acquainted with the shell. Later sections introduce features which are useful, but not necessary for all users of the shell.
Additional information includes an appendix listing special characters of the shell and a glossary of terms and commands introduced in this manual.
Introduction A shell is a command language interpreter. Csh is the name of one particular command interpreter
on UNIX. The primary purpose of csh is to translate command lines typed at a terminal into system actions, such as invocation of other programs. Csh is a user program just like any you might write. Hopefully, csh will be a very useful program for you in interacting with the UNIX system.
In addition to this document, you will want to refer to a copy of the UNIX User Reference Manual. The csh documentation in section 1 of the manual provides a full description of all features of the shell and is the denitive reference for questions about the shell.
Many words in this document are shown in italics. These are important words; names of commands, and words which have special meaning in discussing the shell and UNIX. Many of the words are dened in a glossary at the end of this document. If you don't know what is meant by a word, you should look for it in the glossary.
Acknowledgements Numerous people have provided good input about previous versions of csh and aided in its debug-
ging and in the debugging of its documentation. I would especially like to thank Michael Ubell who made the crucial observation that history commands could be done well over the word structure of input text, and implemented a prototype history mechanism in an older version of the shell. Eric Allman has also provided a large number of useful comments on the shell, helping to unify those concepts which are present and to
 UNIX is a trademark of Bell Laboratories.

-- --

USD:4-2

An Introduction to the C shell

identify and eliminate useless and marginally useful features. Mike O'Brien suggested the pathname hashing mechanism which speeds command execution. Jim Kulp added the job control and directory stack primitives and added their documentation to this introduction.

-- --

An Introduction to the C shell

USD:4-3

1. Terminal usage of the shell
1.1. The basic notion of commands
A shell in UNIX acts mostly as a medium through which other programs are invoked. While it has a set of builtin functions which it performs directly, most commands cause execution of programs that are, in fact, external to the shell. The shell is thus distinguished from the command interpreters of other systems both by the fact that it is just a user program, and by the fact that it is used almost exclusively as a mechanism for invoking other programs.
Commands in the UNIX system consist of a list of strings or words interpreted as a command name followed by arguments. Thus the command
mail bill
consists of two words. The rst word mail names the command to be executed, in this case the mail program which sends messages to other users. The shell uses the name of the command in attempting to execute it for you. It will look in a number of directories for a le with the name mail which is expected to contain the mail program.
The rest of the words of the command are given as arguments to the command itself when it is executed. In this case we specied also the argument bill which is interpreted by the mail program to be the name of a user to whom mail is to be sent. In normal terminal usage we might use the mail command as follows.
% mail bill I have a question about the csh documentation. My document seems to be missing page 5. Does a page ve exist?
Bill EOT %
Here we typed a message to send to bill and ended this message with a ^D which sent an end-of-le to the mail program. (Here and throughout this document, the notation ``^x'' is to be read ``control-x'' and represents the striking of the x key while the control key is held down.) The mail program then echoed the characters `EOT' and transmitted our message. The characters `% ' were printed before and after the mail command by the shell to indicate that input was needed.
After typing the `% ' prompt the shell was reading command input from our terminal. We typed a complete command `mail bill'. The shell then executed the mail program with argument bill and went dormant waiting for it to complete. The mail program then read input from our terminal until we signalled an end-of-le via typing a ^D after which the shell noticed that mail had completed and signaled us that it was ready to read from the terminal again by printing another `% ' prompt.
This is the essential pattern of all interaction with UNIX through the shell. A complete command is typed at the terminal, the shell executes the command and when this execution completes, it prompts for a new command. If you run the editor for an hour, the shell will patiently wait for you to nish editing and obediently prompt you again whenever you nish editing.
An example of a useful command you can execute now is the tset command, which sets the default erase and kill characters on your terminal ! the erase character erases the last character you typed and the kill character erases the entire line you have entered so far. By default, the erase character is the delete key (equivalent to `^?') and the kill character is `^U'. Some people prefer to make the erase character the backspace key (equivalent to `^H'). You can make this be true by typing
tset !e
which tells the program tset to set the erase character to tset's default setting for this character (a backspace).

-- --

USD:4-4

An Introduction to the C shell

1.2. Flag arguments
A useful notion in UNIX is that of a ag argument. While many arguments to commands specify le names or user names, some arguments rather specify an optional capability of the command which you wish to invoke. By convention, such arguments begin with the character `!' (hyphen). Thus the command
ls
will produce a list of the les in the current working directory . The option !s is the size option, and
ls !s
causes ls to also give, for each le the size of the le in blocks of 512 characters. The manual section for each command in the UNIX reference manual gives the available options for each command. The ls command has a large number of useful and interesting options. Most other commands have either no options or only one or two options. It is hard to remember options of commands which are not used very frequently, so most UNIX utilities perform only one or two functions rather than having a large number of hard to remember options.
1.3. Output to les
Commands that normally read input or write output on the terminal can also be executed with this input and/or output done to a le.
Thus suppose we wish to save the current date in a le called `now'. The command
date
will print the current date on our terminal. This is because our terminal is the default standard output for the date command and the date command prints the date on its standard output. The shell lets us redirect the standard output of a command through a notation using the metacharacter `>' and the name of the le where output is to be placed. Thus the command
date > now
runs the date command such that its standard output is the le `now' rather than the terminal. Thus this command places the current date and time into the le `now'. It is important to know that the date command was unaware that its output was going to a le rather than to the terminal. The shell performed this redirection before the command began executing.
One other thing to note here is that the le `now' need not have existed before the date command was executed; the shell would have created the le if it did not exist. And if the le did exist? If it had existed previously these previous contents would have been discarded! A shell option noclobber exists to prevent this from happening accidentally; it is discussed in section 2.2.
The system normally keeps les which you create with `>' and all other les. Thus the default is for les to be permanent. If you wish to create a le which will be removed automatically, you can begin its name with a `#' character, this `scratch' character denotes the fact that the le will be a scratch le.* The system will remove such les after a couple of days, or sooner if le space becomes very tight. Thus, in running the date command above, we don't really want to save the output forever, so we would more likely do
date > #now

*Note that if your erase character is a `#', you will have to precede the `#' with a `\'. The fact that the `#' character is the old (pre-CRT) standard erase character means that it seldom appears in a le name, and allows this convention to be used for scratch les. If you are using a CRT, your erase character should be a ^H, as we demonstrated in section 1.1 how this could be set up.

-- --

An Introduction to the C shell

USD:4-5

1.4. Metacharacters in the shell
The shell has a large number of special characters (like `>') which indicate special functions. We say that these notations have syntactic and semantic meaning to the shell. In general, most characters which are neither letters nor digits have special meaning to the shell. We shall shortly learn a means of quotation which allows us to use metacharacters without the shell treating them in any special way.
Metacharacters normally have effect only when the shell is reading our input. We need not worry about placing shell metacharacters in a letter we are sending via mail, or when we are typing in text or data to some other program. Note that the shell is only reading input when it has prompted with `% ' (although we can type our input even before it prompts).
1.5. Input from les; pipelines
We learned above how to redirect the standard output of a command to a le. It is also possible to redirect the standard input of a command from a le. This is not often necessary since most commands will read from a le whose name is given as an argument. We can give the command
sort < data
to run the sort command with standard input, where the command normally reads its input, from the le `data'. We would more likely say
sort data
letting the sort command open the le `data' for input itself since this is less to type.
We should note that if we just typed
sort
then the sort program would sort lines from its standard input. Since we did not redirect the standard input, it would sort lines as we typed them on the terminal until we typed a ^D to indicate an end-of-le.
A most useful capability is the ability to combine the standard output of one command with the standard input of another, i.e. to run the commands in a sequence known as a pipeline. For instance the command
ls !s
normally produces a list of the les in our directory with the size of each in blocks of 512 characters. If we are interested in learning which of our les is largest we may wish to have this sorted by size rather than by name, which is the default way in which ls sorts. We could look at the many options of ls to see if there was an option to do this but would eventually discover that there is not. Instead we can use a couple of simple options of the sort command, combining it with ls to get what we want.
The !n option of sort species a numeric sort rather than an alphabetic sort. Thus
ls !s | sort !n
species that the output of the ls command run with the option !s is to be piped to the command sort run with the numeric sort option. This would give us a sorted list of our les by size, but with the smallest rst. We could then use the !r reverse sort option and the head command in combination with the previous command doing
ls !s | sort !n !r | head !5
Here we have taken a list of our les sorted alphabetically, each with the size in blocks. We have run this to the standard input of the sort command asking it to sort numerically in reverse order (largest rst). This output has then been run into the command head which gives us the rst few lines. In this case we have asked head for the rst 5 lines. Thus this command gives us the names and sizes of our 5 largest les.
The notation introduced above is called the pipe mechanism. Commands separated by ` | ' characters are connected together by the shell and the standard output of each is run into the standard input of the next. The leftmost command in a pipeline will normally take its standard input from the terminal and the

-- --

USD:4-6

An Introduction to the C shell

rightmost will place its standard output on the terminal. Other examples of pipelines will be given later when we discuss the history mechanism; one important use of pipes which is illustrated there is in the routing of information to the line printer.
1.6. Filenames
Many commands to be executed will need the names of les as arguments. UNIX pathnames consist of a number of components separated by `/'. Each component except the last names a directory in which the next component resides, in effect specifying the path of directories to follow to reach the le. Thus the pathname
/etc/motd
species a le in the directory `etc' which is a subdirectory of the root directory `/'. Within this directory the le named is `motd' which stands for `message of the day'. A pathname that begins with a slash is said to be an absolute pathname since it is specied from the absolute top of the entire directory hierarchy of the system (the root ). Pathnames which do not begin with `/' are interpreted as starting in the current working directory , which is, by default, your home directory and can be changed dynamically by the cd change directory command. Such pathnames are said to be relative to the working directory since they are found by starting in the working directory and descending to lower levels of directories for each component of the pathname. If the pathname contains no slashes at all then the le is contained in the working directory itself and the pathname is merely the name of the le in this directory. Absolute pathnames have no relation to the working directory.
Most lenames consist of a number of alphanumeric characters and `.'s (periods). In fact, all printing characters except `/' (slash) may appear in lenames. It is inconvenient to have most non-alphabetic characters in lenames because many of these have special meaning to the shell. The character `.' (period) is not a shell-metacharacter and is often used to separate the extension of a le name from the base of the name. Thus
prog.c prog.o prog.errs prog.output
are four related les. They share a base portion of a name (a base portion being that part of the name that is left when a trailing `.' and following characters which are not `.' are stripped off). The le `prog.c' might be the source for a C program, the le `prog.o' the corresponding object le, the le `prog.errs' the errors resulting from a compilation of the program and the le `prog.output' the output of a run of the program.
If we wished to refer to all four of these les in a command, we could use the notation
prog.*
This expression is expanded by the shell, before the command to which it is an argument is executed, into a list of names which begin with `prog.'. The character `*' here matches any sequence (including the empty sequence) of characters in a le name. The names which match are alphabetically sorted and placed in the argument list of the command. Thus the command
echo prog.*
will echo the names
prog.c prog.errs prog.o prog.output
Note that the names are in sorted order here, and a different order than we listed them above. The echo command receives four words as arguments, even though we only typed one word as as argument directly. The four words were generated by lename expansion of the one input word.
Other notations for lename expansion are also available. The character `?' matches any single character in a lename. Thus
echo ? ?? ???
will echo a line of lenames; rst those with one character names, then those with two character names, and nally those with three character names. The names of each length will be independently sorted.

-- --

An Introduction to the C shell

USD:4-7

Another mechanism consists of a sequence of characters between `[' and `]'. This metasequence matches any single character from the enclosed set. Thus
prog.[co]
will match
prog.c prog.o
in the example above. We can also place two characters around a `!' in this notation to denote a range. Thus
chap.[1!5]
might match les
chap.1 chap.2 chap.3 chap.4 chap.5
if they existed. This is shorthand for
chap.[12345]
and otherwise equivalent. An important point to note is that if a list of argument words to a command (an argument list) con-
tains lename expansion syntax, and if this lename expansion syntax fails to match any existing le names, then the shell considers this to be an error and prints a diagnostic
No match.
and does not execute the command. Another very important point is that les with the character `.' at the beginning are treated specially.
Neither `*' or `?' or the `[' `]' mechanism will match it. This prevents accidental matching of the lenames `.' and `..' in the working directory which have special meaning to the system, as well as other les such as .cshrc which are not normally visible. We will discuss the special role of the le .cshrc later.
Another lename expansion mechanism gives access to the pathname of the home directory of other users. This notation consists of the character `~' (tilde) followed by another user's login name. For instance the word `~bill' would map to the pathname `/usr/bill' if the home directory for `bill' was `/usr/bill'. Since, on large systems, users may have login directories scattered over many different disk volumes with different prex directory names, this notation provides a convenient way of accessing the les of other users.
A special case of this notation consists of a `~' alone, e.g. `~/mbox'. This notation is expanded by the shell into the le `mbox' in your home directory, i.e. into `/usr/bill/mbox' for me on Ernie Co-vax, the UCB Computer Science Department VAX machine, where this document was prepared. This can be very useful if you have used cd to change to another directory and have found a le you wish to copy using cp. If I give the command
cp thatle ~
the shell will expand this command to
cp thatle /usr/bill
since my home directory is /usr/bill. There also exists a mechanism using the characters `{' and `}' for abbreviating a set of words which
have common parts but cannot be abbreviated by the above mechanisms because they are not les, are the names of les which do not yet exist, are not thus conveniently described. This mechanism will be described much later, in section 4.2, as it is used less frequently.
1.7. Quotation We have already seen a number of metacharacters used by the shell. These metacharacters pose a
problem in that we cannot use them directly as parts of words. Thus the command

-- --

USD:4-8

An Introduction to the C shell

echo *
will not echo the character `*'. It will either echo an sorted list of lenames in the current working directory, or print the message `No match' if there are no les in the working directory.
The recommended mechanism for placing characters which are neither numbers, digits, `/', `.' or `!' in an argument word to a command is to enclose it with single quotation characters `´', i.e.
echo ´*´
There is one special character `!' which is used by the history mechanism of the shell and which cannot be escaped by placing it within `´' characters. It and the character `´' itself can be preceded by a single `\' to prevent their special meaning. Thus
echo \´\!
prints
´!
These two mechanisms sufce to place any printing character into a word which is an argument to a shell command. They can be combined, as in
echo \´´*´
which prints
´*
since the rst `\' escaped the rst `´' and the `*' was enclosed between `´' characters.
1.8. Terminating commands When you are executing a command and the shell is waiting for it to complete there are several ways
to force it to stop. For instance if you type the command
cat /etc/passwd
the system will print a copy of a list of all users of the system on your terminal. This is likely to continue for several minutes unless you stop it. You can send an INTERRUPT signal to the cat command by typing ^C on your terminal.* Since cat does not take any precautions to avoid or otherwise handle this signal the INTERRUPT will cause it to terminate. The shell notices that cat has terminated and prompts you again with `% '. If you hit INTERRUPT again, the shell will just repeat its prompt since it handles INTERRUPT signals and chooses to continue to execute commands rather than terminating like cat did, which would have the effect of logging you out.
Another way in which many programs terminate is when they get an end-of-le from their standard input. Thus the mail program in the rst example above was terminated when we typed a ^D which generates an end-of-le from the standard input. The shell also terminates when it gets an end-of-le printing `logout'; UNIX then logs you off the system. Since this means that typing too many ^D's can accidentally log us off, the shell has a mechanism for preventing this. This ignoreeof option will be discussed in section 2.2.
If a command has its standard input redirected from a le, then it will normally terminate when it reaches the end of this le. Thus if we execute
mail bill < prepared.text
the mail command will terminate without our typing a ^D. This is because it read to the end-of-le of our le `prepared.text' in which we placed a message for `bill' with an editor program. We could also have done
*On some older Unix systems the DEL or RUBOUT key has the same effect. "stty all" will tell you the INTR key value.

-- --

An Introduction to the C shell

USD:4-9

cat prepared.text | mail bill

since the cat command would then have written the text through the pipe to the standard input of the mail command. When the cat command completed it would have terminated, closing down the pipeline and the mail command would have received an end-of-le from it and terminated. Using a pipe here is more complicated than redirecting input so we would more likely use the rst form. These commands could also have been stopped by sending an INTERRUPT.
Another possibility for stopping a command is to suspend its execution temporarily, with the possibility of continuing execution later. This is done by sending a STOP signal via typing a ^Z. This signal causes all commands running on the terminal (usually one but more if a pipeline is executing) to become suspended. The shell notices that the command(s) have been suspended, types `Stopped' and then prompts for a new command. The previously executing command has been suspended, but otherwise unaffected by the STOP signal. Any other commands can be executed while the original command remains suspended. The suspended command can be continued using the fg command with no arguments. The shell will then retype the command to remind you which command is being continued, and cause the command to resume execution. Unless any input les in use by the suspended command have been changed in the meantime, the suspension has no effect whatsoever on the execution of the command. This feature can be very useful during editing, when you need to look at another le before continuing. An example of command suspension follows.

% mail harold

Someone just copied a big le into my directory and its name is

^Z

Stopped

% ls

funnyle

prog.c

prog.o

% jobs

[1] + Stopped

mail harold

% fg

mail harold

funnyle. Do you know who did it?

EOT

%

In this example someone was sending a message to Harold and forgot the name of the le he wanted to mention. The mail command was suspended by typing ^Z. When the shell noticed that the mail program was suspended, it typed `Stopped' and prompted for a new command. Then the ls command was typed to nd out the name of the le. The jobs command was run to nd out which command was suspended. At this time the fg command was typed to continue execution of the mail program. Input to the mail program was then continued and ended with a ^D which indicated the end of the message at which time the mail program typed EOT. The jobs command will show which commands are suspended. The ^Z should only be typed at the beginning of a line since everything typed on the current line is discarded when a signal is sent from the keyboard. This also happens on INTERRUPT, and QUIT signals. More information on suspending jobs and controlling them is given in section 2.6.
If you write or run programs which are not fully debugged then it may be necessary to stop them somewhat ungracefully. This can be done by sending them a QUIT signal, sent by typing a ^\. This will usually provoke the shell to produce a message like:

Quit (Core dumped)

indicating that a le `core' has been created containing information about the running program's state when it terminated due to the QUIT signal. You can examine this le yourself, or forward information to the maintainer of the program telling him/her where the core le is.

-- --

USD:4-10

An Introduction to the C shell

If you run background commands (as explained in section 2.6) then these commands will ignore INTERRUPT and QUIT signals at the terminal. To stop them you must use the kill command. See section 2.6 for an example.
If you want to examine the output of a command without having it move off the screen as the output of the
cat /etc/passwd
command will, you can use the command
more /etc/passwd
The more program pauses after each complete screenful and types `!!More!!' at which point you can hit a space to get another screenful, a return to get another line, a `?' to get some help on other commands, or a `q' to end the more program. You can also use more as a lter, i.e.
cat /etc/passwd | more
works just like the more simple more command above.
For stopping output of commands not involving more you can use the ^S key to stop the typeout. The typeout will resume when you hit ^Q or any other key, but ^Q is normally used because it only restarts the output and does not become input to the program which is running. This works well on low-speed terminals, but at 9600 baud it is hard to type ^S and ^Q fast enough to paginate the output nicely, and a program like more is usually used.
An additional possibility is to use the ^O ush output character; when this character is typed, all output from the current command is thrown away (quickly) until the next input read occurs or until the next shell prompt. This can be used to allow a command to complete without having to suffer through the output on a slow terminal; ^O is a toggle, so ushing can be turned off by typing ^O again while output is being ushed.
1.9. What now?
We have so far seen a number of mechanisms of the shell and learned a lot about the way in which it operates. The remaining sections will go yet further into the internals of the shell, but you will surely want to try using the shell before you go any further. To try it you can log in to UNIX and type the following command to the system:
chsh myname /bin/csh
Here `myname' should be replaced by the name you typed to the system prompt of `login:' to get onto the system. Thus I would use `chsh bill /bin/csh'. You only have to do this once; it takes effect at next login. You are now ready to try using csh.
Before you do the `chsh' command, the shell you are using when you log into the system is `/bin/sh'. In fact, much of the above discussion is applicable to `/bin/sh'. The next section will introduce many features particular to csh so you should change your shell to csh before you begin reading it.

-- --

An Introduction to the C shell

USD:4-11

2. Details on the shell for terminal users
2.1. Shell startup and termination
When you login, the shell is started by the system in your home directory and begins by reading commands from a le .cshrc in this directory. All shells which you may start during your terminal session will read from this le. We will later see what kinds of commands are usefully placed there. For now we need not have this le and the shell does not complain about its absence.
A login shell , executed after you login to the system, will, after it reads commands from .cshrc, read commands from a le .login also in your home directory. This le contains commands which you wish to do each time you login to the UNIX system. My .login le looks something like:
set ignoreeof set mail=(/usr/spool/mail/bill) echo "${prompt}users" ; users alias ts \
´set noglob ; eval `tset !s !m dialup:c100rv4pna !m plugboard:?hp2621nl *`´; ts; stty intr ^C kill ^U crt set time=15 history=10 msgs !f if (!e $mail) then
echo "${prompt}mail" mail endif
This le contains several commands to be executed by UNIX each time I login. The rst is a set command which is interpreted directly by the shell. It sets the shell variable ignoreeof which causes the shell to not log me off if I hit ^D. Rather, I use the logout command to log off of the system. By setting the mail variable, I ask the shell to watch for incoming mail to me. Every 5 minutes the shell looks for this le and tells me if more mail has arrived there. An alternative to this is to put the command
biff y
in place of this set; this will cause me to be notied immediately when mail arrives, and to be shown the rst few lines of the new message.
Next I set the shell variable `time' to `15' causing the shell to automatically print out statistics lines for commands which execute for at least 15 seconds of CPU time. The variable `history' is set to 10 indicating that I want the shell to remember the last 10 commands I type in its history list , (described later).
I create an alias ``ts'' which executes a tset (1) command setting up the modes of the terminal. The parameters to tset indicate the kinds of terminal which I usually use when not on a hardwired port. I then execute ``ts'' and also use the stty command to change the interrupt character to ^C and the line kill character to ^U.
I then run the `msgs' program, which provides me with any system messages which I have not seen before; the `!f' option here prevents it from telling me anything if there are no new messages. Finally, if my mailbox le exists, then I run the `mail' program to process my mail.
When the `mail' and `msgs' programs nish, the shell will nish processing my .login le and begin reading commands from the terminal, prompting for each with `% '. When I log off (by giving the logout command) the shell will print `logout' and execute commands from the le `.logout' if it exists in my home directory. After that the shell will terminate and UNIX will log me off the system. If the system is not going down, I will receive a new login message. In any case, after the `logout' message the shell is committed to terminating and will take no further input from my terminal.

-- --

USD:4-12

An Introduction to the C shell

2.2. Shell variables
The shell maintains a set of variables. We saw above the variables history and time which had values `10' and `15'. In fact, each shell variable has as value an array of zero or more strings. Shell variables may be assigned values by the set command. It has several forms, the most useful of which was given above and is
set name=value

Shell variables may be used to store values which are to be used in commands later through a substitution mechanism. The shell variables most commonly referenced are, however, those which the shell itself refers to. By changing the values of these variables one can directly affect the behavior of the shell.
One of the most important variables is the variable path. This variable contains a sequence of directory names where the shell searches for commands. The set command with no arguments shows the value of all variables currently dened (we usually say set) in the shell. The default value for path will be shown by set to be

% set argv cwd home path prompt shell status term user %

() /usr/bill /usr/bill (. /usr/ucb /bin /usr/bin) % /bin/csh 0 c100rv4pna bill

This output indicates that the variable path points to the current directory `.' and then `/usr/ucb', `/bin' and `/usr/bin'. Commands which you may write might be in `.' (usually one of your directories). Commands developed at Berkeley, live in `/usr/ucb' while commands developed at Bell Laboratories live in `/bin' and `/usr/bin'.
A number of locally developed programs on the system live in the directory `/usr/local'. If we wish that all shells which we invoke to have access to these new programs we can place the command

set path=(. /usr/ucb /bin /usr/bin /usr/local)

in our le .cshrc in our home directory. Try doing this and then logging out and back in and do

set

again to see that the value assigned to path has changed.
One thing you should be aware of is that the shell examines each directory which you insert into your path and determines which commands are contained there. Except for the current directory `.', which the shell treats specially, this means that if commands are added to a directory in your search path after you have started the shell, they will not necessarily be found by the shell. If you wish to use a command which has been added in this way, you should give the command

rehash

to the shell, which will cause it to recompute its internal table of command locations, so that it will nd the newly added command. Since the shell has to look in the current directory `.' on each command, placing it at the end of the path specication usually works equivalently and reduces overhead.

 Another directory that might interest you is /usr/new, which contains many useful user-contributed programs provided with Berkeley Unix.

-- --

An Introduction to the C shell

USD:4-13

Other useful built in variables are the variable home which shows your home directory, cwd which contains your current working directory, the variable ignoreeof which can be set in your .login le to tell the shell not to exit when it receives an end-of-le from a terminal (as described above). The variable `ignoreeof' is one of several variables which the shell does not care about the value of, only whether they are set or unset. Thus to set this variable you simply do
set ignoreeof
and to unset it do
unset ignoreeof
These give the variable `ignoreeof' no value, but none is desired or required.
Finally, some other built-in shell variables of use are the variables noclobber and mail. The metasyntax
> lename
which redirects the standard output of a command will overwrite and destroy the previous contents of the named le. In this way you may accidentally overwrite a le which is valuable. If you would prefer that the shell not overwrite les in this way you can
set noclobber
in your .login le. Then trying to do
date > now
would cause a diagnostic if `now' existed already. You could type
date >! now
if you really wanted to overwrite the contents of `now'. The `>!' is a special metasyntax indicating that clobbering the le is ok.
2.3. The shell's history list
The shell can maintain a history list into which it places the words of previous commands. It is possible to use a notation to reuse commands or words from commands in forming new commands. This mechanism can be used to repeat previous commands or to correct minor typing mistakes in commands.
The following gure gives a sample session involving typical usage of the history mechanism of the shell. In this example we have a very simple C program which has a bug (or two) in it in the le `bug.c', which we `cat' out on our terminal. We then try to run the C compiler on it, referring to the le again as `!$', meaning the last argument to the previous command. Here the `!' is the history mechanism invocation metacharacter, and the `$' stands for the last argument, by analogy to `$' in the editor which stands for the end of the line. The shell echoed the command, as it would have been typed without use of the history mechanism, and then executed it. The compilation yielded error diagnostics so we now run the editor on the le we were trying to compile, x the bug, and run the C compiler again, this time referring to this command simply as `!c', which repeats the last command which started with the letter `c'. If there were other commands starting with `c' done recently we could have said `!cc' or even `!cc:p' which would have printed the last command starting with `cc' without executing it.
After this recompilation, we ran the resulting `a.out' le, and then noting that there still was a bug, ran the editor again. After xing the program we ran the C compiler again, but tacked onto the command an extra `!o bug' telling the compiler to place the resultant binary in the le `bug' rather than `a.out'. In general, the history mechanisms may be used anywhere in the formation of new commands and other characters may be placed before and after the substituted commands.
The space between the `!' and the word `now' is critical here, as `!now' would be an invocation of the history mechanism, and have a totally different effect.

--
USD:4-14
% cat bug.c main()
{ printf("hello);
} % cc !$ cc bug.c "bug.c", line 4: newline in string or char constant "bug.c", line 5: syntax error % ed !$ ed bug.c 29 4s/);/"&/p
printf("hello"); w 30 q % !c cc bug.c % a.out hello% !e ed bug.c 30 4s/lo/lo\\n/p
printf("hello\n"); w 32 q % !c !o bug cc bug.c !o bug % size a.out bug a.out: 2784+364+1028 = 4176b = 0x1050b bug: 2784+364+1028 = 4176b = 0x1050b % ls !l !* ls !l a.out bug !rwxr!xr!x 1 bill 3932 Dec 19 09:41 a.out !rwxr!xr!x 1 bill 3932 Dec 19 09:42 bug % bug hello % num bug.c | spp spp: Command not found. % ^spp^ssp num bug.c | ssp
1 main() 3{ 4 printf("hello\n"); 5} % !! | lpr num bug.c | ssp | lpr %

-An Introduction to the C shell

-- --

An Introduction to the C shell

USD:4-15

We then ran the `size' command to see how large the binary program images we have created were, and then an `ls !l' command with the same argument list, denoting the argument list `*'. Finally we ran the program `bug' to see that its output is indeed correct.
To make a numbered listing of the program we ran the `num' command on the le `bug.c'. In order to compress out blank lines in the output of `num' we ran the output through the lter `ssp', but misspelled it as spp. To correct this we used a shell substitute, placing the old text and new text between `^' characters. This is similar to the substitute command in the editor. Finally, we repeated the same command with `!!', but sent its output to the line printer.
There are other mechanisms available for repeating commands. The history command prints out a number of previous commands with numbers by which they can be referenced. There is a way to refer to a previous command by searching for a string which appeared in it, and there are other, less useful, ways to select arguments to include in a new command. A complete description of all these mechanisms is given in the C shell manual pages in the UNIX Programmer's Manual.
2.4. Aliases
The shell has an alias mechanism which can be used to make transformations on input commands. This mechanism can be used to simplify the commands you type, to supply default arguments to commands, or to perform transformations on commands and their arguments. The alias facility is similar to a macro facility. Some of the features obtained by aliasing can be obtained also using shell command les, but these take place in another instance of the shell and cannot directly affect the current shells environment or involve commands such as cd which must be done in the current shell.
As an example, suppose that there is a new version of the mail program on the system called `newmail' you wish to use, rather than the standard mail program which is called `mail'. If you place the shell command
alias mail newmail
in your .cshrc le, the shell will transform an input line of the form
mail bill
into a call on `newmail'. More generally, suppose we wish the command `ls' to always show sizes of les, that is to always do `!s'. We can do
alias ls ls !s
or even
alias dir ls !s
creating a new command syntax `dir' which does an `ls !s'. If we say
dir ~bill
then the shell will translate this to
ls !s /mnt/bill
Thus the alias mechanism can be used to provide short names for commands, to provide default arguments, and to dene new short commands in terms of other commands. It is also possible to dene aliases which contain multiple commands or pipelines, showing where the arguments to the original command are to be substituted using the facilities of the history mechanism. Thus the denition
alias cd ´cd \!* ; ls ´
would do an ls command after each change directory cd command. We enclosed the entire alias denition in `´' characters to prevent most substitutions from occurring and the character `;' from being recognized as a metacharacter. The `!' here is escaped with a `\' to prevent it from being interpreted when the alias command is typed in. The `\!*' here substitutes the entire argument list to the pre-aliasing cd command, without giving an error if there were no arguments. The `;' separating commands is used here to indicate that

-- --

USD:4-16

An Introduction to the C shell

one command is to be done and then the next. Similarly the denition
alias whois ´grep \!^ /etc/passwd´
denes a command which looks up its rst argument in the password le. Warning: The shell currently reads the .cshrc le each time it starts up. If you place a large number
of commands there, shells will tend to start slowly. A mechanism for saving the shell environment after reading the .cshrc le and quickly restoring it is under development, but for now you should try to limit the number of aliases you have to a reasonable number... 10 or 15 is reasonable, 50 or 60 will cause a noticeable delay in starting up shells, and make the system seem sluggish when you execute commands from within the editor and other programs.
2.5. More redirection; >> and >& There are a few more notations useful to the terminal user which have not been introduced yet. In addition to the standard output, commands also have a diagnostic output which is normally
directed to the terminal even when the standard output is redirected to a le or a pipe. It is occasionally desirable to direct the diagnostic output along with the standard output. For instance if you want to redirect the output of a long running command into a le and wish to have a record of any error diagnostic it produces you can do
command >& le
The `>&' here tells the shell to route both the diagnostic output and the standard output into `le'. Similarly you can give the command
command | & lpr
to route both standard and diagnostic output through the pipe to the line printer daemon lpr. Finally, it is possible to use the form
command >> le
to place output at the end of an existing le.
2.6. Jobs; Background, Foreground, or Suspended When one or more commands are typed together as a pipeline or as a sequence of commands sepa-
rated by semicolons, a single job is created by the shell consisting of these commands together as a unit. Single commands without pipes or semicolons create the simplest jobs. Usually, every line typed to the shell creates a job. Some lines that create jobs (one per line) are
sort < data ls !s | sort !n | head !5 mail harold
If the metacharacter `&' is typed at the end of the commands, then the job is started as a background job. This means that the shell does not wait for it to complete but immediately prompts and is ready for another command. The job runs in the background at the same time that normal jobs, called foreground jobs, continue to be read and executed by the shell one at a time. Thus
du > usage &
 A command of the form command >&! le
exists, and is used when noclobber is set and le already exists.  If noclobber is set, then an error will result if le does not exist, otherwise the shell will create le if it doesn't exist. A form
command >>! le makes it not be an error for le to not exist when noclobber is set.

-- --

An Introduction to the C shell

USD:4-17

would run the du program, which reports on the disk usage of your working directory (as well as any directories below it), put the output into the le `usage' and return immediately with a prompt for the next command without out waiting for du to nish. The du program would continue executing in the background until it nished, even though you can type and execute more commands in the mean time. When a background job terminates, a message is typed by the shell just before the next prompt telling you that the job has completed. In the following example the du job nishes sometime during the execution of the mail command and its completion is reported just before the prompt after the mail job is nished.

% du > usage &

[1] 503

% mail bill

How do you know when a background job is nished?

EOT

[1] ! Done

du > usage

%

If the job did not terminate normally the `Done' message might say something else like `Killed'. If you want the terminations of background jobs to be reported at the time they occur (possibly interrupting the output of other foreground jobs), you can set the notify variable. In the previous example this would mean that the `Done' message might have come right in the middle of the message to Bill. Background jobs are unaffected by any signals from the keyboard like the STOP, INTERRUPT, or QUIT signals mentioned earlier.
Jobs are recorded in a table inside the shell until they terminate. In this table, the shell remembers the command names, arguments and the process numbers of all commands in the job as well as the working directory where the job was started. Each job in the table is either running in the foreground with the shell waiting for it to terminate, running in the background, or suspended. Only one job can be running in the foreground at one time, but several jobs can be suspended or running in the background at once. As each job is started, it is assigned a small identifying number called the job number which can be used later to refer to the job in the commands described below. Job numbers remain the same until the job terminates and then are re-used.
When a job is started in the backgound using `&', its number, as well as the process numbers of all its (top level) commands, is typed by the shell before prompting you for another command. For example,

% ls !s | sort !n > usage & [2] 2034 2035 %

runs the `ls' program with the `!s' options, pipes this output into the `sort' program with the `!n' option which puts its output into the le `usage'. Since the `&' was at the end of the line, these two programs were started together as a background job. After starting the job, the shell prints the job number in brackets (2 in this case) followed by the process number of each program started in the job. Then the shell immediates prompts for a new command, leaving the job running simultaneously.
As mentioned in section 1.8, foreground jobs become suspended by typing ^Z which sends a STOP signal to the currently running foreground job. A background job can become suspended by using the stop command described below. When jobs are suspended they merely stop any further progress until started again, either in the foreground or the backgound. The shell notices when a job becomes stopped and reports this fact, much like it reports the termination of background jobs. For foreground jobs this looks like

% du > usage ^Z Stopped %

`Stopped' message is typed by the shell when it notices that the du program stopped. For background jobs, using the stop command, it is

-- --

USD:4-18

An Introduction to the C shell

% sort usage & [1] 2345 % stop %1 [1] + Stopped (signal) %

sort usage

Suspending foreground jobs can be very useful when you need to temporarily change what you are doing (execute other commands) and then return to the suspended job. Also, foreground jobs can be suspended and then continued as background jobs using the bg command, allowing you to continue other work and stop waiting for the foreground job to nish. Thus

% du > usage ^Z Stopped % bg [1] du > usage & %

starts `du' in the foreground, stops it before it nishes, then continues it in the background allowing more foreground commands to be executed. This is especially helpful when a foreground job ends up taking longer than you expected and you wish you had started it in the backgound in the beginning.
All job control commands can take an argument that identies a particular job. All job name arguments begin with the character `%', since some of the job control commands also accept process numbers (printed by the ps command.) The default job (when no argument is given) is called the current job and is identied by a `+' in the output of the jobs command, which shows you which jobs you have. When only one job is stopped or running in the background (the usual case) it is always the current job thus no argument is needed. If a job is stopped while running in the foreground it becomes the current job and the existing current job becomes the previous job ! identied by a `!' in the output of jobs. When the current job terminates, the previous job becomes the current job. When given, the argument is either `%!' (indicating the previous job); `%#', where # is the job number; `%pref' where pref is some unique prex of the command name and arguments of one of the jobs; or `%?' followed by some string found in only one of the jobs.
The jobs command types the table of jobs, giving the job number, commands and status (`Stopped' or `Running') of each backgound or suspended job. With the `!l' option the process numbers are also typed.

% du > usage & [1] 3398 % ls !s | sort !n > myle & [2] 3405 % mail bill ^Z Stopped % jobs [1] ! Running [2] Running [3] + Stopped % fg %ls ls !s | sort !n > myle % more myle

du > usage ls !s | sort !n > myle mail bill

The fg command runs a suspended or background job in the foreground. It is used to restart a previously suspended job or change a background job to run in the foreground (allowing signals or input from the terminal). In the above example we used fg to change the `ls' job from the background to the foreground since we wanted to wait for it to nish before looking at its output le. The bg command runs a suspended job in the background. It is usually used after stopping the currently running foreground job

-- --

An Introduction to the C shell

USD:4-19

with the STOP signal. The combination of the STOP signal and the bg command changes a foreground job into a background job. The stop command suspends a background job.
The kill command terminates a background or suspended job immediately. In addition to jobs, it may be given process numbers as arguments, as printed by ps. Thus, in the example above, the running du command could have been terminated by the command

% kill %1 [1] Terminated %

du > usage

The notify command (not the variable mentioned earlier) indicates that the termination of a specic job should be reported at the time it nishes instead of waiting for the next prompt.
If a job running in the background tries to read input from the terminal it is automatically stopped. When such a job is then run in the foreground, input can be given to the job. If desired, the job can be run in the background again until it requests input again. This is illustrated in the following sequence where the `s' command in the text editor might take a long time.

% ed bigle

120000

1,$s/thisword/thatword/

^Z

Stopped

% bg

[1] ed bigle &

%

. . . some foreground commands

[1] Stopped (tty input)

ed bigle

% fg

ed bigle

w

120000

q

%

So after the `s' command was issued, the `ed' job was stopped with ^Z and then put in the background using bg. Some time later when the `s' command was nished, ed tried to read another command and was stopped because jobs in the backgound cannot read from the terminal. The fg command returned the `ed' job to the foreground where it could once again accept commands from the terminal.
The command

stty tostop

causes all background jobs run on your terminal to stop when they are about to write output to the terminal. This prevents messages from background jobs from interrupting foreground job output and allows you to run a job in the background without losing terminal output. It also can be used for interactive programs that sometimes have long periods without interaction. Thus each time it outputs a prompt for more input it will stop before the prompt. It can then be run in the foreground using fg, more input can be given and, if necessary stopped and returned to the background. This stty command might be a good thing to put in your .login le if you do not like output from background jobs interrupting your work. It also can reduce the need for redirecting the output of background jobs if the output is not very big:

-- --

USD:4-20

An Introduction to the C shell

% stty tostop % wc hugele & [1] 10387 % ed text . . . some time later q [1] Stopped (tty output) % fg wc wc hugele
13371 30123 302577 % stty !tostop

wc hugele

Thus after some time the `wc' command, which counts the lines, words and characters in a le, had one line of output. When it tried to write this to the terminal it stopped. By restarting it in the foreground we allowed it to write on the terminal exactly when we were ready to look at its output. Programs which attempt to change the mode of the terminal will also block, whether or not tostop is set, when they are not in the foreground, as it would be very unpleasant to have a background job change the state of the terminal.
Since the jobs command only prints jobs started in the currently executing shell, it knows nothing about background jobs started in other login sessions or within shell les. The ps can be used in this case to nd out about background jobs not started in the current shell.

2.7. Working Directories
As mentioned in section 1.6, the shell is always in a particular working directory. The `change directory' command chdir (its short form cd may also be used) changes the working directory of the shell, that is, changes the directory you are located in.
It is useful to make a directory for each project you wish to work on and to place all les related to that project in that directory. The `make directory' command, mkdir, creates a new directory. The pwd (`print working directory') command reports the absolute pathname of the working directory of the shell, that is, the directory you are located in. Thus in the example below:
% pwd /usr/bill % mkdir newpaper % chdir newpaper % pwd /usr/bill/newpaper %
the user has created and moved to the directory newpaper. where, for example, he might place a group of related les.
No matter where you have moved to in a directory hierarchy, you can return to your `home' login directory by doing just
cd
with no arguments. The name `..' always means the directory above the current one in the hierarchy, thus
cd ..
changes the shell's working directory to the one directly above the current one. The name `..' can be used in any pathname, thus,
cd ../programs
means change to the directory `programs' contained in the directory above the current one. If you have several directories for different projects under, say, your home directory, this shorthand notation permits you to switch easily between them.

-- --

An Introduction to the C shell

USD:4-21

The shell always remembers the pathname of its current working directory in the variable cwd. The shell can also be requested to remember the previous directory when you change to a new working directory. If the `push directory' command pushd is used in place of the cd command, the shell saves the name of the current working directory on a directory stack before changing to the new one. You can see this list at any time by typing the `directories' command dirs.
% pushd newpaper/references ~/newpaper/references ~ % pushd /usr/lib/tmac /usr/lib/tmac ~/newpaper/references ~ % dirs /usr/lib/tmac ~/newpaper/references ~ % popd ~/newpaper/references ~ % popd ~ %
The list is printed in a horizontal line, reading left to right, with a tilde (~) as shorthand for your home directory--in this case `/usr/bill'. The directory stack is printed whenever there is more than one entry on it and it changes. It is also printed by a dirs command. Dirs is usually faster and more informative than pwd since it shows the current working directory as well as any other directories remembered in the stack.
The pushd command with no argument alternates the current directory with the rst directory in the list. The `pop directory' popd command without an argument returns you to the directory you were in prior to the current one, discarding the previous current directory from the stack (forgetting it). Typing popd several times in a series takes you backward through the directories you had been in (changed to) by pushd command. There are other options to pushd and popd to manipulate the contents of the directory stack and to change to directories not at the top of the stack; see the csh manual page for details.
Since the shell remembers the working directory in which each job was started, it warns you when you might be confused by restarting a job in the foreground which has a different working directory than the current working directory of the shell. Thus if you start a background job, then change the shell's working directory and then cause the background job to run in the foreground, the shell warns you that the working directory of the currently running foreground job is different from that of the shell.
% dirs !l /mnt/bill % cd myproject % dirs ~/myproject % ed prog.c 1143 ^Z Stopped % cd .. % ls myproject textle % fg ed prog.c (wd: ~/myproject)
This way the shell warns you when there is an implied change of working directory, even though no cd command was issued. In the above example the `ed' job was still in `/mnt/bill/project' even though the shell had changed to `/mnt/bill'. A similar warning is given when such a foreground job terminates or is suspended (using the STOP signal) since the return to the shell again implies a change of working directory.

-- --

USD:4-22

An Introduction to the C shell

% fg ed prog.c (wd: ~/myproject) . . . after some editing q (wd now: ~) %
These messages are sometimes confusing if you use programs that change their own working directories, since the shell only remembers which directory a job is started in, and assumes it stays there. The `!l' option of jobs will type the working directory of suspended or background jobs when it is different from the current working directory of the shell.

2.8. Useful built-in commands
We now give a few of the useful built-in commands of the shell describing how they are used.
The alias command described above is used to assign new aliases and to show the existing aliases. With no arguments it prints the current aliases. It may also be given only one argument such as

alias ls

to show the current alias for, e.g., `ls'.
The echo command prints its arguments. It is often used in shell scripts or as an interactive command to see what lename expansions will produce.
The history command will show the contents of the history list. The numbers given with the history events can be used to reference previous events which are difcult to reference using the contextual mechanisms introduced above. There is also a shell variable called prompt. By placing a `!' character in its value the shell will there substitute the number of the current command in the history list. You can use this number to refer to this command in a history substitution. Thus you could

set prompt=´\! % ´

Note that the `!' character had to be escaped here even within `´' characters.
The limit command is used to restrict use of resources. With no arguments it prints the current limitations:

cputime lesize datasize stacksize coredumpsize

unlimited unlimited 5616 kbytes 512 kbytes unlimited

Limits can be set, e.g.:

limit coredumpsize 128k

Most reasonable units abbreviations will work; see the csh manual page for more details.
The logout command can be used to terminate a login shell which has ignoreeof set.
The rehash command causes the shell to recompute a table of where commands are located. This is necessary if you add a command to a directory in the current shell's search path and wish the shell to nd it, since otherwise the hashing algorithm may tell the shell that the command wasn't in that directory when the hash table was computed.
The repeat command can be used to repeat a command several times. Thus to make 5 copies of the le one in the le ve you could do

repeat 5 cat one >> ve

The setenv command can be used to set variables in the environment. Thus

-- --

An Introduction to the C shell

USD:4-23

setenv TERM adm3a
will set the value of the environment variable TERM to `adm3a'. A user program printenv exists which will print out the environment. It might then show:
% printenv HOME=/usr/bill SHELL=/bin/csh PATH=:/usr/ucb:/bin:/usr/bin:/usr/local TERM=adm3a USER=bill %
The source command can be used to force the current shell to read commands from a le. Thus
source .cshrc
can be used after editing in a change to the .cshrc le which you wish to take effect right away.
The time command can be used to cause a command to be timed no matter how much CPU time it takes. Thus
% time cp /etc/rc /usr/bill/rc 0.0u 0.1s 0:01 8% 2+1k 3+2io 1pf+0w % time wc /etc/rc /usr/bill/rc
52 178 1347 /etc/rc 52 178 1347 /usr/bill/rc 104 356 2694 total 0.1u 0.1s 0:00 13% 3+3k 5+3io 7pf+0w %
indicates that the cp command used a negligible amount of user time (u) and about 1/10th of a system time (s); the elapsed time was 1 second (0:01), there was an average memory usage of 2k bytes of program space and 1k bytes of data space over the cpu time involved (2+1k); the program did three disk reads and two disk writes (3+2io), and took one page fault and was not swapped (1pf+0w). The word count command wc on the other hand used 0.1 seconds of user time and 0.1 seconds of system time in less than a second of elapsed time. The percentage `13%' indicates that over the period when it was active the command `wc' used an average of 13 percent of the available CPU cycles of the machine.
The unalias and unset commands can be used to remove aliases and variable denitions from the shell, and unsetenv removes variables from the environment.
2.9. What else?
This concludes the basic discussion of the shell for terminal users. There are more features of the shell to be discussed here, and all features of the shell are discussed in its manual pages. One useful feature which is discussed later is the foreach built-in command which can be used to run the same command sequence with a number of different arguments.
If you intend to use UNIX a lot you you should look through the rest of this document and the csh manual pages (section1) to become familiar with the other facilities which are available to you.

-- --

USD:4-24

An Introduction to the C shell

3. Shell control structures and command scripts
3.1. Introduction It is possible to place commands in les and to cause shells to be invoked to read and execute com-
mands from these les, which are called shell scripts. We here detail those features of the shell useful to the writers of such scripts.
3.2. Make It is important to rst note what shell scripts are not useful for. There is a program called make
which is very useful for maintaining a group of related les or performing sets of operations on related les. For instance a large program consisting of one or more les can have its dependencies described in a makele which contains denitions of the commands used to create these different les when changes occur. Denitions of the means for printing listings, cleaning up the directory in which the les reside, and installing the resultant programs are easily, and most appropriately placed in this makele. This format is superior and preferable to maintaining a group of shell procedures to maintain these les.
Similarly when working on a document a makele may be created which denes how different versions of the document are to be created and which options of nroff or troff are appropriate.
3.3. Invocation and the argv variable A csh command script may be interpreted by saying
% csh script ...
where script is the name of the le containing a group of csh commands and `...' is replaced by a sequence of arguments. The shell places these arguments in the variable argv and then begins to read commands from the script. These parameters are then available through the same mechanisms which are used to reference any other shell variables.
If you make the le `script' executable by doing
chmod 755 script
and place a shell comment at the beginning of the shell script (i.e. begin the le with a `#' character) then a `/bin/csh' will automatically be invoked to execute `script' when you type
script
If the le does not begin with a `#' then the standard shell `/bin/sh' will be used to execute it. This allows you to convert your older shell scripts to use csh at your convenience.
3.4. Variable substitution After each input line is broken into words and history substitutions are done on it, the input line is
parsed into distinct commands. Before each command is executed a mechanism know as variable substitution is done on these words. Keyed by the character `$' this substitution replaces the names of variables by their values. Thus
echo $argv
when placed in a command script would cause the current value of the variable argv to be echoed to the output of the shell script. It is an error for argv to be unset at this point.
A number of notations are provided for accessing components and attributes of variables. The notation
$?name
expands to `1' if name is set or to `0' if name is not set. It is the fundamental mechanism used for checking whether particular variables have been assigned values. All other forms of reference to undened variables cause errors.

-- --

An Introduction to the C shell

USD:4-25

The notation
$#name
expands to the number of elements in the variable name. Thus
% set argv=(a b c) % echo $?argv 1 % echo $#argv 3 % unset argv % echo $?argv 0 % echo $argv Undened variable: argv. %
It is also possible to access the components of a variable which has several values. Thus
$argv[1]
gives the rst component of argv or in the example above `a'. Similarly
$argv[$#argv]
would give `c', and
$argv[1!2]
would give `a b'. Other notations useful in shell scripts are
$n
where n is an integer as a shorthand for
$argv[n ]
the n th parameter and
$*
which is a shorthand for
$argv
The form
$$
expands to the process number of the current shell. Since this process number is unique in the system it can be used in generation of unique temporary le names. The form
$<
is quite special and is replaced by the next line of input read from the shell's standard input (not the script it is reading). This is useful for writing shell scripts that are interactive, reading commands from the terminal, or even writing a shell script that acts as a lter, reading lines from its input le. Thus the sequence
echo 'yes or no?\c' set a=($<)
would write out the prompt `yes or no?' without a newline and then read the answer into the variable `a'. In this case `$#a' would be `0' if either a blank line or end-of-le (^D) was typed.
One minor difference between `$n ' and `$argv[n ]' should be noted here. The form `$argv[n ]' will yield an error if n is not in the range `1!$#argv' while `$n' will never yield an out of range subscript error.

-- --

USD:4-26

An Introduction to the C shell

This is for compatibility with the way older shells handled parameters.
Another important point is that it is never an error to give a subrange of the form `n!'; if there are less than n components of the given variable then no words are substituted. A range of the form `m!n' likewise returns an empty vector without giving an error when m exceeds the number of elements of the given variable, provided the subscript n is in range.
3.5. Expressions
In order for interesting shell scripts to be constructed it must be possible to evaluate expressions in the shell based on the values of variables. In fact, all the arithmetic operations of the language C are available in the shell with the same precedence that they have in C. In particular, the operations `==' and `!=' compare strings and the operators `&&' and `| |' implement the boolean and/or operations. The special operators `=~' and `!~' are similar to `==' and `!=' except that the string on the right side can have pattern matching characters (like *, ? or []) and the test is whether the string on the left matches the pattern on the right.
The shell also allows le enquiries of the form
!? lename
where `?' is replace by a number of single characters. For instance the expression primitive
!e lename
tell whether the le `lename' exists. Other primitives test for read, write and execute access to the le, whether it is a directory, or has non-zero length.
It is possible to test whether a command terminates normally, by a primitive of the form `{ command }' which returns true, i.e. `1' if the command succeeds exiting normally with exit status 0, or `0' if the command terminates abnormally or with exit status non-zero. If more detailed information about the execution status of a command is required, it can be executed and the variable `$status' examined in the next command. Since `$status' is set by every command, it is very transient. It can be saved if it is inconvenient to use it only in the single immediately following command.
For a full list of expression components available see the manual section for the shell.
3.6. Sample shell script
A sample shell script which makes use of the expression mechanism of the shell and some of its control structure follows:

-- --

An Introduction to the C shell

USD:4-27

% cat copyc # # Copyc copies those C programs in the specied list # to the directory ~/backup if they differ from the les # already in ~/backup # set noglob foreach i ($argv)
if ($i !~ *.c) continue # not a .c le so do nothing
if (! !r ~/backup/$i:t) then echo $i:t not in backup... not cp\´ed continue
endif
cmp !s $i ~/backup/$i:t # to set $status
if ($status != 0) then echo new backup of $i cp $i ~/backup/$i:t
endif end
This script makes use of the foreach command, which causes the shell to execute the commands between the foreach and the matching end for each of the values given between `(' and `)' with the named variable, in this case `i' set to successive values in the list. Within this loop we may use the command break to stop executing the loop and continue to prematurely terminate one iteration and begin the next. After the foreach loop the iteration variable (i in this case) has the value at the last iteration.
We set the variable noglob here to prevent lename expansion of the members of argv. This is a good idea, in general, if the arguments to a shell script are lenames which have already been expanded or if the arguments may contain lename expansion metacharacters. It is also possible to quote each use of a `$' variable expansion, but this is harder and less reliable.
The other control construct used here is a statement of the form
if ( expression ) then command ...
endif
The placement of the keywords here is not exible due to the current implementation of the shell.
The shell does have another form of the if statement of the form

The following two formats are not currently acceptable to the shell:

if ( expression ) then
command ... endif

# Won't work!

and

if ( expression ) then command endif

# Won't work

-- --

USD:4-28

An Introduction to the C shell

if ( expression ) command
which can be written
if ( expression ) \ command
Here we have escaped the newline for the sake of appearance. The command must not involve ` | ', `&' or `;' and must not be another control command. The second form requires the nal `\' to immediately precede the end-of-line.
The more general if statements above also admit a sequence of else!if pairs followed by a single else and an endif, e.g.:
if ( expression ) then commands
else if (expression ) then commands
...
else commands
endif
Another important mechanism used in shell scripts is the `:' modier. We can use the modier `:r' here to extract a root of a lename or `:e' to extract the extension. Thus if the variable i has the value `/mnt/foo.bar' then
% echo $i $i:r $i:e /mnt/foo.bar /mnt/foo bar %
shows how the `:r' modier strips off the trailing `.bar' and the the `:e' modier leaves only the `bar'. Other modiers will take off the last component of a pathname leaving the head `:h' or all but the last component of a pathname leaving the tail `:t'. These modiers are fully described in the csh manual pages in the User's Reference Manual. It is also possible to use the command substitution mechanism described in the next major section to perform modications on strings to then reenter the shell's environment. Since each usage of this mechanism involves the creation of a new process, it is much more expensive to use than the `:' modication mechanism. Finally, we note that the character `#' lexically introduces a shell comment in shell scripts (but not from the terminal). All subsequent characters on the input line after a `#' are discarded by the shell. This character can be quoted using `´' or `\' to place it in an argument word.
3.7. Other control structures The shell also has control structures while and switch similar to those of C. These take the forms
while ( expression ) commands
end
 It is also important to note that the current implementation of the shell limits the number of `:' modiers on a `$' substitution to 1. Thus
% echo $i $i:h:t /a/b/c /a/b:t %
does not do what one would expect.

-- --

An Introduction to the C shell

USD:4-29

and
switch ( word )
case str1: commands breaksw
...
case strn: commands breaksw
default: commands breaksw
endsw
For details see the manual section for csh. C programmers should note that we use breaksw to exit from a switch while break exits a while or foreach loop. A common mistake to make in csh scripts is to use break rather than breaksw in switches.
Finally, csh allows a goto statement, with labels looking like they do in C, i.e.:
loop: commands goto loop
3.8. Supplying input to commands Commands run from shell scripts receive by default the standard input of the shell which is running
the script. This is different from previous shells running under UNIX. It allows shell scripts to fully participate in pipelines, but mandates extra notation for commands which are to take inline data.
Thus we need a metanotation for supplying inline data to commands in shell scripts. As an example, consider this script which runs the editor to delete leading blanks from the lines in each argument le:
% cat deblank # deblank !! remove leading blanks foreach i ($argv) ed ! $i << ´EOF´ 1,$s/^[ ]*// w q ´EOF´ end %
The notation `<< ´EOF´' means that the standard input for the ed command is to come from the text in the shell script le up to the next line consisting of exactly `´EOF´'. The fact that the `EOF' is enclosed in `´' characters, i.e. quoted, causes the shell to not perform variable substitution on the intervening lines. In general, if any part of the word following the `<<' which the shell uses to terminate the text to be given to the command is quoted then these substitutions will not be performed. In this case since we used the form `1,$' in our editor script we needed to insure that this `$' was not variable substituted. We could also have insured this by preceding the `$' here with a `\', i.e.:

-- --

USD:4-30

An Introduction to the C shell

1,\$s/^[ ]*//
but quoting the `EOF' terminator is a more reliable way of achieving the same thing.
3.9. Catching interrupts If our shell script creates temporary les, we may wish to catch interruptions of the shell script so
that we can clean up these les. We can then do
onintr label
where label is a label in our program. If an interrupt is received the shell will do a `goto label' and we can remove the temporary les and then do an exit command (which is built in to the shell) to exit from the shell script. If we wish to exit with a non-zero status we can do
exit(1)
e.g. to exit with status `1'.
3.10. What else? There are other features of the shell useful to writers of shell procedures. The verbose and echo
options and the related !v and !x command line options can be used to help trace the actions of the shell. The !n option causes the shell only to read commands and not to execute them and may sometimes be of use.
One other thing to note is that csh will not execute shell scripts which do not begin with the character `#', that is shell scripts that do not begin with a comment. Similarly, the `/bin/sh' on your system may well defer to `csh' to interpret shell scripts which begin with `#'. This allows shell scripts for both shells to live in harmony.
There is also another quotation mechanism using `"' which allows only some of the expansion mechanisms we have so far discussed to occur on the quoted string and serves to make this string into a single word as `´' does.

-- --

An Introduction to the C shell

USD:4-31

4. Other, less commonly used, shell features
4.1. Loops at the terminal; variables as vectors
It is occasionally useful to use the foreach control structure at the terminal to aid in performing a number of similar commands. For instance, there were at one point three shells in use on the Cory UNIX system at Cory Hall, `/bin/sh', `/bin/nsh', and `/bin/csh'. To count the number of persons using each shell one could have issued the commands
% grep !c csh$ /etc/passwd 27 % grep !c nsh$ /etc/passwd 128 % grep !c !v sh$ /etc/passwd 430 %
Since these commands are very similar we can use foreach to do this more easily.
% foreach i (´sh$´ ´csh$´ ´!v sh$´) ? grep !c $i /etc/passwd ? end 27 128 430 %
Note here that the shell prompts for input with `? ' when reading the body of the loop.
Very useful with loops are variables which contain lists of lenames or other words. You can, for example, do
% set a=(`ls`) % echo $a csh.n csh.rm % ls csh.n csh.rm % echo $#a 2 %
The set command here gave the variable a a list of all the lenames in the current directory as value. We can then iterate over these names to perform any chosen function.
The output of a command within ``' characters is converted by the shell to a list of words. You can also place the ``' quoted string within `"' characters to take each (non-empty) line as a component of the variable; preventing the lines from being split into words at blanks and tabs. A modier `:x' exists which can be used later to expand each component of the variable into another variable splitting it into separate words at embedded blanks and tabs.
4.2. Braces { ... } in argument expansion
Another form of lename expansion, alluded to before involves the characters `{' and `}'. These characters specify that the contained strings, separated by `,' are to be consecutively substituted into the containing characters and the results expanded left to right. Thus
A{str1,str2,...strn}B
expands to

-- --

USD:4-32

An Introduction to the C shell

Astr1B Astr2B ... AstrnB
This expansion occurs before the other lename expansions, and may be applied recursively (i.e. nested). The results of each expanded string are sorted separately, left to right order being preserved. The resulting lenames are not required to exist if no other expansion mechanisms are used. This means that this mechanism can be used to generate arguments which are not lenames, but which have common parts.
A typical use of this would be
mkdir ~/{hdrs,retrot,csh}
to make subdirectories `hdrs', `retrot' and `csh' in your home directory. This mechanism is most useful when the common prex is longer than in this example, i.e.
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
4.3. Command substitution A command enclosed in ``' characters is replaced, just before lenames are expanded, by the output
from that command. Thus it is possible to do
set pwd=`pwd`
to save the current directory in the variable pwd or to do
ex `grep !l TRACE *.c`
to run the editor ex supplying as arguments those les whose names end in `.c' which have the string `TRACE' in them.*
4.4. Other details not covered here In particular circumstances it may be necessary to know the exact nature and order of different sub-
stitutions performed by the shell. The exact meaning of certain combinations of quotations is also occasionally important. These are detailed fully in its manual section.
The shell has a number of command line option ags mostly of use in writing UNIX programs, and debugging shell scripts. See the csh(1) manual section for a list of these options.

*Command expansion also occurs in input redirected with `<<' and within `"' quotations. Refer to the shell manual section for full details.

-- --

An Introduction to the C shell

USD:4-33

Appendix ! Special characters The following table lists the special characters of csh and the UNIX system, giving for each the section(s) in which it is discussed. A number of these characters also have special meaning in expressions. See the csh manual section for a complete list. Syntactic metacharacters
; 2.4 separates commands to be executed sequentially | 1.5 separates commands in a pipeline ( ) 2.2,3.6 brackets expressions and variable values & 2.5 follows commands to be executed without waiting for completion
Filename metacharacters
/ 1.6 separates components of a le's pathname ? 1.6 expansion character matching any single character * 1.6 expansion character matching any sequence of characters [ ] 1.6 expansion sequence matching any single character from a set ~ 1.6 used at the beginning of a lename to indicate home directories { } 4.2 used to specify groups of arguments with common parts
Quotation metacharacters
\ 1.7 prevents meta-meaning of following single character ´ 1.7 prevents meta-meaning of a group of characters " 4.3 like ´, but allows variable and command expansion
Input/output metacharacters
< 1.5 indicates redirected input > 1.3 indicates redirected output
Expansion/substitution metacharacters
$ 3.4 indicates variable substitution ! 2.3 indicates history substitution : 3.6 precedes substitution modiers ^ 2.3 used in special forms of history substitution ` 4.3 indicates command substitution
Other metacharacters
# 1.3,3.6 begins scratch le names; indicates shell comments ! 1.2 prexes option (ag) arguments to commands % 2.6 prexes job name specications

-- --

USD:4-34

An Introduction to the C shell

Glossary
This glossary lists the most important terms introduced in the introduction to the shell and gives references to sections of the shell document for further information about them. References of the form `pr (1)' indicate that the command pr is in the UNIX User Reference manual in section 1. You can look at an online copy of its manual page by doing

man 1 pr

References of the form (2.5) indicate that more information can be found in section 2.5 of this manual.
. Your current directory has the name `.' as well as the name printed by the command pwd; see also dirs. The current directory `.' is usually the rst component of the search path contained in the variable path , thus commands which are in `.' are found rst (2.2). The character `.' is also used in separating components of lenames (1.6). The character `.' at the beginning of a component of a pathname is treated specially and not matched by the lename expansion metacharacters `?', `*', and `[' `]' pairs (1.6).
.. Each directory has a le `..' in it which is a reference to its parent directory. After changing into the directory with chdir , i.e.

chdir paper

you can return to the parent directory by doing

chdir ..

The current directory is printed by pwd (2.7).

a.out Compilers which create executable images create them, by default, in the le a.out. for historical reasons (2.3).

absolute pathname A pathname which begins with a `/' is absolute since it species the path of directories from the beginning of the entire directory system ! called the root directory. Pathname s which are not absolute are called relative (see denition of relative pathname ) (1.6).

alias An alias species a shorter or different name for a UNIX command, or a transformation on a command to be performed in the shell. The shell has a command alias which establishes aliases and can print their current values. The command unalias is used to remove aliases (2.4).

argument

Commands in UNIX receive a list of argument words. Thus the command

echo a b c

argv
background base
bg bin

consists of the command name `echo' and three argument words `a', `b' and `c'. The set of arguments after the command name is said to be the argument list of the command (1.1).
The list of arguments to a command written in the shell language (a shell script or shell procedure) is stored in a variable called argv within the shell. This name is taken from the conventional name in the C programming language (3.4).
Commands started without waiting for them to complete are called background commands (2.6).
A lename is sometimes thought of as consisting of a base part, before any `.' character, and an extension ! the part after the `.'. See lename and extension (1.6) and basename (1).
The bg command causes a suspended job to continue execution in the background (2.6).
A directory containing binaries of programs and shell scripts to be executed is typically called a bin directory. The standard system bin directories are `/bin' containing the most heavily used commands and `/usr/bin' which contains most other user programs.

-- --

An Introduction to the C shell

USD:4-35

break breaksw builtin
case
cat cd chdir chsh

Programs developed at UC Berkeley live in `/usr/ucb', while locally written programs live in `/usr/local'. Games are kept in the directory `/usr/games'. You can place binaries in any directory. If you wish to execute them often, the name of the directories should be a component of the variable path .
Break is a builtin command used to exit from loops within the control structure of the shell (3.7).
The breaksw builtin command is used to exit from a switch control structure, like a break exits from loops (3.7).
A command executed directly by the shell is called a builtin command. Most commands in UNIX are not built into the shell, but rather exist as les in bin directories. These commands are accessible because the directories in which they reside are named in the path variable.
A case command is used as a label in a switch statement in the shell's control structure, similar to that of the language C. Details are given in the shell documentation `csh (1)' (3.7).
The cat program catenates a list of specied les on the standard output . It is usually used to look at the contents of a single le on the terminal, to `cat a le' (1.8, 2.3).
The cd command is used to change the working directory . With no arguments, cd changes your working directory to be your home directory (2.4, 2.7).
The chdir command is a synonym for cd . Cd is usually used because it is easier to type.
The chsh command is used to change the shell which you use on UNIX. By default, you use an different version of the shell which resides in `/bin/sh'. You can change your shell to `/bin/csh' by doing

chsh your-login-name /bin/csh

Thus I would do

chsh bill /bin/csh

It is only necessary to do this once. The next time you log in to UNIX after doing this command, you will be using csh rather than the shell in `/bin/sh' (1.9).

cmp Cmp is a program which compares les. It is usually used on binary les, or to see if two les are identical (3.6). For comparing text les the program diff , described in `diff (1)' is used.

command

A function performed by the system, either by the shell (a builtin command ) or by a program residing in a le in a directory within the UNIX system, is called a command (1.1).

command name

When a command is issued, it consists of a command name , which is the rst word of the command, followed by arguments. The convention on UNIX is that the rst word of a command names the function to be performed (1.1).

command substitution The replacement of a command enclosed in ``' characters by the text output by that command is called command substitution (4.3).

component

A part of a pathname between `/' characters is called a component of that pathname . A variable which has multiple strings as value is said to have several component s; each string is a component of the variable.

continue

A builtin command which causes execution of the enclosing foreach or while loop to cycle prematurely. Similar to the continue command in the programming language C (3.6).

-- --

USD:4-36

An Introduction to the C shell

control-
core dump
cp csh .cshrc cwd date debugging default:
DELETE
detached diagnostic
directory
directory stack
dirs du

Certain special characters, called control characters, are produced by holding down the CONTROL key on your terminal and simultaneously pressing another character, much like the SHIFT key is used to produce upper case characters. Thus control- c is produced by holding down the CONTROL key while pressing the `c' key. Usually UNIX prints an caret (^) followed by the corresponding letter when you type a control character (e.g. `^C' for control- c (1.8).
When a program terminates abnormally, the system places an image of its current state in a le named `core'. This core dump can be examined with the system debugger `adb (1)' or `sdb (1)' in order to determine what went wrong with the program (1.8). If the shell produces a message of the form
Illegal instruction (core dumped)
(where `Illegal instruction' is only one of several possible messages), you should report this to the author of the program or a system administrator, saving the `core' le.
The cp (copy) program is used to copy the contents of one le into another le. It is one of the most commonly used UNIX commands (1.6).
The name of the shell program that this document describes.
The le .cshrc in your home directory is read by each shell as it begins execution. It is usually used to change the setting of the variable path and to set alias parameters which are to take effect globally (2.1).
The cwd variable in the shell holds the absolute pathname of the current working directory . It is changed by the shell whenever your current working directory changes and should not be changed otherwise (2.2).
The date command prints the current date and time (1.3).
Debugging is the process of correcting mistakes in programs and shell scripts. The shell has several options and variables which may be used to aid in shell debugging (4.4).
The label default: is used within shell switch statements, as it is in the C language to label the code to be executed if none of the case labels matches the value switched on (3.7).
The DELETE or RUBOUT key on the terminal normally causes an interrupt to be sent to the current job. Many users change the interrupt character to be ^C.
A command that continues running in the background after you logout is said to be detached .
An error message produced by a program is often referred to as a diagnostic . Most error messages are not written to the standard output , since that is often directed away from the terminal (1.3, 1.5). Error messsages are instead written to the diagnostic output which may be directed away from the terminal, but usually is not. Thus diagnostics will usually appear on the terminal (2.5).
A structure which contains les. At any time you are in one particular directory whose names can be printed by the command pwd . The chdir command will change you to another directory , and make the les in that directory visible. The directory in which you are when you rst login is your home directory (1.1, 2.7).
The shell saves the names of previous working directories in the directory stack when you change your current working directory via the pushd command. The directory stack can be printed by using the dirs command, which includes your current working directory as the rst directory name on the left (2.7).
The dirs command prints the shell's directory stack (2.7).
The du command is a program (described in `du (1)') which prints the number of disk blocks is all directories below and including your current working directory (2.6).

-- --

An Introduction to the C shell

USD:4-37

echo else endif
EOF
escape
/etc/passwd
exit exit status expansion expressions extension

The echo command prints its arguments (1.6, 3.6).
The else command is part of the `if-then-else-endif' control command construct (3.6).
If an if statement is ended with the word then , all lines following the if up to a line starting with the word endif or else are executed if the condition between parentheses after the if is true (3.6).
An end-of-le is generated by the terminal by a control-d, and whenever a command reads to the end of a le which it has been given as input. Commands receiving input from a pipe receive an end-of-le when the command sending them input completes. Most commands terminate when they receive an end-of-le . The shell has an option to ignore end-of-le from a terminal input which may help you keep from logging out accidentally by typing too many control-d's (1.1, 1.8, 3.8).
A character `\' used to prevent the special meaning of a metacharacter is said to escape the character from its special meaning. Thus
echo \*
will echo the character `*' while just
echo *
will echo the names of the le in the current directory. In this example, \ escape s `*' (1.7). There is also a non-printing character called escape , usually labelled ESC or ALTMODE on terminal keyboards. Some older UNIX systems use this character to indicate that output is to be suspended . Most systems use control-s to stop the output and control-q to start it.
This le contains information about the accounts currently on the system. It consists of a line for each account with elds separated by `:' characters (1.8). You can look at this le by saying
cat /etc/passwd
The commands nger and grep are often used to search for information in this le. See `nger (1)', `passwd(5)', and `grep (1)' for more details.
The exit command is used to force termination of a shell script, and is built into the shell (3.9).
A command which discovers a problem may reect this back to the command (such as a shell) which invoked (executed) it. It does this by returning a non-zero number as its exit status , a status of zero being considered `normal termination'. The exit command can be used to force a shell command script to give a non-zero exit status (3.6).
The replacement of strings in the shell input which contain metacharacters by other strings is referred to as the process of expansion . Thus the replacement of the word `*' by a sorted list of les in the current directory is a `lename expansion'. Similarly the replacement of the characters `!!' by the text of the last command is a `history expansion'. Expansions are also referred to as substitutions (1.6, 3.4, 4.2).
Expressions are used in the shell to control the conditional structures used in the writing of shell scripts and in calculating values for these scripts. The operators available in shell expressions are those of the language C (3.5).
Filenames often consist of a base name and an extension separated by the character `.'. By convention, groups of related les often share the same root name. Thus if `prog.c' were a C program, then the object le for this program would be stored in `prog.o'. Similarly a paper written with the `!me' nroff macro package might be stored in `paper.me' while a formatted version of this paper might be kept in `paper.out' and a list of spelling errors in `paper.errs' (1.6).

-- --

USD:4-38

An Introduction to the C shell

fg The job control command fg is used to run a background or suspended job in the foreground (1.8, 2.6).

lename

Each le in UNIX has a name consisting of up to 14 characters and not including the character `/' which is used in pathname building. Most lenames do not begin with the character `.', and contain only letters and digits with perhaps a `.' separating the base portion of the lename from an extension (1.6).

lename expansion Filename expansion uses the metacharacters `*', `?' and `[' and `]' to provide a convenient mechanism for naming les. Using lename expansion it is easy to name all the les in the current directory, or all les which have a common root name. Other lename expansion mechanisms use the metacharacter `~' and allow les in other users' directories to be named easily (1.6, 4.2).

ag Many UNIX commands accept arguments which are not the names of les or other users but are used to modify the action of the commands. These are referred to as ag options, and by convention consist of one or more letters preceded by the character `!' (1.2). Thus the ls (list les) command has an option `!s' to list the sizes of les. This is specied

ls !s

foreach foreground goto grep
head
history home directory

The foreach command is used in shell scripts and at the terminal to specify repetition of a sequence of commands while the value of a certain shell variable ranges through a specied list (3.6, 4.1).
When commands are executing in the normal way such that the shell is waiting for them to nish before prompting for another command they are said to be foreground jobs or running in the foreground . This is as opposed to background . Foreground jobs can be stopped by signals from the terminal caused by typing different control characters at the keyboard (1.8, 2.6).
The shell has a command goto used in shell scripts to transfer control to a given label (3.7).
The grep command searches through a list of argument les for a specied string. Thus
grep bill /etc/passwd
will print each line in the le /etc/passwd which contains the string `bill'. Actually, grep scans for regular expressions in the sense of the editors `ed (1)' and `ex (1)'. Grep stands for `globally nd regular expression and print' (2.4).
The head command prints the rst few lines of one or more les. If you have a bunch of les containing text which you are wondering about it is sometimes useful to run head with these les as arguments. This will usually show enough of what is in these les to let you decide which you are interested in (1.5). Head is also used to describe the part of a pathname before and including the last `/' character. The tail of a pathname is the part after the last `/'. The `:h' and `:t' modiers allow the head or tail of a pathname stored in a shell variable to be used (3.6).
The history mechanism of the shell allows previous commands to be repeated, possibly after modication to correct typing mistakes or to change the meaning of the command. The shell has a history list where these commands are kept, and a history variable which controls how large this list is (2.3).
Each user has a home directory , which is given in your entry in the password le, /etc/passwd . This is the directory which you are placed in when you rst login. The cd or chdir command with no arguments takes you back to this directory, whose name is recorded in the shell variable home . You can also access the home directories of other

-- --

An Introduction to the C shell

USD:4-39

if ignoreeof
input
interrupt
job job control job number jobs kill .login login shell logout .logout

users in forming lenames using a lename expansion notation and the character `~' (1.6).
A conditional command within the shell, the if command is used in shell command scripts to make decisions about what course of action to take next (3.6).
Normally, your shell will exit, printing `logout' if you type a control-d at a prompt of `% '. This is the way you usually log off the system. You can set the ignoreeof variable if you wish in your .login le and then use the command logout to logout. This is useful if you sometimes accidentally type too many control-d characters, logging yourself off (2.2).
Many commands on UNIX take information from the terminal or from les which they then act on. This information is called input . Commands normally read for input from their standard input which is, by default, the terminal. This standard input can be redirected from a le using a shell metanotation with the character `<'. Many commands will also read from a le specied as argument. Commands placed in pipelines will read from the output of the previous command in the pipeline . The leftmost command in a pipeline reads from the terminal if you neither redirect its input nor give it a lename to use as standard input . Special mechanisms exist for supplying input to commands in shell scripts (1.5, 3.8).
An interrupt is a signal to a program that is generated by typing ^C. (On older versions of UNIX the RUBOUT or DELETE key were used for this purpose.) It causes most programs to stop execution. Certain programs, such as the shell and the editors, handle an interrupt in special ways, usually by stopping what they are doing and prompting for another command. While the shell is executing another command and waiting for it to nish, the shell does not listen to interrupts. The shell often wakes up when you hit interrupt because many commands die when they receive an interrupt (1.8, 3.9).
One or more commands typed on the same input line separated by `|' or `;' characters are run together and are called a job . Simple commands run by themselves without any `|' or `;' characters are the simplest jobs. Jobs are classied as foreground , background , or suspended (2.6).
The builtin functions that control the execution of jobs are called job control commands. These are bg, fg, stop, kill (2.6).
When each job is started it is assigned a small number called a job number which is printed next to the job in the output of the jobs command. This number, preceded by a `%' character, can be used as an argument to job control commands to indicate a specic job (2.6).
The jobs command prints a table showing jobs that are either running in the background or are suspended (2.6).
A command which sends a signal to a job causing it to terminate (2.6).
The le .login in your home directory is read by the shell each time you login to UNIX and the commands there are executed. There are a number of commands which are usefully placed here, especially set commands to the shell itself (2.1).
The shell that is started on your terminal when you login is called your login shell . It is different from other shells which you may run (e.g. on shell scripts) in that it reads the .login le before reading commands from the terminal and it reads the .logout le after you logout (2.1).
The logout command causes a login shell to exit. Normally, a login shell will exit when you hit control-d generating an end-of-le, but if you have set ignoreeof in you .login le then this will not work and you must use logout to log off the UNIX system (2.8).
When you log off of UNIX the shell will execute commands from the le .logout in your home directory after it prints `logout'.

-- --

USD:4-40

An Introduction to the C shell

lpr ls mail make makele manual
metacharacter
mkdir modier
more noclobber noglob notify

The command lpr is the line printer daemon. The standard input of lpr spooled and printed on the UNIX line printer. You can also give lpr a list of lenames as arguments to be printed. It is most common to use lpr as the last component of a pipeline (2.3).
The ls (list les) command is one of the most commonly used UNIX commands. With no argument lenames it prints the names of the les in the current directory. It has a number of useful ag arguments, and can also be given the names of directories as arguments, in which case it lists the names of the les in these directories (1.2).
The mail program is used to send and receive messages from other UNIX users (1.1, 2.1), whether they are logged on or not.
The make command is used to maintain one or more related les and to organize functions to be performed on these les. In many ways make is easier to use, and more helpful than shell command scripts (3.2).
The le containing commands for make is called makele or Makele (3.2).
The manual often referred to is the `UNIX manual'. It contains 8 numbered sections with a description of each UNIX program (section 1), system call (section 2), subroutine (section 3), device (section 4), special data structure (section 5), game (section 6), miscellaneous item (section 7) and system administration program (section 8). There are also supplementary documents (tutorials and reference guides) for individual programs which require explanation in more detail. An online version of the manual is accessible through the man command. Its documentation can be obtained online via
man man
If you can't decide what manual page to look in, try the apropos (1) command. The supplementary documents are in subdirectories of /usr/doc.
Many characters which are neither letters nor digits have special meaning either to the shell or to UNIX. These characters are called metacharacters . If it is necessary to place these characters in arguments to commands without them having their special meaning then they must be quoted . An example of a metacharacter is the character `>' which is used to indicate placement of output into a le. For the purposes of the history mechanism, most unquoted metacharacters form separate words (1.4). The appendix to this user's manual lists the metacharacters in groups by their function.
The mkdir command is used to create a new directory.
Substitutions with the history mechanism, keyed by the character `!' or of variables using the metacharacter `$', are often subjected to modications, indicated by placing the character `:' after the substitution and following this with the modier itself. The command substitution mechanism can also be used to perform modication in a similar way, but this notation is less clear (3.6).
The program more writes a le on your terminal allowing you to control how much text is displayed at a time. More can move through the le screenful by screenful, line by line, search forward for a string, or start again at the beginning of the le. It is generally the easiest way of viewing a le (1.8).
The shell has a variable noclobber which may be set in the le .login to prevent accidental destruction of les by the `>' output redirection metasyntax of the shell (2.2, 2.5).
The shell variable noglob is set to suppress the lename expansion of arguments containing the metacharacters `~', `*', `?', `[' and `]' (3.6).
The notify command tells the shell to report on the termination of a specic background job at the exact time it occurs as opposed to waiting until just before the next prompt to report the termination. The notify variable, if set, causes the shell to always report the termination of background jobs exactly when they occur (2.6).

-- --

An Introduction to the C shell

USD:4-41

onintr output
path
pathname pipeline popd port pr printenv

The onintr command is built into the shell and is used to control the action of a shell command script when an interrupt signal is received (3.9).
Many commands in UNIX result in some lines of text which are called their output. This output is usually placed on what is known as the standard output which is normally connected to the user's terminal. The shell has a syntax using the metacharacter `>' for redirecting the standard output of a command to a le (1.3). Using the pipe mechanism and the metacharacter `|' it is also possible for the standard output of one command to become the standard input of another command (1.5). Certain commands such as the line printer daemon p do not place their results on the standard output but rather in more useful places such as on the line printer (2.3). Similarly the write command places its output on another user's terminal rather than its standard output (2.3). Commands also have a diagnostic output where they write their error messages. Normally these go to the terminal even if the standard output has been sent to a le or another command, but it is possible to direct error diagnostics along with standard output using a special metanotation (2.5).
The shell has a variable path which gives the names of the directories in which it searches for the commands which it is given. It always checks rst to see if the command it is given is built into the shell. If it is, then it need not search for the command as it can do it internally. If the command is not builtin, then the shell searches for a le with the name given in each of the directories in the path variable, left to right. Since the normal denition of the path variable is
path (. /usr/ucb /bin /usr/bin)
the shell normally looks in the current directory, and then in the standard system directories `/usr/ucb', `/bin' and `/usr/bin' for the named command (2.2). If the command cannot be found the shell will print an error diagnostic. Scripts of shell commands will be executed using another shell to interpret them if they have `execute' permission set. This is normally true because a command of the form
chmod 755 script
was executed to turn this execute permission on (3.3). If you add new commands to a directory in the path , you should issue the command rehash (2.2).
A list of names, separated by `/' characters, forms a pathname. Each component, between successive `/' characters, names a directory in which the next component le resides. Pathnames which begin with the character `/' are interpreted relative to the root directory in the lesystem. Other pathnames are interpreted relative to the current directory as reported by pwd. The last component of a pathname may name a directory, but usually names a le.
A group of commands which are connected together, the standard output of each connected to the standard input of the next, is called a pipeline. The pipe mechanism used to connect these commands is indicated by the shell metacharacter `|' (1.5, 2.3).
The popd command changes the shell's working directory to the directory you most recently left using the pushd command. It returns to the directory without having to type its name, forgetting the name of the current working directory before doing so (2.7).
The part of a computer system to which each terminal is connected is called a port . Usually the system has a xed number of ports , some of which are connected to telephone lines for dial-up access, and some of which are permanently wired directly to specic terminals.
The pr command is used to prepare listings of the contents of les with headers giving the name of the le and the date and time at which the le was last modied (2.3).
The printenv command is used to print the current setting of variables in the environment (2.8).

-- --

USD:4-42

An Introduction to the C shell

process

An instance of a running program is called a process (2.6). UNIX assigns each process a unique number when it is started ! called the process number . Process numbers can be used to stop individual processes using the kill or stop commands when the processes are part of a detached background job.

program

Usually synonymous with command ; a binary le or shell command script which performs a useful function is often called a program .

prompt

Many programs will print a prompt on the terminal when they expect input. Thus the editor `ex (1)' will print a `:' when it expects input. The shell prompts for input with `% ' and occasionally with `? ' when reading commands from the terminal (1.1). The shell has a variable prompt which may be set to a different value to change the shell's main prompt . This is mostly used when debugging the shell (2.8).

pushd

The pushd command, which means `push directory', changes the shell's working directory and also remembers the current working directory before the change is made, allowing you to return to the same directory via the popd command later without retyping its name (2.7).

ps The ps command is used to show the processes you are currently running. Each process is shown with its unique process number, an indication of the terminal name it is attached to, an indication of the state of the process (whether it is running, stopped, awaiting some event (sleeping), and whether it is swapped out), and the amount of CPU time it has used so far. The command is identied by printing some of the words used when it was invoked (2.6). Shells, such as the csh you use to run the ps command, are not normally shown in the output.

pwd The pwd command prints the full pathname of the current working directory . The dirs builtin command is usually a better and faster choice.

quit The quit signal, generated by a control-\, is used to terminate programs which are behaving unreasonably. It normally produces a core image le (1.8).

quotation

The process by which metacharacters are prevented their special meaning, usually by using the character `´ in pairs, or by using the character `\', is referred to as quotation (1.7).

redirection

The routing of input or output from or to a le is known as redirection of input or output (1.3).

rehash

The rehash command tells the shell to rebuild its internal table of which commands are found in which directories in your path . This is necessary when a new program is installed in one of these directories (2.8).

relative pathname A pathname which does not begin with a `/' is called a relative pathname since it is interpreted relative to the current working directory . The rst component of such a pathname refers to some le or directory in the working directory , and subsequent components between `/' characters refer to directories below the working directory . Pathnames that are not relative are called absolute pathnames (1.6).

repeat

The repeat command iterates another command a specied number of times.

root The directory that is at the top of the entire directory structure is called the root directory since it is the `root' of the entire tree structure of directories. The name used in pathnames to indicate the root is `/'. Pathnames starting with `/' are said to be absolute since they start at the root directory. Root is also used as the part of a pathname that is left after removing the extension . See lename for a further explanation (1.6).

RUBOUT

The RUBOUT or DELETE key is often used to erase the previously typed character; some users prefer the BACKSPACE for this purpose. On older versions of UNIX this key served as the INTR character.

-- --

An Introduction to the C shell

USD:4-43

scratch le

Files whose names begin with a `#' are referred to as scratch les , since they are automatically removed by the system after a couple of days of non-use, or more frequently if disk space becomes tight (1.3).

script

Sequences of shell commands placed in a le are called shell command scripts . It is often possible to perform simple tasks using these scripts without writing a program in a language such as C, by using the shell to selectively run other programs (3.3, 3.10).

set The builtin set command is used to assign new values to shell variables and to show the values of the current variables. Many shell variables have special meaning to the shell itself. Thus by using the set command the behavior of the shell can be affected (2.1).

setenv

Variables in the environment `environ (5)' can be changed by using the setenv builtin command (2.8). The printenv command can be used to print the value of the variables in the environment.

shell A shell is a command language interpreter. It is possible to write and run your own shell , as shells are no different than any other programs as far as the system is concerned. This manual deals with the details of one particular shell , called csh.

shell script

See script (3.3, 3.10).

signal

A signal in UNIX is a short message that is sent to a running program which causes something to happen to that process. Signals are sent either by typing special control characters on the keyboard or by using the kill or stop commands (1.8, 2.6).

sort The sort program sorts a sequence of lines in ways that can be controlled by argument ags (1.5).

source

The source command causes the shell to read commands from a specied le. It is most useful for reading les such as .cshrc after changing them (2.8).

special character See metacharacters and the appendix to this manual.

standard

We refer often to the standard input and standard output of commands. See input and output (1.3, 3.8).

status

A command normally returns a status when it nishes. By convention a status of zero indicates that the command succeeded. Commands may return non-zero status to indicate that some abnormal event has occurred. The shell variable status is set to the status returned by the last command. It is most useful in shell commmand scripts (3.6).

stop The stop command causes a background job to become suspended (2.6).

string

A sequential group of characters taken together is called a string . Strings can contain any printable characters (2.2).

stty The stty program changes certain parameters inside UNIX which determine how your terminal is handled. See `stty (1)' for a complete description (2.6).

substitution

The shell implements a number of substitutions where sequences indicated by metacharacters are replaced by other sequences. Notable examples of this are history substitution keyed by the metacharacter `!' and variable substitution indicated by `$'. We also refer to substitutions as expansions (3.4).

suspended

A job becomes suspended after a STOP signal is sent to it, either by typing a control -z at the terminal (for foreground jobs) or by using the stop command (for background jobs). When suspended , a job temporarily stops running until it is restarted by either the fg or bg command (2.6).

switch

The switch command of the shell allows the shell to select one of a number of sequences of commands based on an argument string. It is similar to the switch statement in the language C (3.7).

termination

When a command which is being executed nishes we say it undergoes termination or terminates. Commands normally terminate when they read an end-of-le from their

-- --

USD:4-44

An Introduction to the C shell

standard input . It is also possible to terminate commands by sending them an interrupt or quit signal (1.8). The kill program terminates specied jobs (2.6).

then The then command is part of the shell's `if-then-else-endif' control construct used in command scripts (3.6).

time The time command can be used to measure the amount of CPU and real time consumed by a specied command as well as the amount of disk i/o, memory utilized, and number of page faults and swaps taken by the command (2.1, 2.8).

tset The tset program is used to set standard erase and kill characters and to tell the system what kind of terminal you are using. It is often invoked in a .login le (2.1).

tty The word tty is a historical abbreviation for `teletype' which is frequently used in UNIX to indicate the port to which a given terminal is connected. The tty command will print the name of the tty or port to which your terminal is presently connected.

unalias

The unalias command removes aliases (2.8).

UNIX

UNIX is an operating system on which csh runs. UNIX provides facilities which allow csh to invoke other programs such as editors and text formatters which you may wish to use.

unset

The unset command removes the denitions of shell variables (2.2, 2.8).

variable expansion See variables and expansion (2.2, 3.4).

variables

Variables in csh hold one or more strings as value. The most common use of variables is in controlling the behavior of the shell. See path , noclobber , and ignoreeof for examples. Variables such as argv are also used in writing shell programs (shell command scripts) (2.2).

verbose

The verbose shell variable can be set to cause commands to be echoed after they are history expanded. This is often useful in debugging shell scripts. The verbose variable is set by the shell's !v command line option (3.10).

wc The wc program calculates the number of characters, words, and lines in the les whose names are given as arguments (2.6).

while

The while builtin control construct is used in shell command scripts (3.7).

word

A sequence of characters which forms an argument to a command is called a word . Many characters which are neither letters, digits, `!', `.' nor `/' form words all by themselves even if they are not surrounded by blanks. Any sequence of characters may be made into a word by surrounding it with `´' characters except for the characters `´' and `!' which require special treatment (1.1). This process of placing special characters in words without their special meaning is called quoting .

working directory At any given time you are in one particular directory, called your working directory . This directory's name is printed by the pwd command and the les listed by ls are the ones in this directory. You can change working directories using chdir .

write

The write command is an obsolete way of communicating with other users who are logged in to UNIX (you have to take turns typing). If you are both using display terminals, use talk(1), which is much more pleasant.

