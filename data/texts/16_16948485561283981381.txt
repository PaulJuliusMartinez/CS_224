IDZ DO
PRZYK£ADOWY ROZDZIA£ SPIS TRECI
KATALOG KSI¥¯EK
KATALOG ONLINE ZAMÓW DRUKOWANY KATALOG
TWÓJ KOSZYK
DODAJ DO KOSZYKA
CENNIK I INFORMACJE
ZAMÓW INFORMACJE O NOWOCIACH ZAMÓW CENNIK
CZYTELNIA
FRAGMENTY KSI¥¯EK ONLINE
Wydawnictwo Helion ul. Chopina 6 44-100 Gliwice tel. (32)230-98-63 e-mail: helion@helion.pl

Projektowanie i analiza algorytmów
Autorzy: Alfred V. Aho, John E. Hopcroft, Jeffrey D. Ullman T³umaczenie: Wojciech Derechowski ISBN: 83-7197-770-0 Tytu³ orygina³u: The Design and Analysis of Computer Algorithms Format: B5, stron: 488
Badanie algorytmów le¿y w samym sercu nauk komputerowych. W ostatnich latach dokonano znacz¹cych postêpów w tej dziedzinie. Opracowano m.in. wiele efektywniejszych algorytmów (szybkie przekszta³cenie Fouriera), odkryto tak¿e istnienie pewnych naturalnych zadañ, dla których wszystkie algorytmy s¹ nieefektywne. Wyniki te powoduj¹ wzrost zainteresowania badaniami algorytmów, co przyczynia siê do intensywnego rozwoju tej dziedziny wiedzy.
Ksi¹¿ka jest podrêcznikiem wstêpnego kursu projektowania i analizy algorytmów. Autorzy po³o¿yli nacisk raczej na prezentacji najwa¿niejszych idei i przystêpnoci wyk³adu, ni¿ na szczegó³ach realizacji i sztuczkach programistycznych. Autorzy przedstawiaj¹ na ogó³ nieformalne, intuicyjne objanienia zamiast d³ugich i pracoch³onnych dowodów. Ksi¹¿ka nie wymaga ¿adnego szczególnego przygotowania z zakresu matematyki, czy jêzyków programowania. Po¿¹dana jest jednak pewna dojrza³oæ w stosowaniu pojêæ matematycznych, ogólne obycie w jêzykach programowania wysokiego poziomu, takich jak FORTRAN lub ALGOL, a tak¿e podstawowa znajomoæ algebry liniowej.
W ksi¹¿ce omówiono m.in.:
· Podstawowe pojêcia i modele (w tym maszynê Turniga) · Najwa¿niejsze struktury danych, rekurencjê, programowanie dynamiczne · Algorytmy sortowania, operacje na zbiorach, drzewach i grafach · Szybkie przekszta³cenie Fouriera z zastosowaniami · Algorytmy arytmetyczne, operacje na wielomianach · Algorytmy dopasowania wzorców · Problemy NP-zupe³ne · Dolne ograniczenia z³o¿onoci obliczeniowej
Wa¿nym uzupe³nieniem treci ksi¹¿ki s¹ æwiczenia o zró¿nicowanych poziomach trudnoci. ,,Projektowanie i analiza algorytmów" to doskona³y podrêcznik dla studentów informatyki i kierunków pokrewnych, a tak¿e wspania³a pomoc dla osób prowadz¹cych wyk³ady i æwiczenia na tych kierunkach.

Spis treci

Przedmowa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

1. Modele obliczania . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1 Algorytmy i ich zloono . . . . . . . . . . . . . . . . . . . . . . . . 1.2 Maszyny o dostpie swobodnym . . . . . . . . . . . . . . . . . . . . . 1.3 Zloono obliczeniowa programów RAM . . . . . . . . . . . . . . . 1.4 Model z zapamitanym programem . . . . . . . . . . . . . . . . . . . 1.5 Abstrakcje RAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.6 Pierwotny model obliczania: maszyna Turinga . . . . . . . . . . . . . 1.7 Zwizek pomidzy maszyn Turinga i modelem RAM . . . . . . . . 1.8 Pidgin ALGOL -- jzyk wysokiego poziomu . . . . . . . . . . . . . .

11
11 14 20 23 28 34 39 41

2. Projektowanie efektywnych algorytmów . . . . . . . . . . . . . . .
2.1 Struktury danych: listy, kolejki i stosy . . . . . . . . . . . . . . . . . 2.2 Reprezentacje zbioru . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.3 Grafy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.4 Drzewa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.5 Rekurencja . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.6 Dziel i zwyciaj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.7 Zrównowaenie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.8 Programowanie dynamiczne . . . . . . . . . . . . . . . . . . . . . . . 2.9 Zakoczenie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

51
52 56 57 60 63 67 73 74 77

3. Sortowanie i statystyka pozycyjna . . . . . . . . . . . . . . . . . . . 85
3.1 Problem sortowania . . . . . . . . . . . . . . . . . . . . . . . . . . . 86 3.2 Sortowanie pozycyjne . . . . . . . . . . . . . . . . . . . . . . . . . . 87 3.3 Sortowanie przez porównania . . . . . . . . . . . . . . . . . . . . . . 95 3.4 Heapsort -- algorytm sortowania przez O (n log n) porówna . . . . 96 3.5 Quicksort -- algorytm sortowania w czasie oczekiwanym O (n log n) 101 3.6 Statystyka pozycyjna . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 3.7 Czas oczekiwany dla statystyki pozycyjnej . . . . . . . . . . . . . . . 108

4. Struktury danych dla zada operujcych na zbiorach . . . . . . . 117
4.1 Operacje pierwotne na zbiorach . . . . . . . . . . . . . . . . . . . . . 117 4.2 Haszowanie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 4.3 Poszukiwanie binarne . . . . . . . . . . . . . . . . . . . . . . . . . . 122 4.4 Drzewa poszukiwa binarnych . . . . . . . . . . . . . . . . . . . . . . 124 4.5 Optymalne drzewa poszukiwa binarnych . . . . . . . . . . . . . . . 128

4 Spis treci
4.6 Prosty algorytm sumy zbiorów rozlcznych . . . . . . . . . . . . . . 132 4.7 Struktury drzew dla problemu UNION-FIND . . . . . . . . . . . . . 136 4.8 Zastosowania i rozszerzenia algorytmu UNION-FIND . . . . . . . . . 146 4.9 Schematy z drzewami zrównowaonymi . . . . . . . . . . . . . . . . . 152 4.10 Slowniki i kolejki priorytetowe . . . . . . . . . . . . . . . . . . . . . 155 4.11 Kopce zlczane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159 4.12 Kolejki konkatenowane . . . . . . . . . . . . . . . . . . . . . . . . . . 162 4.13 Podzial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 4.14 Podsumowanie rozdzialu . . . . . . . . . . . . . . . . . . . . . . . . . 169
5. Algorytmy na grafach . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
5.1 Drzewa rozpinajce o minimalnym koszcie . . . . . . . . . . . . . . . 179 5.2 Przeszukiwanie w glb . . . . . . . . . . . . . . . . . . . . . . . . . . 183 5.3 Dwuspójno . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 5.4 Przeszukiwanie w glb grafu skierowanego . . . . . . . . . . . . . . . 195 5.5 Spójno silna . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197 5.6 Problemy znajdowania cieek . . . . . . . . . . . . . . . . . . . . . . 203 5.7 Algorytm przechodniego domknicia . . . . . . . . . . . . . . . . . . 207 5.8 Algorytm najkrótszych cieek . . . . . . . . . . . . . . . . . . . . . 208 5.9 Problemy cieek i mnoenie macierzy . . . . . . . . . . . . . . . . . 210 5.10 Problemy jednego ródla . . . . . . . . . . . . . . . . . . . . . . . . . 215 5.11 Dominatory w acyklicznym grafie skierowanym . . . . . . . . . . . . 218
6. Mnoenie macierzy i pokrewne operacje . . . . . . . . . . . . . . . 235
6.1 Podstawy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235 6.2 Algorytm Strassena mnoenia macierzy . . . . . . . . . . . . . . . . 239 6.3 Odwracanie macierzy . . . . . . . . . . . . . . . . . . . . . . . . . . . 241 6.4 Rozklad LUP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242 6.5 Zastosowania rozkladu LUP . . . . . . . . . . . . . . . . . . . . . . . 250 6.6 Mnoenie macierzy zero-jedynkowych . . . . . . . . . . . . . . . . . . 252
7. Szybkie przeksztalcenie Fouriera z zastosowaniami . . . . . . . . 263
7.1 Dyskretna transformata Fouriera i transformata odwrotna . . . . . . 264 7.2 Algorytm szybkiego przeksztalcenia Fouriera . . . . . . . . . . . . . 268 7.3 FFT z operacjami na bitach . . . . . . . . . . . . . . . . . . . . . . . 276 7.4 Iloczyny wielomianów . . . . . . . . . . . . . . . . . . . . . . . . . . 281 7.5 Mnoenie liczb calkowitych wedlug algorytm Sch¨onhagego­Strassena 282
8. Arytmetyka na liczbach calkowitych i wielomianach . . . . . . . . 289
8.1 Podobiestwo midzy liczbami calkowitymi i wielomianami . . . . . 290 8.2 Mnoenie i dzielenie liczb calkowitych . . . . . . . . . . . . . . . . . 291 8.3 Mnoenie i dzielenie wielomianów . . . . . . . . . . . . . . . . . . . . 298 8.4 Arytmetyka modularna . . . . . . . . . . . . . . . . . . . . . . . . . 300 8.5 Arytmetyka modularna na wielomianach i wartoci wielomianów . . 304 8.6 Chiskie zliczanie reszt . . . . . . . . . . . . . . . . . . . . . . . . . . 306 8.7 Chiskie zliczanie reszt i interpolacja wielomianów . . . . . . . . . . 310 8.8 Najwikszy wspólny dzielnik i algorytm Euklidesa . . . . . . . . . . 312

Spis treci

5

8.9 Asympotycznie szybki algorytm GCD dla wielomianów . . . . . . . . 315 8.10 Najwikszy wspólny dzielnik liczb calkowitych . . . . . . . . . . . . . 320 8.11 Chiskie zliczanie reszt -- raz jeszcze . . . . . . . . . . . . . . . . . . 322 8.12 Wielomiany rzadkie . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
9. Algorytmy dopasowania wzorców . . . . . . . . . . . . . . . . . . . . 329 9.1 Automaty skoczone i wyraenia regularne . . . . . . . . . . . . . . 329 9.2 Rozpoznawanie wzorców przez wyraenia regularne . . . . . . . . . . 338 9.3 Rozpoznawanie podnapisów . . . . . . . . . . . . . . . . . . . . . . . 341 9.4 Dwukierunkowe deterministyczne automaty ze stosem . . . . . . . . 347 9.5 Drzewa pozycji i indentyfikatory podnapisowe . . . . . . . . . . . . . 358
10. Problemy NP-zupelne . . . . . . . . . . . . . . . . . . . . . . . . . . . 375 10.1 Niedeterministyczne maszyny Turinga . . . . . . . . . . . . . . . . . 376 10.2 Klasy P i N P . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383 10.3 Jzyki i problemy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385 10.4 NP-zupelno problemu spelnialnoci . . . . . . . . . . . . . . . . . . 388 10.5 Inne problemy NP-zupelne . . . . . . . . . . . . . . . . . . . . . . . 395 10.6 Problemy o wielomianowej zloonoci pamiciowej . . . . . . . . . . 406
11. Problemy nielatwe na podstawie dowodu . . . . . . . . . . . . . . . 417 11.1 Hierarchie zloonoci . . . . . . . . . . . . . . . . . . . . . . . . . . . 417 11.2 Hierarchia pamiciowa dla deterministycznych maszyn Turinga . . . 418 11.3 Problem wymagajcy wykladniczego czasu i pamici . . . . . . . . . 421 11.4 Problem nieelementarny . . . . . . . . . . . . . . . . . . . . . . . . . 430
12. Ograniczenia dolne liczby operacji arytmetycznych . . . . . . . . 439 12.1 Ciala . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439 12.2 Kod liniowy -- raz jeszcze . . . . . . . . . . . . . . . . . . . . . . . . 440 12.3 Macierzowe formulowanie problemów . . . . . . . . . . . . . . . . . . 443 12.4 Ograniczenie dolne liczby mnoe zalene od liczby wierszy . . . . . 443 12.5 Ograniczenie dolne liczby mnoe zalene od liczby kolumn . . . . . 445 12.6 Ograniczenie dolne liczby mnoe zalene od liczby wierszy i kolumn 450 12.7 Nastawianie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
Bibliografia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
Indeks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477

Rozdzial 1.
Modele obliczania
Jak, majc dany problem, znajdziemy efektywny algorytm rozwizania? Gdy znalelimy algorytm, jak mamy porówna ten algorytm z innymi algorytmami, które rozwizuj ten sam problem? Jak powinnimy ocenia jako algorytmu? Pytania tego rodzaju s ciekawe zarówno dla programisty, jak i dla uczonego o teoretycznym nastawieniu do nauk komputerowych. W ksice rozpatrujemy róne kierunki bada, które usiluj odpowiedzie na takie pytania.
W tym rozdziale rozwaamy kilka modeli komputera -- maszyn o dostpie swobodnym, maszyn z zapamitanym programem i maszyn Turinga. Porównujemy je co do tego, jak odzwierciedaj zloono algorytmu i wyprowadzamy z nich kilka wyspecjalizowanych modeli oblicze: liniowe programy arytmetyczne, obliczenia na bitach, obliczenia na wektorach bitów i drzewa decyzji. Wreszcie, w ostatnim punkcie rozdzialu wprowadzamy jzyk do opisu algorytmów, zwany ,,Pidgin ALGOL".
1.1. Algorytmy i ich zloono
Algorytmy mog by oceniane na podstawie rozmaitych kryteriów. Najczciej interesuje nas szybko z jak wzrastaj czas lub pami potrzebne, by rozwiza zadanie w coraz bardziej wymagajcych przypadkach. Zawsze bdziemy przypisywa zadaniu liczb calkowit, zwan rozmiarem zadania, która jest miar wielkoci danych. Na przyklad rozmiarem zadania w przypadku mnoenia macierzy moe by najwikszy wymiar macierzy, które mamy pomnoy. Rozmiarem zadania z grafem moe by liczba krawdzi grafu.
Wymagany przez algorytm czas wyraony jako funkcja rozmiaru zadania zwany jest zloonoci czasow algorytmu. Zachowanie si tej zloonoci w granicy, gdy rozmiar zadania wzrasta, nazywa si asymptotyczn zloonoci czasow. Podobnie mona zdefiniowa zloono pamiciow i asymptotyczn zloono pamiciow.
Asymptotyczna zloono algorytmu jest tym, co ostatecznie rozstrzyga o rozmiarze zada, które mog by rozwizane przez ten algorytm. Jeeli algorytm przetwarza dane o rozmiarze n w czasie cn2 dla pewnej stalej c, to mówimy, e czasowa zloono tego algorytmu jest O(n2), czytaj ,,rzdu n2". cilej, funkcja g(n) jest

12 Rozdzial 1. Modele obliczania

Algorytm
A1 A2 A3 A4 A5

Zloono czasowa
n n log n
n2 n3 2n

Maksymalny rozmiar zadania

1 sek.

1 min. 1 godz.

1000 140
31 10 9

6 × 104 4893 244
39 15

3.6 × 106 2.0 × 105
1897 153
21

Rys. 1.1. Ograniczenia rozmiaru zadania spowodowane szybkoci wzrostu zloonoci

O(f (n)), jeeli istnieje stala c taka, e g(n) cf (n) dla wszystkich nieujemnych wartoci n prócz pewnego skoczonego (by moe pustego) zbioru tych wartoci.

Mona by przypuszcza, e ogromny wzrost szybkoci oblicze dziki powstaniu maszyn cyfrowych obecnej generacji zmniejszy znaczenie efektywnych algorytmów. Jest jednak odwrotnie. Skoro komputery staj si szybsze i moemy przetwarza coraz wiksze zadania, to o wzrocie rozmiaru zadania, jaki mona osign przez wzrost szybkoci komputera, rozstrzyga zloono algorytmu.

Zalómy, e mamy pi algorytmów A1 - A5 o podanych zloonociach czasowych:

Algorytm
A1 A2 A3 A4 A5

Zloono czasowa
n n log n (1)
n2 n3 2n

Zloono czasowa jest tu liczb jednostek czasu potrzebnych do przetworzenia danych rozmiaru n. Zakladajc, e jednostka czasu jest równa jednej milisekundzie, algorytm A1 moe przetworzy w cigu jednej sekundy dane o rozmiarze 1000, natomiast algorytm A5 dane o rozmiarze co najwyej 9. Rysunek 1.1 podaje rozmiary zada, które mog by rozwizane przez kady z tych piciu algorytmów w cigu jednej sekundy, jednej minuty i jednej godziny.

Przypumy, e nastpna generacja komputerów bdzie dziesi razy szybsza ni obecna. Rysunek 1.2 pokazuje wzrost rozmiaru zadania, jakie mona rozwiza dziki temu wzrostowi prdkoci. Zauwamy, e z algorytmem A5 dziesiciokrotny wzrost prdkoci zwiksza tylko o trzy rozmiar zadania, które mona rozwiza, natomiast z algorytmem A3 ten rozmiar wzrasta wicej ni trzykrotnie.

Zamiast wzrostu szybkoci rozwamy skutek uycia bardziej efektywnego algorytmu. Popatrzmy raz jeszcze na rys. 1.1. Biorc jedn minut za podstaw porów-

1O ile nie zaznaczono inaczej, wszystkie logarytmy w tej ksice maj podstaw 2.

1.1. Algorytmy i ich zloono

13

Algorytm
A1 A2 A3 A4 A5

Zloono czasowa
n n log n
n2 n3 2n

Maksymalny rozmiar zadania przed przyspieszeniem
s1 s2 s3 s4 s5

Maksymalny rozmiar zadania po przyspieszeniu
10s1 okolo 10s2 dla duych s2
3.16s3 2.15s4 s5 + 3.3

Rys. 1.2. Skutek dziesiciokrotnego przyspieszenia

nania, mona przez zastpienie algorytmu A4 algorytmem A3 rozwiza zadanie szeciokrotnie wiksze, a przez zastpienie algorytmu A4 algorytmem A2, zadanie 125 razy wiksze. Wyniki te s znacznie bardziej przekonujce ni dwukrotna poprawa osignita przez dziesiciokrotny wzrost szybkoci. Jeeli za podstaw porównania weniemy godzin, ronice s jeszcze bardziej istotne. Wnioskujemy, e asymptotyczna zloono algorytmu jest wan miar jakoci algorytmu, miar, która stanie si jeszcze waniejsza w przyszloci, gdy szybko oblicze wzronie.
Mimo uwagi, któr powicamy temu, jak ronie rzd wielkoci, powinnimy zdawa sobie spraw, e algorytm o gwaltownym tempie wzrostu moe mie mniejsz stal proporcjonalnoci ni algorytm o niszym. W takim przypadku szybko rosncy algorytm moe by lepszy dla malych zada, a moe nawet dla wszystkich zada, które maj rozmiar, jaki nas interesuje. Przypumy na przyklad, e zloonociami czasowymi algorytmów A1, A2, A3, A4 i A5 s 1000n, 100n log n, 10n2, n3 i 2n. Wtedy A5 bdzie najlepszy dla zada o rozmiarze 2 n 9, A3 dla 10 n 58, A2 dla 59 n 1024, a A1 dla zada o rozmiarze wikszym ni 1024.
Nim w rozwaaniu algorytmów i ich zloonoci pójdziemy dalej, musimy opisa model maszyny liczcej, która je wykonuje i okreli, co rozumiemy przez krok w obliczeniach. Niestety nie istnieje model oblicze, który pasowalby do wszystkich sytuacji. Jedn z glównych trudnoci jest dlugo slów maszynowych. Jeeli na przyklad zaloy si, e w slowie maszynowym mona umieci liczb calkowit dowolnej wielkoci, cale zadanie mona zakodowa w postaci jednej liczby calkowitej w jednym slowie. Jeeli zaloy si, e slowo maszynowe jest skoczone, trzeba rozway trudno zapamitania dowolnie duych liczb i inne problemy pomijane, gdy zadania maj umiarkowany rozmiar. Dla problemu musimy wybra model, który bdzie odzwierciedla czas oblicze w rzeczywistym komputerze.
W nastpnych punktach tego rozdzialu omówimy kilka podstawowych modeli maszyn liczcych, przede wszystkim maszyn o dostpie swobodnym, maszyn o dostpie swobodnym z zapamitanym programem i maszyn Turinga. Te trzy modele s równowane pod wzgldem mocy obliczeniowej, lecz nie szybkoci.

14 Rozdzial 1. Modele obliczania
Formalne modele oblicze wzily si glównie z pragnienia, by wydoby na jaw istotn trudno obliczeniow rónych problemów. Chcemy poda dowody dolnych ogranicze czasu oblicze. Aby wykaza, e nie istnieje algorytm, który wykonuje dane zadanie w czasie krótszym ni pewien czas, potrzebujemy cislej i w wielu punktach bardzo sztywnej definicji tego, czym jest algorytm. Przyklad takiej definicji stanowi maszyny Turinga (p. 1.6.).
W opisach i objanieniach algorytmów przyda si nam zapis prostszy i bardziej jasny ni program dla maszyny o dostpie swobodnym, maszyna z zapamitanym programem, czy maszyna Turinga. Z tego powodu wprowadzimy jzyk wysokiego poziomu, zwany Pidgin ALGOL. W calej ksice opisujemy algorytmy w tym jzyku. Ale eby rozumie zloono obliczeniow algorytmu opisanego przez Pidgin ALGOL, musimy pokaza, jak Pidgin ALGOL zaley od modeli bardziej formalnych. Zrobimy to w ostatnim punkcie tego rozdzialu.
1.2. Maszyny o dostpie swobodnym
Maszyna (RAM, od random access machine) jest modelem komputera o jednym akumulatorze i instrukcjach, którym nie wolno si modyfikowa.
Maszyna RAM sklada si z tamy wejciowej tylko do czytania, tamy wyjciowej tylko do pisania, programu oraz pamici (rys. 1.3). Tama wejciowa jest cigiem klatek, z których kada zawiera liczb calkowit (by moe ujemn). Ilekro z tamy wejciowej czytany jest symbol, glowica tamy wejciowej przesuwa si o jedn klatk w prawo. Wyjciem jest tama tylko do pisania, podzielona na klatki, które pocztkowo s puste. Gdy wykonywana jest instrukcja pisania, w klatce znajdujcej si na tamie wyjciowej pod glowic tamy wyjciowej drukowana jest liczba calkowita i glowica tamy wyjciowej przesuwana jest na prawo. Gdy symbol wyjciowy zostanie zapisany, nie mona go zmieni.
Pami sklada si z cigu rejestrów r0, r1, . . . , ri, . . . , z których kady moe przechowywa liczb calkowit dowolnej wielkoci. Na liczb rejestrów, które mog by uyte, nie nakladamy adnego ograniczenia górnego. Abstrakcja tego rodzaju jest poprawna, w przypadkach gdy:
1. rozmiar zadania jest na tyle maly, e mieci si ono w pamici komputera, oraz
2. liczby calkowite, uyte do oblicze, s na tyle male, e mieszcz si w pojedynczych slowach maszynowych.
Program dla maszyny RAM nie jest przechowywany w pamici. A wic zakladamy, e program ten nie modyfikuje sam siebie. Program jest jedynie cigiem instrukcji z (nieobowizkowymi) etykietami. cisle okrelenie instrukcji uywanych w programie nie jest zbyt wane, dopóki s podobne do instrukcji spotykanych w rzeczywistych komputerach. Zakladamy instrukcje arytmetyczne, instrukcje wejciawyjcia, instrukcje adresowania poredniego (przykladowo w indeksowaniu do ta-

1.2. Maszyny o dostpie swobodnym

15

Rys. 1.3. Maszyna o dostpie swobodnym
blic) i instrukcje rozgalzienia (branching).2 Wszelkie obliczenia wykonywane s w rejestrze r0, zwanym akumulatorem, który, jak wszystkie pozostale rejestry pamici, moe pomieci dowoln liczb calkowit. Przyklad zbioru instrukcji dla maszyny RAM przedstawia rysunek 1.4. Kada instrukcja sklada si z dwóch czci -- kodu operacji i adresu.
W zasadzie moemy uzupelni ten zbiór o dowolne inne, znane z rzeczywistych komputerów instrukcje, takie jak operacje logiczne czy operacje na znakach, nie zmieniajc przy tym rzdu zloonoci zada. Czytelnik wedle swego uznania moe uwaa zbiór instrukcji za uzupelniony w ten sposób. Operandum moe mie posta:
1. = i, co oznacza sam liczb calkowit i, 2. nieujemnej liczby calkowitej i, co oznacza zawarto rejestru i, 3. i, co oznacza adresowanie porednie. A mianowicie, operandum jest zawar-
toci rejestru j, gdzie j jest liczb calkowit, która znajduje si w rejestrze i. Jeeli j < 0, to maszyna ulega zatrzymaniu.
2Oprócz instrukcji warunkowych (Jump on Greater than Zero, Jump on Zero, jak czytam JGTZ i JZERO), repertuar zawiera JUMP; por. rys. 1.5 (str. 17) -- przyp. tlum.

16 Rozdzial 1. Modele obliczania

Kod operacji
1. LOAD 2. STORE 3. ADD 4. SUB 5. MULT 6. DIV 7. READ 8. WRITE 9. JUMP 10. JGTZ 11. JZERO 12. HALT

Adres
operandum operandum operandum operandum operandum operandum operandum operandum etykieta etykieta etykieta

Rys. 1.4. Tablica instrukcji RAM

Instrukcje te powinny by dobrze znane kademu, kto programowal asembler. Moemy teraz zdefiniowa sens programu P za pomoc dwóch wielkoci: przeksztalcenia c okrelonego na zbiorze nieujemnych liczb calkowitych o wartociach w zbiorze liczb calkowitych i ,,licznika lokalizacji", który ustala nastpn instrukcj do wykonania. Funkcja c jest map pamici; c(i) jest to liczba calkowita umieszczona w rejestrze i (zawarto rejestru i).
Pocztkowo c(i) = 0 dla kadego i 0, licznik lokalizacji jest nastawiony na pierwsz instrukcj P , a tama wyjciowa jest pusta. Po wykonaniu k-tej instrukcji P licznik lokalizacji jest automatycznie nastawiany na k + 1 (tj. na nastpn instrukcj), chyba e k-t instrukcj jest JUMP, HALT, JGTZ lub JZERO.
Aby okreli sens instrukcji, definiujemy v(a), warto operandum a nastpujco:
v(= i) = i, v(i) = c(i), v(i) = c(c(i)).
Tabela na rysuku 1.5 definiuje sens kadej instrukcji z rysunku 1.4. Instrukcje niezdefiniowane, takie jak STORE = i, mona uwaa za równowane HALT. Podobnie zatrzymuje maszyn dzielenie przez zero.
Podczas wykonywania kadej z pierwszych omiu instrukcji licznik lokalizacji jest zwikszany o 1. Instrukcje s wykonywane w porzdku, w którym wystpuj w programie, a do napotkania instrukcji JUMP, HALT, JGTZ przy zawartoci akumulatora wikszej od zera, lub JZERO, przy zawartoci akumulatora równej zero.
Ogólnie program RAM definiuje przeksztalcenie tam wejciowych w tamy wyjciowe. Skoro nie dla wszystkich tam wejciowych program moe si zatrzyma, przeksztalcenie jest czciowe (czyli moe by nieokrelone dla pewnych danych

1.2. Maszyny o dostpie swobodnym

17

Instrukcja 1. LOAD a 2. STORE i
STORE i 3. ADD a 4. SUB a 5. MULT a 6. DIV a 7. READ i
READ i
8. WRITE a
9. JUMP b 10. JGTZ b
11. JZERO b
12. HALT

Sens
c(0)  v(a) c(i)  c(0) c(c(i))  c(0) c(0)  c(0) + v(a) c(0)  c(0) - v(a) c(0)  c(0) × v(a) c(0)  c(0)/v(a) (3) c(i)  biecy symbol na wejciu. c(c(i))  biecy symbol na wejciu. Glowica tamy wejciowej przesuwa si o jedn klatk w prawo w obu przypadkach. v(a) jest drukowane w klatce, która na tamie wyjciowej jest obecnie pod glowic. Nastpnie glowica tamy wyjciowej przesuwana jest o jedn klatk w prawo. Licznik lokalizacji jest nastawiany na instrukcj z etykiet b. Licznik lokalizacji jest nastawiany na instrukcj z etykiet b, jeeli c(0) > 0; w przeciwnym razie licznik lokalizacji jest nastawiany na nastpn instrukcj. Licznik lokalizacji jest nastawiany na instrukcj z etykiet b, jeeli c(0) = 0; w przeciwnym razie licznik lokalizacji jest nastawiany na nastpn instrukcj. Wykonanie ustaje.

3W tej ksice x (ceiling x ) oznacza najmniejsz liczb calkowit, wiksz lub równ x, za x (floor lub cz calkowita x ) oznacza najwiksz liczb calkowit, mniejsz lub równ x.

Rys. 1.5. Sens instrukcji RAM. Operandum a jest tu = i, i, lub i

wejciowych). Przeksztalcenie to mona interpretowa na róne sposoby. Dwiema istotnymi interpretacjami s funkcja, bd jzyk.
Przypumy, e program P zawsze czyta n liczb calkowitych z tamy wejciowej i pisze co najwyej jedn liczb calkowit na tamie wyjciowej. Jeeli x1, x2, . . . , xn s liczbami calkowitymi w pierwszych n klatkach tamy wejciowej a P zapisuje y w pierwszej klatce tamy wyjciowej i zatrzymuje si, to mówimy, e P oblicza funkcj f (x1, x2, . . . , xn) = y. Latwo udowodni, e RAM, jak kady inny realistyczny model komputera, oblicza jedynie funkcje czciowo rekurencyjne. Otó dla kadej czciowo rekurencyjnej funkcji f moemy zdefiniowa program RAM, który oblicza f , i dla kadego programu RAM, równowan funkcj czciowo rekurencyjn (patrz Davis [ 1958 ] lub Rogers [ 1967 ] odnonie funkcji rekurencyjnych).
Program RAM mona interpretowa take jako akceptor jzyka. Alfabetem jest skoczony zbiór symboli, a jzykiem zbiór napisów nad pewnym alfabetem. Symbole alfabetu mog by reprezentowane przez liczby calkowite 1, 2, . . . , k dla pewnego k. Maszyna RAM moe akceptowa jzyk w nastpujcy sposób. Umieszczamy

18 Rozdzial 1. Modele obliczania

begin read r1; if r1 0 then write 0 else begin r2  r1; r3  r1 - 1; while r3 > 0 do begin r2  r2  r1; r3  r3 - 1 end; write r2 end
end
Rys. 1.6. Program dla nn w Pidgin ALGOLu

napis wejciowy s = a1a2 · · · an na tamie wejciowej: symbol a1 w pierwszej klatce, symbol a2 w drugiej, itd. Symbol 0, którego uyjemy jako znacznika koca, umieszczamy w klatce (n + 1), by oznaczy koniec napisu wejciowego.

Napis wejciowy s jest akceptowany przez program P maszyny RAM, jeeli P czyta caly napis s i znacznik koca, pisze 1 w pierwszej klatce tamy wyjciowej i zatrzymuje si. Jzyk akceptowany przez P jest zbiorem akceptowanych napisów wejciowych. Dla napisów wejciowych, które nie nale do jzyka akceptowanego przez P , P moe drukowa na tamie wyjciowej symbol inny ni 1 i zatrzymywa si albo nawet nie zatrzymywa si. Latwo udowodni, e jzyk jest akceptowany przez program RAM wtedy i tylko wtedy, gdy jest rekurencyjnie przeliczalny. Jzyk jest akceptowany przez zatrzymujc si dla wszystkich danych maszyn RAM wtedy i tylko wtedy, gdy jest jzykiem rekurencyjnym (odnonie jzyków rekurencyjnych i rekurencyjnie przeliczalnych, patrz Hopcroft i Ullman [ 1969 ]).

Rozwamy dwa przyklady programów RAM. Pierwszy definiuje funkcj, drugi akceptuje jzyk.

Przyklad 1.1. Rozwamy funkcj f (n) dan wzorem:

f (n) = 0nn,

gdy liczba calkowita n w przeciwnym razie.

1,

Napisany w jzyku Pidgin ALGOL program, który oblicza f (n) mnoc n samo przez siebie (n - 1) razy, podaje rys. 1.6.4 Odpowiedni program RAM to rys. 1.7. Zmienne r1, r2 i r3 le w rejestrach 1, 2 i 3. Nie robimy pewnych oczywistych usprawnie, wic odpowiednio midzy rysunkami 1.6 i 1.7 bdzie jasna.
4Patrz punkt 1.8. w sprawie opisu jzyka Pidgin ALGOL.

1.2. Maszyny o dostpie swobodnym

19

pos:
while: continue:
endwhile: endif:

Program RAM

READ LOAD JGTZ WRITE JUMP LOAD STORE LOAD SUB STORE LOAD JGTZ JUMP LOAD MULT STORE LOAD SUB STORE JUMP WRITE HALT

1 1 pos =0



endif 1 2 1 =1 3 3 continue endwhile 2 1 2 3 =1 3

    

while

2

Odpowiednie instrukcje Pidgin ALGOLu read r1 if r1 0 then write 0
r2  r1 r3  r1 - 1
while r3 > 0 do
r2  r2  r1
r3  r3 - 1
write r2

Rys. 1.7. Program RAM dla nn

begin d  0; read x; while x = 0 do begin if x = 1 then d  d - 1 else d  d + 1; read x end; if d = 0 then write 1
end
Rys. 1.8. Rozpoznawanie napisów z równ liczb jedynek i dwójek
Przyklad 1.2. Rozwamy program RAM, który akceptuje zloony ze wszystkich napisów o tej samej liczbie jedynek i dwójek jzyk nad alfabetem wejciowym {1, 2}. Program ten wczytuje kady symbol wejciowy do rejestru 1, a w rejestrze 2 utrzy-

20 Rozdzial 1. Modele obliczania

while:
one: endif: endwhile: output:

Program RAM

LOAD =0 STORE 2



READ LOAD JZERO LOAD SUB JZERO LOAD SUB STORE

1 1 endwhile 1 =1 one 2 =1 2

  

JUMP LOAD ADD STORE

endif 2 =1 2



READ 1

JUMP LOAD JZERO HALT WRITE

while 2 output
=1



HALT

Odpowiednie instrukcje Pidgin ALGOLu d0 read x while x = 0 do if x = 1
then d  d - 1
else d  d + 1 read x
if d = 0 then write 1

Rys. 1.9. Program RAM odpowiadajcy algorytmowi z rysunku 1.8

muje rónic d pomidzy liczb jedynek i dwójek widzianych dotychczas. Po napotkaniu znacznika koca 0 sprawdza, czy rónica d jest równa zero i jeeli tak jest, drukuje 1 i zatrzymuje si. Zakladamy, e 0, 1 i 2 s wszystkimi moliwymi symbolami wejciowymi.
Program z rysunku 1.8 zawiera istotne szczególy tego algorytmu. Równowany program RAM podaje rys. 1.9; x ley w rejestrze 1, a d w rejestrze 2.

1.3. Zloono obliczeniowa programów RAM
Dwie wane miary algorytmu to jego zloono czasowa i pamiciowa w funkcji rozmiaru danych. Jeeli za zloono, dla pewnego rozmiaru danch, wzi zloono maksymaln dla wszystkich danych tego rozmiaru, to zloono t nazywa si zloonoci najgorszego przypadku. Jeeli za zloono wzi ,,redni" zloono dla wszystkich danych pewnego rozmiaru, t zloono nazywana si zloonoci oczekiwan. Zloono oczekiwana algorytmu jest zwykle trudniejsza do oszacowania

1.3. Zloono obliczeniowa programów RAM

21

ni zloono najgorszego przypadku. Konieczne jest jakie zaloenie o rozkladzie danych, a zaloenia zgodne z rzeczywistoci na ogól nie s latwe (tractable) matematycznie. Poloymy nacisk na zloono najgorszego przypadku, poniewa jest latwiejsza do potraktowania i ma uniwersalne zastosowanie. Jednake naley pamita, e algorytm o najlepszej zloonoci najgorszego przypadku niekoniecznie musi mie najlepsz zloono oczekiwan.

Zloono czasowa najgorszego przypadku (bd po prostu zloono czasowa) programu RAM jest funkcj f (n), która dla wszystkich danych rozmiaru n jest maksimum sumy opisujcej ,,czas" zuywany przez kad wykonywan instrukcj. Oczekiwana zloono czasowa jest redni dla wszystkich danych rozmiaru n tej samej sumy. Odnonie pamici definiujemy podobne terminy, gdy za ,,«czas» zuywany przez kad wykonywan instrukcj" podstawiamy ,,«pami» zuywan przez kady wykorzystywany rejestr".

Aby cile okreli zloono czasow i pamiciow, musimy okreli czas wymagany dla wykonania kadej instrukcji RAM i pami zajmowan przez kady rejestr. Rozwaymy dwa takie kryteria kosztu dla programów RAM. Wedlug kryterium kosztu zuniformizowanego kada instrukcja RAM wymaga jednej jednostki czasu, a kady rejestr, jednej jednostki pamici. O ile nie zaznaczymy inaczej, zloono programu RAM bdzie mierzona wedlug kryterium kosztu zuniformizowanego.

Druga definicja, niejednokro bardziej realistyczna, uwzgldnia skoczon dlugo

rzeczywistego slowa pamiciowego i nazywana jest kryterium kosztu logarytmicz-

nego. Niech l(i) bdzie nastpujc funkcj logarytmiczn dla liczb calkowitych:

l(i) = 1,log | i |

+ 1,

i=0 i=0

Tabela na rysunku 1.10 przedstawia koszt logarytmiczny t(a) dla trzech moliwych postaci operandum a. Rysunek 1.11 przedstawia czas wymagany przez kad z instrukcji.
W tym koszcie uwzgldniony jest fakt, e reprezentacja liczby calkowitej n w rejestrze wymaga log n + 1 bitów. Rejestry, jak pamitamy, mog zawiera dowolnie due liczby calkowite.
Kryterium kosztu logarytmicznego opiera si na grubym zaloeniu, e koszt wykonania instrukcji jest proporcjonalny do dlugoci operandów tych instrukcji. Rozwamy na przyklad koszt instrukcji ADD i. Po pierwsze musimy ustali koszt

Operandum a
=i i
i

Koszt t(a)
l(i) l(i) + l(c(i)) l(i) + l(c(i)) + l(c(c(i)))

Rys. 1.10. Logarytmiczny koszt operandum

22 Rozdzial 1. Modele obliczania

Instrukcja
1. LOAD a 2. STORE i
STORE i 3. ADD a 4. SUB a 5. MULT a 6. DIV a 7. READ i
READ i 8. WRITE a 9. JUMP b 10. JGTZ b 11. JZERO b 12. HALT

Koszt
t(a) l(c(0)) + l(i) l(c(0)) + l(i) + l(c(i)) l(c(0)) + t(a) l(c(0)) + t(a) l(c(0)) + t(a) l(c(0)) + t(a) l(input) + l(i) l(input) + l(i) + l(c(i)) t(a) 1 l(c(0)) l(c(0)) 1

Rys. 1.11. Logarytmiczny koszt instrukcji RAM, gdzie t(a) jest kosztem operandum a, za b oznacza etykiet

dekodowania operandum reprezentowanego przez adres. Aby rozpozna liczb calkowit i, trzeba czasu l(i). Nastpnie, aby odczyta c(i), zawarto rejestru i, oraz odszuka rejestr c(i) potrzeba czasu l(c(i)). Wreszcie, czytanie zawartoci rejestru c(i) kosztuje l(c(c(i))). Skoro instrukcja ADD i dodaje liczb calkowit c(c(i)) do c(0), liczby calkowitej w akumulatorze, widzimy, e realistycznym kosztem, jaki naley przypisa instrukcji ADD i, jest l(c(0)) + l(i) + l(c(i)) + l(c(c(i))).
Logarytmiczn zloono pamiciow programu RAM definiujemy jako sum l(xi) po wszystkich rejestrach z akumulatorem wlcznie, gdzie xi jest liczb calkowit o najwikszej wielkoci, umieszczon w rejestrze i w dowolnej chwili oblicze.
Jest rzecz jasn, e dany program moe mie calkowicie róne zloonoci czasowe zalenie od tego, czy uyje si kosztu zuniformizowanego, czy logarytmicznego. Jeeli zaloenie, e kad liczb napotkan w czasie oblicze mona umieci w jednym slowie maszynowym, jest realistyczne, to wlaciwa jest funkcja kosztu zuniformizowanego. W przeciwnym razie dla realistycznej analizy zloonoci bardziej wlaciwy moe by koszt logarytmiczny.
Obliczmy zloono czasow i pamiciow programu RAM, który wylicza wartoci nn w przykladzie 1.1. Zloono czasowa tego programu jest zdominowana przez ptl z instrukcj MULT. Za i-tym razem, gdy wykonywana jest istrukcja MULT, akumulator zawiera ni, a rejestr 2 zawiera n. Wszystkich wykonywanych instrukcji MULT jest n - 1. Zgodnie z kryterium kosztu zuniformizowanego kada z instrukcji MULT kosztuje jedn jednostk czasu, std na wykonanie wszystkich instrukcji MULT zuywany jest czas O(n). Zgodnie z kryterium kosztu logarytmicznego kosz-

1.4. Model z zapamitanym programem

23

tem wykonania i-tej instrukcji MULT jest l(ni) + l(n) (i + 1) log n i wobec tego kosztem wszystkich instrukcji MULT jest:

n-1
(i + 1) log n,
i=1

który jest O(n2 log n).

Zloono pamiciow dyktuj liczby calkowite, umieszczone w rejestrach od 0
do 3. Zgodnie z kosztem zuniformizowanym zloono pamiciowa jest po prostu
O(1). Zgodnie z kosztem logarytmicznym zloono pamiciowa jest O(n log n), gdy najwiksz liczb calkowit umieszczon w dowolnym z rejestrów jest nn, a l(nn) n log n. Wobec tego dla programu z przykladu 1.1 mamy nastpujce
zloonoci:

Koszt

Koszt

zuniformizowany logarytmiczny

Zloono czasowa Zloono pamiciowa

O(n) O(1)

O(n2 log n) O(n log n)

Koszt zuniformizowany jest dla tego programu realistyczny tylko wtedy, gdy pojedyncze slowo maszynowe moe pomieci liczb calkowit tak du, jak nn. Jeeli liczba nn jest wiksza od tego, co mona pomieci w jednym slowie maszynowym,
to nawet logarytmiczna zloono czasowa jest nieco nierealistyczna, gdy zakla-
da, e dwie liczby calkowite, i oraz j, mog by pomnoone przez siebie w czasie
O(l(i)) + l(j)), a nie wiadomo dotychczas, czy tak jest.

Dla programu RAM z przykladu 1.2, przy zaloeniu, e n jest dlugoci napisu wejciowego, zloonoci czasowe i pamiciowe s nastpujce:

Koszt

Koszt

zuniformizowany logarytmiczny

Zloono czasowa Zloono pamiciowa

O(n) O(1)

O(n log n) O(log n)

Jeeli n jest wiksze od tego, co mona pomieci w jednym slowie maszynowym, to koszt logarytmiczny dla tego programu jest do realistyczny.

1.4. Model z zapamitanym programem
Poniewa program RAM nie jest przechowywany w pamici maszyny, nie moe modyfikowa sam siebie. Teraz rozwaymy inny model komputera, tzw. maszyn o dostpie swobodnym z zapamitanym programem (RASP, od random access stored program), która jest podobna do maszyny RAM z tym, e program jest w pamici i moe modyfikowa sam siebie.

24 Rozdzial 1. Modele obliczania

Instrukcja

LOAD LOAD STORE ADD ADD SUB SUB MULT MULT

i =i
i i =i i =i i =i

Kodowanie
1 2 3 4 5 6 7 8 9

Instrukcja

DIV DIV READ WRITE WRITE JUMP JGTZ JZERO HALT

i =i
i i =i i i i

Kodowanie
10 11 12 13 14 15 16 17 18

Rys. 1.12. Kody dla instrukcji RASP

Zbiór instrukcji RASP jest identyczny ze zbiorem instrukcji RAM prócz tego, e adresowanie porednie nie jest dozwolone, gdy nie jest potrzebne. Jak zobaczymy, RASP moe symulowa adresowanie porednie przez modyfikacje instrukcji w czasie wykonania programu.
Ogólna struktura maszyny RASP jest take podobna do struktury RAM, ale zaklada si, e program RASP ley w rejestrach pamici. Kada instrukcja RASP zajmuje dwa kolejne rejestry. Pierwszy z nich zawiera kod operacji; drugi -- adres. Jeeli adres jest w postaci = i, to pierwszy rejestr bdzie kodowa take fakt, e operandum jest literalem, a drugi rejestr bdzie zawiera i. Do kodowania instrukcji slu liczby calkowite. Rysunek 1.12 pokazuje jeden z moliwych sposobów kodowania. Na przyklad instrukcja LOAD= 32 zostanie zapamitana za pomoc 2 w jednym rejestrze i 32 w nastpnym.
Podobnie jak w przypadku RAM, stan RASP moe by reprezentowany przez:
1. map pamici c, gdzie c(i) dla i 0 jest zawartoci rejestru i, oraz 2. licznik lokalizacji, wskazujcy na pierwszy z dwóch kolejnych rejestrów pa-
mici, z których ma by pobrana bieca instrukcja.
Licznik lokalizacji jest nastawiony pocztkowo na pewien zadany rejestr. Pocztkowa zawarto rejestrów pamici to z reguly nie wszdzie 0, gdy na pocztku do pamici pobierany jest program. Na pocztku jednak wszystkie prócz skoczonej liczby rejestrów pamici i akumulator musz zawiera 0 Po wykonaniu kadej instrukcji licznik lokalizacji jest zwikszany o 2, z wyjtkiem przypadków JUMP i, JGTZ i (gdy akumulator jest dodatni), lub JZERO i (gdy akumulator zawiera 0), w których licznik lokalizacji jest nastawiany na i. Skutek kadej z instrukcji jest taki sam jak odpowiedniej instrukcji RAM.
Zloono czasow programu RASP mona zdefiniowa bardzo podobnie, jak zloono czasow programu RAM. Moemy uy bd kryterium kosztu zuniformizowanego, bd logarytmicznego. Kosztem w tym ostatnim przypadku musimy jednak obciy nie tylko operandum, lecz take dostp do samej instrukcji. Kosztem tego

1.4. Model z zapamitanym programem

25

dostpu jest l(LC), gdzie LC oznacza zawarto licznika lokalizacji. Na przyklad kosztem wykonania instrukcji ADD = i, umieszczonej w rejestrach j oraz j + 1, jest l(j) + l(c(0)) + l(i)5. Kosztem instrukcji ADD i, umieszczonej w rejestrach j oraz j + 1, jest l(j) + l(c(0)) + l(i) + l(c(i)).
Ciekawe jest pytanie, co róni zloono programu RAM i odpowiedniego programu RASP. Odpowied nie jest zaskakujca. Dowolne przeksztalcenie wejcia na wyjcie, które moe by wykonane w czasie T (n) przez jeden model, moe by wykonane przez drugi w czasie kT (n) dla pewnej stalej k, bez wzgldu na to, czy wemie si koszt zuniformizowany, czy logarytmiczny. Podobnie pami wykorzystywana przez te modele róni si tylko o staly czynnik przy obu miarach kosztu.
Dwa twierdzenia wyraaj te zalenoci w sposób formalny. Obydwu dowodzi si, pokazujc algorytmy, na mocy których RAM moe symulowa RASP i odwrotnie.
Twierdzenie 1.1. Jeeli koszt instrukcji jest zuniformizowany lub logarytmiczny, to istnieje taka stala k, e dla kadego programu RAM o zloonoci czasowej T (n) istnieje równowany program RASP o zloonoci czasowej kT (n).
Dowód. Pokazujemy, jak symulowa program RAM P przez program RASP. Rejestr 1 RASP bdzie sluy do tymczasowego przechowywania zawartoci akumulatora RAM. Z programu P skonstruujemy program RASP PS, który bdzie zajmowa nastpne r - 1 rejestrów RASP. Stala r jest zdeterminowana przez program RAM P . Zawarto rejestru i RAM, i 1, bdzie przechowywana w rejestrze r + i RASP, wic w programie RASP wszystkie odniesienia do pamici maj adresy o r wiksze od odpowiednich odniesie w programie RAM.
Kada instrukcja RAM w P , niewymagajca adresowania poredniego, jest kodowana bezporednio w postaci identycznej instrukcji RASP (z odpowiednio zwikszonymi adresami odniesie do pamici). Kada instrukcja RAM w P , wymagajajca adresowania poredniego, jest przeksztalcana w sekwencj szeciu instrukcji RASP, która symuluje adresowanie porednie przez modyfikacj instrukcji.
Aby objani symulacj adresowania poredniego powinien wystarczy przyklad. By symulowa instrukcj RAM SUB i, gdzie i jest liczb calkowit dodatni, tworzymy sekwencj instrukcji RASP, która:
1. umieszcza tymczasowo zawarto akumulatora w rejestrze 1, 2. pobiera zawarto rejestru r+i do akumulatora (rejestr r+i RASP odpowiada
rejestrowi i RAM), 3. dodaje r do akumulatora, 4. umieszcza liczb obliczon w kroku 3. w polu adresu instrukcji SUB, 5. przywraca zawarto akumulatora z tymczasowego rejestru 1, i wreszcie 6. uywa instrukcji SUB stworzonej w kroku 4., by wykona odejmowanie.
5Mona by doliczy koszt czytania rejestru j + 1, ale ten koszt nie moe róni si bardzo od l(j). W tym rozdziale mamy na uwadze nie czynniki stale, lecz raczej szybko wzrostu funkcji. Zatem l(j) + l(j + 1) jest ,,w przyblieniu" l(j) z dokladnoci co najwyej do czynnika 3.

26 Rozdzial 1. Modele obliczania

Rejestr
100 101 102 103 104 105 106 107 108 109 110 111

Zawarto

r

3 1 1 +i 5 r 3 111 1 1 6 -

     

Sens

STORE 1

LOAD r + i

ADD = r

STORE 111

LOAD

1

SUB

b gdzie b jest zawartoci rejestru i RAM

Rejestr RASP
j j+2 j+4 j+6 j+8 j + 10

Rys. 1.13. Symulacja SUB i przez RASP

Instrukcja

STORE LOAD ADD STORE LOAD SUB

1 r+1
=r j + 11
1 -

Koszt
l(j) + l(1) + l(c(0)) l(j + 2) + l(r + i) + l(c(i)) l(j + 4) + l(c(i)) + l(r) l(j + 6) + l(j + 11) + l(c(i) + r) l(j + 8) + l(1) + l(c(0)) l(j + 10) + l(c(i) + r) + l(c(0))
+l(c(c(i)))

Rys. 1.14. Koszt instrukcji RASP

Na przyklad, stosujc kodowanie instrukcji RASP podane na rysunku 1.12, i zakladajc, e sekwencja instrukcji RASP zaczyna si w rejestrze 100, moemy symulowa SUB i za pomoc sekwencji pokazanej na rysunku 1.13. Przesunicie r mona okreli, gdy znana jest liczba instrukcji w programie RASP PS.
Stwierdzamy, e kada instrukcja RAM wymaga co najwyej szeciu instrukcji RASP, zatem wedlug kryterium kosztu zuniformizowanego zloonoci czasow programu RASP jest co najwyej 6T (n). (Zauwamy, e miara ta jest niezalena od sposobu, w jaki okrela si ,,wielko" danych.)
Wedlug kryterium kosztu logarytmicznego stwierdzamy, e kada instrukcja RAM I naleca do P jest symulowana przez sekwencj S jednej lub szeciu instrukcji RASP w PS. Moemy pokaza, i istnieje taka stala k zalena od P , e koszt instrukcji nalecych do S jest nie wikszy ni k razy koszt instrukcji I.
Na przyklad instrukcja RAM SUB i ma koszt:
M = l(c(0)) + l(i) + l(c(i)) + l(c(c(i))).

1.4. Model z zapamitanym programem

27

Sekwencja S, która symuluje t instrukcj RAM, jest pokazana na rysunku 1.14. c(0), c(i), oraz c(c(i)) na rysunku 1.14 odnosz si do zawartoci rejestrów RAM. Poniewa PS zajmuje rejestry RASP od 2 do r, mamy j r-11. Ponadto l(x+y) l(x) + l(y), wic koszt S jest na pewno mniejszy ni:
2l(1) + 4M + 11l(r) < (6 + 11l(r))M.
Wobec tego wnioskujemy, e istnieje stala k = 6 + 11l(r) taka, e jeeli P ma zloono czasow T (n), to PS ma zloono czasow co najwyej kT (n).
Twierdzenie 1.2. Jeeli koszt instrukcji jest zuniformizowany lub logarytmiczny, to istnieje taka stala k, e dla kadego programu RASP o zloonoci czasowej T (n) istnieje równowany program RAM o zloonoci czasowej co najwyej kT (n).
Dowód. Program RAM, który skonstruujemy, by symulowa RASP, bdzie uywa adresowania poredniego, eby dekodowa i symulowa instrukcje RASP umieszczone w pamici RAM. Pewne rejestry RAM bd mie specjalne przeznaczenie:
rejestr 1 -- uywany w adresowaniu porednim, rejestr 2 -- licznik lokalizacji RASP, rejestr 3 -- pami do przechowywania akumulatora RASP.
Rejestr i RASP bdzie umieszczony w rejestrze i + 3 RAM dla i 1.
RAM rozpoczyna prac z programem RASP o skoczonej dlugoci, który jest umieszczony w pamici, poczynajc od rejestru 4. Rejestr 2 -- licznik lokalizacji, zawiera 4; rejestry 1 i 3 zawieraj 0. Program RAM tworzy ptla symulacji, która zaczyna si od przeczytania (za pomoc instrukcji RAM LOAD 2) instrukcji RASP, dekodowania tej instrukcji i rozgalzienia do jednego z 18 zestawów instrukcji, z których kady sluy do obslugi jednego typu instrukcji RASP. W razie niepoprawnego kodu operacji, RAM, jak i RASP zatrzymaj si.
Operacje dekodowania i rozgalzienia s jasne; jako model moe sluy przyklad 1.2 (chocia tam dekodowany symbol byl czytany z wejcia, a tu jest czytany z pamici). Podamy przyklad instrukcji RAM, które symuluj instrukcj 6 RASP, tj. SUB i. Program ten, pokazany na rysunku 1.15, ulega wywolaniu, gdy c(c(2)) = 6, a wic gdy licznik lokalizacji wskazuje na rejestr, który zawiera 6, czyli kod SUB.
Pomijamy dalsze szczególy budowy programu RAM. Jako wiczenie pozostawiamy dowód faktu, e wedlug kryterium kosztu zuniformizowanego lub logarytmicznego, zloono czasowa programu RAM jest co najwyej pewn stal w iloczynie ze zloonoci czasow RASP.
Z twierdze 1.1 i 1.2 wynika, e gdy chodzi o zloono czasow (a take pamiciow, co pozostawiamy jako wiczenie) modele RAM i RASP s równowane z dokladnoci do czynnika stalego, tj. rzd ich zloonoci jest ten sam dla tego samego algorytmu. Sporód tych dwóch modeli na ogól wykorzystujemy w ksice model RAM, gdy jest on nieco prostszy.

28 Rozdzial 1. Modele obliczania

LOAD ADD STORE LOAD ADD STORE LOAD SUB STORE LOAD ADD STORE JUMP

2 =1
2 2 =3
1 3 1 3 2 =1 2

   

a

Zwiksz licznik lokalizacji o 1, tak aby wskazywal na rejestr, który zawiera operandum i instrukcji SUB i.
Pobierz i do akumulatora, dodaj 3, wynik umie w rejestrze 1.
Pobierz zawarto akumulatora RASP z rejestru 3. Odejmij zawarto rejestru i + 3, wynik umie z powrotem w rejestrze 3.
Zwiksz licznik lokalizacji znów o 1, tak by wskazywal teraz na nastpn instrukcj RASP.
Powró na pocztek ptli symulacji (nazwany tutaj ,,a").
Rys. 1.15. Symulacja SUB i przez RAM

1.5. Abstrakcje RAM

W wielu sytuacjach nie s potrzebne tak skomplikowane modele oblicze jak RAM i RASP. Wobec tego liczne modele definiuje si przez abstrakcj pewnych wlasnoci RAM, zaniedbujc inne. Uzasadnieniem dla takich modeli jest fakt, e zaniedbywane instrukcje stanowi co najwyej staly ulamek kosztu kadego efektywnego algorytu, rozwizujcego problemy, do których model jest stosowany.

i. Program liniowy
Pierwszym rozwaanym przez nas modelem jest liniowy program (stright-line program). W wielu problemach wystarczy skupi uwag na klasie programów RAM, gdzie instrukcje rozgalzienia s uywame tylko do powtarzania jakiej sekwencji instrukcji pewn ilo razy, proporcjonaln do n -- rozmiaru danych. W tym przypadku dla kadego rozmiaru n mona program ,,rozwin", powielajc odpowiedni ilo razy instrukcje, które maj by powtarzane. Daje to sekwencj liniowych (wolnych od ptli) i zapewne coraz dluszych programów, po jednym dla kadego n.
Przyklad 1.3. Rozwamy mnoenie dwóch macierzy wymiaru n × n o elementach ze zbioru liczb calkowitych. Zwykle mona oczekiwa nie bez racji, e liczba powtórze ptli w programie RAM bdzie niezalena od wielkosci elementów macierzy. Warto wic zaloy dla uproszczenia, e dozwolone s tylko ptle z instrukcjami testu, w których wchodzi w gr wylcznie n, rozmiar zadania. Oczywisty algorytm mnoenia macierzy zawiera ptle, które musz by na przyklad wykonane dokladnie n razy, gdy wymaga instrukcji rozgalzienia, które porównuj indeks z n.
Dziki rozwiniciu programu do postaci liniowej obywamy si bez instrukcji rozgalzienia. Uzasadnienie czerpiemy std, e w wielu zadaniach nie wicej ni staly

1.5. Abstrakcje RAM

29

ulamek kosztu programu RAM jest przeznaczony na instrukcje rozgalzienia, sterujce ptlami. Podobnie czsto moemy zaloy, e instrukcje wejcia tworz tylko staly ulamek kosztu programu i wykluczy je, zakladajc, e skoczony zbiór wej, wymagany przy pewnym n, znajduje si w pamici, gdy program rozpoczyna prac. Skutki adresowania poredniego mona oszacowa przy ustalonym n, o ile rejestry, sluce do adresowania poredniego, zawieraj wartoci zalene tylko od n, a nie od wartoci zmiennych wejciowych. Wobec tego zakladamy, e nasze programy liniowe s pozbawione adresowania poredniego.
Ponadto skoro kady z programów liniowych moe zawiera odniesienia tylko do skoczonej liczby rejestrów pamici, wygodnie jest nazwa rejestry wykorzystywane przez program. Rejestry podlegaj wobec tego raczej odnosieniom przez adresy symboliczne (symbole lub napisy zloone z liter), ni przez liczby calkowite.
Z repertuaru RAM po usuniciu wymaga co do READ, JUMP, JGTZ i JZERO pozostaj nam LOAD, STORE, WRITE, HALT i operacje arytmetyczne. Nie potrzebujemy HALT, gdy koniec programu musi oznacza zatrzymanie. Moemy oby si bez WRITE, wyróniajc pewne adresy symboliczne jako zmienne wyjciowe; informacj wyjcia programu s wartoci tych zmiennych w chwili zakoczenia.
Moemy wreszcie wlczy LOAD i STORE do operacji arytmetycznych, zastpujc sekwencje, takie jak:
LOAD a ADD b STORE c
przez c  a+b. Caly repertuar instrukcji programu liniowego jest wic nastpujcy:
xy+z xy-z zy z z  y/z xi
gdzie x, y i z s adresami symbolicznymi (czyli zmiennymi), a i jest stal. Latwo zauway, e dowolna sekwencja LOAD, STORE i operacji arytmetycznych na akumulatorze moe by zastpiona pewn sekwencj piciu powyszych instrukcji.
Programowi liniowemu s przyporzdkowane dwa wyrónione zbiory zmiennych: jego wejcia i wyjcia. Funkcja obliczana przez program liniowy jest zbiorem wartoci zmiennych wyjciowych (w zadanym porzdku), wyraanych wzgldem wartoci zmiennych wejciowych.
Przyklad 1.4. Rozwamy obliczanie wielomianu:
p(x) = anxn + an-1xn-1 + · · · + a1x + a0
Zmiennymi wejciowymi s wspólczynniki a0, a1, . . . , an i symbol x. Zmienn wyjciow jest p. Wedlug reguly Hornera p(x) obliczamy jako:

30 Rozdzial 1. Modele obliczania

n=1 t  a1  x p  t + a0

n=2
t  a2  x t  t + a1 tt  x p  t + a0

n=3
t  a3  x t  t + a2 tt  x t  t + a1 tt  x p  t + a0

Rys. 1.16. Programy liniowe, odpowiadajce regule Hornera

1. a1x + a0

dla n = 1,

2. (a2x + a1)x + a0

dla n = 2,

3. ((a3x + a2)x + a1)x + a0 dla n = 3.

Wyraeniom tym odpowiadaj programy liniowe z rysunku. 1.16. Regula Hornera dla dowolnego n powinna by jasna. Dla kadego n mamy program liniowy o 2n krokach, który oblicza wielomian n-tego stopnia. W rozdziale 12. pokaemy, e aby obliczy warto wielomianu n-tego stopnia, gdy wspólczynniki s dane jako wejcie, konieczne jest n mnoe i n dodawa. Regula Hornera jest optymalna wedlug modelu programu liniowego.

Wedlug modelu programu liniowego oblicze zloonoci czasow cigu programów jest liczba kroków n-tego programu jako funkcja n. Regula Hornera na przyklad daje cig o zloonoci czasowej 2n. Zauwamy, e mierzenie zloonoci czasowej to tyle, co mierzenie liczby operacji arytmetycznych. Zloonoci pamiciow cigu programów jest liczba wymienionych zmiennych take jako funkcja n. Programy z przykladu 1.4 maj zloono pamiciow n + 4.

Definicja. Gdy chodzi o model programu liniowego, mówimy, e problem ma zloono czasow lub pamiciow OA(f (n)), jeeli istnieje cig programów, którego zloono czasowa lub pamiciowa siga co najwyej cf (n) dla pewnej stalej c. (Zapis OA(f (n)) oznacza ,,rzd f (n) kroków, gdy modelem jest programu liniowy". Wskanik A oznacza ,,arytmetyczny", co jest glówn cech kodu liniowego.) Obliczanie wartoci wielomianu ma zloono czasow OA(n), jak i pamiciow OA(n).

ii. Obliczenia na bitach
Model programu liniowego opiera si oczywicie na funkcji kosztu zuniformizowanego. Jak wspomnielimy, koszt ten jest wlaciwy, gdy wszystkie obliczane wielkoci s ,,rozsdne". Istnieje prosta modyfikacja modelu programu liniowego, która jest odbiciem funkcji kosztu logarytmicznego. Model ten, nazywamy przez nas obliczaniami na bitach, jest zasadniczo taki sam jak kod liniowy za wyjtkiem tego, e:
1. zakladamy, e wszystkie zmienne maj warto 0 lub 1, tj. s bitami.

1.5. Abstrakcje RAM

31

Rys. 1.17. (a)Program dodawania na bitach, (b) równowany uklad logiczny
2. uywamy operacji logicznych, a nie arytmetycznych.6 Piszemy  dla i,  dla lub,  dla rozlcznego lub i ¬ dla nie.
Zgodnie z modelem bitowym operacje arytmetyczne na liczbach calkowitych i i j wymagaj przynajmniej l(i)+l(j) kroków, co jest odbiciem logarytmicznego kosztu operandów. Faktycznie, mnoenie i dzielenie wedlug najlepszych znanych algorytmów wymaga wiecej ni l(i) + l(j) kroków, by pomnoy lub podzieli i przez j.
Na oznaczenie rzdu wielkoci w modelu oblicze na bitach stosujemy OB. Model bitowy przydaje si, gdy chcemy mówi o podstawowych operacjach, jak operacje arytmetyczne, które s pierwotne w innych modelach. Na przyklad w modelu programu liniowego mnoenie dwóch n-bitowych liczb calkowitych jest do wykonania w OA(1) kroku, natomiast w modelu bitowym najlepszy znany wynik to OB(n log n log log n) kroków.
6Std zbiór instrukcji RAM musi zawiera te operacje.

32 Rozdzial 1. Modele obliczania
Innym zastosowaniem modelu bitowego s uklady logiczne. Programy liniowe z bitowymi wejciami i operacjami odpowiadaj wzajemnie jednoznacznie logicznokombinatorycznym ukladom do obliczania ukladów funkcji boolowskich. Liczba kroków programu jest liczb elemetów logicznych ukladu.
Przyklad 1.5. Rysunek 1.17(a) przedstawia program dodawania dwóch dwubitowych liczb [ a1a0 ] i [ b1b0 ]. Zmiennymi wyjciowymi s c2, c1 i c0, takie e [ a1a0 ] + [ b1b0 ] = [ c2c1c0 ]. Program liniowy z rysunku 1.17(a) oblicza:
c0 = a0  b0, c1 = ((a0  b0)  a1)  b1, c2 = ((a0  b0)  (a1  b1))  (a1  b1).
Rys. 1.17(b) przedstawia odpowiedni uklad logiczny. Dowód, e dodawanie dwu n-bitowych liczb mona wykona w OB(n) krokach zostawiamy jako wiczenie.
iii. Operacje na wektorach bitowych
Zamiast ogranicza warto zmienej do 0 lub 1, mona pój w przeciwnym kierunku i pozwoli, by zmienne przybieraly jako warto dowolny wektor bitów. Faktycznie, wektory bitów o danej dlugoci odpowiadaj w oczywisty sposób liczbom calkowitym, wic nie wykraczamy istotnie poza model RAM, tj. w razie potrzeby wci zakladamy nieograniczon wielko rejestrów.
Jednake, jak zobaczymy w tych kilku algorytmach, w których stosowany jest model z wektorami bitów, dlugo uywanych wektorów znacznie przewysza liczb bitów potrzebnych do przedstawienia wielkoci zadania. Wielko liczb calkowitych uywanych w algorytmie bdzie na ogól tego samego rzdu co wielko zadania. Na przyklad, rozwizujc problemy dróg w grafie o 100 wierzcholkach, mona by zastosowa wektory bitów o dlugoci 100 do wskazywania, czy istnieje droga z danego wierzcholka v do kadego z wierzcholków grafu; tzn. w wektorze dla wierzcholka v na i-tej pozycji jest 1 wtedy i tylko wtedy, gdy istnieje droga z v do vi. W przypadku tego samego problemu mona uywa take liczb calkowitych (przykladowo do liczenia i indeksowania) i bd one mie wielko zapewne rzdu 100. Std dla liczb calkowitych bdzie potrzebne 7 bitów, podczas gdy dla wektorów 100.
Rónica nie musi by jednak a tak znaczna, poniewa wikszo komputerów wykonuje operacje logiczne na wektorach bitów o dlugoci pelnego slowa w cyklu jednej instrukcji. Zatem wektory bitów o dlugoci 100 mog podlega manipulacjom w trzech lub czterech krokach, w porównaniu z jednym krokiem dla liczb calkowitych. Niemniej wyniki na temat czasowej i pamiciowej zloonoci algorytmów dla modelu z wektorami bitów naley bra cum grano salis, gdy wielko zadania, przy której model ten staje si nierealistyczny jest znacznie mniejsza, ni dla modelu RAM i modelu kodu liniowego. Na oznaczenie rzdu wielkoci w modelu z wektorami bitowymi stosujemy OBV.

1.5. Abstrakcje RAM

33

iv. Drzewa decyzji
Rozwaylimy trzy abstrakcje RAM, które zaniedbywaly instrukcje rozgalzienia i obejmowaly tylko kroki zwizane z obliczaniem. Istniej pewne problemy, w których mona realistycznie uzna liczb instrukcji rozgalzienia za podstawow miar zloonoci. W sortowaniu na przyklad, wyjcia s identyczne z wejciami, wyjwszy uporzdkowanie. Rozsdnie jest wic rozway model, w którym wszystkie kroki s rozgalzieniami od dwóch ramionach, i polegaj na porównaniu dwóch wielkoci.
Czst reprezentacj programu z rozgalzieniami jest drzewo binarne7, zwane drzewem decyzji. Kady wewntrzny wierzcholek reprezentuje decyzj. Test reprezentowany przez korze jest wykonywany jako pierwszy, po czym zalenie od wyniku ,,sterowanie" przechodzi do jednego z synów. Ogólnie, sterowanie tak dlugo przechodzi od wierzcholka do jednego z synów, przy czym wybór zaley zawsze od testu na wierzcholku, a dotrze do licia. Wynik jest dostpny na tym liciu.
Przyklad 1.6. Rys. 1.18 pokazuje drzewo decyzji dla programu, który sortuje trzy liczby a, b i c. Testy wskazuj owale wokól porówna na wierzcholkach; sterowanie przechodzi na lewo, jeeli test daje odpowied ,,tak", i na prawo, jeeli ,,nie".
Zloonoci czasow drzewa decyzji jest jego wysoko jako funkcja rozmiaru zadania. Zwykle chcemy oszacowa maksimum liczby porówna, które trzeba wykona, by doj z korzenia do licia. Zakladajc model drzewa decyzji (porówna), oznaczamy rzd wielkoci przez OC. Liczba wierzcholków moe by znacznie wiksza od wysokoci drzewa. Na przyklad drzewo decyzji, które sortuje n liczb, musi mie przynajmniej n! lici, lecz wystarczy, e ma wysoko okolo n log n.

Rys. 1.18. Drzewo decyzji
7W sprawie definicji dotyczcych drzew patrz punkt 2.4.

34 Rozdzial 1. Modele obliczania
1.6. Pierwotny model obliczania: maszyna Turinga
By udowodni, e dana funkcja wymaga pewnego minimum czasu, potrzebujemy modelu, który jest równie ogólny, lecz bardziej pierwotny od rozpatrzonych. Repertuar instrukcji ma by jak najbardziej ograniczony, jednak model nie tylko musi oblicza to wszystko, co oblicza RAM, lecz czyni to niemal równie szybko. Wedlug definicji, której uyjemy, ,,niemal" oznacza ,,równowano wielomianow".
Definicja. Mówimy, e funkcje f1(n) i f2(n) s równowane wielomianowo, jeeli istniej wielomiany p1(x) i p2(x) takie, e dla wszystkich wartoci n, f1(n) p1(f2(n)) i f2(n) p2(f1(n)).
Przyklad 1.7. Funkcje f1(n) = 2n2 i f2(n) = n5 s równowane wielomianowo; niech na przyklad p1(x) = 2x, skoro 2n2 2n5, i p2(x) = x3, skoro n5 (2n2)3. Natomiast n2 i 2n nie s równowane wielomianowo, gdy nie istnieje wielomian p(x), taki e dla kadego n, p(n2) 2n.
Obecnie jedynym zakresem, w którym do dowodu dolnych ogranicze zloonoci obliczeniowej moemy uy ogólnych modeli, takich jak maszyna Turinga, jest ,,wyszy zakres". Na przyklad w rozdziale 11. pokaemy, e pewne problemy wymagaj wykladniczego czasu i pamici. (f (n) jest funkcj wykladnicz, jeeli istniej stale c1 > 0, k1 > 1, c2 > 0 i k2 > 1 takie, e c1k1n f (n) c2k2n dla wszystkich, prócz skoczonej liczby wartoci n.) W wykladniczym zakresie funkcje wielomianowo równowane s zasadniczo tosame, gdy dowolna funkcja, która jest równowana wielomianowo z funkcj wykladnicz, jest funkcj wykladnicz.
Jest wic powód, by uywa pierwotnego modelu, w którym zloono czasowa problemów jest równowana wielomianowo ich zloonoci w modelu RAM. Model, którego uywamy -- maszyna Turinga z wieloma tamami -- moe wymaga czasu8 ([ f (n) ]4), lecz nie wicej, aby wykona to, co RAM z funkcj kosztu logarytmicznego wykonuje w czasie f (n). Zloono czasowa z uyciem modelu RAM i maszyny Turinga bdzie równowana wielomianowo.
Definicja. Maszyn Turinga z wieloma tamami (TM) przedstawia rys. 1.19. Sklada si ona z pewnej liczby k nieskoczoczonych w prawo tam. Kada tama jest podzielona na komórki, a kada z nich zawiera jeden symbol sporód skoczonej liczby symboli tam. Jedna komórka na kadej tamie jest czytana przez glowic tamy; glowica moe czyta i pisa. Dzialanie maszyny Turinga jest okrelone przez pierwotny program, zwany sterowaniem skoczonym. Sterowanie skoczone jest zawsze w jednym ze skoczonej liczby stanów, które mona uzna pozycje w programie.
Jeden krok obliczeniowy maszyny Turinga zbudowany jest nastpujco. Zgodnie z biecym stanem sterowania skoczonego i symbolami tam, które ustawione
8Mona udowodni dokladniejsze ograniczenie: O([ f (n) log f (n) log log f (n) ]2), lecz skoro nie rozwaamy tu czynników wielomianowych, wynik z czwart potg wystarczy (patrz p. 7.5).

1.6. Pierwotny model obliczania: maszyna Turinga

35

Rys. 1.19. Maszyna Turinga z wieloma tamami
s pod (s czytane przez ) kad z glowic tam, maszyna Turinga moe wykona dowoln lub wszystkie z poniszych operacji.
1. Zmieni stan sterowania skoczonego. 2. Wydrukowa nowe symbole tam na biecych symbolach w dowolnej lub
kadej z komórkek pod glowicami tam. 3. Przesun niezalenie dowoln lub kad glowic o jedn komórk w lewo (L),
lub w prawo (R), lub pozostawi glowice bez ruchu (S).
Formalnie oznaczamy k-tamow maszyn Turinga przez siódemk uporzdkowan:
(Q, T, I, , b, q0, qf ),
gdzie:
1. Q jest zbiorem stanów. 2. T jest zbiorem symboli tam. 3. I jest zbiorem symboli wejciowych; I  T . 4. b, element T - I, jest bialym znakiem. 5. q0 jest stanem pocztkowym. 6. qf jest stanem kocowym (lub akceptujcym). 7. , funkcja nastpnego ruchu, odwzorowuje podzbiór Q × T k w rodzin pod-
zbiorów Q × (T × L, R, S)k. Tj. dla pewnych (k + 1)-elementowych ukladów uporzdkowanych, zloonych ze stanu i k symboli tam daje nowy stan oraz k par uporzdkowanych, zloonych z nowego symbolu tam i kierunku dla glowicy. Zalómy, e (q, a1, a2, . . . , ak) = (q , (a1, d1), (a2, d2), . . . , (ak, dk) i maszyna Turinga jest w stanie q i dla 1 i k, i-ta glowica czyta symbol tam ai. Wtedy w jednym ruchu maszyna Turinga wchodzi w stan q , zmienia symbol ai na ai i przesuwa i-t glowic w kierunku di dla 1 i k.

36 Rozdzial 1. Modele obliczania
Rys. 1.20. Maszyna Turinga przetwarzajca 01110 Maszyna Turinga moe rozpoznawa jzyk. Symbole tam maszyny Turinga obejmuj alfabet jzyka, zwany symbolami wejciowymi, specjalny bialy znak, oznaczony przez b, i prócz tego by moe inne symbole. Pocztkowo pierwsza tama zawiera napis w symbolach wejciowych, po jednym symbolu w komórce, poczynajc od komórki poloonej najbardziej na lewo. Wszystkie komórki na prawo od komórek zawierajcych napis wejciowy s puste. Wszystkie inne tamy s zupelnie puste. Napis w symbolach wejciowych jest akceptowany wtedy i tylko wtedy, gdy maszyna Turinga, zaczynajc od wyrónionego stanu pocztkowego ze wszystkimi glowicami na lewych kocach tam wykonuje cig ruchów, w którym przechodzi kiedy w stan akceptujcy. Jzyk akceptowany przez maszyn Turinga jest zbiorem akceptowanych w powyszym sensie napisów w symbolach wejciowych. Przyklad 1.8. Na rysunku 1.20 maszyna Turinga z dwiema tamami rozpoznaje palindromy9 nad alfabetem {0, 1} w nastpujcy sposób.
9Napis, który od tylu mona odczyta, tak jak do przodu, np. 0100010, nazywa si palindromem.

1.6. Pierwotny model obliczania: maszyna Turinga

37

Stan

Symbol

(Nowy symbol, ruch glowicy) Nowy

biecy Tama 1 Tama 2 Tama 1 Tama 2 stan

Komentarze

q0 0 1 b
q1 0 1 b
q2 b b b
q3 0 1
q4 0 0 1 1 0 1

b 0,S X,R q1 Jeeli dana nie jest pusta, drukuj X b 1,S X,R q1 na tamie 2 i przesu glowic w prab b,S b,S q5 wo; przejd do stanu q1. W przeciw-
nym razie przejd do stanu q5.

b 0,R 0,R q1 Pozostawaj w stanie q1, kopiujc tab 1,R 1,R q1 m 1 na 2, a dotrzesz do b na tab b,S b,L q2 mie 1. Wtedy przejd do stanu q2.

0 b,S 0,L q2 Pozostaw bez ruchu glowic tamy 1, 1 b,S 1,L q2 a 2 przesuwaj w lewo, a dotrzesz do X b,L X,R q3 X. Wtedy przejd do stanu q3.

0 0,S 0,R q4 Sterowanie na przemian w stanie q3 1 1,S 1,R q4 i q4. W q3 porównaj symbole na obu

0 1 0 1

0,L 0,L 1,L 1,L

0,S 1,S 0,S 1,S

q3 q3 q3 q3

tamach, przesu glowic tamy 2 w prawo i przejd do q4. W q4 przejd do q5 i akceptuj, jeeli glowica dotarla do b na tamie 2. W przeciwnym

b b

0,S 1,S

b,S b,S

q5 q5

razie przesu glowic tamy 1 w lewo i wró do q3. Alternacja q3, q4 zapobiega przekroczeniu lewego koca

tamy przez glowic wejciow.

q5 Akceptuj

Rys. 1.21. Funkcja nastpnego ruchu maszyny Turinga rozpoznajcej palindromy

1. Pierwsz komórk na tamie 2 oznaczona specjalny symbol X; dane s kopiowane z tamy 1, gdzie pocztkowo wystpuj (patrz rys. 1.20a), na tam 2 (patrz rys. 1.20b).
2. Nastpnie glowica tamy 2 jest przesuwana na X (rys. 1.20c), 3. Glowica tamy 2 jest wielokrotnie przesuwana o jedn komórk w prawo,
glowica tamy 1, o jedn komórk w lewo, i porównywane s odpowiednie symbole. Jeeli wszystkie symbole pasuj, dane tworz palindrom i maszyna wchodzi w stan akceptujcy q5. W przeciwnym razie maszyna Turinga nie bdzie mogla w pewnej chwili zrobi adnego poprawnego ruchu; zatrzyma si bez akceptowania.
Funkcj nastpnego ruchu tej maszynie Turinga podaje tablica z rysunku 1.21.
Dzialanie maszyny Turinga mona opisa formalnie za pomoc ,,chwilowych opisów". Opis chwilowy (ID, od instantaneous description) k-tamowej maszyny Turinga M jest to k-elementowy uklad uporzdkowany (1, 2, . . . , k), gdzie i jest napisem postaci xqy takim, e xy jest napisem na i-tej tamie M (pomijajc ko-

38 Rozdzial 1. Modele obliczania
(q0010, q0) ­­ (q0010, Xq1) ­­ (0q110, X0q1) ­­ (01q10, X01q1) ­­ (010q1, X010q1) ­­ (010q2, X01q20) ­­ (010q2, X0q210) ­­ (010q2, Xq2010) ­­ (010q2, q2X010) ­­ (01q30, Xq3010) ­­ (01q40, X0q410) ­­ (0q310, X0q310) ­­ (0q410, X01q40) ­­ (q3010, X01q30) ­­ (q4010, X010q4) ­­ (q5010, X010q5)
Rys. 1.22. Cig pewnych ID maszyny Turinga
cowe biale znaki), a q jest biecym stanem M . Symbol bezporednio na prawo od i-tego q jest symbolem obecnie czytanym na i-tej tamie.
Gdy opis chwilowy D1 staje si opisem chwilowym D2 po jednym ruchu maszyny Turinga M , piszemy D1 ­M­ D2. Jeeli D1 ­M­ D2 ­M­ · · · ­M­ Dn dla pewnego n 2, piszemy D1 ­M+­ Dn. Jeeli D = D lub D ­M+­ D , piszemy D ­M*­ D . ( ­­ czytaj ,,przechodzi w".)
k-tamowa maszyna Turinga M = (Q, T, I, , b, q0, qf ) akceptuje napis a1a2 · · · an, gdzie a-ki nale do I, jeeli (q0a1a2 · · · an, q0, q0, . . . , q0) ­M*­ (1, 2, . . . , k), dla pewnych i, wród których jest qf .
Przyklad 1.9. Cig opisów chwilowych, który wyznacza maszyna Turinga z rysunku 1.21, gdy otrzymuje dane 010, jest przedstawiony na rysunku 1.22. Skoro q5 jest stanem kocowym, ta maszyna Turinga akceptuje 010.
Oprócz naturalnej interpretacji, przy której maszyna Turinga akceptuje jzyk, moliwa jest interpretacja, e jest to urzdzenie do obliczania funkcji f . Argumenty tej funkcji s zakodowane na tamie wejciowej jako napis x, przy czym rozgranicza je specjalny znacznik, taki jak #. Jeeli maszyna Turinga zatrzymuje si z liczb calkowit y (warto funkcji) zapisan na tamie, która jest wyróniona jako tama wyjciowa, mówimy, e f (x) = y. Std proces obliczania funkcji jest nieco inny ni akceptowania jzyka.

1.7. Zwizek pomidzy maszyn Turinga i modelem RAM

39

Zloono czasowa T (n) maszyny Turinga M jest to maksimum liczby ruchów, które wykonuje M przy przetwarzaniu dowolnych danych o dlugoci n, dla wszystkich danych o dlugoci n. Jeeli dla pewnych danych o dlugoci n maszyna Turinga nie zatrzymuje si, to T (n) jest nieokrelona dla tej wartoci n. Zloono pamiciowa S(n) maszyny Turinga jest to maksimum odlegloci od lewego koca tamy, na któr dociera glowica tamy przy przetwarzaniu dowolnych danych o dlugoci n. Jeeli glowica tamy przesuwa si w prawo bez koca, S(n) jest nieokrelona. Na oznaczenie rzdu wielkoci, gdy modelem jest maszyna Turinga, uywamy OTM.
Przyklad 1.10. Zloonoci czasow maszyny Turinga z rysunku 1.21 jest T (n) = 4n + 3, a zloonoci pamiciow S(n) = n + 2, jak mona si przekona, gdy dane faktycznie s palindromem.

1.7. Zwizek pomidzy maszyn Turinga
i modelem RAM
Glównym zastosowaniem modelu maszyny Turinga (TM) jest wyznaczanie dolnych ogranicze wicych czas lub pami, które s konieczne do rozwizania danego problemu. W wikszoci przypadków moemy wyznaczy dolne ograniczenia tylko z dokladnoci do funkcji równowanej wielomianowo. Wyprowadzenie dokladniejszych ogranicze wymaga dalszych szczególów danego modelu. Na szczcie obliczenia RAM i RASP s równowane wielomianowo z obliczeniami TM.
Rozwamy zwizek pomidzy modelami RAM i TM. Rzecz jasna RAM moe symulowa k-tamow maszyn TM, przechowujc jedn komórk tamy TM w kadym ze swoich rejestrów. W szczególnoci i-ta komórka tamy j moe by zapamitana w rejestrze ki + j + c, gdzie c jest stal dobran tak, by zapewni maszynie RAM pewn ,,pami robocz". Pami robocza zawiera k rejestrów, w których przechowywane s pozycje k glowic TM. Komórki tamy TM mog by czytane przez RAM dziki adresowaniu poredniemu poprzez rejestry zawierajce pozycje glowicy tej tamy.
Zalómy, e TM ma zloono czasow T (n) n. Wtedy RAM moe przeczyta dane, umieci je w rejestrach, które reprezentuj pierwsz tam, i symulowa TM w czasie O(T (n)), jeeli uywamy kryterium kosztu zuniformizowanego, lub O(T (n) log T (n)), jeeli uywamy funkcji kosztu logarytmicznego. W obu przypadkach czas na maszynie RAM jest ograniczony od góry przez wielomianow funkcj czasu na TM, gdy dowolna funkcja O(T (n) log T (n)) jest z pewnoci O(T 2(n)).
Odwrotne twierdzenie zachodzi tylko wtedy, gdy dla maszyn RAM obowizuje koszt logarytmiczny. Gdy obowizuje koszt zuniformizowany program RAM o n krokach bez wejcia moe oblicza tak due liczby, jak 22n , co wymaga 2n komórek TM ju przy zapisie i odczycie. Wobec tego gdy obowizuje koszt zuniformizowany, nie ma adnej wyranej zalenoci wielomianowej pomidzy maszynami RAM i TM (wiczenie 1.19).

40 Rozdzial 1. Modele obliczania
Rys. 1.23. Reprezentacja RAM w TM
Chocia ze wzgldu na prostot wolimy uywa kosztu zuniformizowanego w analizie algorytmów, musimy go odrzuci w dowodach dolnych ogranicze zloonoci czasowej. Model RAM z kosztem zuniformizowanym jest zupelnie rozsdny, gdy liczby nie rosn nadmiernie wraz z rozmiarem zadania. Lecz, jak mówilimy wczeniej, model RAM ,,zamiata pod dywan" wielko tych liczb i tylko wyjtkowo mona otrzyma uyteczne ograniczenia dolne. Dla kosztu logarytmicznego mamy jednake nastpujce twierdzenie.
Twierdzenie 1.3. Niech L bdzie jzykiem akceptowanym przez program RAM o zloonoci czasowej T (n) wedlug kryterium kosztu logarytmicznego. Jeeli ten program RAM nie wykonuje mnoenia i dzielenia, to L na maszynie Turinga z wieloma tamami ma zloono co najwyej O(T 2(n)).
Dowód. Wszystkie rejestry RAM, które nie zawieraj 0, reprezentujemy tak, jak na rysunku 1.23. Tama zawiera cig par (ij, cj), zapisanych w postaci binarnej bez wiodcych zer i rozgraniczonych znacznikami. Dla kadego j, cj jest zawartoci rejestru ij RAM. Zawarto akumulatora ley w postaci binarnej na drugiej tamie; trzecia tama sluy jako pami robocza. Dwie inne tamy zawieraj wejcie i wyjcie RAM. Krok programu RAM jest reprezentowany przez skoczony zbiór stanów TM. Nie bdziemy opisywa symulacji dowolnej instrukcji RAM, lecz rozwaymy tylko instrukcje ADD 20 i STORE 30, co wiele wyjani. Dla ADD 20 moemy zbudowa TM do wykonania nastpujcych czynnoci.
1. Szukaj na tamie 1 zapisu dla rejestru 20 RAM, tj. sekwencji ##10100#. Jeeli jest taka, to nastpujc po tej sekwencji liczb calkowit, która musi by zawartoci rejestru 20, umie na tamie 3. Jeeli takiej nie ma, zatrzymaj si. Zawartoci rejestru 20 jest 0, wobec czego adresowanie porednie jest niemoliwe.
2. Szukaj na tamie 1 zapisu dla rejestru RAM, którego numer jest umieszczony na tamie 3. Jeeli jest taki zapis, kopiuj zawarto tego rejestru na tam 3. Jeeli nie ma, umie tam 0.
3. Dodaj liczb umieszczon na tamie 3 w kroku 2. do zawartoci akumulatora, który jest utrzymywany na tamie 2.
Aby symulowa instrukcj STORE 30, mona zbudowa TM do wykonania nastpujcych czynnoci:
1. Szukaj zapisu dla rejestru 30 RAM, tj. ##11110#. 2. Jeeli jest taki, kopiuj wszystko, co znajduje si na prawo od ##11110#,
prócz liczby calkowitej bezporednio na prawo (stara zawarto rejestru 30), na tam 3. Nastpnie kopiuj zawarto akumulatora (tama 2) bezporednio na prawo od ##11110# i dopisz do niej napis skopiowany na tam 3.

1.8. Pidgin ALGOL -- jzyk wysokiego poziomu

41

3. Jeeli nie ma zapisu dla rejestru 30 na tamie 1, przejd w takim razie do bialego znaku, poloonego najbardziej na lewo, drukuj ##11110#, dopisz zawarto akumulatora, a nastpnie ##.
Po chwili namyslu powinno by jasne, e mona zbudowa TM do wiernej symulacji RAM. Musimy pokaza, e obliczenia RAM, które maj koszt logarytmiczny k, wymagaj co najwyej O(k2) kroków maszyny Turinga. Rozpoczynamy od stwierdzenia, e rejestr nie pojawia si na tamie 1, chyba e wczeniej zostala w nim umiesczona jego bieca warto. Kosztem zapamitania cj w rejestrze j jest l(cj)+l(ij), co z dokladnoci do stalej oznacza dlugo reprezentacji ##ij#cj##. Wnioskujemy, e dlugo niepustej czci tamy 1 jest O(k).
Symulacja dowolnej innej instrukcji, rónej od STORE, jest rzdu dlugoci tamy 1, czyli O(k), gdy koszt dominujcy stanowi szukanie na tamie. Podobnie koszt STORE jest nie wikszy ni koszt szukania na tamie 1 plus koszt jej kopiowania, oba O(k). Std jedna instrukcja RAM (poza mnó i dziel) moe by symulowana w co najwyej O(k) krokach TM. Skoro instrukcja RAM wedlug kryterium kosztu logarytmicznego kosztuje przynajmniej jedn jednostk czasu, ogólny czas zuywany przez TM jest O(k2), co bylo do udowodnienia.
Jeeli program RAM zawiera instrukcje mnoenia i dzielenia, mona napisa procedury TM, aby zaimplementowa te instrukcje za pomoc dodawania i odejmowania. Dowód, e koszt logarytmiczny tych procedur jest nie wikszy ni kwadrat kosztu logarytmicznego instrukcji, które symuluj, pozostawiamy Czytelnikowi. Nie trudno udowodni nastpujce twierdzenie.
Twierdzenie 1.4. RAM i RASP z kosztem logarytmicznym oraz maszyna Turinga s modelami równowanymi wielomianowo.
Dowód. Naley skorzysta z twierdze 1.1, 1.2 i 1.3, i wlasnej analizy procedur mnoenia i dzielenia.
Analogiczne twierdzenie zachodzi dla zloonoci pamiciowej, lecz wynik ten wydaje si mniej ciekawy.

1.8. Pidgin ALGOL -- jzyk wysokiego poziomu
Chocia podstawowe miary zloonoci zostaly okrelone w sensie operacji RAM, RASP lub maszyny Turinga, to przewanie nie chcemy opisywa algorytmów w sensie tak prymitywnych maszyn, ani nie jest to wcale konieczne. Do janiejszego opisu algorytmów uyjemy jzyka wysokiego poziomu, zwanego Pidgin ALGOL.
Program w jzyku Pidgin ALGOL moe by latwo przetlumaczony na program RAM lub RASP. W istocie jest to zadanie kompilatora Pidgin ALGOLu. Nie bdziemy jednak zajmowa si szczególami tlumaczenia Pidgin ALGOLu na kod RAM lub RASP. Musimy uwzgldni dla naszych celów tylko czas i pami potrzebne do wykonania kodu, który odpowiada instrukcji jzyka Pidgin ALGOL.

42 Rozdzial 1. Modele obliczania
Inaczej ni konwencjonalne jzyki programowania Pidgin ALGOL pozwala na uycie dowolnego wyraenia matematycznego, o ile jego znaczenie jest jasne, a przeklad na kod RAM lub RASP oczywisty. Jzyk ten nie ma stalego zbioru typów danych. Zmienne mog reprezentowa liczby calkowite, napisy lub tablice. Typy danych, takie jak zbiory, grafy, listy i kolejki mona wprowadza w miar potrzeb. Wszdzie, gdzie to moliwe, unika si formalnych deklaracji typów danych. Typ zmiennej i jej zasig10 powinien by jasny na podstawie jej nazwy lub kontekstu.
Pidgin ALGOL ma tradycyjne konstrukcje jzykowe, takie jak wyraenia, warunki, instrukcje i procedury. Nieformalny opis niektórych podajemy poniej. Próba cislej definicji wykraczalaby znacznie poza zakres tej ksiki. Trzeba zauway, e z latwoci mona napisa programy, których sens bdzie zalee od szczególów, jakich tutaj nie omawiamy, lecz tego naley unika, jak to (miejmy nadziej skutecznie) czynimy w tej ksice.
W jzyku Pidgin ALGOL program jest instrukcj jednego z nastpujcych typów:
1. zmienna  wyraenie 2. if warunek then instrukcja else instrukcja11 3a. while warunek do instrukcja b. repeat instrukcja until warunek 4. for zmienna  warto pocztkowa step rozmiar kroku12 until warto ko-
cowa do instrukcja 5. etykieta: instrukcja 6. goto etykieta 7. begin
instrukcja instrukcja
. . . instrukcja instrukcja end 8a. procedure nazwa (lista parametrów): instrukcja b. return wyraenie c. nazwa procedury (argumenty) 9a. read zmienna b. write wyraenie 10. comment komentarz 11. róne inne instrukcje dodatkowe
10Zasig zmiennej jest otoczeniem, w którym ona ma sens. Na przyklad zasig wskanika sumowania jest okrelony tylko wewntrz sumowania i poza nim nie ma sensu.
11Cz ,,else instrukcja" jest nieobowizkowa. Opcja ta prowadzi do znanej wieloznacznoci ,,chwiejnego" else (dangling else). Uciekniemy si do tradycyji i zaloymy, e else odpowiada najbliszemu then bez pary.
12Cz ,,step rozmiar kroku" jest nieobowizkowa, jeeli rozmiarem kroku jest 1.

1.8. Pidgin ALGOL -- jzyk wysokiego poziomu

43

Przedstawimy krótki przegld kadego z tych typów instrukcji.
1. Instrukcja przypisania
zmienna  wyraenie
powoduje, e wyraenie po prawej stronie  ulega obliczeniu i jego warto jest przypisywana zmiennej po lewej stronie. Zloono czasowa instrukcji przypisania jest czasem zuytym na to, by obliczy warto wyraenia i przypisa t warto do zmiennej. Jeeli warto wyraenia nie jest typu podstawowego, takiego jak typ calkowity, to w pewnych przypadkach mona obniy koszt za pomoc wskaników. Na przyklad przypisanie A  B, gdzie A i B s macierzami wymiaru n×n, wymaga na ogól czasu O(n2). Jeeli jednak nie uywa si dluej B, to mona uzyska czas skoczony i niezaleny od n, zwyczajnie zmieniajc nazw tablicy.
2. W instrukcji if
if warunek then instrukcja else instrukcja
warunkiem nastpujcym po if moe by dowolne wyraenie, które ma warto true lub false. Jeeli warunek ma warto true, wykonana bdzie instrukcja nastpujca po then. W przeciwnym razie bdzie wykonana instrukcja nastpujca po else (jeeli wystpuje). Koszt instrukcji if jest to suma kosztów niezbdnych, by obliczy i sprawdzi warto wyraenia, plus koszt instrukcji nastpujcej po then, lub instrukcji nastpujcej po else, zalenie od tego, która z nich faktycznie jest wykonana.
3. Celem instrukcji while
while warunek do instrukcja
oraz instrukcji repeat
repeat instrukcja until warunek
jest tworzenie ptli. W insrukcji while obliczana jest warto warunku nastpujcego po while. Jeeli warunek ma warto true, wykonywana jest instrukcja zadana po do. Proces ten jest powtarzany, a wartoci warunku stanie si false. Gdy warunek ma pocztkowo warto true, to wykonanie zadanej instrukcji spowoduje kiedy, e uzyska on warto false, jeeli wykonanie instrukcji while ma si zakoczy. Koszt instrukcji while jest to suma kosztów obliczania wartoci warunku tylekro, ilekro obliczana jest ta wrto, plus suma kosztów wykonania zadanej instrukcji tylekro, ilekro jest wykonywana.
Instrukcja repeat jest podobna, wyjwszy to, e instrukcja nastpujca po repeat jest wykonywana zanim warunek bdzie poddany obliczaniu.
4. W instrukcji for
for zmienna  warto pocztkowa step rozmiar kroku until warto kocowa do instrukcja

44 Rozdzial 1. Modele obliczania
warto pocztkowa, rozmiar kroku i warto kocowa s wyraeniami. W przypadku, gdy rozmiar kroku jest dodatni, wymienionej zmiennej (zwanej indeks) nadaje si warto równ wartoci wyraenia, wymienionego jako warto pocztkowa. Jeeli warto ta przewysza warto kocow, to wykonanie ulega zakoczeniu. W przeciwnym razie wykonywana jest instrukcja nastpujca po do, warto zmiennej jest zwikszana o rozmiar kroku, a potem porównywana z wartoci kocow. Proces ten jest powtarzany, a warto zmiennej przewyszy warto kocow. W przypadku, w którym rozmiar kroku jest ujemny, dzieje si podobnie, lecz zakoczenie nastpuje, gdy warto zmiennej jest mniejsza ni warto kocowa. Koszt instrukcji for powinien by oczywisty w wietle wczeniejszej analizy instrukcji while.
Powyszy opis pomija zupelnie takie szczególy, jak to, kiedy obliczane s wartoci wyrae na warto pocztkow, rozmiar kroku i warto kocow. Niewykluczone równie, e wykonanie instrukcji nastpujcej po do modyfikuje warto wyraenia na rozmiar kroku, a wtedy obliczanie wartoci wyraenia na rozmiar kroku za kadym razem, gdy zmienna jest zwikszana, wywiera inny efekt, ni obliczenie rozmiaru kroku raz na zawsze. Od obliczenia wartoci dla rozmiaru kroku moe rówmie zalee warto wyraenia na warto kocow, a zmiana znaku rozmiaru kroku zmienia warunek zakoczenia. 13 Problemy te rozwizujemy, powstrzymujc si od pisania programów, których sens moe sta si niejasny wskutek takich zjawisk.
5. Przez poprzedzenie instrukcji etykiet, po której nastpuje dwukropek, mona z kadej instrukcji utworzy instrukcj z etykiet. Glównym zadaniem etykiety jest oznaczenie celu dla instrukcji goto. Z etykiet nie jest zwizany aden koszt.
6. Instrukcja goto
goto etykieta
powoduje, e jako nastpna jest wykonywana instrukcja z dan etykiet. Oznaczonej t etykiet instrukcji nie wolno by wewntrz instrukcji-bloku (7), chyba e instrukcja goto naley do tej samej instrukcji-bloku. Kosztem instrukcji goto jest jeden. Instrukcje goto powinny by uywane oszczdnie, poniewa zwykle powoduj, e programy s trudne do zrozumienia. Instrukcje goto slu przede wszystkim do wyskakiwania z instrukcji while.
7. Sekwencja instrukcji rozgraniczonych rednikami i osadzonych pomidzy slowami kluczowymi begin i end jest instrukcj zwan blokiem. Skoro blok jest instrukcj, moe by uywany wszdzie tam, gdzie mona uy instrukcji. Program na ogól bdzie blokiem. Koszt bloku jest to suma kosztów instrukcji wystpujcych wewntrz bloku.
8. Procedury. W jzyku Pidgin ALGOL procedury mog by definiowane, a nastpnie wywolane. Procedury s definiowane przez intrukcj definicji procedury, która ma posta:
13Ang. test for termination; (z.­ (wk.)) × sign(rk.) -- przyp. tlum.

1.8. Pidgin ALGOL -- jzyk wysokiego poziomu

45

procedure nazwa (lista parametrów): instrukcja
Lista parametrów jest to cig zwanych parametrami formalnymi nazw zmiennych. Przykladowo nastpujca instrukcja definiuje procedur funkcji, nazwan MIN:

procedure MIN(x, y): if x > y then return y else return x
Argumenty x i y s parametrami formalnymi.
Procedury s uywane na jeden z dwóch sposobów. Po pierwsze jako funkcje. Gdy procedura funkcji jest zdefiniowana, moe by wywolana w wyraeniu przez uycie jej nazwy z podanymi argumentami. W takim przypadku ostatni instrukcj wykonan w procedurze musi by instrukcja return 8(b). Instrukcja return powoduje obliczenie wartoci wyraenia nastpujcego po slowie kluczowym return i zakoczenie wykonania procedury. Wartoci funkcji jest warto tego wyraenia. Na przyklad:
A  MIN(2 + 3, 7)
powoduje, e A otrzymuje warto 5. Wyraenia 2 + 3 i 7 nazywane s parametrami aktualnymi tego wywolania procedury.
Druga metoda uycia procedury pozwala wywola j przez instrukcj wywolania procedury 8(c). Instrukcja ta jest tylko nazw procedury, po której nastpuje lista parametrów aktualnych. Instrukcja wywolania procedury moe modyfikowa (i zwykle to czyni) dane wywolujcego programu. Wywolana w ten sposób procedura nie wymaga instrukcji return w swej definicji. Dokoczenie wykonania ostatniej instrukcji w procedurze koczy wykonanie instrukcji wywolania procedury. Przykladowo nastpujca instrukcja definiuje procedur, nazwan INTERCHANGE:
procedure INTERCHANGE(x, y): begin
t  x; x  y; yt end
Aby wywola t procedur, moemy napisa instrukcj wywolania procedury, tak jak:
INTERCHANGE(A[ i ], A[ j ])
Istniej dwie metody, którymi procedura moe komunikowa si z innymi procedurami. Po pierwsze przez zmienne globalne. Zakladamy, e zmienne globalne s deklarowane domylnie w pewnym uniwersalnym rodowisku. W tym rodowisku istnieje otoczenie (subenvironment ), w której definiowane s procedury.

46 Rozdzial 1. Modele obliczania
Drug z metod komunikacji z procedurami jest uycie parametrów. ALGOL 60 posluguje si wywolaniem przez warto i wywolaniem przez nazw. W wywolaniu przez warto parametry formalne procedury s traktowane jak zmienne lokalne, które inicjuje si wartociami parametrów aktualnych. W wywolaniu przez nazw parametry formalne slu do oznaczania miejsc w programie, parametry aktualne podstawia si za kade wystpienie odpowiednich parametrów formalnych. Dla prostoty odstpimy od ALGOLu 60 i uyjemy wywolania przez odniesienie. W wywolaniu przez odniesienie parametry s przekazywane poprzez wskaniki do parametrów aktualnych. Jeeli parametr aktualny jest wyraeniem (bd stal), to odpowiedni parametr formalny traktowany jest jak zmienna lokalna, inicjowana wartoci wyraenia. Wobec tego koszt funkcji lub procedury (procedure-call ) w implementacji RAM lub RASP jest sum kosztów wykonania instrukcji, które nale do definicji procedury. Koszt i implementacja procedury, która wywoluje inne procedury, bd siebie sam, jest omówiony w rozdziale 2.
9. Instrukcja read oraz instrukcja write maj jasny sens. Instrukcja read ma koszt 1. Instrukcja write ma koszt jeden plus koszt obliczenia wartoci wyraenia nastpujcego po slowie kluczowym write.
10. Instrukcja comment pozwala na wstawianie uwag, które maj pomóc w zrozumieniu programu i ma koszt zero.
11. Dodatkowo prócz konwencjonalnych instrukcji jzyka programowania dolczamy w punkcie ,,róne" kad instrukcj, która pomaga zrozumie algorytm lepiej, ni czyni to równowana sekwencja instrukcji jzyka programowania. Instrukcje tego rodzaju uywane s wtedy, gdy szczególy implementacji s bd nieistotne, bd oczywiste, albo gdy podany jest wyszy poziom opisu. Przykladami czsto uywanych instrukcji dodatkowych s:
a) niech a bdzie najmniejszym elementem zbioru S b) oznacz element a jako "stary"14 c) without loss of generality (wlg) zaló, e . . . otherwise . . . in instrukcja.
Na przyklad:
wlg zaló, e a b otherwise zamie c i d in instrukcja
znaczy, e jeeli a b, to naley wykona instrukcj w zapisanej postaci. Jeeli a > b, to naley wykona instrukcj w postaci, w której role c i d ulegly zamianie.
Implementacja tych instrukcji przez konwencjonalne instrukcje jzyka programowania albo kod RAM jest bezporednia, lecz pracochlonna. Przypisanie kosztu instrukcjom tego rodzaju zaley od kontekstu, w którym wystpuj. Dalsze ich przyklady mona znale w programach Pidgin ALGOLu, które zawiera ksika.
14Zakladamy tym samym, e istnieje tablica STATUS taka, e STATUS[ a ] jest 1, jeeli a jest "stary", i 0, jeeli a jest "nowy".

wiczenia

47

Poniewa zmienne na ogól nie bd deklarowane, powinnimy przyj pewn umow, co do zasigu zmiennych. W danym programie lub procedurze nie uywamy tej samej nazwy dla dwóch rónych zmiennych. Std zwykle za zasig zmiennej mona wzi cal procedur lub program, w którym ta zmienna wystpuje.15 Wany wyjtek stanowi wspólna baza danych, na której operuje kilka procedur. W takim przypadku zmienne bazy danych uznawane s za globalne, natomiast zmienne wykorzystywane przez procedury jako pami tymczasowa przy operacjach na wspólnej bazie danych uznaje si za zmienne lokalne tych procedur. Jeliby moglo wystpi kiedy nieporozumienie co do zasigu zmiennych, zostanie dostarczona wyrana deklaracja.

wiczenia

1.1 Udowodni, e g(n) jest O(f (n)), jeeli (a) f (n)

dla pewnego > 0

i wszystkich n, prócz pewnego skoczonego zbioru n, i (b) istniej stale c1 > 0 i c2 > 0 takie, e g(n) c1f (n) + c2 dla prawie wszystkich n 0.

1.2 Piszemy f (n) g(n), jeeli istnieje dodatnia stala c taka, e f (n) cg(n) dla wszystkich n. Udowodni, e jeeli f1 g1 i f2 g2, to f1 + f2 g1 + g2. Jakie inne wlasnoci przysluguj relacji ?

1.3 Poda programy RAM, RASP i Pidgin ALGOLu dla nastpujcych zada. a) Oblicz n! dla danego wejcia n. b) Czytaj n liczb calkowitych dodatnich, po których nastpuje znacznik koca (0), a nastpnie drukuj owe n liczb w posortowanym porzdku (ang. sorted order ). c) Akceptuj wszystkie wejcia o postaci 1n2n20.
1.4 Zbada zloono czasow i pamiciow swoich odpowiedzi w wiczeniu 1.3, jeeli obowizuje (a) koszt zuniformizowany (b) koszt logarytmiczny. Wyrazi swoj miar ,,wielkoci" danych.

*1.5 Napisa program RAM o zloonoci czasowej O(log n) przy koszcie zuniformizowanym do obliczania nn. Udowodni, e program jest poprawny.

*1.6 Pokaza, e dla kadego programu RAM o zloonoci czasowej T (n) przy funkcji kosztu zuniformizowanego istnieje równowany program RAM o zloonoci czasowej O(T 2(n)), który nie zawiera instrukcji MULT i DIV. Wskazówka: Zasymulowa MULT i DIV przez podprogramy, które na pami robocz wykorzystuj rejestry o numerach parzystych. Dla MULT pokaza, e jeeli trzeba pomnoy i przez j, to kady z l(j) iloczynów czciowych oraz ich sum mona obliczy w O(l(j)) krokach, przy czym kady krok wymaga czasu O(l(i)).

15Zachodz pewne niezbyt istotne wyjtki od tego postanowienia. Na przyklad procedura moe mie dwie niezagniedone instrukcje for, obie z indeksem i. Mówic cile, zasigiem indeksu instrukcji for jest instrukcja for, wic kade z tych i jest inn zmienn.

48 Rozdzial 1. Modele obliczania
*1.7 Co stanie si z moc obliczeniow RAM lub RASP, jeeli MULT i ADD zostan usunite z repertuaru instrukcji? Jak wplynie to na koszt oblicze?
**1.8 Pokaza, e dowolny jzyk, akceptowany przez RAM, moe by akceptowany przez RAM bez adresowania poredniego. Wskazówka: Pokaza, e cal tam TM mona zakodowa w postaci jednej liczby calkowitej. Zatem dowolna maszyna Turinga moe by symulowana w skoczonej liczbie rejestrów RAM.
1.9 Pokaza, e przy kosztcie (a) zuniformizowanym i (b) logarytmicznym, RAM i RASP s równowane z dokladnoci do czynnika stalego ze wzgldu na zloono pamiciow.
1.10 Znale program liniowy, który oblicza wyznacznik macierzy wymiaru 3 × 3, dla danych, którymi jest dziewi skalarnych elementów tej macierzy.
1.11 Napisa sekwencj operacji bitowych do obliczania iloczynu dwóch dwubitowych liczb calkowitych
1.12 Pokaza, e uklad funkcji obliczanych przez dowolny program liniowy o n instrukcjach, z binarnymi wejciami i operatorami boolowskimi moe by zrealizowany przez uklad logiczno-kombinatoryczny z n elementami boolowskimi.
1.13 Pokaza, e kad funkcj boolowsk oblicza pewien program liniowy.
*1.14 Zalómy, e graf o n wierzcholkach jest reprezentowany przez zbiór wektorów bitowych vi, gdzie vi ma j-ty element 1 wtedy i tylko wtedy, gdy istnieje krawd prowadzca od wierzcholka i do wierzcholka j. Znale algorytm OBV(n) wyznaczania wektora p1, który ma 1 na pozycji j wtedy i tylko wtedy, gdy istnieje droga lczca 1 z wierzcholkiem j. Mona uywa bitowych operacji logicznych na wektorach bitów, operacji arytmetycznych (na zmiennych, które s ,,typu calkowitego"), instrukcji, które ustawiaj w pewnych bitach pewnych wektorów 0 lub 1, oraz instrukcji, która przypisuje j do zmiennej a, jeeli bit 1 polony najbardziej na lewo w wektorze v, znajduje si na pozycji j, i ustawia a = 0, jeeli v sklada si z samych 0.
*1.15 Opisa maszyn Turinga, która, majc dane dwie binarne liczby calkowite na tamach 1 i 2, drukuje sum tych liczb na tamie 3. Mona zaloy, e lewe koce tam s oznaczone specjalnym symbolem #.
1.16 Poda cig konfiguracji, w który wchodzi TM z rysunku 1.21 (str. 37), otrzymujc dane (a) 0010, (b) 01110.
*1.17 Poda TM, która: a) drukuje 0n2 na tamie 2, jeeli zaczyna dzialanie z 0n na tamie 1, b) akceptuje dane o postaci 0n10n2.
1.18 Poda zbiór stanów TM i funkcj nastpnego ruchu, które pozwol TM symulowa instrukcj RAM LOAD 3 tak, jak w dowodzie twierdzenia 1.3.
1.19 Poda program RAM w O(n) krokach, który oblicza 22n dla danego n. Jaki jest koszt (a) zuniformizowany i (b) logarytmiczny tego programu?

Noty bibliograficzne

49

*1.20 Definiujemy g(m, n) przez g(0, n) = n i g(m, n) = 2g(m-1,n) dla m > 0. Poda program RAM do obliczania g(n, n) dla danego n. Jak maj si do siebie koszt zuniformizowany i logarytmiczny tego programu?
1.21 Wykona procedur INTERCHANGE z punktu 1.8 z parametrami aktualnymi i, A[ i ], uywajc wywolania przez nazw, a nastpnie przez odniesienie. Czy wyniki s takie same?
Problem badawczy
1.22 Czy górne ograniczenie O(T 2(n)) czasu wymaganego przez maszyn Turinga do symulacji RAM, jak w twierdzeniu 1.3, mona poprawi?

Noty bibliograficzne
RAM i RASP znalazly ujcie formalne w pracach Shepherdson i Sturgis [ 1963 ], Elgot i Robinson [ 1964 ], oraz Hartmanis [ 1971 ]. Wikszo przedstawionych tutaj wyników, dotyczcych maszyn RAM i RASP, jest wzorowana na pracy Cook i Reckshow [ 1973 ].
Maszyn Turinga zawdziczamy pracy Turing [ 1936 ]. Bardziej szcególowy wyklad tego pojcia mona znale w pracach Minsky [ 1967 ], oraz Hopcroft i Ullman [ 1969 ], tak samo jak odpowied do wiczenia 1.8. Zloono czasowa maszyn Turinga byla po raz pierwszy badana w pracy Hartmanis i Stearns [ 1965 ], a zloono pamiciowa w pracach Hartmanis, Lewis i Stearns [ 1965 ] oraz Lewis, Stearns i Hartmanis [ 1965 ]. Pojciu zloonoci obliczeniowej powicono wiele bada teoretycznych, poczynajc od pracy Blum [ 1967 ]. Przegld mona znale w pracach Hartmanis i Hopcroft [ 1971 ], oraz Borodin [ 1973a ]
Praca Rabin [ 1972 ] przedstawia interesujce rozszerzenie obliczeniowego modelu drzewa decyzji.

