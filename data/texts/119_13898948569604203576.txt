Scptcmbcr 1983

Report No. S'l',lN-C'S-83-980

The WEB System of Structured Documentation
bY Donald E. Knuth

Department of Computer Science
Stanford University St:mford, CA 94305

The WEB System of Structured Documentation
by Donald E. Knuth Stanford University (Version 2.3, September, 1983)
Tile preparation of this report was supported in part by the National Scicncc Foundation llndt~r grants ET-831!1926 ad MCS-8300084, and by the System Develoymcnt Foundation. *`I$$'is a tradclnrrrk of the Amcricau Matlmmtical Society.

--

WEB USER MANUAL
The WEB System of Structured Documentation

1

This memo describes how to write programs in the WEB language; and it also includes the full WEB documentation for WEAVE and TANGLE, the programs that read WEB input and produce TJJX and PASCAL output,
respectively. The philosophy behind WEB is that an experienced system programmer, who wants to provide the best possible documentation of his or her softwcare products, needs two things simultaneously: a language like TEX for formatting, and a language like PASCAL for programming. Neither type of language can provide
the best documentation by itself; but when both are appropriately combined, we obtain a system that is much more useful than either language separately.
The structure of a software program may be thought of as a "web" that is made up of many interconnected pieces. To document such a program, we want to explain each individual part of the web and how it relates to its neighbors. The typographic tools provided by TEX give us an opportunity to explain the local structure
of each part by making that structure visible, and the programming tools provided by PASCAL make it possible for us to specify the algorithms formally and unambiguously. By combining the two, we can develop a style of programming that maximizes our ability to perceive the structure of a complex piece of software, and at the same time the documented programs can be mechanically translated into a working software system that matches the documentation.
Since WEB is an experimental system developed for internal use within the TEX project at Stanford, this report is rather terse, and it assumes that the reader is an experienced programmer who is highly motivated
to read a detailed description of WEB's rules. Furthermore, even if a less terse manual were to be written, the reader would have to be warned in advance that WEB is not for beginners and it never will be: The user of WEB must be familiar with both T@i and PASCAL. When one writes a WEB description of a software system,
it is possible to make mistakes by breaking the rules of WEB and/or the rules of TEX and/or the rules of PASCAL. In practice, all three types of errors will occur, <and you will get different error messages from the different language processors. In compensation for the sophisticated expertise needed to cope with such a variety of languages, however, experience has shown that reliable software can be created quite rapidly by working entirely in WEB from the beginning; and the documentation of such programs seems to bc better than the documentation obtained by any other known method. Thus, WEB users need to be highly qualified, but they can get some satisfaction and perhaps even a special feeling of accomplishment when they have successfully created a software system with this method.
To use WEB, you prcparc a file called COB. WEB (say), and then you apply a system program called WEAVE
to this file, obtaining an output file called COB .TEX. When T@ processes COB .TEX, your output will be a "pretty printed" version of COB. WEB that takes appropriate care of typographic clctails like page layout and the USC of indentation, italics, boldface, etc.; this output will contain extensive cross-index information that is gathered automatically. You can also submit the same file COB. WEB to another system program called TANGLE, which will produce a file COB. PAS that contains the PASCAL code of your COB program. The PASCAL compiler will convert COB. PAS into machine-language instructions corresponding to the Calgorithms
that wcrc so nicely formatted by WEAVE and TEX. Finally, you can (and should) delete the files COB. TEX and COB. PAS, because COB. WEB contains t,he definitive source code. Examples of the behavior of WEAVE and TANGLE are appended to this mCanual.
Bcsidcs providing a documentation tool, WEB cnhnnces the PASCAL language by providing a rudimentary macro capability togcthcr with tlic ability to permute picccs of the program text, so t2liLt a. large syst,cm can bc understood cntircly in terms of srrmll modules and their local intcrrclationships. The TANGLE program is so named because it takes a given web (and moves the modules from their web structure into the order rcqlrircd
by PASCAL; the advantage of programming in WEB is that the algorit~hms can bc expressed in `Luntnngled" form, with each module explained scparatcly. The WEAVE program is so named bccausc it takes a given web
and intertwines the ?m and PASCAL portions contained in each ~rlotlnle. then it knit,s the whole f&ric into a structured document. (Get it ? Wow.) Perhaps there is some deep connection horc with the fact tllat the
German word for "weave" is "web"? and the corresponding Latin imperative is "teze"!
It is impossible to list all of the rclntcd work that has influcnccd the design of WEB, but the key contributions
should be mentioned here. (I) Myrtle Kellington, as cxccutivc editor for ACM publications, tlcvcloped excellent typographic standards for the typesetting of Algol programs during the 19GOs, based on the origimal

2 WEB USER MANUAL
designs of Peter Naur; the subtlety and quality of this influential work can be appreciated only by people who have seen what happens when other printers try to typeset Algol without the advice~of ACM's copy editors. (2) Bill McKecman introduced a program intended to automate some of this task [Algorithm 268, "Algol60 reference language editor," CACM 8 (1965), 667-6681; and a considerable flowering of such programs has occurred in recent years [see especially Derek Oppen, "Prettyprinting," ACM TOPLAS 2 (1980), 465-483; G. A. Rose and J. Welsh, "Formatted programming languages," SOFTWARE Practice & Exper. 11 (1981), 651-6691. (3) The top-down style of exposition encouraged by WEB was of course chiefly influenced by Edsger Dijkstra's essays on structured programming in the late 1960s. The less well known work of Pierre-Arnoul de Marneffe [ "Holon programming: A survey," Univ. de Liege, Service Informatique, Liege, Belgium, 1973; 135 pp.] also had a significant influence on the author as WEB was being formulated. (4) Edwin Towster has proposed a similar style of documentation in which the programmer is supposed to specify the relevant data structure environment in the name of each submodule ["A convention for explicit declaration of environments and top-down refinement of data," IEEE Tram. on Software Eng. SE-5 (1979), 374-3861; this requirement seems to make the documentation a bit too verbose, although experience with WEB has shown that any unusual control structure or data structure should definitely be incorporated into the module names on psychological grounds. (5) Discussions with Luis Trabb Pardo in the spring of 1979 were extremely helpful for setting up a prototype version of WEB that was called DOC. (6) Ignacio Zabala's extensive experience with DOG, in which he created a fulI implementation of `I)$ in PASCAL that was successfully transported to many different computers, was of immense value while WEB was taking its present form. (7) David R. Fuchs made several crucial suggestions about how to make WEB more portable; he and Arthur L. Samuel coordinated the initial installations of WEB on dozens of computer systems, making changes to the code so that it would be acceptable to a wide variety of PASCAL compilers. (8) The name WEB itself was chosen in honor of my wife's mother, Wilda Ernestine Bates.
The appendices to this report contain complete WEB programs for the WEAVE and TANGLE processors. A study of these examples, together with an attempt to write WEB programs by yourself, is the best way to understand why WEB has come to be like it is.
General rules. A WEB Iile is a long string of text that has been divided into individual lines. The exact line boundaries are not terribly crucial, arid a programmer can pretty much chop up the WEB file in whatever way seems to look best as the file is being edited; but string constants and control texts must end on the same line on which they begin, since this convention helps to keep errors from propagating. The end of a line means the same thing as a blank space.
Two kinds of material go into WEB files: TFX text and PASCAL text. A programmer writing in WEB should be thinking both of the documentation arid of the PASCAL program that he or she is creating; i.e., the programmer should be instinctively aware of the different actions that WEAVE and TANGLE will perform on the WEB file. TFX text is essentially copied without change by WEAVE, and it is entirely deleted by TANGLE, since the Tl$ text is "pure documentation." PASCAL text, on the other hand, is formatted by WEAVE and it is shuffled around by TANGLE, according to rules that will become clear later. For now the important point to keep in mind is that there are two kinds of text. Writing WEB programs is something like writing T&X documents, but with an additional "PASCAL mode" that is added to w's horizontal mode, vertical mode, and math mode.
A WEB file is built up from units called modules that are more or less self-contained. Each module has three parts:
1) A TEX part, containing explanatory material about what is going on in the module. 2) A definition part, containing macro definitions that serve as abbreviations for PASCAL constructions that
would be less comprehensible if written out in full each time.
3) A PASCAL part, containing a piece of the program t#hat TANGLE will produce. This PASCAL code should ideally be about a dozen lines long, so that it is easily comprehensible as a unit and so that its structure is readily perceived.
The three parts of each module must appear in this order; i.e., the T@ commentary must come first, then the definitions, and finally the PASCAL code. Any of the parts may be empty.

WEB USER MANUAL

3

A module begins with the pair of symbols `@,'or `@*`, where `,,' denotes a blank space. A module ends at the beginning of the next module (i.e., at the next `Q "' or `@* `), or at the end of the file, whichever comes first. The WEB file may also contain material that is not part of any module at all, namely the text (if any)
that occurs before the first module. Such text is said to be "in limbo"; it is ignored by TANGLE and copied essentially verbatim by WEAVE, so its function is to provide any additional formatting instructions that may be desired in the `I$$ output. Indeed, it is customary to begin a WEB file with T&C code in limbo that loads special fonts, defines special macros, changes the page sizes, and/or produces a title page.
Modules are numbered consecutively, starting with 1; these numbers appear at the beginning of each module of the T@ documentation, and they appear as bracketed comments at the beginning of the code
generated by that module in the PASCAL program.
Fortunately, you never mention these numbers yourself when you are writing in WEB. You just say 3"' or `(Q*' at the beginning of each new module, and the numbers are supplied automatically by WEAVE and TANGLE. As far as you are concerned, a module has a name instead of a number; such a name is specified by writing `9~'followed by TQC text followed by `@>`. When WEAVE outputs a module name, it replaces the `@<' and `@>'by angle brackets and inserts the module number in small type. Thus, when you read the output of WEAVE it is easy to locate any module that is referred to in another module.
For expository purposes, a module name should be a good description of the contents of that module, i.e., it should stand for the abstraction represented by the module; then the module can be "plugged into" one or more other modules so that the unimportant details of its inner workings are suppressed. A module name therefore ought to be long enough to convey the necessary meaning. Unfortunately, however, it is laborious to type such long names over and over again, and it is also difficult to specify a long name twice in exactly
the same way so that WEAVE and TANGLE will be able to match the names to the modules. Therefore a module name can be abbreviated after its first appearance in the WEB file, by typing `@<a. . . CO', where cy is any string that is a prefix of exactly one module name that appears in the file. For example, `@<Clear the arrays@>' can be abbreviated to `@<Clear. . . Q>' if no other module name begins with the five letters `Clear'. Module names must otherwise match character for character, except that consecutive blank spaces and/or tab marks are treated as equivalent to single spaces, and such spaces are deleted at the beginning and end of the name. Thus, `0~ Clear the arrays Q>' will also match the name in the previous example.
We have said that a module begins with `&'or `Q* `, but we didn't say how it gets divided up into a TJ$' part, a definition part, and a PASCAL part. The definition part begins with the first appearance of `Qd' or `Qf' in the module, and the PASCAL part begins with the first appearance of Qp' or `CK'. The latter option `@<' stands for the beginning of a module name, which is the name of the module itself. An equals sign
(=) must follow the `CD' at the end of this module name; you are saying, in effect, that the module name stands for the PASCAL text that follows, so you say `(module name) = PASCAL text'. Alternatively, if the PASCAL part begins with `@p' instead of a module name, the current mod& is said to be unnamed. Note that module names cannot appear in the d&&ion part of a module, because the first `a<' in a module signals the beginning of its PASCAL part. Any number of module names might appear in the PASCAL part, however, once it has started.
The general idea of TANGLE is to make a PASCAL program out of these modules in the following way: First all the PASCAL parts of unnamed modules are copied down, in order; this constitutes the initial
approximation To to the text of the program. (Thcrc should bc at least one unnn,mod module, otherwise there will be no program.) Then all ~nodule I~IIKS that appear in the initial text To are rcplaccd by the PASCAL parts of the corresponding modules, and this substitution process continues until no module
names remain. Then all defined macros arc replaced by their equivCalcnts, according to certain rules that are explained later. The resulting PASCAL code is "sanitized" so that it will be acceptable to an average garden-
variety PASCAL compiler; i.e., lowercase letters are converted to uppercase, long identifiers are chopped, and
the lines of the output file arc constrained to be at most 72 characters long. All comments will have been
removed from this PASCAL program except for the mcta-comments dclimitcd by %('and `@)`, as explained below, and except for the module-number comments that point to the source location where each piece of
the program text originated in the WEB file.
If the same name has been given to more than one module, the PASCAL text for that name is obtained by putting together ,211 of the PASCAL parts in the corresponding modules. This feature is useful, for example,

4

WEB USER MANUAL

.

in a module named `Global variables in the outer block', since one can then declare global variables in
whatever modules those variables are introduced, When several modules have the same name, WEAVE assigns the first module number as the number corresponding to that name, and it inserts a note at the bottom of that module telling the reader to `See also sections so-and-so'; this footnote gives the numbers of all the other modules having the same name as the present one. The PASCAL text corresponding to a module is usually formatted by WEAVE so that the output has an equivalence sign in place of the equals sign in the
WEB file; i.e., the output says `(module name) E PASCAL text'. However, in the case of the second and subsequent appearances of a module with the same name, this `='sign is replaced by `+=`, as an indication that the PASCAL text that follows is being appended to the PASCAL text of another module.
The general idea of WEAVE is to make a TEX file from the WEB file in the following way: The first line of the TEX file will be `\input webmac'; this will cause TJ$ to read in the macros that define WEB's documentation conventions. The next lines of the file will be copied from whatever T$ text is in limbo before the first module. Then comes the output for each module in turn, possibly interspersed with end-of-page marks
and the limbo material that precedes the next module after a page ends. Finally, WEAVE will generate a cross-reference index that lists each module number in which each PASCAL identifier appears, and it will also generate an alphabetized list of the module names, as well as a table of contents that shows the page and module numbers for each "starred" module.
What is a "starred" module, you ask ? A module that begins with `@*' instead of `&' is slightly special
in that it denotes a new major group of modules. The `@)*' should be followed by the title of this group, followed by a period. Such modules will always start on a new page in the m output, and the group title will appear as a running headline on all subsequent pages until the next starred module. The title will also
appear in the table of contents, and in boldface type at the beginning of its module. Caution: Do not use I&X control sequences in such titles, unless you know that the webmac macros will do the right thing with them. The reason is that these titles are converted to uppercase when they appear as running heads, and they are converted to boldface when they appear at the beginning of their modules, and they are also written out to a table-of-contents tie used for temporary storage while m is working; whatever control sequences you use must be meaningful in all three of these modes.
The w output produced by WEAVE for each module consists of the following: First comes the module number (e.g., `\M123. ' at the beginning of module 123, except that `\N' appears in place of `\M' at the,
beginning of a starred module). Then comes the l$$ part of the module, copied almost verbatim except as noted below. Then comrs the definition part and the PASCAL part, formatted so that there will be a little extra space between them if both are noncmpty. The definition and PASCAL parts are obtained by inserting a bunch of funny looking T@ macros into the PASCAL program; these macros handle typographic details about fonts and proper math spacing, as well as line breaks and indentation.
When you arc typing TJ$ text, you will probably want to make frequent reference to variables and other quantities in your PASCAL code, <and you will waut those variables to have the same typographic treatment when they appear in your text as when they appear in your program. Therefore the WEB language allows you to get the effect of PASCAL editing within T@ text, if you place ` I ' miarks before <and after the PASCAL
material. For example, suppose you want to say something like this:

The characters are placed into bufler , which is a packed array [ 1 . . n] of char.

The T&C text would look like this in your WEB file:

T h e c h a r a c t e r s a r e p l a c e d i n t o (bufferi, w h i c h i s a lpacked a r r a y [l..n] o f charl.

And WEAVE translates this into something you ae gltid you didn't have to type:

The characters are placed into \\{bnffer), w h i c h i s a \&{packed) \&{array) $ [l\to\ln]$ \&{of) \\(char).

Incidentally, the cross-reforcnce index that WEAVE would make, in the presence of a comment like this, would include the current module number as 0;~: of the index entries for bufler and char, even though bufleer and

WEBUSER MANUAL

3

char might not appear in the PASCAL part of this module. Thus, the index covers references to identifiers
in the explanatory comments as well as in the program itself, you will soon learn to ,appreciate this feature. However, the identifiers packed and array and n and of would not be indexed, because WEAVE does not
make index entries for reserved words or single-letter identifiers. Such identifiers are felt to be so ubiquitous that it would be pointless to mention every place where they occur.
Speaking of identifiers, the author of WEB thinks that Identi~ersSeueraZWordsLong look terribly ugly when they mix uppercase and lowercase letters. He recommends that identifiers-aeueraLwordaJong be written
with underline characters to get a much better effect. The actual identifiers sent to the PASCAL compiler by TANGLE will have such underlines removed, and TANGLE will check to make sure that two different identifiers
do not become identical when this happens. (In fact, TANGLE even checks that the 6rst seven characters of identifiers are unique, when lowercase letters have been converted to uppercase; the number seven in this constraint is more strict than PASCAL's eight, and it can be changed if desired.) The WEAVE processor will properly alphabetize identifiers that have embedded underlines when it makes the index.
Although a module begins with QX text and ends with PASCAL text, we have noted that the dividing line isn't sharp, since PASCAL text can be included in TF$ text if it is enclosed in ` I . . . I `. Conversely, T@ text also appears frequently within PASCAL text, because everything in comments (i.e., between left and right braces) is treated as `&X text. Furthermore, a module name consists of T@ text; thus, a WEB file typically involves constructions like `if x = 0 then @<Empty the I buffer I array@>'where we go back and
forth between PASCAL and `I@ conventions in a natural way.

Macros. A WEB programmer can define three kinds of macros to make the programs shorter and more readable:
`Qd identifier = constant'defines a numeric macro, allowing TANGLE to do rudimentary arithmetic.
`Qd identifier == PASCAL text' defines a simple macro, where the identifier will be replaced by the PASCAL text when TANGLE produces its output.
`Qd identifier (#) == PASCAL text'defines a parametric macro, where the identifier will be replaced by the PASCAL text and where occurrences of # in that PASCAL text will be replaced by an argument.
In all three cases, the identifier must have length greater than one; it must not be a single letter. Furthermore, the identifier must be making its first appearance in the WEB file; a macro must be defined before it is used.
Numeric macros are subject to the following restrictions: (1) The right-hand side of the numeric definition must be made entirely from integer constants, numeric macros, preprocessed strings (see below), and plus signs or minus signs. No other operations or symbols are allowed, not even parentheses, except that PASCAL-like comments (enclosed in braces) can appear. Indeed, comments are recommended, since it is usually wise to give a brief explanation of the significance of each identifier as it is defined. (2) The numeric value must be less than 2" = 32768 in absolute value. (For larger values, you can use `==' in place of `=`, thus making use of a simple macro instead of a numeric one. Note, however, that simple macros sometimes have a different effect. For example, consider the three definitions `Qd nl=2 @d n2=2+nl Qd n3==2+nl'; then `x-n2' will expand into `x-4', while `x-n3'will expand into `x-2+2'which is quite different! It is wise to include parentheses in non-numeric macros, e.g., `Od n3==(2+nl) `, to avoid such errors.)
When constants are connected by plus signs or minus signs in a PASCAL program, TANGLE does the <arithmetic before putting the constant into the output file. Therefore it is permissible to say, for example, `array [O.. size - I]' if site has been declared as a macro; note that PASCAL doesn't allow this kind of compile-time arithmetic if size is a constant quantity in the program. Another use of TANGLE's arithmetic is to make case statement labels such as `flag + 1' legitimate. Of course, it is improper to change 2+2 into 4 without looking at the surrounding context; many counterexamples exist, such as the phrases `-2+2', `x/2+2', and `2+2E5'. The program for TANGLE, in the appendix, gives precise details about this conversion, which TANGLE does only when it is safe.
The right-hand sides of simple and parametric macros are required to have balanced parentheses, and the PASCAL texts of modules must have balanced parentheses too. Therefore when the argument to a parametric macro appears in parentheses, both parentheses will belong to the same PASCAL text.
The appcndiccs to this report contain hundreds of typical examples of the usefulness of WEB macros, so it is not necessary to dwell on the subject here. However, the reader should know that WEB's apparently

WEB USER MANUAL

.

primitive macro capabilities can actually do a lot of rather surprising things. Here is a construction that sheds further light on what is possible: After making the definitions
O<! two-cases (#> = = c a s e j o f l:#(l); 2:#(2); e n d (Od reset-file(#)==reset(input-file@&#)
I one can write `two-cases (reset-file)' and the resulting PASCAL output will be case j of 1: reset (input-f ilel) ; 2: reset (input-f ile2) ; end
(but in uppercase letters. and with _ `s removed). The `O&' operation used here joins together two adjacent tokens into a single token, as explained later; otherwise the PASCAL file would contain a space between input-file and the digit that followed it. This trick can be used to provide the effect of an array of files, if you are unfortunate enough to have a PASCAL compiler that doesn't allow such arrays. Incidentally, the cross-reference index made by WEAVE from this example would contain the identifier input-file but it would not contain input-file1 or input-filei?. Furthermore, TANGLE would not catch the error that INPUTFILE and INPUTFILE both begin with the same nine letters; one should be more careful when using `@a'! But such aspects of the construction in this trick are peripheral to our main point, which is that a parametric macro name without arguments can be used as an argument to another parametric macro.
Although WEB's macros are allowed to have at most one parameter, the following example shows that this is not as much of a restriction as it may seem at first. Let umac and bmac be any parametric macros, <and suppose that we want to get the effect of
Qd cmac(#l,#2) == amac (#l) bmac(#2)
which WEB doesn't permit. The solution is to make the definitions
Od cmac (#) == amac(#) dmac Qd dmac (#> == bmac(#)
and then to say `cmac (x) (y) `. There is one restriction in the generality of WEB's parametric macros, however: the argument to a para-
metric macro must not come from the expansion of a macro that has not already been "started." For example, here is one of the things WEB cannot handle:
@d a r g = = (p) Qd i d e n t i t y ( # ) == # Qp i d e n t i t y a r g
In this case TANGLE will complain that the identity macro is not followed by an argument in parentheses. The WEB language has another feature that is somewhat similar to a numeric macro. A preprocessed
string is a string that is like a PASCAL string but delimited by double-quote marks (`I) instead of singlequotes. Dou11) e-quote marks inside of such strings are indicated by giving two double-quotes in a row. lf a preprocessed string is of length one (e.g., "A" or """"), it will be treated by TANGLE as equivalent to the corresponding ASCII-code integer (e.g., 65 or 34). And if a preprocessed string is not of length one, it will be converted into an integer equal to 128 or more. A string pool containing all such strings will be written out by the TANGLE processor; this string pool file consists of string 128, then string 129, etc., where each string is followed by an end-of-line and prefixed by two decimal digits that dcfinc its length. Thus, for example, the empty string "`I would be rcprcscntcd in the string pool file by a line containing the two charnctcrs `00') while the string """String""" would be represented by `08"String"`. A given string appears at most once in the string pool; the use of such a pool makes it easier to cope with PASCAL's restrictions on string manipulation. The string pool ends with `snnnnnnnnn', where nnnnnnnnn is a decimal number called the string pool check sum. lf any string changes, the check sum almost surely changes too; thus, the `a$' feature described bolow makes it possible for a program to assure itself that it is reading its own string pool.
Here is a simple example that combines numeric macros with preprocessed strings of length one:
Qd upper-case-Y = "Y" Qd c a s e - d i f f e r e n c e = -"y"+upper-case-Y
The result is to define upper-case-Y = 89, ewe-diflerence = -32.

WEB USER MANUAL

7

Control codes. We have seen several magic uses of `62' signs in WEB files, and it is time to make a systematic study of these special features. A WEB control code is a two-character combination of which the first is `0'.
Here is a complete list of the legal control codes. The letters L, T, P, M, C, and/or S following each,code
indicate whether or not that code is allowable in limbo, in 'I@ text, in PASCAL text, in module names, in comments, and/or in strings. A bar over such a letter means that the control code terminates the present part of the WEB file; for example, z means that this control code ends a section that is in limbo and begins non-L material.

99 [C, L, M, P, S, T] A double 0 denotes the single character `9'. This is the only control code that is legal

in limbo, in comments, and in strings.

---
Q~ [L,P,T]

Thr`s denotes the beginning of a new (unstarred) module. A tab mark or end-of-line (carriage

@*

-retu- rn-) [L&T]

is

equivalent to Tlu`s denotes

a space when the beginning

it follows an @ sign. of a new starred module,

i.e.,

a

module that begins

a new

major

group. The title of the new group should appear after the @*, followed by a period. As explained above,

T@ control sequences should be avoided in such titles unless they are quite simple. When WEAVE and

TANGLE read a @*, they print an asterisk followed by the current module number, so that the user can

@d -[sPe,eT-]somMeaicnrdoicdaetfiionnitioonf spbroeggirnesws.itThhOedve(ryorfiQrDs)t,mofodlulolwe esdhobuyldthbeePsAtaSrCreAdL. text for one of the three kinds

of macros, as explained earlier. Qf [-P,-T] Format definitions begin with Qf (or QF); they cause WEAVE to treat identifiers in a special way

when they appear in PASCAL text. The general form of a format definition is `Qf I == r', followed by

an optional comment enclosed in braces, where 1 and r are identifiers; WEAVE will subsequently treat

identifier 1 as it currently treats r. This feature allows a WEB programmer to invent new reserved words

and/or to unreserve some of PASCAL's reserved identifiers. The definition part of each module consists

of any number of macro definitions (beginning with Qd) and format definitions (beginning with Qf),

6p

[P-i,nteT-r]mixTehde

in any order. PASCAL part

of

an

unnamed

module

begins

with

Qp

(or

@P).

This causes TANGLE

to append

the following PASCAL code to the initial program text Te as explained above. The WEAVE processor

does not cause a `Qp' to appear explicitly in the T@ output, so if you are creating a WEB file based on

a w-printed WEB documentation you have to remember to insert Op in the appropriate places of the

unnamed modules.

Q< [I',?`] A module name begins with @< followed by m text followed by Q>; the T$X text should not contain any WEB control sequences except 00, unless these control sequences appear in PASCAL text that is delimited by I . . . I. The module name may be abbreviated, after its first appcarancc in a WEB file, by giving any unique prefix followed by . . . . , where the three dots immediately precede the closing 9>. Module names may not appear in PASCAL text that is enclosed in I . . . I, nor may they appear in
the definition part of a module (since the appearance of a module name ends the definition part and
begins the PASCAL part).

0' [P, T] This denotes an octal constant, to be formed from the succeeding digits. For example, if the WEB file contains `0' loo', the TANGLE processor will treat this an equivalent to `64'; the constant wih be formatted as "`100" in the Tf$ output produced via WEAVE. You should use octal notation only for
posit.& constants; don't try to get., e.g., -1 by saying `Q.777777777777'.

GI" [P,T] A hexadecimal constant; `O"DOD0 tangles to 53456 cand weaves to "'DODO'.

Q$ [I'] This denotes the string pool check sum.

@{ [P] The beginning of a "meta comment," i.e., a comment that is supposed to appear in the PASCAL code, is indicated by 9{ in the WEB file. Such delimiters can be used as isolated symbols in macros or modules, but they should bc properly nested in the final PASCAL program. The TANGLE processor will
convert `@(' into `0 in the PASCAL output file, unless the output is already part of a meta-comment; in the latter case `Q(' is converted into ` [', since PASCAL does not, allow nested comment,s. IncidentalJy, module numbers are automatically insertctl as mcta-colnmonts into the PASCAL program, in order to help correlate the outputs of WEAVE arlrl TANGLE (see Appendix C). Mcta-comments can be used to

8

WEB USER MANUAL

.

put conditional text into a PASCAL program; this helps to overcome one of the limitations of WEB, 1 since the simple macro processing routines of TANGLE do not include the dynamic evaluation of boolean
expressions.
9) [P] The end of a "meta comment" is indicated by `a)`; this is converted either into `1' or `1' in the PASCAL output, according to the conventions explained for 8( above.
P] The @& operation causes whatever is on its left to be adjacent to whatever is on its right, in the PASCAL output. No spaces or line breaks will separate these two items. However, the thing on the left should not be a semicolon, since a line break might occur after a semicolon.
P, T] The "control text" that follows, up to the next `@>`, will be entered into the index together with the identifiers of the PASCAL program; this text will appear in roman type. For example, to put the phrase "system dependencies" into the index, you can type `Q-system dependencies@>'in each module that you want to index as system dependent. A control text, like a string, must end on the same line of the WEB file as it began. Furthermore, no WEB control sequences are allowed in a control text, not even (~0. (If you need an @ sign you can get around this restriction by typing `\AT! `.)
(Q. [I', T] The "control text" that follows will be entered into the index in typewriter type; see the rules for `O^ `, which is analogous.
(0: [P,`T] The "control text,, that follows will be entered into the index in a format controlled by the QX macro `\9', which the user should define as desired; see the rules for `@-`, which is analogous.
8t [P] The "control text" that follows, up to the next `@>`, will be put into a T@X \hbox and formatted along with the neighboring PASCAL program. This text is ignored by TANGLE, but it can be used for various purposes within WEAVE. For example, you can make comments that mix PASCAL and classical mathematics, as in `size < 215', by typing ` I size < @t$2^(153$@> I `. A control text must end on the same line of the WEB file as it began, and it may not contain any WEB control codes.
@= [P] The "control text" that follows, up to the next `0') will be passed verbatim to the PASCAL program.
O\ [P] Force end-of-line here in the PASCAL program file.
@ ! [P, T] The module number in an index entry will be underlined if `Q ! ' immediately precedes the identifier or control text being indexed. This convention is used to distinguish the modules where an identifier is defined, or where it is explained in some special way, from the modules where it is used. A reserved word or an identifier of length one will not be indexed except for underlined entries. An `@! 'is implicitly inserted by WEAVE just after the rescrvcd words function, procedure, program, and var, and just after Qd and Qf. But you should insert your own `0 ! ' bcforc the definitions of types, constants, variables, par<ameters, and components of records and enumerated types that are not covered by this implicit convention, if you want to improve the quality of the index that you get.
@? [P, T] This cancels an implicit (or explicit) `Q! `, so that the next index entry will not be underlined.
9, [I'] This control code inserts a thin space in WEAVE's output; it is ignored by TANGLE. Somctimcs you need this extra space if you arc using macros in [an unusual way, e.g., if two identifiers arc adjacent.
a/ [P] This control code causes a line break to occur within a PASCAL program formatted by WEAVE; it is ignored by TANGLE. Line breaks are `chosen automatically by Tf$ according to a scheme that works 99% of the time, but somctimcs you will prefer to force a line bre,ak so that the program is scgmcntcd according to logical rather than visual criteria. Caution: `@/' should be used only after statements or clauses, not in the middle of an expression; use @I in the middle of expressions, in order to keep WEAVE's
I parser happy.
Q I [I'] This control code specifies an optional line break in the midst of an expression. For example, if you have a long condition between if and then, or a long expression on the right-hand side of an assignment statement, you can use `Q I 'to specify breakpoints more logiccal than the ones that Tf$ might choose on visual grounds.
Q# [P] This control code forces a lino break, like @/ does, and it .also causes a little extra white space to appear between the lines at this brenk. You might use it, for example, between proccdurc definitions or between groups of macro definitions that are logically separate but within the same module,

WEB USER MANUAL

9

dD+ [P] This control code cancels a line break that might otherwise be inserted by WEAVE, e.g., before the word `else', if you want to put a short if-then-else construction on a single line. It is ignored by TANGLE.
Q; [ P ] This control code is treated like a semicolon, for formatting purposes, except that it is invisible. You can use it, for example, after a module name when the PASCAL text represented by that module name ends with a semicolon.
The last six control codes (namely `Q, `, `@/`, `Q I `, `O#`, `a+`, and `Q; `) have no effect on the PASCAL program output by TANGLE; they merely help to improve the readability of the w-formatted PASCAL that is output by WEAVE, in unusual circumstances. WEAVE's built-in formatting method is fairly good, but it is incapable of handling all possible cases, because it must deal with fragments of text involving macros and module names; these fragments do not necessarily obey PASCAL's syntax. Although WEB allows you to override the automatic formatting, your best strategy is not to worry about such things until you have seen what WEAVE produces automatically, since you will probably need to make only a few corrections when you are touching up your documentation.
Because of the rules by which every module is broken into three parts, the control codes `Qd', `Qf', and `@p'are not allowed to occur once the PASCAL part of a module has begun.

Additional features and caveats. 1. The character pairs `(*`, `*I', `(. `, and ` . > 'are converted automatically in PASCAL text as though
they were `@{`, 93') ` [`, and `I', respectively, except of course in strings. Furthermore in certain installations of WEB that have an extended character set, the characters `#`, `L', `Z', `4') `E'~ `A', `v', `7') and `E'can be used as abbreviations for `<>`, `<=`, `>=`, ` : =`, `==`, `and', `or', `not', and `in', respectively. However, the latter abbreviations are not used in the standard versions of WEAVE. WEB and TANGLE. WEB that are distributed to people who are installing WEB on other computers, and the programs are designed to produce only standard ASCII characters as output if the input consists entirely of ASCII characters.
2. If you have an extended character set, all of the characters listed in Appendix C of The !QXbook can be used in strings. But you should stick to standard ASCII characters if you want to write programs that will be useful to the all the poor souls out.there who don't have extended character sets.
3. The TBX file output by WEAVE is broken into lines having at most 80 characters each. The algorithm that does this line breaking is unaware of T@`s convention about comments following `%' signs on a line. When T@ text is being copied, the existing line breaks are copied as well, so there is no problem with `%' signs unless the origimal WEB file contains a lint more than eighty characters long or a line with PASCAL text in I.. . 1 that expands to more than eighty characters long. Such lines should not have `%' signs.
4. PASCAL text is translated by a "bottom up" procedure that identifies each token as a "part of speech" and combines parts of speech into larger and larger phrases as much as possible according to a special grammar t,hat is explained in the documentation of WEAVE. It is easy to learn the translation scheme for simple constructions like single identifiers and short expressions, just by looking at a few examples of what WEAVE does, but the general mechanism is somewhat complex because it must handle much more than PASCAL itself. Furthermore the output contains embedded codes that cause T@ to indent and break lines as necessary, dcpcnding on the fonts used and the desired page width. For best results it is wise to adhere to the following restrictions:
a) Comments in PASCAL text should appear only after statcmcnts or clauses; i.c., after semicolons, after reserved words like then and do, or before reserved words like end and else. Otherwise WEAVE's parsing method may well get mixed up.
b) Don't cm-lose long PASCAL texts in 1 . . . I, since the indentation and line breaking codes are omitted when the 1 . . . 1 text is translated from PASCAL to Tl$ Stick to simple expressions or statements.
5. Comments (and module names are not permitted in I . . . 1 text. After a ` I' signals the change from w text to PASCAL text, the next `I 'that is not part of a string or control text ends the PASCAL text.
6. A comment must have properly nested occurrcnccs of left and right braces, otherwise WEAVE and TANGLE will not know whcrc the comment ends. However, the character pairs `\O <and `\3'do not count as left and right braces in comments, and the character pair `\ 1' does not count as a delimiter that begins PASCAL text. (The actual rule is that a character after `\' is ignored; hence in `\\('the left brace does count.) At present,

10

WEB USER MANUAL

.

TANGLE and WEAVE treat comments in slightly different ways, and it is necessary to satisfy both conventions:

TANGLE ignores ` I ' characters entirely, while WEAVE uses them to switch between `I@$ text and PASCAL text.

Therefore, a comment that includes a brace in a string in 1 . . . [--e.g., `( l o o k a t t h i s I "(" I )`--will be

handled correctly by WEAVE, but TANGLE will think there is an unmatched left brace. In order to satisfy both

processors, one can write `( look at this \lef tbrace\ )`, after setting up`\def \leftbrace( I "(" I)`.

7. Reserved words of PASCAL must appear entirely in lowercase letters in the WEB file; otherwise their

special nature will not be recognized by WEAVE. You could, for example, have a macro named END and it

would not be confused with PASCAL's end.

However, you may not want to capitalize macro names just to distinguish them from other identifiers.

Here is a way to unreserve PASCAL's reserved word `type'and to substitute another word `mtype'in the

WEB file.

8d type(#) == mem[#] .t

6d mtype == t Q& y O& p @& e

Qf mtype == type

Of type == true

In the output of TANGLE, the macro mtype now produces `TYPE'and the macro type(x) now produces
`MEMIX] . T'. In th e output of WEAVE, these same inputs produce mtype and type (z), respectively. 8. The Qf feature allows you <to define one identifier to act like another, and these format definitions are
carried out sequentially, as the example above indicates. However, a given identifier has only one printed format throughout the entire document (and this format will even be used before the Qf that defines it). The reason is that WEAVE operates in two passes; it processes @f's and cross-references on the first pass and does the output on the second.
9. You may want some Qf formatting that doesn't correspond to any existing reserved word. In that case,
WEAVE could be extended in a fairly obvious way to include new "reserved words" in its vocabulary. The identifier `xclause' has in fact been included already as a reserved word, so that it can be used to format the `loop'macro, where `loop'is defined to be equivalent to `while true do'.
10. Sometimes it is desirable to insert spacing into PASCAL code that is more general than the thin space provided by `Q , `. The @t feature can be used for this purpose; e.g., `@t\hskip linQ>'will leave one inch of blank space. Furthermore, `@t\4@>' can be used to backspace by one unit of indentation, since the control sequence \4 is defined in webmac to be such a backspace. (This control sequence is used, for example, at the beginning of lines that contain labeled statements, so that the label will stick out a little at the left.)
11. WEAVE and TANGLE are designed to work with two input files, called web-file and change-file, where change-file contains data that overrides sclecttd portions of web&e. The resulting merged text is actually what has been called the WEB file elsewhere in this report.
Here's how it works: The &angc file consists of zero or more "changes," where a change has the form `@x(old lines)@y(new lines)@z'. The special control codes Qx, Qy, @z, which are allowctl only in change files, must appear at the beginning of a line; the rcmaindcr of such a line is ignored. The (old lines) represent material that exactly matches consecutive lines of the web-file; the (new lines) represent zero or more lines
that arc supposed to replace the old. Whenever the first "old lint" of a change is found to match a lint in the web$le, all the other lines in that change must match too.
Between changes, before the first change, and after the last change, the change file can have any number of lincv that do not begin with `@3x', `Qy', or `Qz'. Such lines (arc bypassed <and not used for matching purposes.
This dual-input feature is useful when working with a master WEB file that has been rcccivcd from elscwhcre
(e.g., TANGLE. WEB or WEAVE. WEB or TEX . WEB), when changes arc drsirable to customize the program for your local computer system. You will be able to debug your systcI11-dcpc:ndcrlt changes without clobbering the
master web file; and once your changes arc working, you will be able to incorporate them readily into new
releases of the master web file that you might rcceivc from time to time.

Appendices. The basic ideas of WEB can be understood most easily by looking at examples of "real" programs. Appendix A shows the WEB input that gcll(`riLtcti rnodultks 55 59 of the> WEAVE program; Appcnclix 13
shows the corresponding T&C code output by WEAVE: and Appendix C shows exc*ctrTjts t'ro1rt the` corrcspontling PASCAL code output by TANGLE.

WEB USER MANUAL

11

The complete webs for WEAVE and TANGLE appear as the bulk of this report, in Appendices D and E. The reader should first compare Appendix A to the corresponding portion of Appendix D; then the same material should be compared to Appendices B and C. Finally, if time permits, the reader may enjoy, studying the complete programs in Appendices D and E, since WEAVE and TANGLE contain several interesting aspects, and
since an attempt has been made in these appendices to evolve a style of programming that makes good use
of the WEB language. Finally, Appendix F is the `webmac'file that sets `I&X up to accept the output of WEAVE; Appendix G
discusses how to use some of its macros to vary the output formats; and Appendix H discusses what needs to be done when WEAVE and TANGLE are installed in a new operating environment.

Performance statistics. The programs in Appendices D and E will optionally keep statistics on how much memory they require. Here is what they printed out when processing themselves:
TANGLE applied to TANGLE (CPU time 15 set) Memory usage statistics: 456 names, 215 replacement texts; 3396+3361 bytes, 6683+7314+5803 tokens.
TANGLE applied to WEAVE (CPU time 29 set) Memory usage statistics:
692 names, 339 replacement texts;
4576+4294 bytes, 10181+9867+9141 tokens.
WEAVE applied to TANGLE (CPU time 45 set) Memory usage statistics: 478 names, 2044 cross references, 4158+3725 bytes; parsing required 684 scraps, 1300 texts, 3766 tokens, 119 levels; sorting required 34 levels.
WEAVE applied to WEAVE (CPU time 64 set) Memory usage statistics: 737 names, 3305 cross references, 4894+4968 bytes;
parsing required 684 scraps, 1300 texts, 3766 tokens, 119 levels;
sorting required 73 levels.
The cpu time for PASCAL to process TANGLE. PAS was approximately 13 seconds, and WEAVE. PAS took approximately 26 seconds; thus the tangling time was slightly more than the compiling time. The cpu time for m to process TANGLE. TEX was approximately 500 seconds, and WEAVE .TEX took approximately 750 seconds (i.e., about 7 seconds per printed page, where these pages are substantially larger than the pages in a normal book). All cpu times quoted are.for a DECsystem-10.
The file TANGLE. WEB is about 125K characters long; TANGLE reduces it to a file TANGLE. PAS whose size is about 42K characters, while WEAVE expands it to a file TANGLE. TEX of about 185K. The corresponding file sizes for WEAVE. WEB, WEAVE.PAS, and WEAVE.TEX are J8OIi, 89K, and 265K.
The much larger file TEX. WEB led to the following numbers:
TANGLE applied to TEX (CPU time 110 set)
Memory usage statistics:
3752 names, 1768 replacement texts;
41766+41466 bytes, 42445+45061+41039 tokens.
WEAVE applied to TEX (CPU time 270 set)
Memory usage statistics: 3410 names, 19699 cross references, 38899+39362 bytes;
parsing required 685 scraps, 1303 texts, 3784 tokens, 104 levels;
sorting required 52 levels.
PASCAL did TEX . PAS in about 75 seconds; T@ did TEX . TEX in about 3600.

0, what a tangled web we weave When first we practise to deceive!
-SIR WALTER SCOTT, M a r m i o n 6:17 (1808)

0, what a tangled WEB we weave When T@ we practise to conceive!
- R I C H A R D PALAIS ( 1 9 8 2 )

12 APPENDIX A - WEB FILE FORMAT
Appendix A. This excerpt from WEAVE. WEB produced modules 55-59 in Appendix D. Note that some of the lines are indented to show the program structure. The indentation is ignored by WEAVE and TANGLE, but users find that WEB ties are quite readable if they have some such indent;ation.
Q* Searching for ldentiflerr. The hash table described above is updated by the lid-lookupi procedure, which finds a given identifier and returns a pointer to Its index in Ibyte-starti. The identifier is supposed to match character by character and it Is also supposed to have a given lllkl code; the same name may be present more than once If it is supposed to appear In the index with different typesetting conventions. If the identifier was not already present, it is inserted into the table.
Because of the way \.{WEAVE)`s scanning mechanism works, it Is most convenient t o l e t lid-lookup1 s e a r c h f o r a n i d e n t i f i e r t h a t i s p r e s e n t i n t h e Ibuffer] array. Two other global variables specify Its position in the buffer: the f i r s t c h a r a c t e r i s lbufferlid-first]l, a n d t h e l a s t Is Ibuffer [id-lot-1] 1.
O<Clob...O>= O!id-first:O. .long-buf-size; ( wh ere the current identifier begins in the buffer) O!ld-loc:O..long-buf-size; ( j u s t a f t e r t h e c u r r e n t I d e n t i f i e r i n t h e b u f f e r ) 0t O ! h a s h : a r r a y [O..hash-size] o f s i x t e e n - b i t s ; { h e a d s o f h a s h l i s t s )
0 Initially all the hash lists are empty.
O<Local v a r i a b l e s f o r init...O>= O!h:O..hash-size; (index Into hash-head array)
0 O<Set lnit...O>= f o r h:=O t o h a s h size- 1 do hash [h] :=O:
0 Acre now Is the main procedure for finding Identifiers (and index e n t r i e s ) . T h e p a r a m e t e r ItI i s s e t t o t h e d e s i r e d lilkl c o d e . T h e i d e n t i f i e r m u s t e i t h e r h a v e (ilk=t(, or we must have lt=normall and the identifier must be a reserved word.
Op f u n c t i o n id-lookup(O!t:eight-bits):name-pointer; { f i n d s c u r r e n t I d e n t i f i e r ) label found; v a r i:O..long-buf-size; { i n d e x i n t o lbufferl) O!h:O..haeh-size; {hash code) O!k:O..max-bytes; ( i n d e x i n t o Ibyte-meml] O!w:O. .ww-1; < r o w o f Ibyte-meml] O!l:O..long-buf-size; < l e n g t h o f t h e g i v e n i d e n t i f i e r ) O!p:name-pointer; (where the identifier is being sought 3 b e g i n l:=ld-lot-id-first; {compute the length) O<Compute t h e h a s h c o d e Ih(O>; O<Compute the name location IplO>; i f p=name-ptr t h e n O<Enter a new name into the table at p o s i t i o n IplO>; id-lookup:=p; end ;
0 A simple hash code Is used: If the sequence of ASCII codes Is $c_lc_2\ldots c-m$, Its hash value will be $$(2^~n-l)c_1+2'~n-2)c_2+\cdots+c_n)\,\bmod\,Ihash_sizel.$$
O<Compute t h e hash...O>= h:=buffer[id-first]; l:=fd-flrst+l; wh-ile i<id-lot d o
b e g i n h:=(h+h+buffer[i]) mod hash-size; lncr(i); end

APPENDIX B - TRANSLATION BY WEAVE

Appendix B. This excerpt from WEAVE. TEX corresponds to Appendix A.

\~66. Searching for ldentffiers. The hash table described above is updated by the \\{ld\-lookup) procedure, which finds a given identifier and returns a pointer to its Index in \\{byte\-start}. The identifier is supposed to match character by character and It Is also supposed to have a given \\{llk) code; the same name may be present more than once if it is supposed to appear In the index with different typesetting conventions. If the identifier was not already present, It is inserted into the table.
Because of the way \.{WEAVE}`s scanning mechanism works, it Is most convenient t o l e t \\{id\-lookup) s e a r c h f o r a n i d e n t i f i e r t h a t Is p r e s e n t In t h e x \\{buffer) array . Two other global variables specify Its position in the buffer: the f lrst character is $\\{buf f er) [\\{id\-f irst)] 8, and the last Is $\\{buf fer)[% \\{id\-lo+118.

\Y\P$\I\XQ:Globals I n t h e o u t e r block\X\mathrel{+)\S$\6 \4\\{ld\-first): \37$O\to\\{long\-bus\-size>$;\C{where t h e c u r r e n t i d e n t i f i e r begins in the buffer)\6 \4\\{id\-lot): \37$O\to\\{long\-bus\-sizc)S;\C{just a f t e r t h e c u r r e n t identifier in the buffer)\7 \4\\{hash}: \37\&{array) $[O\to\\{hash\-size)]$ \l\&{of)\S `\\{slxteen\-bits);\C{heads o f h a s h llsts)\2\par
\fi

\M66. I n i t i a l l y a l l t h e h a s h l i s t s a r e e m p t y .

\Y\P$\4\Xl6:Local v a r i a b l e s f o r initlalization\X\mathrel{+~\S$\6 \4\lh: \37$O\to\\{hash\-slze}$;\C{index into. h a s h - h e a d array)\par \fi

\M67. \P$\XlO:Set i n i t i a l values\X\mathrel{*}\S(\b
\&{for) $\lh\KO\mathrel{\&{to))\\{hash\-size)-l$ \l\&{do)\6
$\\<hash)[\lhl\KOS;\2\par \fi

\M68. Here now is the main procedure for finding identifiers (and index e n t r i e s ) . The parameter \It i s s e t t o t h e d e s i r e d \\{ilk) code. The i d e n t i f i e r m u s t e i t h e r h a v e $\\{ilk)=\lt$, er we must have $\lt=\\{normal)$ and the Identifier must be a reserved word.

\Y\P\4\&<functlon}\l\ \37$\\{ld\-lookup)(\It:\\{eight\_bits))S:

\37\\{name%

\-pointer);\C{finds c u r r e n t identifier)\6

\4\&{label) \37\\{found);\6

\4\&{var) \37\11: \37$O\to\\{long\-bus\-size));\C{lndex i n t o \\{buffer)}\6

\lh: \37$O\to\\{hash\-size}$;\C{hash code)\6

\(k: \37$O\to\\{max\-bytes}$;\C{index i n t o \\{byte\-mem})\b \Iw: \37$O\to\\{ww)-l$;\C{row o f \\{byte\-men))\6

\Il: \37$O\to\\{long\-buf\_size)$;\C{length o f t h e g i v e n identifier)\6

\Ip: \37\\{name\-pointer);\C{where t h e i d e n t i f i e r i s b e i n g sought)\2\6

\&{begln) \37$\Il\K\\{id\-lot)-\\{id\-first)$;\C{compute t h e l e n g t h ) \ 6

\X69:Compute the hash code \Ih\X;\6

\X60:Compute the name location \jp\X;\6

\&{if) S\lp=\\{name\-ptr)$ \l\&{then3\6

\X62:Enter a new name into the table at position \Ip\X;\2\6

$\\{id\-lookup)\K\lp$;\6

\&{end);\par

\fl

\M69. A simple hash code is used: If the sequence of ASCII codes is $c_lc_2\ldots c-m$, its hash value will be $$(2"{n-l}c~l~2~{n-2)c_2+\cdota+c_n)\,\bmod\,\\{hash\~s~ze~.$$

\Y\P$\4\XSQ:Compute the hash code \lh\X\S$\S
S\lh\K\\{buffer~[\\{id\_iirst~~$;\6 $\li\K\\{id\_first)+1$;\6 \&{while} $\li<\\{id\-loc)$ \l\&{do)\6 \&{begln} \37$\1h\K(\lh+\lh+\\{buffer}[\li])\mathbin{\&{mod}~\\{hash\-size. ~$;\6 S\\{incr)(\li)S;\6
\k{end)\2\par
\lJ section'68.\fl

13

14 APPENDIX C - TRANSLATION BY TANGLE
Appendix C. The TANGLE processor converts WEAVE. WEB into a syntactically correct (but not very pretty) PASCAL program WEAVE. PAS. The first three and last two lines of output are shown.here, together with the lines of code generated by modules 55-62 and the environments of those lines. There are 1546 lines in all; the notation ` . . .' stands for portions that are not shown.
Note that, for example, the code corresponding to module 55 begins with `(55 : 1'and ends with `(: 66)`; the code from modules 59-62 has been tangled into the code from module 58.
{2:3(4:)($C-,A+,D-)([$C+,D+])(:4) PROGRAMWEAVE(WEBFILE,CHANGEFILE,TEXFILE);LABEL9999;CONST(8:) :llAXBYTES=45000;MAXNAMES=5000;MAXMODULES=2000;HASHSIZE=353;BUFSIZE=l00;
TOKPT~:~.:MAXTOKS;~KAXTOKPTR,MAXTXTPTR:O..MAXTOKS;~(:53)~55:~ IDFIRST:O..LONGBUFSIZE;IDLOC:O..LONGBUFSIZE; HASH:ARRAY[O..HASHSIZE]OF SIXTEENBITS;(:55>(63:)CURNAME:NAMEPOINTER;
... TOKPTR:=l;TEXTPTR:=l;TOKSTART[O]:=l;TOKSTART[l]:=l;~MAXTOKPTR:=l; MAXTXTPTR:=l;)(:54)(57:)FOR H:=O TO HASHSIZE- DO HASH[H]:=O;(:57)(94:) SCANNINGHEX:=FALSE;(:94)(102:)MODTEXT[O]:=32;{:lO2~~l24:~OUTPTR:=l;
IF R=; iHEN XREF[P]:=XREFPTR ELSE XMEM[R].XLINKFIELD:=XREFPTR;END;(:S1) (58:)FUNCTION IDLOOKUP(T:EIGHTBITS):NAMEPOINTER;LABEL 31; VAR I:O..LONGBUFSIZE;H:O..HASHSIZE;K:O..MAXBYTES;W:O..l; L:O..LONGBUFSIZE;P:NAMEPOINTER;BEGINL:=IDLOC-IDFIRST;{59:) H:=BUFFER[IDFIRST];I:=IDFIRST+l; WHILE ICIDLOC DO BEGIN H:=(H+H+BUFFER[I])MOD HASHSIZE;I:=I+>;ENDC:59); (60:)P:=HASH[H]; WHILE PC>0 DO BEGIN IF(BYTESTART[P+2]-BYTESTART[P]=L)AND((ILK[P]=T)OR( (T =O>AND(ILK[P]>3>>>THEN(G1:)BEGIN Is=IDFIRST;K:=BYTESTART[P];W:=P MOD 2; WHILE(I<IDLOC>AND(BUFFER[I]=BYTEMEM[W,K])DO BEGINI:=I+l;K:=K+l;END; IF I=IDLOC THEN GOT0 3l;END{:Gl);P:=LINK[P];END;P:=NAMEPTR; LINK[P]:=HASH[H];HASH[H]:=P;31:{:6O>;IF P=NAMEPTR THEN(62:) BEGIN W:=NAMEPTR MOD 2; IF BYTEPTR[W]+L>MAXBYTES THEN BEGIN WRITELNCTERMOUT); WRITE(TERMOUT,'! Sorry, ','byte memory','capacity exceeded');ERROR; HISTORY:=3;JUMPOUT;END; IF NAMEPTR+2>MAXNAMES THEN BEGIN WRITELN(TERMOUT); WRITE(TERMOUT,'! Sorry, ','name',' capacity exceeded');ERROR;HISTORY:=3; JUMPOUT;END;I:=IDFIRST;K:=BYTEPTR[W]; WHILE I<IDLOC DO BEGIN BYTEMEM[W,K]:=BUFFER[I];K:=K+l;I:=I+l;END; BYTEPTR[W]:=K;BYTESTART[NAMEPTR+2]:=K;NAMEPTR:=NAMEPTR+l;ILK[P]:=T; XREF[P]:=O;END(:62);IDLOOKUP:=P;END;(:58){66:> FUNCTION MODLOOKUP(L:SIXTEENBITS):NAMEPOINTER;LABEL 31;VAR C:O..4;
... WRITE(TERMOUT,'(That was afatal error, my friend.)');END;END{:263); END.{:2613

Appendix D

15

The WEAVE processor
(Version 2.3)

Section

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

Thecharacterset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

Input and output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Reporting errors to the user . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Datastructures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Searching for identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Initializing the table of reserved words . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Searching for module names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

19 29 36
55 63
65

Lexicalscanning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 Inputting the next token . . . . . . . . . . . ..r....~ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 Phaseoneprocessing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

Low-leveloutputroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 Routines that copy T&X material . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132

Parsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139 Implementing the productions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144 Initializingthcscraps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183

Output of tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

Phasetwoprocessing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Phase three processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Themainprogram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

218
239 258
261

System-dependent changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264

Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

265

Page 16 19
23 25 27 32 34 36
38 46
52 56 59 62 69
83 90 97 104 109 111 112 113

16 INTRODUCTION

W E A V E $1

1. Introduction. This program converts a WEB file to a TDX file. It was written by D. E. Knuth in October, 1981; a somewhat similar SAIL program had been developed in March, 1979, although the earlier program used a top-down parsing method that is quite different from the present scheme.
The code uses a few features of the local PASCAL compiler that may need to be changed in other installations:
1) Case statements have a default. 2) Input-output routines may need to be adapted for use with a particular character set and/or for printing
messages on the user's terminal.
These features are also present in the PASCAL version of I$$, where they are used in a similar (but more complex) way. System-dependent portions of WEAVE can be identified by looking at the entries for `system dependencies' in the index below.
The "banner line" defined here should be changed whenever WEAVE is modified.
define banner = `ThisUisUWEAVE, uVersionU2. 3 '

2. The program begins with a fairly normal header, made up of pieces that will mostly be filled in later. The WEB input comes from files web-file and change-file, and the Tl$ output goes to file tez-file.
If it is necessary to abort the job because of a fatal error, the program calls the `jump-out' procedure, which goes to the label end-of_WEA VE.

define end-of_ WEAVE = 9999 { go here to wrap it up }

( Compiler directives 4)

program WEAVE (web-file, change-file, tex-file);

label end-of- WEAVE; { go here to finish }

const ( Constants in the outer block 8)

type ( Types in the outer block 11)

var ( Globals in the outer block o )

( Error handling procedures 30)

procedure initialize ;

var ( Local wariables for initialization 16)

begin ( Set initial values IO)

.

end;

.

3. Some of this code is optional for use when debugging only; such material is enclosed bctwccn the delimiters debug and gubed. Other parts, delimited by stat and tats, are optionally included if statistics about WEAVE's memory usage arc desired.
define debzlg = @(: { change this to `debug f ' when debugging } define gubeci = Q) {change this to `gubed = ' when debugging } format debug 3 begin format gubed z end
define stat E 9{ {change this to `stat E ' when gathering usage statistics ) define tats = 0) { change this to `tats - ' when gathering usage statistics} format stat z begin format tats z end

4 WEAVE

I N.T R O D T J C T I O N 17

4. The PASCAL compiler used to develop this system has "compiler directives" that can appear in comments whose first character is a dollar sign. In production versions of WEAVE these directives tell the compiler that it is safe to avoid range checks and to leave out the extra code it inserts for the PASCAL debugger's benefit, although interrupts will occur if there is arithmetic overflow.
( Compiler directives 4) z @(o&$C-, A+, D-al { no range check, catch arithmetic overflow, no debug overhead } debug @(@&$C+, II+@) gubed {but, turn everything on when debugging }
This code is used in section 2.

5. Labels are given symbolic names by the following definitions. We insert the label `exit :' just before the `end'of a procedure in which we have used the `return'statement defined below; the label `restart' is occasionally used at the very beginning of a procedure; and the label `reswitch'is occasionally used just prior to a case statement in which some cases change the conditions and we wish to branch to the newly applicable case. Loops that are set up with the loop construction defined below are commonly exited by going to `done' or to `found' or to `not-found', and they are sometimes repeated by going to `continue `.
define exit = 10 { go here to leave a procedure } define restart = 20 { go here to start a procedure again } define reswitch = 21 { g0 h ere to start a case statement again} define continue = 22 { go here to resume a loop } define done = 30 { go here to exit a loop } define found = 31 { go here when you've found it } define not-found = 32 { go here when you've found something else }

6. Hcrc are some macros for common programming idioms.
define incr (#) G # t # + 1 { increase a variable by unity } -define deer(#)-#t#-1 { decrease a variable by unity}
define loop E while true do { repcat over and over until a goto happens } define do-nothing E {empty statement } define return G goto exit { terminate a procedure call } format return E nil format loop - xclause

7. WC assume that case statements may include a default case that applies if no matching label is found. Thus, WC shall use constructions like
case x of 1: (code for x = 1); 3: ( code for x = 3); othercases (co& for x # 1 and x # 3) endcases

since rnwt PASCAL compilers have pluggc~l this hole in thr lnnguagt~ by incorporat,irlg some sort of default mechanism. For cxamplc, the compiler used to develop WEB and T@ allows `otheru :'as a default label, and other PASCALs allow syntaxes like `else' or `otherwide' or `otherwi~c:`, etc. The definitions of othercases and endcases should bc changed to agree with local convcmtions. (Of course, if no default mechanism is available, the case statrmcnts of this program must be extclndcd by listing all remaining cases.)
define otherca.vea E others: {default for cases not listed explicitly } define en&mea s end {follows the default case in an cxtendtd case statement } format, othercasea E else format enrlcnses G end

18 INTRODUCTION

W .E A V E $8

8. The following parameters are set big enough to handle `l&X, so they should be sufficient for most ' applications of WEAVE.
( Constants in the outer block 8 j 3 mm-bytes = 45000; { l/ ww times the number of bytes in identifiers, index entries, and module names; must bc less than 65536) maz-names = 5000; { number of identifiers, index entries, and module names; must be less than 10240) maz-modules = 2000; { greater than the total number of modules} hash-size = 353; { should be prime } buf-size = 100; { maximum length of input line } longest-name = 400; { module names shouldn't be longer than this }
long-buf-size = 500; { buf-size + longest-name } line-length = 80; {Iines of T&X output have at most this many characters, should be less than 256) maz-refs = 20000; { number of cross references; must be less than 65536 } maz-toks = 20000; {number of symbols in PASCAL texts being parsed; must be less than 65536 } maz-texts = 2000; {number of phrases in PASCAL texts being parsed; must be less than 10240 } maz-scraps = 1000; { number of tokens in PASCAL texts being parsed } stuck-size = 200; { number of simultaneous output levels }
This code is used in section 2.

9. A global variable called history will contain one of four vahles at the end of every run: spotless means that no unusual messages were printed; harmless-message means that a message of possible interest was printed but no serious errors were detected; error-message means that at least one error was found; fatal-message means that the program terminated abnormally. The value of history does not influence the behavior of the program; it is simply computed for the convenience of systems that might want to use such information.
define spotless = 0 { history value for normal jobs} define harmless-message = 1 { history value when non-serious info was printed} define error-message = 2 { history value when an error was noted} define fatal-message = 3 { history value when we had to stop prematurely}
define mark-harmless z if history = spotless then history + harmless-message
define mark-error E history +- error-message define mark-fatal E history +- fatal-message
( Globals in the outer block 9) z history: spotless . . fatal-message; { how bad was this run? }
See also sections 13, 20, 23, 25, 27, 29, 37, 39, 45, 48, 53, 55, 63, 65, 71, 73, 93, 108, 114, 1 18, 121, 129, 144, 177, 202, 219, 229, 234, 240, 242, 244, 246, and 258.
This code is used in section 2.

10. ( Set initial values 10) history +- spotless;
See also scctious 14, 17, 18, 21, 26, 41, 43, 49, 54, 57, 94, 102, 124, 126, 145, 203, 245, 248, and `X9.
This code is used in section 2.

ll WEAVE

THE CHARACTER SET

19

11. The character set. One of the main goals in the design of WEB has been to make it readily portable between a wide variety of computers. Yet WEB by its very nature must use a greater variety of characters than most computer programs deal with, and character encoding is one of the areas in which existing machines
differ most widely from each other. To resolve this problem, all input to WEAVE and TANGLE is converted to an internal seven-bit code that is
essentially standard ASCII, the "American Standard Code for Information Interchange." The conversion is done immediately when each character is read in. Conversely, characters are converted from ASCII to the user's external representation just before they are output.
Such an internal code is relevant to users of WEB only because it is the code used for preprocessed constants like "A". If you are writing a program in WEB that makes use of such one-character constants, you should convert your input to ASCII form, like WEAVE and TANGLE do. Otherwise WEB's internal coding scheme does
not affect you. Here is a table of the standard visible ASCII codes:

01 234 56 7 `040 `050 `060 `070 `100 `110 `120 `130
240 `150 `160 p Q I- s t U V w `170 x Y z < I 3 -

(Actually, of course, code `040 is an invisible blank space.) Code `136 was once as an upward arrow (t), and code `137 was once a left arrow (+), in olden times when the first draft of ASCII code was prepared; but WEB works with today's standard ASCII in which those codes represent circumflex and underline as shown.
( Types in the outer block 11) E ASCII-code = 0 . . 127; { seven-bit numbers, a subrange of the integers }
See also sections 12, 36, 38, 47, 52, and 201.
This code is used in section 2.

20 THE CHARACTER SET

WEAVE 12

12. The original PASCAL compiler was designed in the late 60s when six-bit character sets were common, so it did not make provision for lowercase letters. Nowadays, of course, we need to deal with both capital and small letters in a convenient way, so WEB assumes that it is being used with a PASCAL whose character set contains at least the characters of standard ASCII as listed above. Some PASCAL compilers use the original name char for the data type associated with the characters in text files, while other PASCALs consider char to be a 64-element subrange of a larger data type that has some other name.
In order to accommodate this difference, we shall use the name text-char to stand for the data type of the characters in the input and output files. We shall also assume that text-char consists of the elements chr (first-text-char) through chr (last-text-char), inclusive. The following definitions should be adjusted if necessary.
define text-char s char { the data type of characters in text files } define first-text-char = 0 {ordinal number of the smallest element of text-char } define last-ted-char = 127 {ordinal number of the largest element of text-char }
( Types in the outer block 11) +E tezt-file = packed file of text-char;

13. The WEAVE and TANGLE processors convert between ASCII code and the user's external character set by means of arrays xord and xchr that are analogous to PASCAL's ord and chr functions.

( Globals in the outer block 9) +E zord: array [text-char] of ASCII-code; xchr : array [ASCII-code] of text-char ;

{ specifies conversion of input characters } { specifies conversion of output characters }

14 WEAVE

THE CH.ARACTER SET 21

14. If we assume that every system using WEB is able to read and write the visible characters of stan' dard ASCII (although not necessarily using the ASCII codes to represent them), the following assignment
statements initialize most of the'xchr array properly, without needing any system-dependent changes. For example, the statement xchr [@*lOl] := 'A l that appears in the present WEB file might be encoded in, say, EBCDIC code on the external medium on which it resides, but TANGLE will convert from this external code to ASCII and back again. Therefore the assignment statement XCHR [65] : = `A'will appear in the corre-
sponding PASCAL file, and PASCAL will compile this statement so that xchr [65] receives the character A in
the external (char) code. Note that it would be quite incorrect to say xchr [Q '1011 :="A", because "A" is a constant of type integer, not char, and because we have "A" = 65 regardless of the external character set.

( Set initial values 10) +S xchr[`40] t `,,`; xchr[21] +- `!`; xchr[`42] t `l"; xchr[`43] t `#*; xchr[`&] t `$`;

xchr[`45] t `%`; xchr[`46] +-- `&`; zchr[`47] +- `**`;
xchr[`/j(J] t `(`; xchr[`51] t `)`; xchr[`52] + `*`; xchr[`53] +- `+`; x c h r `54 1 tl *.;

xchr[`55] t `-`; xchr[`56] +- `. `; zchr[`57] +- `/`;

xchr [ `601 + '0'; xchr['61] t '1'; zchr[`62] t '2'; xchr[`63] + `3'; xchr `641 + `4 ';

xchr [ `651 t -6'; xchr[`66] t `6 '; zchr[`67] + `7 ';
xchr [ `701 +- `8'; xchr[`71] t `9'; xchr[`72] t `: `; xchr[`73] + `; `; x c h r '74]t I<'; xchr[`75] t *=`; xchr[`76] t l >`; xchr[`77] + `?*;

xchr [ `IO01 + `0'; xchr [ `IO1 xchr [ `1051 + `E'; xchr [ `106 xchr [ `IlO] + 'H'; xchr [ `III
xchr [ `1151 t `M'; xchr [ `116 xchr [ `1201 +-- 'P'; xchr [ `121

t 'A'; xchr['jo2] t 'B'; xchr[`lO$] + `C'; xchr[`~O4] + `D';
t 'F'; xchr[`107] +- l G'; e 01'; xchr['112] t 'J'; xchr[`ll8] t l K'; xchr[`LLJ] + `L'; t l N'; xchr[ `1171 t- `0'; +-. l Q*; xchr[ 'i,$!,!j] t 'R'; xchr[`123] + `S'; xchr[ `1241 + `T';

xchr [ `1251 + 'U'; xchr [ `126 xchr [ `1301 t 'X'; xchr [ `131 xchr[`135] t `I `; xchr[`l36 xchr[`140] t `* `; xchr[`l.#l xchr[`145] +-- *e'; xchr[`l46 xchr [ `1501 + 'h'; xchr [ `151

t *V'; xchr [ `1271 + `W `;

I't `Y `; xchr [ `1321 t 'Z'; xchr[`l33] + ' 1'; xchr `1341 + `\`;

t *-`; xchr[`f87] +-- l -`;

L

t *a*; xchr [ `1421 +- *b'; xchr[`l43] + #C `; xchr `1441 +- 'd';

t 'f '; xchr[`l47] +- l g';

t .i'; xchr [ `1521 t `j `; xchr[ `1531 + l k'; xchr `1541 t '1';

xchr[`.f55] t `m'; xchr[`156 t `n'; xchr[`l57] +- `0';

xchr[`160] + `p'; xchr[`l61 t *q'; x c h r [ `1621 +- `r'; xchr[ `1631 + `s'; x c h r `1641 t `t';
xchr[`l65] +- `u'; xchr[`l66 t l v'; xchr[`167] +- `w';

xchr[`l70] t `x'; xchr[`l71] t `y'; xchr[`l72] +- `2'; xchr[`l73] + `(`; x c h r `1741 + ' I `;

xchr[`l75] t `I'; xchr[`l76] +- `-*; xchr[O] t `U*; xchr [ `1771 t *u'; {these ASCII codes are not used }

15. Some of the ASCII codes below `40 have been given symbolic names in WEAVE and TANGLE because they <are used with a special meaning.
define and-aign = `4 { equivalent to 'and' } define not-sign = `5 { equivalent to `not'} define set-element-sign = `6 {equivalent to `in'} define tab-murk = `11 { ASCII code used as tab-skip} define line-feed = `12 { ASCII code thrown away at end of line} define lorm-feed = `14 { ASCII code used at end of page} define curriage-return = `15 { ASCII code used at end of line} define lejt-urrow = `30 { equivalent to ` : ='} define not-equal = `32 {equivalent to `<>`} define less-or-equul = `34 {equivalent to `<=`} define greater-or-equal = `35 {equivalent to `>=' } define equivalence-sign = `36 { cquivalcnt t,o `==' } define or-sign = `37 ( equivalent to `or'}

22 THE CHARACTER SET

WEAV.E W

16. When we initialize the xord array and the remaining parts of xchr, it will be convenient to make use of an index variable, i.
( Local variables for initialization IS) E i: 0 . . last-text-char;
See also sections 40, 56, and 247.
This code is used in section 2.

17. Here now is the system-dependent part of the character set. If WEB is being implemented on a gardenvariety PASCAL for which only standard ASCII codes will appear in the input and output files, you don't
need to make any changes here. But at MIT, for example, the code in this module should be changed to

for i t 1 to `37 do xchr[i] t &r(i);

WEB's character set is essentially identical to MIT's, even with respect to characters less than `40. Changes to the present module will make WEB more friendly on computers that have an extended character
set, so that one can type things like Z instead of <>. If you have an extended set of characters that are easily incorporated into text files, you can assign codes arbitrarily here, giving an xchr equivalent to whatever characters the users of WEB are allowed to have in their input files, provided that unsuitable characters do not correspond to special codes like carriage-return that are listed above.
(The present file WEAVE. WEB does not contain any of the non-ASCII characters, because it is intended to be used with all implementations of WEB. It was originally created on a Stanford system that has a convenient extended character set, then "sanitized" by applying another program that transliterated all of the non-standard characters into standard equivalents.)
( Set initial values 10 ) +r for i t 1 to `37 do xchr[i] t `"`;

18. The following system-independent code makes the xord array contain a suitable inverse to the information in xchr .
( Set initial values 10) +G for i +- first-text-char to last-text-cha; do xord[chr(i)] t `40; for i t 1 to `176 do xord[xchr [i]] t i;

t

19 WEAVE

I N P U T.A N D O U T P U T 2 3

19. Input and output. The input conventions of this program are intended to be very much like those
of T@ (except, of course, that they <are much simpler, because much less needs to be done). Furthermore they are identical to those of TANGLE. Therefore people who need to make modifications to all three sy&ems
should be able to do so without too many headaches. We use the standard PASCAL input/output procedures in several places that TjjX cannot, since WEAVE
does not have to deal with files that are named dynarnic,ally by the user, and since there is no input from the terminal.

2 0 . Terminal output is done by writing on file term-out, which is assumed to consist of characters of type
text-char:
define print (#) G write (term-out, #) { `print ' means write on the terminal } define print-ha(#) s write-In (term-out, #) { `p tint ' (and then start new line } define new-line E write-fn (term-out) { start new line } define print-d (#) E { printin of rmation starting on a new line }
begin new-line ; print (#); end
( Globals in the outer block 9) +E term-out : text-file ; { the terminal as an output file.}

21. Different systems have different ways of specifying that the output on a certain file will appear on the user's terminal. Here is one way to do this on the PASCAL system that was used in TANGLE's initial development:
( Set initial values 10) +E rewrite (term-out, 'TTY: `); { send term-out output to the terminal}

2 2 . The update-terminal procedure is called when we want to make sure that everything we have output to the terminal so far has actually left the computer's internal buffers and been sent.
define update-terminal z break (term-out ) { empty the terminal out,put buffer }

2 3 . The main input comes from web-fife; this input may be overridden by changes in change-file. (If change-file is empty, there are no changes.)
( Globals in the outer block 9) +ZE we b-file : text-file ; { primary input } change-file : ted.file ; { updates }

2 4 . The following code opens the input files. Since tllcse files were listed in the program header, we rassume that the PASCAL runtime system has already checked that suitable file names have been given; therefore no additional error checking needs to be done. We will set below that WEAVE reads through the entire input twice.
procedure open-input ; { prepare t,o read web-file and change-file } begin re,set (web-file); reset (change-file); end;

2 5 . The main out,put goes to tez-file.
( Globals in the outer block o ) +Z tes-file : text-file;

24 INPUT AND OUTPUT

WEA. VE 26

26. The following code opens tez-file. Since this file was listed in the program header, we assume that the `PASCAL runtime system has checked that a suitable external file name has been given.

( Set initial values 10) +r

'

rewrite (tes-file );

27. Input goes into an array called bufler.
( Globals in the outer block 9) +r bufler: array [0 . . long-buf-size] of ASCII-code;

28. The input-h procedure brings the next line of input from the specified file into the bufler array and returns the value true, unless the file has already been entirely read, in which case it returns false. The conventions of `l&X are followed; i.e., ASCKcode numbers representing the next line of the file are input into bufler [0], bu#er [I], . . . , bufler [limit - 11; trar`1'mg blanks are ignored; and the global variable limit is set to the length of the line. The value of limit must be strictly less than buf-size.
We assume that none of the ASCII-code values of bu.er [j] for 0 5 j < limit is equal to 0, `177, line-feed, form-feed, or carriage-return. Since buf_size is strictly less than long-buf_size, some of WEAVE's routines use the fact that it is safe to refer to bufier [limit + 21 without overstepping the bounds of the array.
function input-h (var f : tezt-file): boolean; { inputs a line or returns false } var final-limit : 0 . . buf-size ; { limit without trailing blanks} begin limit t 0; final-limit t 0; if eof (f) then input-h t false else begin while leoln (f) do begin bufier[limit] t zord[fr]; get(f); incr (Zimit); if bufler [limit - l] # ",," then final-limit t limit ; if limit = buf_size then begin while leoln(f) do get(f); deer (limit ); { keep bufier [ buf-size] empty } print-nl ( ' ! UInput,line,tooUlong `); Zoc t 0; error ; end; end;
read-h (f); limit t final-limit; input-h t true ; end; end;

I

29 WEAVE

REPORTING ERRORS .TO THE USER

25

29. Reporting errors to the user. The WEAVE processor operates in three phases: first it inputs the source file and stores cross-reference data, then it inputs the source once again and produces the T@ output file, and finally it sorts and outputs the index.
The global variables phuae-one and phase-three tell which Phase we are in.
( Globals in the outer block 9) +r phase-one : boolean ; { true in Phase I, false in Phases II and III} phase-three : boolean; { true in Phase III, false in Phases I and II}

30. If an error is detected while we are debugging, we usually want to look at the contents of memory. A special procedure will be declared later for this purpose.
( Error handling procedures 30 ) s debug procedure debug-help; forward; gubed
See also sections 31 and 33.
This code is used in section 2.

31. The command `err-print ('! ,ErrorUmessage `)'will report a syntax error to the user, by printing the error message at the beginning of a new line and then giving an indication of where the errcr was spotted in the source file. Note that no period follows the error message, since the error routine will automatically supply a period.
The actual error indications are provided by a procedure called error. However, error messages are not actually reported during phase one, since errors detected on the first pass &ill be detected again during the second.
define err-print (#) G begin if lphuse-one then begin new-line ; print (#); error ; end;
end
( Error handling procedures 30) +s procedure error; {prints `. ' and location of error message }
var k, 1: 0 . . long-buf-size ; {indices into bufler } begin (Print error location based on input buffer 32);
update-terminal; mark-error; debug debug-skipped t debug-cycle; debug-help; gubed end;

26 REPORTING ERRORS TO THE USER

WEAVE $32

32. The error locations can be indicated by using the global variables lot, line, and changing, which tell respectively the first unlooked-at position in bufer , the current line number, and whether or not the current line is from change-file or web-file. This routine should be modified on systems whose standard text ,editor has special line-numbering conventions.
(Print error location based on input buffer 32 ) E begin if changing then print ( '. U (change,f ile, `) else print ( '. U ( `); print-ln ( `1. `, line : 1, `1 `); if lot > limit then 1 t limit else 1 +- lot; for k t- 1 to 1 do if bu#er [k - l] = tab-mark then print ( `" `) else print (zchr [bufler [k - 111); { print the characters already read }
new-line ; for k t 1 to 1 do print ( `U*); {space out the next line } for k c I + 1 to limit do print(zchr[bufler[k - 111); {print the part not yet read} if bufler [limit] = " I " then print (zchr [I' I"]); {end of PASCAL text in module names } print( `U'); {t ihs s pace separates the message from future asterisks } end
This code is used in section 31.

3 3 . The jump-out procedure just cuts across all active procedure levels and jumps out of the program. This is the only non-local goto statement in WEAVE. It is used when no recovery from a particular error has been provided.
Some PASCAL compilers do not implement non-local goto statements. In such cases the code that appears at label end-of- WEAVE should be copied into the jump-out procedure, followed by a calI to a system procedure that terminates the program.
define fatal-error (#) z begin nedine ; print (#); error; mark-fntal; jump-out ; end
(Error handling procedures 30) +Z procedure jump-out;
begin goto end-of- WEAVE; end;

34. Sometimes the program's behavior is far different from what it should be, and WEAVE prints an error message that is really for the WEAVE maintenance PWSOIl, not the user. In such cases the program says con/u.uion ( `indicat ionLof ,where,we,are `).
define confu,sion (#) E /utdertor ( '! LIThisUcan '`tLhappen, ( `, #: `> `)

35. An overflow stop occurs if WEAVE's tables aren't large enough. define over/low (#) z jntderror ( ' !,Sorry , U `, #, `,capacityLexceeded `)

36 WEAVE

D A T A .S T R U C T U R E S 27

36. Data structures. During the first phase of its processing, WEAVE puts identifier names, index entries, and module names into the large byte-mem array, which is packed with seven-bit integers. Allocation is sequential, since names are never deleted.
An auxiliary array byte-start is used as a directory for byte-mem, and the fink, ilk, and zref arrays give
further information about names. These auxiliary arrays consist of sixteen-bit items.

(Types in the outer block II ) +r

.

eight-bits = 0 . . 255; { unsigned one-byte quantity }

sizteen-bits = 0 . . 65535; { unsigned two-byte quantity }

3 7 . WEAVE has been designed to avoid the need for indices that are more than sixteen bits wide, so that it can be used on most computers. But there arc programs that need more than 65536 bytes; T@ is one of these. To get around this problem, a slight complication has been added to the data structures: byte-mem is a two-dimensional array, whose first index is either 0 or 1. (For generality, the first index is actually allowed to run between 0 and ww - 1, where ww is defined to be 2; the program will work for any positive value of ww, and it can be simplified in obvious ways if ww = 1.)
define ww = 2 {we multiply the byte capacity by approximately this amount }
( Globals in the outer block 9) +E byte-mem: packed array [0 . . ww - 1,O . . muz-bytes] of ASCII-code; { characters of names} byte-start: array [0 . . maz-names] of sizteen-bits; { directory into 6yte-mem } link: array [0 . . maz-names] of s&teen-bits; { hash table or tree links } ilk: array [0 . . mu%-names] of sizteen-bits ; { type codes or tree links } sref : array [0 .,. muz.numes] of sisteen-6its ; { heads of cross-reference lists }

The names of identifiers are found by computing a hash address h and then looking at strings of E:ics signified by hash[h], link[hush[h]], Zinkllink[hush[h]]], . . . , until either finding the desired name or encountering a zero.
A `nume-pointer ' variable, which signifies a name, is an index into byte-start. The actual sequence of characters in the name pointed to by p appears in positions byte-sturt [p] to byte-start [p + ww] - 1, inclusive, in the segment of byte-mem whose first index is p mod ww. Thus, when ww = 2 the even-numbered name bytes appear in byte-mem[O, *] and the odd-numbered ones appear in byte-mem[l, *]. The pointer 0 is used for undefined module names; we don't want to USC it for the names of identifiers, since 0 stands for a null pointer in a linked list.
WC usually llave byte-start [name-ptr + 201 = byte-ptr [( name-ptr + W) mod ww] for 0 5 UI < ww, since these arc the starting positions for the next ww names to be stored in byte-mem.
define length (#) z byte-start [# + ww] - byte-start [#I { the length of a name }
( Types in the outer block II ). += name-pointer = 0 . . muz-names; { identifies a name }

39. ( Globals in the outer block 9) +C
nrlme-ytr: name-pointer ; { first unused position in byte-start } byte-ptr : array [0 . . ww - I] of 0 . . muz-bytes ; { first unused position in byte-mem }

40. ( Local variables for initialization IS) += w i : O..ww - 1 ; { to initialize the byte-mem indices }

41. (Set initial values 10) +s for wi +- 0 to ww - 1 do
begin byte-start [wi] +- 0; byte-ptr [wi] t- 0; end;
byte-sturt [WV] t 0; { this ~mkcs name 0 of length zero} name-ptr t 1;

*

28 DATA STRUCTURES

WEAVE

942

42. Several types of identifiers are distinguished by their ills:

normal identifiers are part of the PASCAL program and will appear in italic type:

toman identifiers are index entries that appear after O^ in the WEB file.

wildcard identifiers are index entries that appear after 0: in the WEB file.

typewriter identifiers are index entries that appear after Q. in the WEB file.

array-like, begin-like, . . . , war-like identifiers are PASCAL reserved words whose ilk explains how they are to be treated when PASCAL code is being formatted.

Finally, if c is an ASCII code, an ilk equal to char-like + c denotes a reserved word that will be converted to character c.

define normal = 0 { ordinary identifiers have normal ilk }

define roman = 1 {normal index entries.have romun ilk }

define wildcard = 2 { user-formatted index entries have wildcard ilk }

define typewriter = 3 { `typewriter type'entries have typewriter ilk }

define reserved (#) E (ilk[#] > typewriter) { tells if a name is a reserved word}

define array-like = 4 {array, file, set }

define begin-like = 5 { begin )

define case-like = 6 { case }

define const-like = 7 { const, label, type }

define div-like = 8 { div, mod }

define do-like = 9 { do, of, then}

define else-like = 10 { else }

define end-like = 11 { end }

define for-like = 12 { for, while, with}

define goto-like = 13 { goto, packed}

define if-like = 14 { if }

define in-like = 15 { in }

define nil-like = 16 { nil }

define proc-like = 17 { function, procedure, program}

define record-like = 18 { record } '

define repeat-like = 19 { repeat }

define to-like = 20 { downto, to}

define until-like = 21 {until}

.

define vnr-like = 22 { var }

define loop-like = 23 {loop, xclause }

define char-like = 24 {and, or, not, in }

4 3 . The names of modules are stored in byte-mem together with the identifier names, but a hash table is not used for them because WEAVE needs to bc able to recognize a module name when given a prefix of that name. A conventional binary seach tree is used to retrieve module names, with fields called llink and rlink in place of link and ilk. The root of this tree is rlink[O].
define llink E link {left link in binitry search tree for module names } define r-link E ilk { right link in binary search tree for module names } define root G rlink[O] { the root of the binary search tree for module names }
( Set init,ial values 10 ) + Z root +- 0; { the binary search tree starts out wit'h nothing in it }

44 WEAVE

D A T A >TRUCTURES 29

44. Here is a little procedure that prints the text of a given name on the user's terminal.
procedure print-id (p : name-pointer); { p rint identifier or module name } var k: 0 . . max-bytes; {index into byte-mem } w : 0 . . ww - 1; {row of byte-mem } begin if p > name-ptr then print (`IMPOSSIBLE') else begin w +- p mod tow; for k +- byte-start [p] to byte-start [p + ww] - 1 do print (xchr[ byte-mem [w, k]]); end; end;

45. We keep track of the current module number in modulecount, which is the total number of modules that have started. Modules which have been altered by a change file entry have their changed-module flag turned on during the first phase.
(Globals in the outer block 9) +module-count: 0 . . max-modules; { the current module number } changed-module: packed array [0 . . mux-modules] of boolean; {is it changed? } change-exists : boolean; { has any module changed? }

46. The other large memory area in WEAVE keeps the cross-reference data. All uses of the name p a.re recorded in a linked list beginning at xref [p], which points int.o the xmem array. Entries in xmem consist of two sixteen-bit items per word, called the num and xlink fields. If x is an index into xmem, reached from name p, the value of num(x) is either a module number where p is used, or it is def-flag plus a module number where p is defined; and xlink(x) p oints to the next such cross reference for p, if any. This list of cross references is in decreasing order by module number. The current number of cross references is xref-ptr .
The global variable xref-switch is set either to def_flag or to zero, depending on whether the next cross reference to an identifier is to be underlined or not in the index. This switch is set to de,f&g when Q! or Od or Qf is scanned, and it is cleared to zero when the next identifier or index entry cross reference has been made. Similarly, the global variable mod-xref-switch is either de/-flag or zero, depending on whether a module name is being defined or used.
define num(#) E xmem[#].num-field define xlink (#) = xmem [#] .xlink-field define de/-flag = 10240 { must be strictly larger than max-modules }

47. (Types in the outer block II) +E xref-number = 0 . . max-refs;

48. (Globals in the outer block 9) +E xmem: array [xref-number] of packed record
num-field : sixteen-bits ; { module number plus zero or de!-/Zag } xlink-field: sixteen-bitu; { pointor to t$ho previous cross roferencc } end;
xreJ-ptr : xrej-number ; { the hrrgcst occupied position in xmem } xreJ_switch, mod-xreJ-switch: 0 . . de/-flag ; { either zero or deJ$ug }

49. ( Set initial values 10) +r xref-ptr +- 0; xref-switch +- 0; mod-xref-switch +-- .O; nurn (0) t 0; xref [0] +- 0; { cross references to undefined modules }

30 DATA STRUCTURES

WEAVE 50

60. A new cross reference for an identifier is formed by calling new-zref , which discards duplicate entries ' and ignores non-underlined references to one-letter identifiers or PASCAL's reserved words.

define append-xref (#) s

*

if zref-ptr = maz-rejs then overflow ( `crossUref erence `)

else begin incr (zref-ptr); num(zref-ptr) t #;

end

procedure new-xref (p : name-pointer);
label etit;
var q: xref-number ; { pointer to previous cross reference } m, n: sixteen-bits; { new and previous cross-reference value }
begin if (reserved(p) V (byte-start [p] + 1 = byte-start [p + ww])) A (xref-switch = 0) then return;
m +- module-count + xref-switch; zref_switch t 0; q t zref [p];
if q > 0 then begin n t num (q); if (n = m) V (n = m + def&g) then return else if m = n + dej-jlag then begin num(q) t m; return;
end; end;

append-zref (m); xlink (xref-ptr ) +- q; xref [p] t xrej-ptr ; exit: end;

51. The cross reference lists for module names are slightly different. Suppose that a module name is defined in modules ml, . . . , mk and used in modules ni, . . . , q. Then its list will contain ml + def-flag, mk + dej-flag, . . . , ma + dej-jlag, nl, . . . , n1, in this order. After Phase II, however, the order will be ml $ def-flag, . . . , mk + def-flag, n1, . . . , nl.

procedure new-mod-xref (p : name-pointer); var q, r: xref-number ; { pointers to previous cross references }
begin q t zref [p]; r t 0; if q > 0 then
begin if mod-xref-switch = 0 then while num(q) > def-Jag do begin r +- q; q t xlink (q); end
else if num(q) 2 def-flag then begin r +- q; q t xlink (q); end;
end;

append-xref (module-count + mod-xref-switch); xlink (xref-ptr ) t q; mod-xrej-switch
if r = 0 then zref [p] t zref-ptr else xlink (r) t xref-ptr ;
end;

t 0;

52., A third large area of memory is used for sixteen-bit `tokens', which appear in short lists similar to the strings of characters in byte-mem. Token lists arc used to contain the result of PASCAL code translated into QjX form; further details about them will be explained later. A text-pointer variable is an index into tok-start .
I (Types in the outer block 11) +r tezt-pointer = 0 . . mux-texts; { identifies a token list }

53 WEAVE

D A T A. S T R U C T U R E S 31

53. The first position of tok-mem that is unoccupied by replacement text is called tok-ptr, and the first unused location of tok-start is called text-ptr . Thus, we usually have tok-start [ted-ptr] = tok-ptr.
( Globals in the outer block 9) +r tok-mem: packed array [0 . . max-toks] of sixteen-bits; { tokens} tok-start : array [text-pointer] of sixteen-bits; { directory into tok-mem } text-ptr : text-pointer ; {fist unused position in tok-start } tok-ptr: 0 . . max-toks; { first unused position in tok-mem } stat max-tok-ptr , max-txt-ptr : 0 . . max-toks ; { largest values occurring } tats

54. ( Set initial values 10) +E tok-ptr t 1; text-ptr t 1; tok-start[O] +- 1; tok-start[l] t 1; stat max-tok-ptr 4- 1; max-txt-ptr t 1; tats

32 SEARCHING FOR IDENTIFIERS

W E .A V E $ 5 5

65. Searching for identifiers. The hash table described above is updated by the id-lookup procedure, which finds a given identifier and returns a pointer to its index in byte-start. The identifier is supposed to match character by character and it. is also supposed to have a given ilk code; the same name may be present more than once if it is supposed to appear in the index with different typesetting conventions. If the identifier was not already present, it is inserted into the table.
Because of the way WEAVE's scanning mechanism works, it is most convenient to let id-lookup search for an identifier that is present in the bufler array. Two other global variables specify its position in the buffer: the first character is bufler[id-first], and the last is bufier [id-lot - 11.
(Globals in the outer block 9) +r id-first: 0 . . long-buj&ze ; { where the current identifier begins in the buffer }. id-lot: 0 . . long-buf-size; {just after the current identifier in the buffer }
hash: array (0.. hash-size] of s&teen-bits; ( heads of hash lists }

56. Initially all the hash lists are empty.
(Local variables for initialization 16) +r h: 0 . . hash-site ; { index into hash-head array }

57. ( Set initial values 10) +Z for h t 0 to hash-size - 1 do hash[h] + 0;

58. Here now is the main procedure for finding identifiers (and index entries). The parameter t is set to the desired ilk code. The identifier must either have ilk = t, or we must have t = normal and the identifier must be a reserved word.
function id-lookup (t : eight-bits): name-pointer; { finds current identifier } label found;
. v a r i : 0 . . long-buj-sixe ; {index into bufier } h: 0 . . hash-size; { hash code } k : 0 . . max-bytes; {index into byte-mem } 20: 0 . . ww - 1; {row of byte-mem } 1: 0 . . long-buf-size ; {length of the given identifier } p: name-pointer; {where the identifier is being sought }
begin 1 t id-lot - id.Jrst; { compute the length } ( Compute the hash code h 59); ( Compute the name location p GO); if p = name-ptr then (Enter a new name into the table at position p ~2);
id-lookup +- p; end;

59. A simple hash code is used: If the scqucnce of ASCII codes is crc2 . . .c,,, its hash value will be

(2" `cl + 2n -2c2 + s s . + c,,) ~rwd hash-size.

( Compute the hash code h 59) G
h +- bufler[id&st]; i t id-first + 1; while i < id-lot do
begin h t (h + h + bufler [i]) mod hashAze; incr (i): end
This code is used in sect,ion 58.

60 WEAVE

SEARCHING FOn IDENTIFIERS

33

60. If the identifier is new, it will be placed in position p = name-ptr, otherwise p will point to its existing ' location.
( Compute the name location p eb ) z
p + hash[h]; while p # 0 do
begin if (length(p) = 1) A ((ilk [p] = t) V ((t = normal) A reserved(p))) then ( Compare name p with current identifier, goto found if equal 61);
p t link [p]; end; p 4- name-ptr; { the current identifier is new } link [p] + hash [h]; hash[h] +-- p; { insert p at beginning of hash list }
found:
This code is used in section 58.

61. ( Compare name p with current identifier, goto found if equal 61) s begin i +- id&at ; k +- byte-start [p]; w + p mod ww ; while (i < id-Zoc) A (bufler [i] = byte-mem[w, k]) do begin incr (i); incr (k); end; if i = id-Zoc then goto found; {all characters agree} end
This code is used in section 60.

62. When we begin the following segment of the program, p = name-ptr.
(Enter a new name into the table at position p 62 ) z begin w + name-ptr mod w; if byte-ptr [w] + 1 > maz-bytes then overflow (`byte,memory `); if name-ptr + ww > maz-names then overflow ( `name `); i + id-first; k 4-- byte-ptr [w]; { getready to move the identifier into byte-mem } while i < id-Zoc do begin byte-mem [w, k] + bufler [i]; incr (k); incr (i); end;
byte-ptr [w] + k; byte-start [name-ptr + ww] t k; incr (name-ptr ); ilk [p] t t; sref [p] t 0 end
This code is used in section 58.

34 INITIALIZING THE TABLE OF RESERVED WORDS

WEA.VE

63

63. Initializing the table of reserved words. We have to get PASCAL's reserved words into the hash table, and the simplest way to do this is to insert them every time WEAVE is run. A few macros permit us to do the initialization with a compact program.
define sid9 (#) E bufer [9] t #; cur-name t id-lookup d e f i n e sid8 ( # ) ES bufler [8] + #; sid9 define sid7(#) G bufler [7] t #; sidd define sid6 (#I) G bufer [6] +- #; aid7 define sid5 (#) z bufier [5] t #; sid6 define sid4 (#I) E bufler [4] +- #I; sid5 define sid3 (#) G 6ufier [3] t #; sid( define sid2 (#) G 6ufer [2] + #; sid3 define sidl (#) zz bufler [l] t #; aid2 define id2 G id-first t 8; Ad8 define id3 G id-first t 7; sid7 define id4 E id-first t 6; sid6 define id5 E id-first t 5; sid5 define id6 3 id-first t 4; sid4 define id7 E id-first + 3; sid9 define id8 zz id-first t 2; aid2 define id9 5 id-first t 1; sidl
( Globals in the outer block 9) +E cur-name : name-pointer ; { points to the identifier just inserted}

P

64 WEAVE

INITIALIZING THE TABLE OF RESERVED WORDS 35

64. The intended use of the macros above might not bc immediately obvious, but the riddle is answered by the following:

( Store a,ll the reserved words 64) z

id-Zoc t 10;

id3 ("a")( "n")( "d")( char-like + and-sign); ~d5("a")("r")("r")("a")(`ty")(array_l~~e);

~d5("b")("e")("g")("i")("n")(begin_l~~e);

id4 ("c")("a")("s")("e'`)(case-l&e);

~d5("c")("o")("n")("s")("t")(const_like);

id3 (I',")( "i")( "v")( div-like);

id2 ("d") ( "0") (do-like);

~d6("d")("ot')("w")("n")("t'1)("o")(to_Z~ke);

id4 ("e")("l")("s")("e'`)(eZse-like);

~d3("e")("n")("d")(end-like);

id4 ("f")("i")("l")("e")(array-like);

~d$("f")("o")("r")(,r-Zike);

~d8("f")("u")("n")("c")(~`t")("i")("o")("n")(proc~Zike);

id4 ("g")("o")("t")("o'`)(goto-like);

;d.Z("i")("f")(,Zike);

id2 ("i")( "n")( char-like + set-element-sign);

id~("l")("a")("b")("e")("l")(cotast-like);

~d3("m")("o")("d")(div-like); ,

~d3("n")("i")("l")(nil-like);

id3 ("n") ( "o")( "t ") (char-Zike + not-sign);

idZ("o")("f")(do-like);

. id,2 ("o")( "r")( char-like + or-sign);

~~~~("p")("a")("c")("k")("e")("d")(goto-like);

~d~(`~p")("r")("o")(`~c")(~`e~`)("d")("u")("r")("e")(proc-Zike);

id7("p")("r")("o")("g")("r")("a")("mt')(proc-Zike);

~dG("r")("e")("c")("o'~)("r")("d")(record~Zike);

~dG("r")("e")("p")("e")("a")("t")(repeat-like);

id3 ("s")( "e")( "t")( array-like);

id4 ("t")("h")("e")("n")(do-Zike);

~dL?("t")("o")(to-Zike);

id4 ("t")("y")("p")("e")(con&Zike);

~d5("u")("n")("t")(t'i")("l")(untiZ_like);

'

id3 ("v")( "a")( "r")( vur-like);

id5("w")("h")("i")("l")(``e")(jor-Z&e);

id,/ ("w")("i")("t")("h")(,r-Zike);

~d7("x")("c")("l")("a'~)("u")("s")("e")(Zoop~Zike);

This code iu used in section 261.

36 SEARCHING FOR MODULE NAMES

WE.AVE 65

65. Searching for module names. The mod-lookup procedure finds the module name mod-text [I . . I] ' in the search tree, after inserting it if necessary, and returns a pointer to where it was found.
( Globals in the outer block 9) +`= mod-text: array [0 . . longest-name] of ASCII-code ; { name being sought for }

66. According to the rules of WEB, no module name should be a proper prefix of another, so a "clean" comparison should occur between any two names. The result of mod-lookup is 0 if this prefix condition is violated. An error message is printed when such violations are detected during phase two of WEAVE.

define less = 0 { the first name is lexicographically less than the second } define equal = 1 { the first name is equal to the second } define greater = 2 { the first name is lexicographically greater than the second} define prefix = 3 { the first name is a proper prefix of the second }
define extension = 4 { the first name is a proper extension of the second}

function mod-lookup (I : sixteen-bits): name-pointer ; { finds module name } label found;
var c: less . . extension; { comparison between two names } j : 0 . . longest-name ; {index into mod-text }
k: 0 . . mux-bytes; {index into byte-mem } 20: 0 . . ww - 1; {row of byte-mem } p: name-pointer ; { current node of the search tree }
q: name-pointer ; { father of node p } begin c t greater; q t 0; p +-- root;
while p # 0 do begin ( Set c to the result of comparing the given name to name p 68);

Q +- Pi if c = less then p +- ZZink[q] else if c = greater then p +-- rZink[q]
else goto found;
end; (Enter a new module name into the tree 67); found: if C # equal then
begin err-print ('!uIncompatible,sectionunames'); end;

pt0;

mod-lookup +-- p; end;

67. (Enter a new module name into the tree 67 ) s w t nnme-ptr mod ww; k +- byte-ptr [w]; if k + 1 > mux..bytes then overflo?u( `byte,memory `); if name-ptr > mux-numes - 20~1) then overflow ( `name `);
p +- name-ptr; if c = less then ZZink[q] +-- p else rZink[q] +- p; lhnk [p] t 0; rlink[p] t 0; xref [p] t 0; c t equal; for j +- 1 to 1 do byte-mem [w, k + j - I] +- mod-text [j];
byte-ptr [w] +- k + 1; byte-start [name-ptr + ww] t k -t I; incr (name-ptr );
This code iR wd in section 66.

E

68 WEAVE

SEARCHING FOR MODULE NAMES

68. ( Set c to the result of comparing the given name to name p 68 ) ES begin k t byte-start [p]; w + p mod ww; c + equal; j +- 1; while (k < byte-start [p + ww]) A (j 5 1) A (mod-text [j] = byte-mem [w, k]) do begin incr (k); incr (j); end; if k = byte-start [p + ww] then if j > 2 then c +- equal else c t extension else if j > I then c t prefix else if mod-text [j] < byte-mem [w, k] then c t Zese else c 4- greater; end
This code is used in sections 66 and 69.

37

69. The prefixJookup procedure is supposed to 6nd exactly one module name that has mod-text [l . . 11 as a prefix. Actually the algorithm silently accepts also the situation that some module name is a prefix of mod-text [l . . 11, b ecause the user who painstakingly typed in more than necessary probably doesn't want to be told about the wasted effort.
Recall that error messages are not printed during phase one. It is possible that the prefix-lookup procedure will fail on the first pass, because there is no match, yet the second pass might detect no error if a matching module name has occurred after the offending prefix. In such a case the cross-reference information will be incorrect and WEAVE will report no error. However, such a mistake will be detected by the TANGLE processor.

function prefix-Zookup(Z : sixteen-bits): name-pointer; { finds name extension}

var c: less . . extension; { comparison between two names}

count: 0 . . max-names ; { the number of hits }

j: 0 . . longest-name; {index into mod-text }

k: 0 . . max.-bytes; {index into byte,mem } w: 0 . . ww - I; {row of byte-mem }

.

p: name-pointer ; { current node of the search tree }

q: name-pointer ; { Canother place to resume the search after one branch is done}

r: name-pointer; { extension found }

begin q + 0; p t root; count t 0; r t 0; { begin search at root of tree}

while p # 0 do

begin ( Set c to the result of comparing the given name to name p 68);

if c = less then p +- Zlink[p]

else if c = greater then p t rZink[p]

else begin r +- p; incr (count); q +- rZink[p]; .p +- Zlink[p];

end;

if p = 0 then

begin p t q; q t 0;

end;

end;

if count # 1 then

if count = 0 then err-print ('!,Name,doesUnotUmatch')

else err-print ( ' ! LAmbiguousupref ix `);

prefix-lookup t- r; { the result will be 0 if there was no match}

end;

38 LEXICAL SCANNING

WEAVE 70

70. Lexical scanning. Let us now consider the subroutines that read the WEB source file and break it
into meaningful units. There are four such procedures: One simply skips to the next `QU' or `@*' that begins a module; another passes over the TJ$ text at the beginning of a module; the third passes over the T# text in a PASCAL comment; and the last, which is the most interesting, gets the next token of a PASCAL text.

71. But first we need to consider the low-level routine get-line that takes care of merging change-file into web-file. The get-line procedure also updates the line numbers for error messages.
( Globals in the outer block 9) +Z line : integer ; { the number of the current line in the current file} other-line : integer ; { the number of the current line in the input file that is not currently being read } temp-line : integer ; {used when interchanging line with other-line } limit : 0 . . long-buj-size ; { the last character position occupied in the buffer } lot: 0 . . long-bujsize; {the next character position to be read from the buffer } input-has-ended: boolean; {if true, there is no more input } changing : boolean ; {if true, the current line is from change-file }

72. As we change changing from true to false aud back again, we must remember to swap the values of line and other-line so that the err-print routine will be sure to report the correct line number.
define change-changing E changing t lchanging; temp-line t other-line; other-line t line; line +-- temp-line { line H other-line }

73. When changing is false, the next line of change-file is kept in change-bufler [0 . . change-limit], for purposes of comparison with the next line of web-file. After the change file has been completely input, we set change-limit +- 0, so that no further matches will be made.
( Globals in the outer block 9) +r change-bufier: array [0 . . buj-size] of ASClIcode; change-limit: 0 . . buj-size; { the last p osi tion occupied in chunge-bufer }

74. Here's a simple functiou that checks if the two buffers are different.
function lines-dent-match: boolean; label exit; var k: 0 . . buj-size; {index into the buffers } begin lines-dent-match t true; if change-limit # limit then return; if limit > 0 then for k +- 0 to limit - 1 do if changebuflcr [k] # bufler[k] then return;
lines-dont-match t false ; exit: end:

75 WEAVE

LEXIC.AL SCANNING 39

75. Procedure prime-the-change-bufler sets change-bufler in preparation for the next matching operation. ' Since blank lines in the change file are not used for matching, we have (change-limit = 0) A lchanging if and only if the change file is exhausted. This procedure is called only when changing is true; hence error messages will be reported correctly.
procedure prime-the-change-bufler; label continue, done, ezit; var k: 0 . . buf_size; {index into the buffers } begin change-limit +- 0; { this value will be used if the change file ends} ( Skip over comment lines in the change file; return if end of fde 76); ( Skip to the next nonblank line; return if end of file 77); (Move buffer and limit to change-bufler and change-limit 78 );
ezit: end;

76. While looking for a line that begins with Qx in the change file, we allow lines that begin with 9, as long as they don't begin with @y or Qz (which would probably indicate that the change file is fouled up).

( Skip over comment lines in the change file; return if end of file 76) E loop begin incr (line); if Gnput-ln (change-file) then return; if limit < 2 then goto continue; if bufler[O] # "@" then goto continue; if (bufer [l] 2 "X1') A (bufler [1] 5 "Z") then bufler [l] + bufer [l] + "z" - "Z"; if bufler [l] = "x" t h e n goto d o n e ; if (bufler [l]`= "y") V (buffer [I] = "z") then
begin lot + 2; err-print ( l !,WhereUisUtheUmatchingU@x?`); end;
continue : end;

{ lowercasify }

done:

This code is used in section 75.

77. Here we are looking at lines following the Qx.

( Skip to the next nonblank line; return if end of file 77) G repeat incr (line); if Tinput-ln (change.&) then begin err-print ('!,Change,fileuendeduafterU@x'); end;
until limit > 0;

This code is used in section 75.

.

return;

7 8 . (Move bufler and limit to change-bufler and change-limit 78) E begin change-limit t limit; for k t 0 to limit do change-btlfler [k] t buJer[k]; end
This code is used in sections 75 and 79.

40 LEXICAL SCANNING

WEA. VE

!m

79. The following procedure is used to see if the next change entry should go into effect; it is called only
when changing is false. The idea is to test whether or not the current contents of bufler matches the current
contents of change-bufer . If not, there's nothing more to do; but if so, a change is called for: All of the text down to the @y is supposed to match. An error message is issued if any discrepancy is found. Then the
procedure prepares to read the next line from change-file.

procedure check-change; { switches to change-file if the buffers match} label exit; var 72: integer; { the number of discrepancies found } k: 0 . . buf-site; { index into the buffers } begin if lines-dont-match then return; n + 0; loop begin change-changing; {now it's true }
incr (line); if Tinput-ln (change-file) then
begin err-print ( ' ! ,Jhangeuf ileuendedubef oreJOy `); changelimit t 0; change-changing; {false again}
return;
end;
(If the current line starts with Oy, report any discrepancies'and return 80); (Move bu,O'er and limit to change-bufler and change_Zimit 78); change-c hanging ; {now it's false }
incr (line); if Tinput-ln (web-fife) then
begin err-print ( * ! uWE&f ileUendedUduringUa,change `); input-has-ended t- true ; return;
end; if lines-dent-match then incr (n);
end; exit: end;

80. (zf the current line starts with Qy, report any discrepancies and return 80) s if limit > 1 then if bufler[O] = "@I' then begin if (buJer [l] 2 "X") A (bufier [l] 5 "Z") then bufler[l] t bufler [l] + "z" - "Z"; { lowercasify } if (buJer[l] = "x") V (bufier [l] = "z") then begin Zoc t 2; err-print ('!,WhereUisUtheUmatchingU9y?`); end else if bufler [l] = "y" then begin if n > 0 then begin lot t 2;
err-print( `!uHmm.. .U',n : 1, `uofutheuprecedingulines,failed,to,match'); end; return; end; . end
This code is used in section 79.

81 WEAVE

LEXI.CAL SCANNING 41

81. The reset-input procedure, which gets WEAVE ready to read the user's WEB input, is used at the beginning of phases one and two.
procedure reset-input; begin open-input; line t 0; other-line t 0;
changing +- true ; prime-the-change-bufler ; change-changing; limit t 0; lot t 1; bufier [0] t "U"; input-has-ended t false; end;

82. The get-line procedure is called when lot > limit; it puts the next line of merged input into the buffer and updates the other variables appropriately. A space is placed at the right end of the line.
procedure get-line ; { inputs the next line } label restart; begin restart: if changing then changed-moduZe[module-count] t true else (Read from web-file and maybe turn on chunging 83); if changing then begin (Read from change-file and maybe turn off changing 84); if lchanging then begin changed-module [module-count] t true; goto restart; end; end;
Zoc +-- 0; bufler [limit] t "U"; end;

83. (Read from web-file and maybe turn on changing 83) G begin incr (line);
. if Tinput-ln (web-file) then input-has-ended +- true else if limit = change-limit then if bllfler[O] = change-buJer[O] then if change-limit > 0 then check-change; end
This code is used in section 82.

84. (Read from change-file and maybo turn off changing 84) E begin incr (line ); if Tinput-ln (change-file) then begin err-print ('! ,-Changebf ile,ended,withouth@z `); bufler [0] + "@"; bufier [I] t "z"; limit t 2; end; if limit > 1 then { check if the change has ended } if bllll;:r[O] = I'@" then begin if (bzhfler [I] 2 "X1`) A (bufler [I] 5 "Z") then bufler [I] t bufler [l] + "z" - "Z"; { lowcrcasify } if (b2Lfler[l] = "x") V (bufler [I] = "y") then begin lot +- 2; err-print ('!UWhereLiskthe,matchingU@z?');
end else if bufler [l] = "z" then
begin prime-the-chunge-bufler; change-changing;
end; end;
end
This code is used in section 82.

42 LEXICAL SCANNING

WEAVE .

85

8 5 . At the end of the program, we will tell the user if the change file had a line that didn't match any `relevant line in web-file.

( Check that all changes have beeh read 85) 3 if change-limit # 0 then ( changing is false} begin for lot + 0 to change-limit do bufer [Zoc] + change-buflet [Zoc];
limit t change-limit; changing t true; line +- other-fine; lot t change-limit; err-print ( '! ,ChangeUf ileUentryUdid,not,match'); end

This code is used in section 261.

86. Control codes in WEB, which begin with `@`, are converted into a numeric code designed to simplify WEAVE's logic; for example, larger numbers are given to the control codes that denote more significant milestones, and the code of new-module should be the largest of all. Some of these numeric control codes
take the place of ASCII control codes that will not otherwise appear in the output of the scanning routines.
define ignore = 0 { control code of no interest to WEAVE} define verbatim = `2 { extended ASCII alpha will not appear } define force-line = `3 {extended ASCII beta will not appear} define begincomment = `12 { ASCII tab mark will not appear } define end-comment = `12 (ASCII line feed will not appear } define octal = `14 {ASCII form feed will not appear } define hex = `15 { ASCII carriage return will not appear} define double-dot = `40 { ASCII space will not appear except in strings} define no-underline = `175 { this code will be intercepted without confusion }
define underline = `176 { this code will be intercepted without confusion} define param = `177 { ASCII delete wilI not appear } define zref-roman = `203 { control code for `@-' } define zref-wildcard = `204 { control code for `9: ' } define zref-typewriter = `205 {control code for `Q. ' } define TeX-string = `206 { control code for `Qt' } define check-sum = `207 {control code for `@$`} define join = `210 { control code for `@&' }
define thin-space = `211 { control code for `0, ' } define math-break = `212 { control code for `Q I ' }
define line-break = `213 { control code for `@/'} define big-fine-break = `214 { control code for `@#'} define no-line-break = `215 { control code for `@+'} define pseudo-semi = `216 {control code for `0; `}
define format = `217 { control code for `Of'} define definition = `220 (control code for `Od' ) define begin-Pascal = `221 { control code for `Qp'} define module-name = `222 {control code for `@<`} define new-module = `223 {control code for `~3~' and `a*`}

87 WEAVE

LEXICAL SCANNING 43

87. Control codes are converted from ASCII to WEAVE's internal representation by the ( :ontroZ-code routine.

function control-code(c : ASCII-code): eight-bits; {convert c after 0) begin case c of
"@`I: control-code + "@"; { `quoted'at sign} " "I: control-code +- octal; {precedes octal constant }
"""": control-code +- hex; {precedes hexadecimal constant } I'$`,: control-code t check-sum; { prcccdes check sum constant }
`I "`I, tab-mark, "*": control-code +- new-module ; { beginning of a new module }

`I=": control-code t verbatim;

`I \ l, : control-code t force-line ;

"D ", "d": control-code t definition; { macro definition }

"F", "f ": control-code +- format; { format definition }

ll{ll: control-code + begin-comment ; { begin-comment delimiter }

")": control-code +- end-comment; { end-comment delimiter }

) p":nptc II control-code +-- begin-Pascal; { PASCAL text in unnamed module }

"&`I: control-code t join; { concatenate two tokens }

.`I < `I . control-code t module-name ; { beginning of a module name }

">": begin err-print ( ' ! ,,Extra,& `); control-code +- ignore;

end; { en d o fmodu e1 name should not be discovered in this way}

"T ,II II t": control-code +- TeX-string; { I'@ box within PASCAL}

" ! ": control-code t underline ; { set definition flag}

I'7 Il. .*

control-code

+-- no-underline ;

{ reset definition flag }

.I'- I'* control-code c xref-roman; { index entry to be typeset normally }

" : `I: control-code +- xrej-wildcard; {index entry to be in user format }

II II. ..

control-code

+-

xrej-typewriter

;

{ index entry to bc in typewriter type}

II `I. control-code +- thin-space ; { puts extra space in PASCAL format } `I ; "I control-code t math-break; { allows a break in a formula }

11 / 1' : control-code t line-break; { forces end-of-line in PASCAL format }

I, # I, : control-code t big-line-break; { forces end-of-line and some space besides }

"+": control-code t no-line-break; {cancels end-of-line down to single space}

" ; `I: control-code +-- pseudo-semi; { acts like a semicolon, but is invisible }

( Special control codes allowed only when debugging 88)

othercases begin err-print ('!JJnknown,control,code `); control-code t ignore;

end

endcases;

end;

8 8 . If WEAVE is compiled with debugging commands, one can write @2, Ql, and QO to turn tracing fully on, partly on, and off, respectively.

( Special control codes allowed only when debugging 88 ) -

debug

"2":`,()I, `I > I",

begin

tracing

t

c

-

"0";

control-code

t

ignore;

end;

gubed

This code is 11vcd in section 87.

44 LEXICAL SCANNING

WEAVE 589

89. The skip-limbo routine is used on the first pass to skip through portions of the input that are not in any modules, i.e., that precede the first module. After this procedure has been called, the value of input-has-ended will tell whether or not a new module has actmally been found.
procedure skip-limbo; {skip to next module} label ezit ; var c: ASCII-code; { character following Q } begin loop if lot > limit then begin get-fine; if input-has-ended then return; end else begin bufler[limit + I] +- "@I'; while bufler [lot] # "Q" do incr (lot); if Zoc < limit then begin lot t lot + 2; c t bufler(loc - l]; if (c = ItUt') V (c = tab-mark) V (c = "*`I) then return
end; end; exit: end;

90. The skip-TeX routine is used on the first pass to skip through the w code at the beginning of a module. It returns the next control code or ` 1' found in the input. A new--module is assumed to exist at the very end of the file.
function skip- TeX : eight-bit3 ; { skip past pure lm code } label done;
_ var c: eight-bits; { control code found } begin loop begin if lot > limit then begin get-line ; if input-hns_entled then begin c +- new-module; goto done; end; end; buflrr [limit + I] +- "C?"; repeat c + btlfles [lot]; incr (Zoc); if c = "I" then got0 done; until c = "C-I";
if lot 5 limit then begin c t control-code (bufler [lot]); incr (lot); goto (Lone; end;
end;
done : ,vkip-TeX +-- c ; end;

ii91 WEAVE

LEXICAL SCANNING 45

91. The skip-comment routine is used on the first pass to skip through l$jX code in PASCAL comments. The bul parameter tells how many left braces are assumed to have been scanned when this routine is called, and the procedure returns a corresponding value of bal at the point that scanning has stopped. Scanning stops either at a ` I ' that introduces PASCAL text, in which case the returned value is positive, or it stops at the end of the comment, in which case the returned value is zero. The scanning also stops in anomalous situations when the comment doesn't end or when it contains an illegal use of 9. One should call skip-comment(l) when beginning to scan a comment.
function skip-comment (bal : eight-bits): eight-bita; {skips T)jX code in comments} label done; var c: ASCII-code; { the current character ) begin loop begin if Zoc > limit then begin get-line ; if input-has-ended then begin bal +- 0; goto done; end; { an error message will occur in phase two } end;
c t bufet [Zoc]; incr (lot); if c = I' I II then goto done; (Do special things when c = "o", "\`I, "(`I, "3"; goto done at end 92); end;
done: skip-comment +- bal; end;

92. (Do special things when c =VI Q", "\I', "(", "3"; goto done at end 92) E if c = "@" then
begin c t bufiet [foe]; if (c # `tUtt) A (c # tab-mark) A (c # "*I') then incr (foe) else begin decr(foc); bal t 0; goto done;
end { an error message will occur in phase two } end
else if (c = I'\") A (bufieer [Zoc] # `w') then incr(loc) else if c = "{" then incr (bal) else if c = "3" then
begin deer (baf); if bal = 0 then goto done;

This code is used in section 91.

46 INPUTTING THE NEXT TOKEN

W E A V E $93

93. Inputting the next token. As stated above, WEAVE's most interesting lexical scanning routine is the get-next function that inputs the next token of PASCAL input. However, get-next is not especially complicated.
The result of get-next is either an ASCII code for some special character, or it is a special code representing a pair of characters (e.g., `:=' or `. .`), or it is the numeric value computed by the control-code procedure, or it is one of the following special codes:
ezponent: The `E' in a real constant.
identifier: In this case the global variables id-first and id-lot will have been set to the appropriate values needed by the id-lookup routine.
string: In this case the global variables id-first and id-Zoc will have been set to the beginning and endingplus-one locations in the buffer. The string ends with the first reappearance of its initial delimiter; thus, for example, `T h i s i s n "t a s i n g l e s t r i n g '
will be treated as two consecutive strings, the first being `This isn `.
Furthermore, some of the control codes cause get-next to take additional actions:
xref-roman , xref-wildcard, xref-typewriter , TeX-string: The values of id-first and id-lot will be set so that the string in question appears in bufier [id-first . . (id-lot - l)].
module-name: In this case the global variable cur-module will point to the byte-start entry for the module name that has just been scanned.
If get-next sees `@! ' or `@?`, it sets xref-switch to def&g or zero and goes on to the next token. A global variable called scanning-hex is set true during the time that the letters A through F should be
treated as if they were digits.
define exponent = `200 {E or e following a digit } define string = `201 {PASCAL string or WEB precomputed string ) define identifier = `202 {PASCAL identifier or reserved word} .
( Globals in the outer block 9) += cur-module : name-pointer ; {name of module just scanned } scanning-hex: boolean; { are we scannirig a hexadecimal constant? }

94. ( Set initial values 10) +3 scanning-hex t false;

95 WEAVE

INPUTTING THE NEXT TOKEN 47

95. As one might expect, get-nezt consists mostly of a big switch that branches to the various special cases that can arise.
define up~to(#)~#-24,#-23,#-22,#-21,#-20,#-19,#-18,#-17,#-16,#-15,#-14,#.-13, # - 12, # - 11, # - 10, # - 9, # - 8, # - 7, # - 6, # - 5, # - 4,# - 3,# - 2,# - l,#
function get-nezt : eight-bits ; {produces the next input token } label restart, none, found; var c: eight-bits; { the current character } d: eight-bits; { the next character } j, k: 0 , . longest-nakae; {indices into mod-text ) begin restart: if lot > limit then begin get-line ; if input-has-ended then begin c +- new-module; goto found; end; end;
c t bufer (Zoc]; incr (lot); if scanning-hez then ( Go to found if c is a hexadecimal digit, otherwise set scanning-hex t false 96); case c of "A", up-to ( "ZI'), "a", up-to ("z"): ( Get an identifier 98 ); , " "I, """": ( Get a string 99 ); "@": ( Get control code and possible module name 100); ( Compress two-symbol combinations like `: ='97 ) "U", tab-mark: goto restart ; {ignore spaces and tabs } othercases do-nothing endcases; found: debug if trouble-shooting then debug-help; gubed
get-next i- c; end;

9 6 . ( Go to found if c is a hexadecimal digit, otherwise set scanning-hex t false 96) E if ((c 2 tlOt') A (c 5 "9")) V ((c > "A") A (c < "F")) then goto found else scanning-hex +- false
This code is used in section 95.

48 INPUTTING THE NEXT TOKEN

WEAVE

97

97. Note that the following code substitutes @{ and Q) for the respective combinations ` (*' and `*I `. Explicit braces should be used for T&X comments in PASCAL text.
define compress (#) z if lot 5 limit then begin c t #; incr (lot); end
( Compress two-symbol combinations like ` : ='97 ) E ". ": if bufler [Zoc] = " . " then compress (double-dot )
else if bufler [Zoc] = "> " then compress ("I `I); " : ": if bufler [Zoc] = "=`I then compress (left-arrow); "=": if buJer [lot] = "=`I then compress (equivalence-sign); ">": if bufler [Zoc] = "=" then compress (greater-or-equal); "c": i f buJer[Zoc] = "=" then compress (less-or-equal)
else if bufler [lot] = ">" then compress(not-equal); " (I': if bufier [lot] = "*" then compress (begin-comment)
else if bufler [lot] = ". " then compress(" [`I); "*I': if ,bufler [lot] = "> " then compress( end-comment);
This code is used in section 95.

98. ( Get an identifier 98) begin if ((c = "E") V (c = "e")) A (lot > 1) then if (bufier [Zoc - 21 5 "9") A (bufer[loc - 2] > "0") then c + exponent; if c # exponent then begin decr(Zoc); id-first t lot; repeat incr (Zoc); d t bufler [foe]; until ((d < "0") V ((d > "9") A (d < "A")) V ((d > "Z") A (d < "a")) V (d > "z")) A (d # "-");
c t identifier; id-loc + lot; end; end
This code is used in section 95.

. 99. A string that starts and ends with single or double quote marks is scanned by the following piece of the program.

( Get a string 99) begin id-first t lot - 1; repeat d +- bufler [lot]; incr (lot); if lot > limit then begin err-print ( ' ! ,StringUconstantUdidn' end;
until tl = c;
id-lot +- lot; c +- string; end

`tUend'); lot t- limit; d t c;

Thiv code is used in section 95.

q100 WEAVE

INPUTTING THE'NEXT TOKEN 49

100. After an Q sign has been scanned, the next character tells us whether there is more work to do.
(Get control code and possible module name 100 ) E begin c + control-code (bufler [Zoc]); incr (Zoc); if c = underline then begin xref-switc h t def_fEag ; goto restart ; end else if c = no-underline then begin xref_switch t 0; got0 restart; end else if (c 5 TeX-string) A (c 2 xrcf_roman ) then ( Scan to the next O> 106 ) else if c = hex then scanning-hex t true else if c = module-name then ( Scan the module name and make cur-module point to it 101) else if c = verbatim then (Scan a verbatim string 107); end
This code is used in section 95.

101. ( Scan the module name and make cur-module point to it 101) G begin (Put module name into mod-text [l . . k] 103 ); if k > 3 then begin if (mod-text [k] = If. ") A (mod-text [k - I] = ". `I) A (mod-text [k - 21 = ". ") then
cur-module +- prefix-Zookup(k - 3) else cur-module + mod-lookup(k); end else cur-module + mod-lookup (Cc); end
This code is used in section 100.

102. Module names are placed into the mod-text array with consecutive spaces, tabs, and carriage-returns replaced by single spaces. There will be no spaces at the beginning or the end. (We set mod-text [0] t "U" to facilitate this, since the mod-lookup routine uses mod-text [I] as the first character of the name.)
( Set initial values 10) +mod-text [0] +- "L";

50 INPUTTING THE NEXT TOKEN

103. ( Put module name into mod-tezt [l . . k] 103 ) G
' kt0; loop begin if lot > limit then begin get-line; if input-has-ended then begin err-print ( '! ,,InputuendeduinusectionUname end;
end; d t bufler [Zoc]; ( If end of name, goto done 104 ); incr (foe); if k < longest-name - 1 then incr (k); if (d = `lblt) V (d = tab-mark) then
begin d t t'U't; if mod-ted (k - l] = `tutt then deer (k); end;
mod-ted [k] t d; end;
done : ( Check for overlong name 105 ); if (mod-tezt [k] - l'U" ) A (k > 0) then dect (k)
This code is used in section 101.

`); Zoc + 1; goto done;

104. ( If end of name, goto done 104) s if d = lt@lt then begin d t bufier[Zoc + l]; if d = ">" then begin lot +- lot + 2; goto done; end; if (d = `tU1t) V (d = tub-murk) V (d = "*`I) then begin err-print ( `!,SectionUnameUdidnO'ttiend'); goto d o n e ; end; incr (Cc); mod-tezt [k] t "@"; incr (Zoc); {now d = buffer [Zoc] again } end
This code is used in section 103.

105. ( Check for overlong name 105) zz if k > longest-name - 2 then begin print-n2 ( ' !,Secti~n,name,tooU1ong:U'); for j t 1 to 25 do print (zchr [mod-tezt [j]]);
print(`. . . `); mark-harmless; end
This code is used in section 103.

WEAVE $103

5106 WEAVE

INPUTTING THE NEXT TOKEN

106. ( Scan to the next 9> 100) f begin id-first t lot; bufler [limit + l] + "@"; while bufler [roe] # "@" do incr (Zoc);
id-lot t lot; if lot > limit then
begin err-print ( !l Jontrolutextudidn ' `t,,end `); lot t limit ; end else begin lot +- lot + 2; if bufier [Zoc - l] # ">" then err-print ('!,,Controlucodesuareuforbiddenuinucontrolutext'); end; end
This code is used in section 100.

51

107. A verbatim PASCAL string will be treated like ordinary strings, but with no surrounding delimiters. At the present point in the program we have bufler [lot - l] = verbatim; we must set id&rat to the beginning of the string itself, and id-lot to its ending-plus-one location in the buffer. We also set Zoc to the position just after the ending delimiter.
( Scan a verbatim string 107) G begin id-first +- Zoc; incr(Zoc); bufler[limit + l] t "@"; bujer[limit + 2] t II > 11 .9 while (huger [Zoc] # "@I") V (bufler [Zoc + l] # ">") do incr (Zoc); if Zoc 2 limit then err-print ( ' ! uVerbatimustringudidn ' `tuend'); '
id-loc t lot; lot t lot + 2 ; end
This code is used in section 100.

52 PHASE ONE PROCESSING

WEAVE $108

108. Phase one processing. We now have accumulated enough subroutines to make it possible to carry out WEAVE's first pass over the source file. If everything works right, both phase one and phase two of WEAVE will assign the same numbers to modules, and these numbers will agree with what TANGLE dots.
The global variable next-control often contains the most recent output of get-next; in interesting cases, this will be the control code that ended a module or part of a module.
( Globals in the outer block Q ) +r next-control: eight-bits ; { control code waiting to be acting upon }

109. The overall processing strategy in phase one has the following straightforward outline.
(Phase I: Read all the user's text and store the cross references 109) E phase-one t true; phase-three t false; reset-input; module-count e 0; skip-limbo; change-en&s t false ; while Tinput-has-ended do (Store cross reference data for the current module 110); changed-module [module-count ] t change-exists ; { the index changes if anything does } phase-one t false; { prepare for second phase } (Print error messages about unused or undefined module names 120);
This code is used in section 261.

110. ( Store cross reference data for the current module 110) begin incr (module-count ); if module-count = max-modules then overflow (`sectio~~~number'); changed-module [module-count ] t false ; { it will become true if any line changes } if bufier[loc - l] = `I*" then begin print ( `* `, module-count : 1); update-terminal; { print a progress report } end;
. ( Store cross references in the TJ$ part of a module 113 ); ( Store cross references in the definition part of a module 115); ( Store cross references in the PASCAL part of a module 117); if changed-module [module-count] then change-exists t true; end
This cn&= is used in section 109.

8111 WEAVE

PHASE ONE.PROCESSING 53

111. The PASCAL-xref subroutine stores references to identifiers in PASCAL text material beginning with ' the current value of nextcontrol and continuing until next-control is `('or ` I `, or until the next "milestone" is passed (i.e., next-control > foimat). If next-control 2 format when PASCAL-xref is called, nothing will happen; but if next-control = ** I I' upon entry, the procedure assumes that this is the ` I ' preceding PASCAL text that is to be processed.
The program uses the fact that our internal code numbers satisfy the relations xref-roman = identifier + roman and xref-wildcard = identifier + wildcard and xref-typewriter = identifier + typewriter and normal = 0. An implied `@! ' is inserted after function, procedure, program, and var.
p r o c e d u r e P A S C A L - x r e f ; { m a k es cross references for PASCAL identifiers } label exit; var p: name-pointer ; { a referenced name } begin while next-control < format do begin if (next-control 2 identifier) A ( next-control 5 xref-typewriter) then begin p e id-lookup (nezt-control - identifier); new-xref (p); if (ilk [p] = proc-like ) V (ilk [p] = vat-like) then xref-switch t def-ftag ; { implied `(Q! '} end;
next-control t get-next ; if (next-control = " I `I) V (next-control = "<I') then return; end; exit: end;

112. The outer-xref subroutine is like PASCAL-xref but it begins with next-control # " I " and ends with next-control > format. Thus, it handles PASCAL text with embedded comments.
procedure outer-xref ; {extension of PASCALxref } var bal: eight-bits ; { brace level in comment } begin while next-control < format do if next-control # "(" then PASCAL-xref else begin bal t skip-comment (1); next-control t- " I `I; while bal > 0 do
begin PASCAL-xref ; if next-control = " I " then bal +- skip-comment (bal) else baf t 0; {an error will be reported in phase two } end; end; end;

54 PHASE ONE PROCESSING

WEAVE $113

113. In the `I&X part of a module, cross rcfercnce entries <are made only for the identifiers in PASCAL texts ' enclosed in I . . . I, or for control texts enclosed in @^ . . . O> or (Q . . . .9> or Q : . . . O>.
( Store cross references in the TJ$C part of a module 113) 3 repeat 7zextcontrol t- skip-TeX; case next-control of
underline: xref-switch t def-flag; .
nou7hderline : xref-switch t 0;
I' I I': PASCA L-xref ; xref-reman, xref-wildcard, xref-typewriter , module-name : begin lot t lot - 2; next-control t get-next
{ scan to Q> } if next-control f module-name then new-xref (id-lookup (next-control - identifier )); end; othercases do-nothing endcases; until nextcontrol > format
This code is used in section 110.

114. During the definition and PASCAL part,3 of a module, cross references are made for all identifiers except rcscrved words; however, the identifiers in a format definition arc referenced even if they arc reserved. The TJ$ code in comments is, of course, ignored, except for PASCAL portions enclosed in I . . . I ; the text of a module name is skipped entirely, even if it contains I . . . I constructions.
The variables Zha and rha point to the respective identifiers involved in a format definition.
( Globals in the outer block 9) +E lha , rhs : name-pointer ; { indices into byte-start for format identifiers }

115. When we get to the following code we have next-control 2 format.
( Store cross references in the definition part of a module 115) G while next-control 5 definition do {format or definition } begin xref-switch +- def-flag ; { implied @! } if raext-control = definition then next-control t getnext else (Process a format definition IIS); outer-xref ; end
This code is used in section 110.

5116 WEAVE

PHASE ONE. PROCESSING 55

116. Error messages for improper format definitions will be issued in phase two. Our job in phase one is to define the ilk of a properly formatted identifier, and to fool the new-zref routine into thinking that the identifier on the right-hand side of the format definition is not a reserved word.
(Process a format definition 116) E begin next-control + getnezt; if next-control = identifier then begin Zhs +- id-lookup (normal); ilk [lhs] t normal ; new-xref (Zhs); next-control t get-next; if nextcontrol = equivalence-sign then begin next-control t get-next; if neztcontrol = identifier then begin rhs t idJookup(norma1); ilk [lhs] t ilk~[rhs]; iZk[rhs] t normal; new-xref (rhs);
ilk [ rhs] +- ilk [Zhs]; next-control 4- getnext ; end; end; end; end
This code is used in section 115.

117. Finally, when the TEX and definition parts have been treated, we have next-control 2 begin-puscal.

( Store cross references in the PASCAL part of a module 117) G if next-control _< module-name then { begin-Pascal or module-name } .
begin if next-control = begin-pascal then mod-xref-switch t 0
else mod-xref-switc h +- def-flag ; repent if next-control = module-name then new-mod-xref (cur-module);

next-control 4- get-next ; outer-xref ; until next-control > module-name ; end
This code is used iu section 110.

.

118. After phase one has looked at everything, WC want to check that each module name was both defined and used. The variable cur-xref will point to cross references for the current module name of interest.
( Globals in the outer block 9) +G cur-xref : xrefnumber ; { temporary cross reference pointer }

110. The following recursive procedure walks through the tree of module names and prints out anomalies.

procedure mod-check (p : name-pointer); begin if p > 0 then begin mod-chcck(llink[p]);

{ print anomalies in subtree p }

cur-xref r xref [p]; if num(cur..xref) < def-flag then
begin print-n1 ( ' ! ,-Never"def ined : ,,< `); print-id(p); print ( `> `); mark-harmless; end;
while num (cur-xref ) 2 def&g do cur-xref t slink (cur-xref ); if cur-xrcf = 0 then
begin print-n1 ( * !,Never,used: "< `); print-id(p); print ( `> `); mark-harmless;
end;

mod-check (rlink [p]); end;

end:

120. ( Print crrm messages about unused or undefined module names 120) E mod-check (root)
This code is used in scctinn 100.

56 LOW-LEVEL OUTPUT ROUTINES

WEAVE $121

121. Low-level output routines. The TI$C output is supposed to appear in lims at most line-length characters long, so we place it into an output buffer. During the output process, out-line will hold the current line number of the line about to be output.
( Globals in the outer block 9) +r out-buf : array [0 . . line-length] of ASCII-code ; { assembled characters } out-ptr: 0 . . line-length; {number of characters in out-buf } out-line : integer ; { coordinates of next line to be output }

122. The flush-bufler routine empties the buffer up to a given breakpoint, and moves any remaining characters to the beginning'of the next line. If the per-cent parameter is true, a "7," is appended to the line that is being output; in this case the breakpoint b should be strictly less than line-length. If the per-cent parameter is false, trailing blanks are suppressed. The characters emptied from the buffer form a new line of output.

procedure flush-bufler (b : eight-bits; per-cent : boolean); label done ; var j, k: 0 . . line-length; begin j t b;
if kper-cent then {remove trailing blanks } loop begin if j = 0 then goto done; if out-buf [j] # `lL" then goto done;

{outputs out-buf [l . . b],where b 2 out-ptr }

deer (j);
end; done: for k t 1 to j do write (tex-file, xchr [out-buf (ICI]);
if per-cent then write (tex-file , xchr ["X1']);

writf-ln (tex_file); incr (out-line); if b < out-ptr then
for k t b + 1 to out-ptr do out-buf (k - b] +- out-buf [k];

out-ptr +-- out&r - 6; end;

123. When we are copying `QX source material, we retain line breaks that occur in the input, except that an empty line is not output when the Tli$ source line wras noncmpty. For example, a line of the T&C file that contains only an index cross-reference entry will not be copied. The JGziuhJine routine is called just before get..line inputs a new line, and just after a line break token has been emitted during the output of translated PASCAL text.
procedure finish-line ; { do this at the end of a line } label exit; var k: 0 . . huf-size; { index into bufler } begin if out-ptr > 0 then flush-bufier (out-ptr, false) else begin for k + 0 to limit do if (bufler [k] # `lU I') A (btlger [k] # tab-rrmrk) then return;
jZuuh_buflcr (O,f&e); end; .exit : end;

124. In particular, the finish-line procedure is called near the very beginning of phase two. WC initialize the output v(ariables in a slightly tricky way so that the first line of the output file will be `\input webmac'.
( Set initial values 10 ) +r out -ptr t 1; out..line t 1; oukbuf [I] +- "cl'; write (tex-file, `\input,webma `);

$125 WEAVE

LOW-LEVEL OUTPUT ROUTINES 57

125. When we wish to append the character c to the output buffer, we write `out(c)`; this will cause the buffer to be emptied if it was already full. Simil=arly, `out!? appends a pair of characters. A line bre;tk will occur at a space or after a single-nonletter T# control sequence.
define oat(#) G if out-ptr = line-length then break-out;
incr (out-ptr ); out-buj [ outqtr ] + #; define oot1 (#) E oot (#) end
define oot& (#) G oot (#) ootl define oot3 (#) c oot (#) oot2 define oot4 (#) z oot (#) oot3 define oot5 (#) 3 oot (#) oota define out E begin ootl define out2 3 begin oot2
define out3 EE begin oot3 define out4 E begin oota define out5 E begin oot5

126. The break-out routine is called just before the output buffer is about to overflow. To make this routine a little faster, we initialize position 0 of the output buffer to `\`; this character isn't really output.
(Set initial values 10) +r outhf[0] + `I\`,;

127. A long line is broken at a blank space or just before a backslash that isn't preceded by another backslash. In the latter case: a "1" is output at the break.
procedure break-out ; { finds a way to break the output line} label exit; var k: 0 . . fine-length; {index into out-buf } c, d: ASCII-code ; { characters from the buffer } begin k t out-ptr; loop begin if k = 0 then (Print waking message, break the Line, return 128);
d t out-bu{ [k]; if (1 = `lU" then
begin jZush_buffer (k,/dse); return; end; if (u! = "\") A (out-bul[lc - l] # "\") then {in this case Ic > 1) begin flush-bufler (k - 1, true); return; end; deer (k);
end; exit: end:

128. WC get to this module only in unusual cases that the entire output line consists of a string of backslashes followed by a string of nonblank non-backslashes. In such casts it is almost always safe to break the line by putting a "1" just before the last character.
(Print wCarning message, break the line, return 128) E begin print-d ( ' ! bLineLhadUtoEbeLbroken, (outputUl . `, out-line : 1); print-ln ( `> : `); for k +- 1 to out-ptr - 1 do print (z&r [out-buf [ICI]); 7kr:wJine; mark-hnrnrlesu; jlush-blhflcr (out-ptr - 1, true); return; end
This code is used in section 127.

58 LOW-LEVEL OUTPUT ROIJTINES
129. Here is a procedure that outputs A module number in decimal notation. ( Glob& in the outer block s ) +S clip: array [0 . . 41 of 0 . . 9; { digits to output }

WEAVE $129

130. The number to be converted by out-mod is known to be less than def_flag, so it cannot have more than five decimal digits. If the module is changed, we output `\*'just after the number.
procedure out-mod(m : integer); {output a module number } var k: 0 . . 5; {index into dig } a: integer ; { acc&ulator } begin k + 0 ; a t m ; repeat dig [k] +-- a mod 10; a +- a div 10; incr (k); until Q = 0; repeat deer (k); out (dig [k] + "0"); until k = 0; if changed-module [m] then out2 ("\")("*"); end;

131. The out-nume subroutine is used to output an identifier or index entry, enclosing it in braces.
procedure out-nume (p : name-pointer); { outputs a name } var I?: 0 . . max.-bytes; {index into Gyte-mem } 20: 0 . . ww - 1: {row of byte-mem } begin out ("C"); w t p mod ww; for k +- byte-start [p] to byte-start [p + ww] - 1 do begin if byte-mem[w, k] = "-" then out (I'\");
out (byte-mem [w, k]); _ end;
out ("p); end;

$132 WEAVE

ROUTINES THAT COPY Q?C MATERIAL

59

132. Routines that copy T&X material. During phase two, we use the subroutines copy-limbo,
copy-TeX, and copy-comment in place of the analogous skip-limbo, akip_TeX, and skip-comment that were used in phase one.
The copy-limbo routine, for example, takes `lj$ material that is not part of any module and transcribes it almost verbatim to the output file. No `@' signs should occur in such material except in `W pairs; such pairs are replaced by singletons.
procedure copy-limbo; { copy T~~JX code until the next module begins } label ezit ; var c: ASCII-code; { character following Q sign } begin loop if lot > limit then begin finish-line; get-line; if input-has-ended then return; end else begin bufer [limit + l] t cc@a; ( Copy up to control code, return if finished 133); end;
ezit: end;

133. ( copy up to control code, return if finished 133) 4 while bufer [Zoc] # "@" do begin out (bufler [Zoc]); incr (lot); end; if Zoc 5 limit Ahen begin Zoc t Zoc + 2; c t bufler [Zoc - 11; if (c = f'U1l) V (c = tab-mark) V (c = "*") then return; if (c # "z") A (c # "Z") then begin out ("Q"); if c # "@" then err-print ( `!,DoubleUQ,required,outsideUof,sections'); end; end
This code is used in section 132.

134. The copy_TeX routine processes the T@ code at the beginning of a module; for example, the words you are now reading were copied in this way. It returns the next control code or ` I ' found in the input.
function copy-TeX: eight-bits; {copy pure 7&X material} label done; var c: eight-bits; { control.code found } begin loop begin if lot > limit then begin finish-line ; get-line; if input-has-ended then begin c +- new-module; goto done; end; end; bufler [limit + l] t "42"; ( Copy up to ` I ' or control code, goto done if finished 135); end;
done: copy_TeX t c; end;

60 ROUTINES THAT COPY QX MATERIAL

WEAVE $135

135. We don't copy spaces or tab marks into the beginning of a line. This makes the test for empty lines in finish-line work.
( Copy up to ` I ' or control code, goto done if finished 135 ) G repeat c t Zwfler [lot]; incr (Zoc); if c = I1 I `I then goto done; if c # "~3" then begin out (c); if (oui!$r = 1) A ((c = ttU't) V (c = tabxmrk)) then decr(out-ptr); end; until c = lt@t'; if lot 5 limit then begin c t control-code (bufer [Zoc]); incr (Zoc); goto done; end
This code is used in section 134.

136. The copy-comment uses and returns a brace-balance value, following the conventions of skip-comment
above. Instead of copying the T@ material into the output buffer, this procedure copies it into the token memory. The abbreviation app-tok (t) is used to append token t. to the current token list, and it also makes
sure that it is possible to append at least one further token without overflow.

define app-tok (#) E begin if tok-ptr + 2 > maz-toks then overflow
tok-mem [ tok-ptr] +- #; incr (tok-ptr);
end

(`token');

'

function copy-comment (bal : eight-bits): eight-bits; { copies TJ$ code in comments } label done;
var c: ASCII-code; { current character being copied} begin loop
begin if Zoc > limit then
begin get-line ; if input-has-ended then
begin err-print ( '!,Input,endedUinUmid-comment `); Zoc + 1; ( Clear bal and goto done 138) end;
end;

c + bufler[Zoc]; incr (Zoc);
if c = " I " then goto done; app-tok(c); ( Copy special things when c = "@", "\", "(", "1"; goto done at end 137); end;

done: copy-comment e bul; end;

$137 WEAVE

ROUTINES THAT COPY l&X MATERIAL

137. (Copy special things when c = "O", "\", "(", ")"; goto done at end 137) 3 if c = "6" then begin incr (Zoc); if bufler [Zoc - l] # W' then begin err-print ( ' ! ,IllegalUuse,of ,Q,inucomment `); Zoc + Zoc - 2; deer (tok-ptr ); ( Clear bul and goto done 138); end;
end else if (c = "\I~) A (bufer [Zoc] # "Q") then
begin upp-tok (bufler [Zoc]); incr (Zoc); end else if c = "(" then incr (bul) else if c = "}" then
begin deer (bul); if bul = 0 then goto done; end
This code is used in section 136.

61

138. When the comment has terminated abruptly due to an e&or, we output enough right braces to keep
W bw
( Clear 6uZ and goto done 138) G u p p - t o k ("& { this is done in case the previous character was `\'} repeat upp-tok (")"); deer (bul); until bul = 0; goto done;
This code is used in sections 136 and 137.

62 PARSING

WEAVE $139

1 3 9 . P a r s i n g . The most intricate part of WEAVE is its mechanism for converting PASCAL-like'code into
' I&X code, and we might as well plunge into this aspect of the program now. A "bottom up" approach is used to parse the PASCAL-like material, since WEAVE must deal with fragmentary constructions whose overall
"part of speech" is not known. At the lowest level, the input is represented as a sequence of entities that we shall call acrup.v, where each
scrap of information consists of two parts, its category and its translation. The category is essentially a syntactic class, and the translation is a token list that represents T@ code. Rules of syntax and semantics
tell us how to combine adjacent scraps into larger ones, and if we are lucky an entire PASCAL text that starts out as hundreds of small scraps will join together into one gigantic scrap whose translation is the desired T@ code. If we are unlucky, we will be left with several scraps that don't combine; their translations will simply be output, one by one.
The combination rules are given as context-sensitive productions that are applied from left to right. Suppose that we are currently working on the sequence of scraps a1 92 . . . s,. We try first to find the longest
production that applies to an initial substring a1 52 . . . ; but if no such productions exist, we find to find the longest production applicable to the next substring s2 a3 . . . ; and if that fails, we try to match 33 34 . . . , etc.
A production applies if the category codes have a given pattern. For example, one of the productions is

open math semi -+ open math

and it means that three consecutive scraps whose respective categories are open, muth, and semi a.re converted to two scraps whose categories are open and math. This production <also has an associated rule that tells how to combine the translation parts:
=02 01
M2 = MIS\, opt 6
This means that the open scrap has not changed, while the new math scrap has a translation M2 composed of the translation Al, of the original math scrap followed by the translation S of the semi scrap followed by `\ , ' followed by `opt'followed by `5'. (In the TJ$ file? this will specify an additional thin space after the semicolon, followed by an optional line break with penalty 50.) Translation rules use subscripts to distinguish between translations of scraps whose categories have the same initial letter; these subscripts arc assigned from left to right.
WEAVE also has the production rule semi -+ t e r m i n a t o r
(meaning that a semicolon can terminate a PASCAL statement). Since productions arc applied from left to right, this rule will be activated only if the semi is not preceded by scraps that match other productions; in particular, a semi that is preceded by `open math'will have disappeared because of the production above, and such semicolons do not act as statement terminators. This incidentally is how WEAVE is able to treat semicolons in two distinctly different ways, the first of which is intended for semicolons in the parameter list of a proccdurc declaration.
The translation rule corresponding to semi + terminator is

T=S

but we shall not mention translation rules in the common case that the translation of the new scrap on t h e right-hand side is simply the concatenation of the disappearing scraps on the left-hand side.

5140 WEAVE

. PARSING 63

140. Here is a list of the category codes that scraps can have.

define simp = 1 { the translation can be used both in horizontal mode and in math mode of QjX } define math = 2 { the translation should be used only in T&X math mode}
define intro = 3 {a statement is expected to follow this, after a space and an optional break } define open = 4 { denotes an incomplete parenthesized quantity to be used in math mode}
define beginning = 5 {denotes an incomplete compound statement to be used in horizontal mode} define close = 6 { ends a parenthesis or compound statement }
define alpha = 7 { denotes the beginning of a clause} define omega = 8 { denotes the ending of a clause and possible comment following}
define semi = 9 { denotes a semicolon and possible comment following it } define terminator = 10 { something that ends a statement or declaration } define stmt = 11 {denotes a statement or declaration including its terminator } define cond = 12 {precedes an if clause that might have a matching else } define clause = 13 {precedes a statement after which indentation ends } define colon = 14 { denotes a colon } define ezp = 15 { stands for the E in a floating point constant } define proc = 16 { denotes a procedure or program or function heading } define case-head = 17 { denotes a case statement or record, heading }
define record-head = 18 { denotes a record heading without indentation } define vat-head = 19 { denotes a variable declaration heading } define eke = 20 { else}
define Casey = 21 {case }
define mod-scrap = 22 { denotes a module name}

debug procedure print-cut (c : eight-bits); begin case c of simp : print ( 'simp `); math: print ( `math `); intro : print ( ' intro `); open: print (`open');
beginning : print ( `beginning');
close : print ( `close `); alpha : print ( `alpha `); omega : print ( * omega `); semi : print ( `semi `); terminator: print ( `terminator `); stmt : print ( `stmt `);
cond: print ( 'cond'); clnuae : print ( `clause `);
colon : print ( 'colon'); ezp : print ( "exp `);
proc : print ( `proc `);
cut!-head: print ( `casehead `); record-head: print ( `recordhead `);
vnr-head: print ( `varhead');
elaie: print (`elsie'); casey: print (`Casey');
mod-scrap : print ( `module `); othercases print ( 'UNKNOWN ') endcases; end; gubed

{ symbolic printout of a category }

64 PARSING

WEAVE $141

141. The token lists for translated `l&X output contain some special control symbols as well as ordinary characters. These control symbols are interpreted by WEAVE before they are written to the output file.
break-apace denotes an optional line break or an en space;
force denotes a line break;
big-force denotes a line break with additional vertical space;
opt denotes an optional line break (with the continuation line indented two ems with respect to the normal starting position)-this code is followed by an integer n, and the break will occur with penalty 1On;
backup denotes a backspace of one em;
cancel obliterates any break-space or force or big-force tokens that immediately precede or follow it and also cancels any backup tokens that follow it;
indent causes future lines to be indented one more em;
outdent causes future lines to be indented one less em.
All of these tokens are removed from the T&X output that comes from PASCAL text between I . . . I signs; break-space and force and big-force become single spaces in this mode. The translation of other PASCAL texts results in TJ$ control sequences \l, \2, \3, \4, \5, \6, \7 corresponding respectively to indent, outdent, opt, backup, break-apace, force, and big-force. However, a sequence of consecutive `U', break-space, force, and/or big-force tokens is first replaced by a single token (the maximum of the given ones).
The tokens math-rel, math-bin, math-op will be translated into \mathrel(, \mathbin(, and \mathop(, respectively. Other control sequences in the TJ$ output will be `\\( . . .I'surrounding identifiers, `\a(. . . )' surrounding reserved words, `\ . (: . . . )' surrounding strings, `\C( . . .I force'surrounding comments, and `\Xn: . . . \X' surrounding module names, where n is the module number.
define math-bin = `203 define math-rel = `204 . define math-op = `205 define big-cancel = `206 { lik e cancel, also overrides spaces } define cancel = `207 { overrides backup, break-space, force, big-force define indent = cancel + 1 {one more tab (\I) } define outdent = cancel + 2 { one less tab (\2) } define opt = cancel + 3 { optional break in mid-statement (\3) } define backup = cancel + 4 {stick out one unit to the left (\4) } define break-space = cancel + 5 { optional break between statements (\5) } define force = cancel + 6 { farced break between stat,ements (\6) } define big-force = cancel + 7 { farced break with additional space (\7) } define end-translation = big-force + 1 {special sentinel token at end of list }

!j142 WEAVE

PARSING 65

142. The raw input is converted into scraps according to the following table, which gives category codes ' followed by the translations. Sometimes a single item of input produces more than one scrap. (The symbol
`**'stands for `\&(identifier)`, i.e., the identifier itself treated as a reserved word. ln a few cases the category is given as `comment `; this is not an actual category code, it means that the translation will be treated as a
comment, as explained below.)

0 <= >= := ==
(* *I (. .I " string It 'string ' O= string O>
:
ia
. .. . .. ,
identifier E in constant, digit d other character c and array begin case const div do downto else end file for function got0 if in

math: \I math: \L

m a t h : \C math; \K

math: \S math: \B

math: \T

open: [

close: 1
simp : \ . (I'modified string "1
simp : \ . -C\ ' modified string \ `1 simp : \=( modified string )

math: \#

m a t h : \$

m a t h : \,

math: \%

m a t h : \^

open: (

close: )

open: [

close: 1

math: \ast

math: , opt 9
math: \to simp: .

colon: : semi: ;

simp : \\( identifier 1 e x p : \E<

simp: d

math: c

math: \W

alpha: **

beginning: force ** cancel

intro :

case y :

alpha: force **

intro: force backup **

math: math-bin ** 3 omega: **

math: math-rel ** 3

terminator:

elsie: force backup **

terminator:

close: force **

alpha: **

alpha: force **

proc: force backup ** cancel

intro: indent \"

intro: **

cond:

alpha: force **

math: \in

66 PARSING

WEAVE 142

label

intro: force backup **

mod math: math-bin ** 3

nil simp: **

not math: \R

of omega: **

or math: \V

packed

i&to: **

procedure

proc : force backup ** cancel

intro: indent \U

program

proc: force backup ** cancel

intro: indent \U

record

record-head: **

intro :

repeat

beginning: force indent ** cancel

intro:

set alpha: **

then

omega: **

to math: math-rel ** )

type until

intro: force backup **

terminator:

close: force backup **

clause:

var

var-head: force backup ** cancel

intro:

while

alpha: force **

with

alpha: force **

xclause

alpha: force \-

omega: **

Q ' const

simp : \O{const)

@" const

simp: \H{const)

9$ s i m p : \) O\ simp: \J

Q, math: \,

Qt stuff Q>

simp :\hbox( stuff)

Q< module @>

mod-scrap: \Xn : module \X

@#I comment: big-force

@/ comment: force

@I simp : opt 0

Q+ comment: big-cancel \U big-cancel

9; semi: @& math: \J

Q< math: \B

91 math: \T

When a string is output, certain characters are preceded by `\' signs so that they will print properly. A comment in the input will be combined with the preceding omega or semi scrap, or with the following
terminator scrap, if possible; otherwise it will be inserted <as a separate terminator scrap. An additional
"comment" is cffcctivcly appended at the end of the PASCAL text, just before translation begins; this consists
of a cnncel token in the cnsc of PASCAL text in 1 . . . I, otherwise it consists of a force token. From this table it is evident that WEAVE will parse a lot of non-PASCAL programs. For example, the
rcscrvcd words `for' and `array'are treated in [an identical way by WEAVE from a syntactic standpoint, and
semantically they are equivalent except that a forced line 1ne`a.k occurs just boforc `for'; PASCAL programmers may well be surprised at this similarity. T1lc idea is to keep WEAVE's rules as simple as possible, consistent
with doing a reasonable job on syntactically correct PASCAL programs. The production rules below have been formulated in the same spirit of "almost anything goes."

5143 WEAVE

PARSING 67

143. Here is a table of all the productions. The reader can best get a feel for how they work by trying them out by hand on small examples; no amount of explanation willb e as effective as watching the rules in action. Parsing can also be watched by debugging with `02'.

Production categories [translations]

Remarks

1 alpha math colon +, alpha math
2 alpha math omega -+ clause [C = A, $ M $ U indent O]l
3 alpha omega + clause [C = Auindent 01
4 alpha simp + alpha math 5 beginning close (terminator or stmt) -+ stmt
6' beginning stmt + beginning I[& = I31 break-apace S]
7 case-head Casey clause + case-head [Cd = Cl outdent Cz C,]
8 case-head close terminator + stmt [S = Cl cancel outdent Cz 2'1
9 case-head atmt -+ case-head [C, = Cl force S]
10 Casey clause + case-head 11 clause stmt + stmt [Sg = C brea k-sp ace Sl cancel outdent force]
12 cond clause stmt elsie + clause [C, = Cl C's break-space S EU cancel1 IS cond clause atmt -+ stmt
[Sz = Cl Cz break-space S1 cancel outdent force]
14 elsie + intro
15 exp math simp + math I[Mz = EMI S >I
16 exp aimp + math [M = E S 3) 17 intro stmt + stmt [S, = IU opt 7 cancel Sly 18 math close + stmt close [S = $ M $1 19 math colon - intro [I = force backup $ M $ C]
20 math math -+ math
21 math aimp -+ math

e.g., case u : boolean of e.g., while CC > 0 do e.g., file of convert to math mode compound statement ends compound statement grows variant records end of case statement case statement grows beginning of cast statement end of controlled statement complete conditional
incomplete conditional unmatched else signed exponent unsigned exponent labeled statement, etc. end of field list compound label simple concatenation simple concatenation

22 math stmt ---f atmt [Sr = $ M $ indent b reak-space S1 cancel outdent force1
23 math terminator -+ atmt I[S = $ M $7'1 24 mod-scrap (terminator or semi) -+ stmt [S = M T force] 2,5 mod-scrap + simp
26 open case-head close + math [M = 0 $ cancel Cl cancel outdent $ C,]
27 open close + math [M = 0 \ , C] 28 open math case-hear1 close --+ math
[Mz = 0 Ml $ cancel Cl cancel outdent $ C2]1 29 open math close + math 30 open math colon + open math
31 open math proc intro -+ open math [Mz = MI math-op cancel P >]
32 open math semi + open math [Mz = Ml S \ , opt 51) 35 open math var-head intro -+ open math [Mz = Ml math-o?) cancel V 31
34 open proc intro --+ open math [M = math-op cancel P 1)
9.5 open simp + open math
36 open atmt close --t math [M = 0 $ cancel S cancel $ Cj 37 open var-head intro -+ open math [M = math-op cancel V >I
$8 yroc beginning close terminator -+ strnt [S = P cancel outdent I3 C I']
39 proc stmt + proc [I'2 = F'l break-space Sl 40 record-head intro Casey -+ Casey [Cz = R I,, cancel Cl1
41 record..head --+ case-head UC = indent R cancel]
42 semi + terminator
43 nimp close --+ stmt close 44 wirnp colon -+ intro [II = force backup S C] 45 aimp math -+ rnath

macro or type definition statement involving math module like a.statemcnt module unlike a statement case in field list empty set [J
case in field list parcnthcsizcd group colon in pnrent,lieses procedure in parentheses semicolon in parentheses var in parentheses procedure in parentheses convert to math mode field list var in parcnthcscs end of procedure dcclarntion procetlurc declaration grows record case . . . other record struct#urcs semicolon aft,er statement cd of field list simple label simple coricatc~nation

68 PARSING

WEAVE $143

4 6 simp mod-scrap --) mod-scrap

47 simp simp -+ simp

48 simp terminator -+ stmt

*

49 stmt stmt -+ stmt [Ss = S1 break-space Sz]

50 terminator + stmt

51 var-head beginning -+ stmt beginning.

52 var-head math colon -+ var-head intro [I = $ M $ Cl

53 var-head simp colon + var-head intro

54 var-head stmt -+ var-head I[Vz = VI break-space S]

in emergencies * simple concatenation simple statement
adjacent statements empty statement end of variable declarations variable declaration variable declaration variable declarations grow

Translations are not specified here when they are simple concatenations of the scraps that change. For example, the full translation of `open math colon + open math' is 02 = 01, M2 = MIC.

9144 WEAVE

IMPLEMENTING THE PRODUCTIONS

69

144. Implementing the productions. When PASCAL text is to be processed with the grammar above, we put its initial scraps 31.. . s, into two arrays cat [ 1 . . n] and trans [ 1 . . n]. The value of cat [k] is simply a category code from the list above; the value of trans [ICI is a text pointer, i.e., an index into tok-start. Our production rules have the nice property that the right-hand side is never longer than the left-hand side. Therefore it is convenient to use sequential allocation for the current sequence of scraps. Five pointers are used to manage the parsing:
pp (the parsing pointer) is such that we are trying to match the category codes cat [pp] cat [pp + l] . . . to the left-hand sides of productions.
scrap-base, lo-ptr , hi-ptr , and scrap-ptr are such that the current sequence of scraps appears in positions scrap-base through lo-ptr and hi-ptr through scrap-ptr, inclusive, in the cat and trans arrays. Scraps located between scrap-base and lo-ptr have been examined, while those in positions >_ hi-ptr have not yet been looked at by the parsing process.
Initially scrap-ptr is set to the position of the final scrap to be parsed, and it doesn't change its value. The parsing process makes sure that lo-ptr 2 pp + 3, since productions have as many as four terms, by moving scraps from hi-ptr to lo-ptr. If there are fewer than pp + 3 scraps left, the positions up to pp + 3 are filled with blanks that will not match in any productions. Parsing stops when pp = lo-ptr + 1 and hi-ptr = scrap-ptr + 1.
( Globals in the outer block 9) +E cat: array [0 . . max-scraps] of eight-bits ; {category codes of scraps } trans : array [0 . . mar-scraps] of text-pointer; { translation texts of scraps} p p : 0 . . max-scraps ; { current position for reducing productions } scrap-base: 0 . . maz-scraps; { beginning of the current scrap sequence } scrap-ptr : 0 . . max-scraps; { ending of the current scrap sequence } lo-ptr : 0 . . max-scraps; { last scrap that has been examined } hi-ptr : 0 . . max-scraps ; { first scrap that has not been examined}
stat max-scr-ptr: 0 . . max-scraps; {largest value assumed by scrap-ptr } tats

145. ( Set initial values 10) +Z scrap-base t 1; scrap-ptr t 0; stat max-scr-ptr t 0; tats

70 IMPLEMENTING THE PRODUCTIONS

WEAVE

146. Token lists in tok-mem are composed of the following kinds of items for T@ output. *
l ASCII codes and special codes like force and math-rel represent themselves; ' l id-flag + p represents \\(idcntifier p); l res-flag + p represents \&(identifier p); l mod-flag + p represents module name p; l tok-flag + p represents token list number p; l inner-tok-flag + p represents token list, number p, to be translated without line-break controls.
define id-flag = 10240 { signifies an identifier } define res-flag = id-flag + id-flag { signifies a reserved word } define mod-flag = res-flag + id-flag { signifies a module name} define tok-flag G mod-flag + id&g { signifies a token list, } define inner-tok-flag G tok-flag + id-flag { signifies a token list in ` I . . . I ' }
define Zbrace G xchr [lf{N'] { th is avoids possible PASCAL compiler confusion } define rbrace G xchr ["3"] { b ecause these braces might occur within comments}
debug procedure print-text (p : text-pointer); {prints a token list } var j: 0 . . max-toks; {index into tok-mem }
r: 0 . . id-flag - 1; {remainder of token after the flag has been stripped off } begin if p 2 text-ptr then print ( `BAD `) else for j +- tok-start [p] to tok-start [p + l] - 1 do
begin r +- tok-mem[j] mod id-flag; case tok-mem [j] div id&g of 1: begin print ( `\\ ' , Zbrace); print-id(r); print (rbrace);
e n d ; { id-flag } 2: begin print ( `\&z', Zbrace); print-id(r); print (rbrace);
end; { res-flag } 3: begin print ( `< `); print-id(r); print ( `> `);
end; { mod-flag }
4 : print(`[[`,r : 1, `I] `); { tok-flag } 5 : print(`I [[`,r: 1, `]I I `); { inner-tok-flag } othercases (Print token r in symbolic form 147) endcases; end; end; gubed

$146

$147 WEAVE
147. ( Print token r in symbolic form 147 ) E ' case r of
math-bin: print (`\mathbin', Ibrace); math-rel: print ( `\mathrel *, Zbrace); math-op : print ( `\mathop *, lbrace); big-cancel: print ( ' [ccancell `); cancel: print ( l [cancel] `); indent: print (' [indent] `); outdent: print ( '[outdent] `); backup : print ( l [backup) `); opt: print ( l [opt] `); break-space : print ( '[break] `); force : print ( ' [f orcel `); big-force : print ( ' [f f orcel `); end-translation : print ( '[quit I `); othercases print (xchr [r]) endcases
This code is used in section 146.

IMPLEMENTING THE PRODUCTIONS

71

72 IMPLEMENTING THE PRODUCTIONS

WEAVE $148

148. The production rules listed above are embedded directly into the WEAVE program, since'it is easier
to do this than to write an interpretive system that would handle production systems in general. Several macros are defined here so that the program for each production is fairly short.
All of our productions conform to the general notion that some CG consecutive scraps starting at some position j are to be replaced by a single scrap of some category c whose translations is composed from the
translations of the disappearing scraps. After this production has been applied, the production pointer pp should change by an amount d. Such a production can be represented by the quadruple (j, k, c, d). For example, the production `simp math --+ math' would be represented by `(pp, 2, math, -1)`; in this case the pointer pp should decrease by 1 after the production has been applied, because some productions with math in their second positions might now match, but no productions have math in the third or fourth position of their left-hand sides. Note that the value of d is determined by the whole collection of productions, not by an
individual one. Consider the further example `var-head math colon + var-head intro', which is represented by `( pp + 1,2, intro, +I)`; the $1 here is deduced by looking at the grammar and seeing that no matches could possibly occur at positions 5 pp after this production has been applied. The determination of d has been done by hand in each case, based on the full set of productions but not on the grammar of PASCAL or on the rules for constructing the initial scraps.
We also attach a serial number of each production, so that additional information is available when
debugging. For example, the program below contains the statement `reduce (pp + 1,2, intro, +1)(52)' when it implements the production just mentioned.
Before calling reduce, the program should have appended the tokens of the new translation to the tok-mem array. We commonly want to append copies of several existing translations, and macros are defined to simplify these common cases. For example, app2 (pp) will append the translations of two consecutive scraps, trans [pp] and trans [pp + 11, to the current token list. If the entire new translation is formed in this way, we write `squash (j, k, c, d) ' instead of `reduce(j, k,c, d)`. For example, `squash(pp, 2, math, -1)'is an abbreviation for `app2 (pp); reduce (pp, 2, math, -1)`.
The code below is an exact translation of the production rules into PASCAL, using such macros, and the reader should have no difficulty understanding the format by comparing the code with the symbolic productions as they were listed earlier.
Caution: The macros app , appl , app2, and app3 are sequences of statements that are not enclosed with begin and end, because such delimiters would make the PASCAL program much longer. This means that it is necessary to write begin and end e&licitly when such a macro is used as a single statement. Several mysterious bugs in the original programming of WEAVE were caused by a failure to remember this fact. Next time the aut,hor will know better.
define production (#) G
debug prod (#) gubed; goto found define reduce (#) 3 red (#); production
define productionend (#) G debug prod (#)
gubed; got0 [ountl; end define squash (#) =
begin sq (#); production-end define app (#) E tok-mem [tok-ptr] +- #; incr (tok-ptr)
{ this is like apptok, but it doesn't test for overflow }
define nppl (#) E tok-mcm [tok-ptr] t tok-/Zag + trans [#]; incr (tok-ptr) define app2 (#) E appf (#I); appl (# + 1) define q~p? (#) E app2 (#); appl (# + 2)

$149 WEAVE

IMPLEMENTING THE PRODUCTIONS

73

149. Let us consider the big case statement for productions now, before looking at its context. We want to design the program so that this case statement works, so WC might as well not keep ourselves in suspense about exactly what code needs to be provided with a proper environment.
The code here is more complicated than it need be, since some popular PASCAL compilers are unable to deal with procedures that contain a lot of program text. The translate procedure, which incorporates the case statement here, would become too long for those compilers if WC did not do something to split the cases into parts. Therefore a separate procedure called five-cases has been introduced. This auxiliary procedure contains approximately half of the program text that translate would otherwise have had. There's also a procedure called ulpha-cases, which turned out to be necessary because the best two-way split wasn't good enough. The procedure could be split further in an analogous manner, but the present scheme works on all compilers known to the author.
(Match a production at pp, or increase pp if there is no match 149) z if cat[pp] 5 alpha then if cat[pp] < alpha then five-cases else alpha-cases else begin case cat[pp] of case-head: ( Cases for case-head 153); caaey : ( Cases for Casey 154); clause: ( Cases for clause 155 ); cond: ( Cases for cond 156); elaie: ( Cases for elaie 157); ezp: ( Cases for ezp 158 ); mod-scrap: ( Cases for mod-scrap 161); proc: ( Cases for proc 164); record-head: ( Cases for record-head 165 ); semi: ( Cases for semi 166); stmt: ( Cases for stmi! 168); terminator: ( Cases for terminator 169); uar-head: ( Cases for war-head 170); othercases do-nothing endcases;
incr (pp); { if no match was found, WC move to the right } found: end
Thiv code is used in section 175.

74 IMPLEMENTING THE PRODUCTIONS
150. Here are the procedures that need to be present for the reason just explained.
' (Declaration of subprocedures for translate 150) 3 procedure five-cases ; { handles almost half of the syntax} label found; begin case cat [pp] of beginning : ( Cases for beginning 152 );. intro: ( Cases for intro 159); math: (Cases for math ISO); open: ( Cases for open 162 ); simp: ( Cases for simp 167 ); othercases do-nothing endcases; incr ( p p ) ; {if no match was found, we move to the right } found: end;
procedure alpha-cases; label found; begin ( Cases for alpha 151); incr (pp); { if no match was found, we move to the right }
found: end;
This code is used in section 179.

WEAVE $150

151. Now comes the code that tries to match each production that starts with a particular type of scrap. Whenever a match is discovered, the squash or reduce macro will cause the appropriate action to be performed, followed by goto found.
( Cases for alpha 151) z if cut [pp + l] = moth then begin if cat[pp + 21 = coIon then squash(pp + 1,2, math,O)(l) else if cut [pp + 21 = omega then begin nppl(pp); upp(","); api("$"); appl(pp + 1); app("$"); app("u"); app(indent); UPPI (PP + 2); reduce(pp,3, clause, -2)(2); end; end else if cut [pp + l] = omega then begin appl (pp); app(","); app(indent); nppl (pp + 1); reduce(pp,2,clause,-2)(3); end else if cat [pp + l] = simp then squaah(pp + l,l, math, O)(4)
This code is used in section 150.

152. ( Cases for begiPzning 152) E if cat [pp + I] = close then begin if (cut [pp + 21 = t erminator) V (cut [pp + 2] = stmt ) then squash (pp, 3, stmt , -2)(5); end else if cat [pp + I] = stmt then begin appl (pp); app (break-space); appl (pp + 1); reduce (pp, 2, beginning, :1)(G); end
This code is used in section 150.

5153 WEAVE

IMPLEMENTING THE PRODUCTIONS

153. ( Cases for case-head 153 ) 3 if cut [pp + l] = Casey then begin if cut [pp + 21 = clause then begin uppl (pp); app (outdent ); app2 (pp + 1); reduce (pp, 3, case-head, 0) (7); end; end else if cat [pp + l] = close then begin if cut [pp + 21 = terminator then begin UPPI (PPh (-JPP( cancel); app (outdent); app2 (pp + 1); reduce(pp, 3, atmt , -2)(8); end; end else if cut [pp + l] = stmt then begin app.2 (pp); upp(jorce); appl (pp + 1); reduce(pp,2, caae_heud,0)(9); end
This code is used in section 149.

75

154. ( Cases for Casey 154) = if cat [pp + l] =c 2 auae then squash (pp, 2, case-head, O)(lO)
This code is used in section 149.

155. ( Cases for clause 155) f if cut [pp + l] = stmt then begin app1 (pp); app (break-space); appl (pp + 1); app (cancel); app (outdent ); app (force);
reduce(pp,2,stmt,-2)(11); end
This code is used in section 149.

156. ( cases for cond 156) =

.

if (cut [pp + 1) = c Iuuse) A (cut [pp + 21 = atmt ) then

j;if cat [pp + 31 = elsie then begin UPP~ (PP); UPP (6 f-e&space

app2 (pp + 2); upp ("U"); upp (cancel);

reduce(pp,4, clause,-2)(12);

end

else begin app2 (pp); app (break-space); app1 (pp + 2); app (cancel); app (outdent ); app (force);

reduce(pp, 3, stmt, -2)(13);

end

This code is used in section 149.

157. ( Casts for elsie 157) squush (pp ,I; intro, -3) (14)
This rode is used in section 149.

158. ( Caws for ezp 158) 3 if cut [pp + I] = math then begin if cut [pp + 21 = simp then b e g i n npp3(yp); upp("1"); reduce(pp,3, math,-1)(15); end; end else if cut [pp + I] = sirnp then begin npp2(pp); npp("3"); reduce(pp,2, muth, -1)(16); end
This codr is used in section 149.

76 IMPLEMENTING THE PRODUCTIONS
159. ( Cases for intro 159) E if cat [pp + l] = atmt then b e g i n appl ( p p ) ; app(","); app(opt); dpp("7"); dpp(cdnceZ); UPP~ (PP + 1); reduce (pp ,2, atmt , -2) (17); end
This code is used in section 150.

WEAVE $159

160. ( Cases for math 160) E if cut [pp + l] = close -then begin ap~(~`$"); appl (pp); app("$"); reduce(pp, 1, atmt , -2)(18); end else if cut [pp + l] = colon then
begin ~PP (force); app(backup); app("$"); dppl (PP); ~PP("$"); aPP1 ( P P + 1); reduce (pp, 2, intro, -3)( 19); end else if cut [pp + l] = math then squash(pp,2, math, -1)(20) else if cat [pp + l] = aimp then aquaah(pp, 2, math, -1)(21)
else if cat [pp + l] = atmt then begin app ( ll$`l); appl (pp); app (`I$");' dpp (indent); dpp (break-apace); UPPI (PP + 1);
app (cancel); app (outdent ); app (force); reduce (pp, 2, stmt , -2)(22); end else if cut [pp + l] = terminator then
begin app("$"); appl (pp); app("$"); appl (pp + 1); reduce(pp,2,atmt,-2)(23); end
This code is used in section 150.

161. ( Cases for mod-scrap 161) f if (cat[pp + l] = t erminator) V (cut [pp + l] = semi) then begin app2(pp); app(jorce); reduce (pp, 2, stmt, -2)(24); end else squash(pp, 1, simp, -2)(25)
This code is used in section 149.

$162 WEAVE

IMPLEMENTING THE PRODUCTIONS

77

162. ( Cases for open 162) G ' i f (cat[pp+l] = case-head) A (cat [pp + 21 = close) then
begin appl (pp); ap~(~`$"); `app(cancel); appl (pp + 1); app(conceZ);

.
app(outdent); app(`*$");

aPPl (PP + 2); reduce(pp,3,math,-1)(26); end

else if cut[pp + l] = close then
begin appl (pp); app("\"); app(","); appl (pp + 1); reduce(pp,2, math,-1)(27); end

else if cat[pp + l] = math then ( Cases for open math 163) else if cat[pp + l] = proc then begin if cat[pp + 21 = intro then
begin app (matkop); app ( cancel); appJ (pp + 1); app(")"); reduce(pp + 1,2,math,0)(34);

end;

end

else if cat [pp + l] = aimp then squash (pp + 1, 1, math, 0)(35) else if (cat [pp + l] = stmt ) A (cat [pp + 21 = close) then begin appl (pp); app ("$"); app (cancel); appl (pp + 1); app (cancel); upp ("$"); UPPI (PP + 2); reduce(pp,3, math, -1)(36); end

else if cat [pp + l] = var-head then begin if cat[pp + 2] = intro then begin app (math-op); app ( cancel); appl (pp + 1); upp("3");

reduce(pp + 1,2, m&,0)(37);

end;

end

This code is used in section 150.

163. ( Cases for open math 163) E begin if (cat [pp + 21 = case-head) A (cat[pp + 31 = close) then begin app2 (pp); app ("$"); app (cancel); appl (pp + 2); app (cancel); app (outdent ); app ("$");
UPPJ (PP + 3); reduce(pp,4,math,-1)(28); end else if cat [pp + 21 =c2 ose then squash(pp,3, math, -1)(29) else if cat [pp + 2) = coIon then squnsh(pp + 1,2, math, 0)(30)
else if cat [pp + 21 = proc then begin if cat [pp + 3] = intro then begin nppl (pp +- 1); app(math-op); app(cancef); appl (pp + 2); app(")"); reduce (pp + 1,3, math, 0)(31); end; end
else if cat [pp + 21 = semi then begin app2(pp + 1); app("\"); upp(","); app(opt); upp("5"); reduce (pp + 1,2, m&h, 0)(32); end
else if cat [pp -t 21 = uar-head then begin if cut [pp t 31 = intro then begin appl (pp + 1); app (math-op); app (cancel); uppf (pp + 2); app ("I");
reduce (pp + 1,3, math, 0)(31); end; end; end
This code is used in section lG2.

78 IMPLEMENTING THE PRODUCTIONS

WEAVE

164. ( Cases for proc 164) 3

.

if cut[pp + l] = beginning then

begin if (cut [pp + 21 = close) A (cat[pp + 31 = terminator) then

begin ~PPJ (PP); ~PP( cancel); upp(outdent); appJ(pp + 1); reduce(pp,4,stmt,-2)(38); end;

end

else if cat [pp + l] = `atmt then

begin uppl (pp); app(breukspace); appl (pp + 1); reduce(pp,2,proc,-2)(39);

end

This code is used in section 149.

165. ( Cases for record-head 165) f if (cat [pp + I] = intro) A (cat[pp + 21 = cusey) then begin upp2(pp); ~pp("~~`); app(cuncd); uppj (pp + 2); reduce(pp 3, cue, -2)(40); end else begin upp(indent); uppl (pp); upp( cancel); reduce (pp, 1, cuse-head, 0) (41); end
This code is used in section 149.

166. ( Cases for semi 166) = squush (pp, 1, terminator, -3)(42)
This code is used in section 149.

167. ( Cases for simp 167) z if cut [pp + I] = close then squush(pp, 1, stmt, -2)(43) else if cut[pp + I] = colon then begin upp (force); app (backup); upp2 (pp); reduce (pp, 2, intro,.-3)(44); end else if cat [pp + l] = math then squash(pp,2, math, -1)(45) else if cut [pp + l] = mod-scrap then squash (pp, 2, mod-scrap, 0)(46) else if cut [pp + l] = simp then squaah(pp,2,simp,-2)(47) else if cat [pp + l] = t erminator then squash (pp, 2, stmt , -2)(48)
This code is used in section 150.

168. ( Casts for stmt 168) = if cut [pp t I] = stmt then begin appl (pp); upp (break-apace); uppl (pp + J.); reduce (pp, 2, stmt , -2)(49); end
This code is used in section 149.

160. (C~zscs for terminutor 169) zz sp~u~h(pp, 1, atmt, -2)(50)
This code is used in srction 149.

$164

5170 WEAVE

IMPLEMENTING THE PRODUCTIONS

170. ( Cases for uur-head 170) 3

.

if cut[pp + l] = beginning then aquuah(pp, 1, atmt, -2)(51)

else if cut[pp + l] = math then

begin if cat [pp + 21 = colon then

begin upp("$"); uppl (pp + 1); upp("$"); uppl (pp + 2); reduce(pp + 1,2, intro, +1)(52);

end;

end

else if cat[pp + l] = simp then

begin if cut[pp- + 21 = colon then squush(pp + 1,2, intro, +1)(53);

end

else if cut[pp + l] = stmt then

begin uppl (pp); upp (break-space); uppl (pp + 1); reduce (pp, 2, vur-head, -2)(54);

end

This code is used in section 149.

79

171. The `freeze-tezt'macro is used to give official status to a token list. Before saying freeze-ted, items are appended to the current token list, and we know that the eventual number of this token list will be the current value of tezt-ptr . But no list of that number really exists as yet, because no ending point for the current list has been stored in the tok-start array. After saying freeze-tezt , the old current token list becomes legitimate, and its number is the current value of tezt-ptr - 1 since ted-ptr has been increased. The new current token list is empty and ready to be appended to. Note that freeze-tezt does not check to see that ted-ptr hasn't gotten too large, since it is assumed that this test was done beforehand.
define freeze-text E incr (tezt-ptr ); tok-start [tezt-ptr] +-- tok-ptr

172. The `reduce'macro used in our code for productions actually calls on a procedure named `red `, which makes the appropriate changes to the scrap list.
procedure red(j : sixteen-bits; k : eight-bits; c : eight-bits; d : integer); var i: 0 . . muz-scraps ; { index into scrap memory } begin cut [j] t c; truna [j] c text-ptr ; freeze-tezt ; if k > 1 then begin for i + j + k to lo-ptr do begin cut[i - k + l] t cut [i]; truns[i - k t l] +- trans [i]; end; lo-ptr t lo-ptr - k + 1; end; (Change pp to max(scrup-base,pp+d) 173); end;

1 7 3 . ( Change pp to mcw(scrup-base ,pp+d) 173 ) z if pp + tl 2 ecrup-base then pp +- pp + d else pp + scrup-base
This CO& in USC~ irl sections 172 ilrld 174.

80 IMPLEMENTING THE PRODUCTIONS

WEAVE $174

174. Similarly, the `aquuah' macro invokes a procedure called `aq'. This procedure takes advantage of the ' simplification that occurs when k = 1.
procedure sq (j : sixteen-bits; k `: eight-bits; c : eight-bits; d : integer); var i: 0 . . mux-scraps ; { index into scrap memory } begin if k = 1 then begin cut[j] t c; ( Change pp to max(scrup-base ,pp +d) 173); end else begin for i t j to j + k - 1 do begin uppl (i); end;
45 hc,d); end; end;

175. Here now is the code that applies productions as long as possible. It requires two local labels (found and done), as well as a local variable (i).
(Reduce the scraps using the productions until no more rules apply 175) z loop begin (Make sure the entries cat [pp . . (pp + 3)] are defined 176); if (tok-ptr + 8 > mux-toks) V (text-ptr + 4 > mux-texts) then begin stat if tok-ptr > mux-tok-ptr then mux-tok-ptr t tok-ptr; if text-ptr > mux-txt-ptr then muxAxt_ptr t text-ptr; tats overflow ("token/text `); end; if pp > lo-ptr then goto done; (Match a production at pp, or increase pp if there is no match 149); end;
done:
This code is used in section 179.

176. If we get to the end of the scrap list, category codes equal to zero are stored, since zero does not match anything in a production.
(Make sure the entries cut [pp . . (pp + 3)] are defined 176 ) E if lo-ptr < pp + 3 then begin repeat if hi-ptr 5 scrap-ptr then begin incr (lo-ptr );
cut [lo-ptr] t cut [hijtr]; truns [lo-ptr ] +- truns [hi-ptr];
incr (hi-.ptr ); end; until (hi-ptr > scrap-ptr) V (lo-ptr = j~p + 3); for i +- lo-ptr + 1 to pp + 3 do cut [i] + 0; end
This code is used in section 175.

177. If WEAVE is being run in debugging mode, the production numbers and current stack categories will be printed out whn tracing is set to 2; a sequence of two or more irreducible scraps will be primed out when tracing is set to 1.
( Globals in the outer block 9) +E debug trueing : 0 . . 2; { can bc used to show parsing details } gubed

5178 WEAVE

IMPLEMENTING THE PRODUCTIONS

81

178. The prod procedure is called in debugging mode just after reduce or squash; its parameter is the number of the production that has just been applied.

debug procedure prod(n : eigh&ts); {shows current categories }

var k: 1 . . max-scraps; { index into cat }

begin if trueing = 2 then

begin print-nl (n i 1, ': `);

lfor k +- scrap-base to lo-ptr do begin if k = pp then print ( `* `) else print (

u');

print-cat (cat [k]);

end;

if hi-ptr 5 scrap,ptr then print (* . . . `); {indicate that more is coming }

end;

end;

gubed

179. The translate function assumes that scraps have been stored in positions scrap-base through scrap-ptr
of cat and trans. It appends a terminator scrap and begins to apply productions as much as possible. The result is a token list containing the translation of the given sequence of scraps.
After calling translate, we will have text-ptr + 3 5 max-texts and tok-ptr + 6 5 max-toks, so it will be possible to create up to three token lists with up to six tokens without checking for overflow. Before calling translate, we should have text-ptr < max-texts and scrap-ptr < max-scraps; since translate might add a new text and a new scrap before it checks for overflow.

( Declaration of subprocedures for translate 150 )

function translate : text-pointer ; { converts a sequence of scraps }

label done, found ;

var i: 1 . . max-scraps ; { index into cat }

j: 0 . . max-scraps ; {runs through final scraps } k: 0 . . long-buj-size; { index into bufler }

.

begin pp t- scrap-base; lo-ptr + pp - 1; hi-ptr +- pp;

(zf tracing, print an indication of where we are 182 );

( Reduce the scraps using the productions until no more rules apply 175);

if (lo-ptr = scrap-base) A (cat [lo-ptr] # math) then translate + trans[Zo-ptr]

else ( Combine the irreducible scraps that remain 180);

end;

82 IMPLEMENTING THE PRODUCTIONS

WEAVE

$180

.
180. If the initial sequence of scraps does not reduce to a single scrap, we concatenate the translations

of all remaining scraps, separated by blank spaces, with dollar signs surrounding the translations of math

scraps.

( Combine the irreducible scraps that remain 180) begin ( If semi-tracing, show the irreducible scraps 181); for j t scrap-base tg lo-ptr do begin if j # scrap-base then begin app ( ttUtt); end;
if cat [j] = math then begin app (*`$"); end;

~PPI (j); if cat [j] = muth then
begin app ( t'$f'); end;
if tok-ptr + 6 > max-toks then overflow (`token'); end;
freeze-text; translate t text-ptr - 1; end

This code is used in section 179.

181. ( If semi-tracing, show the irreducible scraps 181) z

debug if (lo-ptr > scrap-buse) A (tracing = 1) then

begin print-n1 ( `Irreducible,scrapUsequenceUinUsectionU',

mark-harmless ;

for j t scrap-base to lo-ptr do

begin print ( `U `); print-cat (cat [j]);

end;

end;

.

gubed

This code is used in section 180.

module-count : 1); print-fn( `: `); .

182. ( If tracing, print <an indication of where we are 182 ) s debug if tracing = 2 then begin print-nZ( `TracingUafterUl. `, line : 1, ' : `); mark-harmless; if lot > 50 then begin print ('. . . `); for k t lot - 50 to Zoc do print (xchr [bufler [k - 111); end else for k +- 1 to lot do print (xchr[bufler [k - 111); end gubcd
This code is used in section 179.

5183 WEAVE

INITIALIZING THE SCRAPS

83

183. Initializing the scraps. If WC are going to USC the powerful production mechanism just developed,
' we must get the scraps set up in the first place, given a PASCAL text. A table of the initial scraps corresponding to PASCAL tokens appeared above in the section on parsing; our goal now is to implement that table. We shall do this by implementing a subroutine called PASCAL-parse that is analogous to the
PASCAL-xref routine used during phase one. Like PASCAL-xref , the PASCAL-parse procedure starts with the current value of next-control and it uses
the operation next-control t get-nezt repeatedly to read PASCAL text until encountering the next `I' or `(`, or until next-control > format. The scraps corresponding to what it reads are appended into the cat and trans arrays, and scrap-ptr is advanced.
Like prod, this procedure has to split into pieces so that each part is short enough to be handled by PASCAL compilers that discriminate against long subroutines. This time there are two split-off routines, called easy-cases and sub-cases.
After studying PASCAL-parse, we will look at the sub-procedures app-comment , app-octal, and app-hex that are used in some of its branches.
(Declaration of the app-comment procedure 195 ) ( Declaration of the app-octal and app-hex procedures 196 ) ( Declaration of the easy-cases procedure 186) (Declaration of the sub-cases procedure 192) procedure PASCAL-parse ; { creates scraps from PASCAL tokens } label reswitch, exit; var j: 0 . . long-buf-size; {index into bufler }
p: name-pointer ; { identifier designator } begin while next-control < format do
begin ( Append the scrap appropriate to next-control 185 );
next-control + get-next; if (next-control = " I ") V (next-control = "{") then return; end; exit: end;

184. The macros defined here are helpful abbreviations for the operations needed when generating the scraps. A scrap of category c whose translation has three tokens tl,t 2t, i3s generated by sc3(tl)(t2)(t3)(c), etc.
define SO(#) E incr (scrap-ptr ); cat [scrap-ptr] t #; trons [scrap-ptr ] + text-ptr ; freeze-text; end
define a1 (#) 3 app(#); SO define s2 (#) E app(#); $1 define s3 (#) G app (#); a2 define s4 (#) G app (#); a3 define sc4 z begin 34 define sc3 G begin a3
define sc2 z begin a2 define scl z begin al
define x0(#) 3 begin incr (scrap-ptr); cut (scrap-ptr] + #; trnns[scrap-ptr] +-- 0; end
define comment-scrap (#) z begin upp (#); app-comment ; end

84 INITIALIZING THE SCRAPS

WEAVE $185

185. ( Append the scrap appropriate to next-control 185 ) G

.

(Make sure that there is room for at least four more scraps, six more tokens, and.four more texts 187 );

reswitch: case next-control of

string, verbatim: ( Append a string scrap 189);

identifier : ( Append an identifier scrap 191);

TeX-string: (Append a T@ string scrap 190);

othercases easy-ccl&s

endcases

This code is used in section 183.

186. The easy-cases each result in straightforward scraps.

(Declaration of the easy-cases procedure 186) G procedure easy-cases ; { a subprocedure of PASCAL-parse }
begin case next-control of set-element-sign: sc3(ff\ff)(`fif')(ffnff)(math); double-dot: sc3(ff\ff)("tff)(ffo'f)(math); ll#ll, ll$ll, ll~ll, "-0, ll~ll: sc& ("\")( next-control)( math); ignore, " I ", xref-roman, xref-wildcard, xref-typewriter : do-noth.ing; " (`I, " [`I : sc1 (nextcontrol)(open); I') If, "I ": sc1 (next-control)( close);
"*": sc4 (ff\ff)(ffaff)(ffsff)(ffttf)(math);

Il'l, `I1l.. ll~cl~(l~f~ ")(opt)("~")(m~th);

`1 4 ,`I `I 1' 5","6","7 If, ff8ff, lf9'l: sc1 (next-controf)(simp);

;*
`1

:,
I'

s:;(

lll;`Lj'g~~;

'

* If: scf (`I : `I)( colon);

;cases involving nonstandard ASCII characters 188)

exponent: sc3 (ff\ff)( "Eff)( `@{")( exp); .

begin-comment: sc2 ("\")( "B")(math);

end-comment : sc2 ("\")( "T")( math);

octal: app-octal;

.

hex : app-hex ;

check-sum: s~,2(`~\~~)(~~)~~)(sirnp);

force-line: sc+!?("\")("l ")(simp);

thin-space: sc,$?("\")( `I, `I)( math);

.

math-break: s~.2(opt)(~~O")(simp);

line-break: commentscrap (force);

big-line-break: comment-scrap (big-force);

no-line-break: begin app (big-cancel); app ("\"); sip ( ffUf'); comment-scrap(

end;

pseudo-semi i sc0 (semi);

join : s~,%?(`~\~`)(~~J")(math);

othercases scf (next-control){ moth)

endcases;

end;

This code is used in section 183.

big-cancel);

$187 WEAVE

INITIALIZING THE SCRAPS

187. (Make sure that there is room for at least four more scraps, six more tokens, and four more texts 187 ) =
if (scrap-ptr + 4 > max-scraps ) V (tok-ptr + 6 > maz-toks ) V (text-ptr + 4 > max-texts ) then begin stat if scrap-ptr > max-scr-ptr then max-scr-ptr +- scrap-ptr; if tok-ptr > max-tok-ptr then max-tok-ptr t tok-ptr ; if text-ptr > max-txt-ptr then max-txt-ptr t text-ptr; tats
overflow (`scrap/token/text `); end
This code is used in section 185.

85

188. Some nonstandard ASCII characters may have entered WEAVE by means of standard ones. They are converted to T&X control sequences so that it is possible to keep WEAVE from stepping beyond standard
ASCII.
( Cases involving nonstandard ASCII characters 188 ) E not-equal: sc2("\11)("I")(math); less-or-equal : sc2 ("\")( `*L")( math); greater-or-equal: sc2(`1\11)("G'1)(math); equivalence-sign: sc2(11\11)(11S11)(muth); and-sign : sc2 ("\") ( "WI') (math); or-sign : sc2 (lt\ll)(t'V1l)(mutA); no t-sign : sc2 (ll\")(llR")(math); left-arrow: sc2 ("\")( `I,")( math);
This code is used in section 186.

189. The following code must use app-tok instead of app in order to protect against overflow. Note that tok-ptr + 1 5 max-toks after app-tok has,been used, so arlother app is,legitimate before testing again.
Many of the special characters in a string must be prefixed by `\' so that T@ will print them properly.

( Append a string scrap 189 ) begin app ("\`l);

,

if next-control = verbatim then

begin npp ("=I');

end

else begin app (" . `0;

end;

app("("); j +- id-first;

while j < id-Zoc do

begin case bufler [j] of 11 utt, tt\tt, II.#II, tt%tt, "$11, II-II, II *II, II* II, II(II, II)II, II-II, O&II, II-II: begin ,~(II\II);

end;

l"@": if bufler [j + I] = `I@" then incr (j)

else err-print (

!UDoubleUQ,shouldLbe,used,inUstrings');

othercases do-nothing

endcases;

opp-tok (bufler [j]); incr (j);

end;

SC1 ("P')( aimp);

end

This rode is used in section 185.

86 INITIALIZING THE SCRAPS
190. ( Append a `J&X string scrap 190 ) f ' begin app( ll\ll); app ("h"); app ("b"); app ( "otl); app (11x1*); app (`,(");
for j t id-first to id-Zoc - 1 do upp-tok (bufler [j]); 8C1(")")(8imJ)); end
This code is used in section 185.

WEAVE

191. ( Append an identifier scrap 191) s begin p t id-lookup (normal); case ilk [p] of normal, array-like, const-like , div-like , do-like, for-like, goto-like, nil-like, to-like: sub-cases(p); ( Cases that generate more than one scrap 193 ) othercases begin nezt-control t iZk[p] - char-like; goto reswktch; end {and, in, not, or} endcases; end
This code is used in section 185.

192. The 8UbAa8e8 also result in straightforward scraps.
(Declaration of the sub~cases procedure 192) G procedure sub&.zses (p : name-pointer); { a subprocedure of PASCAL-parse }
begin case ilk[p] of normal: scl (id-flag + p)( simp); {not a reserved word } array-like : scl (res&g + p)( alpha); { array, Ale, set } const-like : ac3 (force)( backup)( res-flag + p)(intro); { const, label, type } div-like : ac3 (math-bin)( res&g + p)(tt}ll)(muth); { div, mod} do-like: acl (res$ag + p)( omega); { do, of, then } for-like : SC2 (force) ( res-flag + p)( alphu); { for, while, with } goto-like: acl (res&g + p)(intro); { goto, packed } nil-like : ac1 (res-Bug $ p)( aimp); { nil } to-like: SC,? (math-reZ)(res-flag + p)( ">")( math); { downto, to } . end;
end;
This code is used in section 183.

$190

$193 WEAVE

INITIALIZING THE SCRAPS

193. ( Cases that generate more than one scrap 193) s
begin-like : begin SC 3 (force) ( tee-flag + p) ( cancel) (beginning); SCU (intro); end; ( begin }
case-like : begin ac0 (casey ); sc2 (force)( res-flag + p)( alpha); end; { case }
else-like: begin ( Append terminator if not already present 184); sc3 (force)( backup)( res&g + p)( eltic); end; { else }
end-like: begin ( Append terminator if not already present 194);
SC.2 (fOrCe)(re8.$Ug + p)( CfOt?e);
end; { end} if-like: begin acU (cond); SC.2 (force)(ns-fZag + p)( alpha);
end; {if } loop-like : begin sc3 (force)( "\")( `I-")(uZpha); acl (res-flag + p)( omega);
end; { xclause'} proc-like : begin sc4 (force ) (bat kup ) (res-flag + p) ( cancef)(proc); ac~(indent)("\")("u'l)(~ntro);
end; { function, procedure, program}
record-like : begin acl (res.$ag + p)( record-head); acU (intro); end; { record }
repeat-like : begin SC4 (force)(indent )( res&g + p)( canceZ)( beginning); scU(intro); end; { repeat }
until-like: begin (Append terminator if not already present 184); ac,!? (force)( backup)( res-flag + p)( close); scU (cfause); end; { until }
var-like : begin sc4 (force) (backup)( reaJia;g + p) ( canceZ)( var-head); scU (intro); end; { var}
This code is used in section 191.

87

194. If a comment or semicolon appears before the reserved words end, else, or until, the s e m i or
terminator scrap that is already present *overrides the te,rminator scrap belonging to th.is reserved word.
(Append terminator if not already present 194) s if (scrap-ptr < scrap-base) V ((cat[acrap-ptr] # terminator) A (cat[acrap-ptr] # semi)) then 3cU (terminator)
This code is used in sections 193, 193, and 193. .

195. A comment is incorporated into the previous scrap if that scrap is of type omega or semi or terminator. (These three categories have consecutive .catcgory codes.) Otherwise the comment is entered as a separate scrap of type terminator, and it will combine with a terminator scrap that immediately follows it.
The app-comment procedure takes care of placing a comment at the end of the current scrap list. When app-comment is called, we assume that the current token list is the translation of the comment involved.

(Declaration of the app-comment procedure 195 ) z~

procedure app-comment ; { append a comment to the scrap list )

begin freeze-text;

if (scrap-ptr < scrap-base) V (cat[ scrap-ptr] < omega) V (cat [scrap-ptr] > terminator 1 then

8cU ( t e r m i n a t o r ) else begin appf (scrap-ptr );
end;

{ cat [ s c r a p - p t r ] i s omega o r semi o r t e r m i n a t o r }

upp(text-ptr - 1 + tok&g); trans (scrap-ptr] t text-ptr; freeze-text;

end;

This code is used in section 183.

88 INITIALIZING THE SCRAPS

WEAVE

$196

196. We are now finished with PASCAL-pm-se, except for two relatively trivial subproccdures that convert
constants into tokens.

( Declaration of the app-octal and app-hez procedures 196) zz

procedure upp-octal;

begin upp ("\"); upp ("0"); upp (`l(n);

while (bufler [Zoc] 2 "0") A (bufler [lot] 5 "7") do

begin app-tok (bufler [lot]); incr (foe);

end;

SC1 (",")( aimp);

.

end;

procedure upp-hex; begin upp (I'\"); upp ("H"); upp ("("); while (( bufler [Zoc] > "0") A (bufler [lot] 5 "9")) V (( bufer [lot ] 2 "A") A (bufler [Zoc] 5 "F")) do begin upp-tok (bufler [lot]); incr (lot); end;
SC1 (",")( simp); end;

This code is used in section 183.

197. When the ` I' that introduces PASCAL text is sensed, a call on PASCAL-translate will return a pointer
to the w translation of that text. If scraps exist in the cut and truns a.rrays, they are unaffected by this translation process.
function PASCAL-translate: text-poinfer; var p: text-pointer; { points to the translation } save-base: 0 . . mux-scraps; { holds origimal value of scrap-buse }
. begin awe-buse +- scrap-base; scrap-base +- scrap-ptr + 1; PASCAL-purse; { get the scraps together } if next-control # " I " then err-print( `!,MissingU" I ",after,PASCAL,text `); upp-tok (cuncel); app-comment; { place a cancel token as a final "conmicnt" } p +- translute; { make the translation } stat if scrap-ptr > mux-scr-ptr then mux-scr-ptr + scrup-ptr; tats
. scrap-ptr +- scrap-base - 1; scrap-base +- save-base; { scrap the scraps } PASCAL_trunslate t p; end;

$198 WEAVE

INITIALIZIN. G THE SCRAPS

89

198. The outer-purse routine is to PASCAL-purse as outer-xref is to PASCAL-xref: It const,ructs a ' sequence of scraps for PASCAL text until next-control 2 format. Thus, it takes care of embedded comments.

procedure outer-purse ; {makes scraps from PASCAL tokens and comments } var bul : eight-bits ; { brace level in comment } p, q: text-pointer ; { partial comments } begin while next-control < format do
if next-control # 11{11 then PASCAL-purse else begin (Make sure that there is room for at least seven more tokens, three more texts, and one
more scrap 199); upp (l'\ll); upp ( llC1l)i upp ( ll{l'); bul t copy-comment (1); next-control + " I ";
while bul > 0 do
begin p t text-ptr ; freeze-text; q + PASCAL-trunslute; { at this point we have tok-ptr + 6 5 mux-toks }
upp (tok-flag + p); upp (inner-tok-flag + q); if next-control = " I I' then bul +- copy-comment (bal) else bul +- 0; {an error has been reported } end;
upp (force); upp-comment ; { the full comment becomes a scrap } end; end;

199. (Make sure that there is room for at least seven more tokens, three more texts, and one more scrap 1999 z
if (tok-ptr + 7 > mux-toks) v (text-ptr + 3 > mux-texts) V (scrap-ptr 2 mux-scraps) then begin stat if scrap-ptr > max-scr-ptr then max-scr-ptr +- acrup-ptr; if tok-ptr > mux-tok-ptr then max-tok-ptr +-- tok-ptr; if text-ptr > mux-txt-ptr then mux-txt-ptr + text-ptr ; tats
overflow ( `token/text/scrap'); end
This code is used in section 198.

90 OUTPUT OF TOKENS

WE. AVE

$200

200. Output of tokens. So far our programs have only built up multi-layered token lists in WEAVE's ' internal memory; we have to figure out how to get them into the desired final form. The job of converting
token lists to characters in the T$$ output file is not difficult, although it is an implicitly recursive process. Three main considerations had to be kept in mind when this part of WEAVE w<as designed: (a) There are two modes of output, outer mode that translates tokens like force into line-breaking comrol sequences, and inner mode that ignores them except that blank spaces take the place of line breaks. (b) The cancel instruction applies to adjacent token or tokens that are output, and this cuts across levels of recursion since `cuncel'
occurs at the beginning or end of a token list on one level. (c) The m output file will be semi-readable if line breaks are inserted after the result of tokens like break-space and force. (d) The final line break should be suppressed, and there should be no force token output immediately after `\Y\P'.

201. The output process uses a stack to keep track of what is going on at different "levels" as the token lists arc being written out. Entries on this stack have three parts:
end-field is the tok-mem location where the token list of a particular level will end;
tok-field is the tok-mem location from which the next token on a particular level will be read;
mode-field is the current mode, either inner or outer.
The current values of these quantities are referred to quite frequently, so they are stored in a sepCarate place instead of in the stuck array. We call the current values cur-end, cur-tok, and cur-mode.
The globcal variable stuck-ptr tells how many levels of output are currently in progress. The end of output occurs when an end-translation token is found, so the stack is never empty except when we first begin the output process.
define inner = 0 {value of mode for PASCAL texts within w texts } define outer = 1 { value of mode for PASCAL texts in modules }
( Types in the outer block 11) +r mode = inner . . outer; output-state = record end-field: sixteen-bits ; { ending location of token list > tok-field: sixteen-bits; { present location within token list } mode-field: mode; { interpretation of control tokens } end;

202. define cur-end E cur-stute.end-field { current ending location in tok-mem } define cur-tok z cur-stute.tok$eld { 1ocation of next output token in tok-mem } define cur-mode z cur-state .modc-field { current mode of interpretation } define init-stuck E stack-ptr t 0; cur-mode +-- outer {do this to initialize the stack >
( Globals in the outer block 9 ) +curAnte : output-state ; { curlend, cur-tok, cur-mode } stack: array [I . . stack-size] of output-stute; { info for non-current levels } stuck-ptr : 0 . . stuck-size; { first unused location in the output state stack }
st'at mux-stuck-ptr : 0 . . stack-size; {largest v&e assumed by stuck-ptr } tats

203. ( Set initial values 10) +stat mux-stuck-ptr t 0; tats

$204 WEAVE

OUTPUT OF TOKENS

01

204. To insert token-list p into the output, the push-level subroutine is called; it saves the old level of output and gets a new one going. The value of cur-mode is not changed.
procedure push-level (p : text-pointer); { suspends the current level } begin if stackptr = stack-size then overflow ( `stack') else begin if stack-ptr > 0 then stack[atack-ptr] t cur-state; {save cur-end.. . cur-mode } incr (stack-ptr); stat if stack-ptr > max-stack-ptr then max-stack-ptr t stack-ptr ; tats cur-tok + tok-start [p]; cur-end +- tok-start [p + I]; end;
end;

205. Conversely, the pop-level routine restores the conditions that were in force when the current level was begun. This subroutine will never be called when stack-ptr = 1. It is so simple, we declare it as a macro:
define pop-level SE begin deer (stack-ptr); cur-state t stack [stack-ptr]; end {do this when cur-tok reaches cur-end )

206. The get-output function returns the next byte of output that is not a reference to a token list. It returns the values identifier or res-word or mod-name if the next token is to be an identifier (typeset in italics), a reserved word (typeset in boldface) or a module name (typeset by a complex routine that might generate additional levels of output). In these cases cur-name points to the identifier or module name in question.
define res-word = `201 {returned by get-output for reserved words } define mod-name = `200 {returned by get-output for module names }
function get-output : eight-bits ; {returns the next token of output } . label restart;
var a: sixteen-bits ; { current item read from tok-mem } begin resturt : while cur-tok = cur-end do pop-level;
a t tok-mem [ cur-tok]; incr (cur-tok); if a 2 `400 then
begin cur-name t CL mod id-,/Zag; case u div id-&g of
2: a +-- res-word; { a = res&g + cur-name } 3: a + mod-name: (u = mod-flag + cur-name > 4: begin push-level (cur-name); goto restart ; .
end; {a = tok-flag + cur-nume } 5: begin push-level (cur-name ); cur-mode +- inner; goto restart;
end; {a = inner-tok-jlng + cur-name } othercascs a +-- identifier { u = id-flag + cur-name } cndcases;
end; debug if trouble-ilootitly then debug-help; gubed
get-output +-- a; end;

92 OUTPUT OF TOKENS

WEAVE

$207

207. The real work associated with token output is done by make-output. This procedure appends an ' end-translation token to the current token list, and then it repeatedly calls get-output and feeds characters to the output buffer until reaching the end-translation sentinel. It is possible for make-output to be called recursively, since a module name may include embedded PASCAL text; however, the depth of recursion never exceeds one level, since module names cannot be inside of module names.
A procedure called output-PASCAL does the scanning, translation, and output of PASCAL text within (1 . . . I' brackets, and this procedure uses make-output to output the current token list. Thus, the recursive call of make-output actually occurs when make-output calls output-PASCAL while outputting the name of a module.
procedure make-output; forward;
procedure output-PASCAL; {outputs the current token list } var save-tok-ptr , save-text-ptr , save-next-control: sixteen-bits; { values to be restored } p: text-pointer; { translation of the PASCAL text } begin save-tok-ptr +- tok-ptr ; save-text-ptr +- text-ptr ; save-next-control + next-control; next-control t " I "; p +- PASCAL-translate ; upp (p + inner-tok-flag ); make-output ; { output the list } stat if text-ptr > max-txt-ptr then max-txt-ptr + text-ptr; if tok-ptr > mux-tok-ptr then max-tok-ptr t tok-ptr ; tats text-ptr t save-text-ptr ; tok-ptr +- save-tok-ptr ; {forget the tokens } next-control +- save-next-control; { restore next-control to original state } end;

$208 WEAVE

OUTJ'UT OF TOKENS

93

208. Here is WEAVE's major output handler.
procedure make-output; { outputs the equivalents of tokens } label reawitch, exit ,found ; var a: eight-bits; { current output byte } b: eight-bits ; { next output byte } k, k-limit : 0 . . max-bytes; {indices into byte-mem } 20: 0 . . ww - 1; {row of byte-mem } j: 0 . . long-buf-size; { index into bufier } string-delimiter : ASCII-code ; { first and last character of string being copied } save-Zoc, save-limit : 0 . . long-bu/-3ize ; { Zoc and limit to be restored } cur-mod-name : name-pointer; { name of module being output } save-mode : mode ; {value of cur-mode before a sequence of breaks } begin app (end-translation); { append a sentinel }
freeze-text ; push-ZeveZ (text-ptr - 1); loop begin a +- get-output; reawitch: case a of
end-translation: return; identifier, re3-word: ( Output an identifier 209);
mod-name : ( Output a module name 213 ); math-bin, math-op, math-rel: ( Output a \math operator 210); cancel: begin repeat a t get-output;
until (a < backup) V (a > big-force); goto reawitch;
end;
big-cancel: begin repeat a + get-output; until ((a < backup) A (a # ",,")) V (a > big-force); goto reawitch; end;
indent, outdent, opt, backup, break-apuce,force, big-lorce: ( Output a control, look ahead in case of line breaks, possibly goto reawitch 211);
othercases out (a) {otherwise a is an ASCII character } endcases; .
end;
exit: end;

209. An identifier of length one does not have to be enclosed in braces, and it looks slightly better if set in a math-italic font instead of a (slightly narrower) text-italic font. Thus we output `\ I a'but `\\(aa>`.
( Output an idcntificr 209) f begin out ("\"); if a = identifier then if length (cur-name) = 1 then out (" I `I) else out ("\") else out ("19"); {u = rea-word } if Zength (cur-name) = 1 then out (byte-mem [cur-name mod ww , byte-start [cur-name]]) else out-name (cur-name); end
This code is used in section 208.

94 OUTPUT OF TOKENS
210. ( Output a \math operator 210) f begin out5(11\")("m'1)("a")("t")("h"); if a = math-bin then out3(`1b'1)("i")(`1nn) else if a = math-rel then out3 ("r")("e")("l") else out2 ( lloll)( "p"); out (`T'); end
This code is used in section 208.

WEAVE $210

211. The current mode does not affect the behavior of WEAVE's output routine except when we are
outputting control tokens.
(Output a control, look ahead in case of line breaks, possibly goto reswitch 211) s if a < break-space then begin if cur-mode = outer then
begin out2("\")(a + -cancel + "0");
if a = opt then out (get-output) { opt is followed by a digit } end else if a = opt then b t get-output { ignore digit following opt } end else (Look ahead for strongest line break, goto reswitch 212)
This code is used in section 208.

212. If several of the tokens break-space, force, big-force occur in a row, possibly mixed with blank spaces
(which are ignored), the largest one is used. A line break also occurs in the output file, except at the very end of the translation. The very first line break is suppressed (i.e., a line break that follows `\Y\P').
(.Look ahead for strongest line break, goto reswitch 212) z begin b t a; save-mode t cur-mode; loop begin a t get-output; if (a= cunceZ)V( a -- big-cancel) then goto reawitch; { cancel overrides everything } if ((a # `IU") A (a < break-space)) V (a > big-force) then begin if save-mode = outer then begin if out-ptr > 3 then if (out-buj [out-ptr] = llPtl) A (out-buf [out-ptr - I] = "\") A (out-buf [out-ptr - 21 = "Y") A (out-buj[out-ptr - 31 = "\") then goto reawitch; out2 ("\")(b - ca?lceZ + "0"); if a # end-trnnslution then finish-line; end
else if (a # end-translation) A (cur-mode = inner) then out ("U"); goto reswitch; end; if a > b then b t a; { if a = ",,`I we have a < b } end;
end
This code is uucd in see tion 211.

$213

WEAVE

OUTPUT OF TOKENS

95

213. The remaining part of make-output is somewhat more complicated. When we output a module ' name, we may need to enter the parsing and translation routines, since the name may contain PASCAL code
embedded in I . . . 1 constructions. This PASCAL code is placed at the end of the active input buffer and the translation process uses the end of the active tok-mem area.
( Output a module name 213 ) E begin out2 ("\")( u1X1t); cur-xref +-- xref [cur-name];
if num( cur-xref ) 1 def&zg then
begin out-mod (num (cur-xref ) - def_fIag ); if phase-three then
begin cur-xref +-- xlink (cur-xref ); while nurn( cur-xref ) 1 def-flag do
begin out2 (" , ")( "Un); out-mod( num( cur-xref ) - def-flag ); cur-xref +- xZink( cur-xref );
end;
end;
end
else out ("0"); { output the module number, or zero if it was undefined } out (`I : `I); ( Output the text of the module name 214);
out2 (`,,")( "x");
end
This code is used in section 208.

214. ( Output the text of the module name 214 ) s k t byte-start [cur-name]; w +-- cur-name mod ww; k-limit + byte-start [cur-name + ww]; cur-mod-name + cur-name ; while k < k-limit do begin b +- byte-mem[w, k]; incr(k); if b = "9" then ( Skip next character, give error if not `Q' 215); if b # " I " then out (b) else begin ( Copy the PASCAL text -into bufler [(limit + 1) . . j] 216); save-lot +- lot; save-limit t limit; Zoc t limit + 2; limit t j + 1; bnifler [limit] + " I "; output-PASCAL; 1oc t save-lot; limit t save-limit;
end;
end
This code is used in acction 213.

215. ( Skip next character, give error if not `Q' 215 ) E begin if byte-mem[w, k] # !`@`I then begin print-n1 ( ' !UIllegalUcontrolUcode,inlsectionUname: print-id (cur-mod-name); print ( `>b,`); murk-error; end; incr (k);
end
This code is used in section 214.

`); print-nl(`c');

96 OUTPUT OF TOKENS

WEA. VE

5216

216. The PASCAL text enclosed in 1 . . . I should not contain ` I ' characters, except within strings. We put a ` I ' at the front of the buffer, so that an error message that displays the whole buffer will look a little bit sensible. The variable string-delimiter is zero outside of strings, otherwise it equals the delimiter that began the string being copied.

( Copy the PASCAL text into bufier [(limit + 1) . . j] 216) E j t limit + 1; bufier [j] t " I "; string-delimiter + 0; loop begin if k 2 k-limit then begin print-nZ( `!,,PASCALutextuinusection,name,didn"t,end: print-id (cur-mod-name); print ( `>U'); mark-error; goto found; end;
b + byte-men? [w, k]; incr (k); if b = "@I' then ( Copy a control code into the buffer 217) else begin if (b = WI")" (b = I'*") then
if string-delimiter = 0 then string-delimiter t b else if string-delimiter = b then string-delimiter + 0; if (b # " I ") V (string-delimiter # 0) then begin if j > ion,g-buf-size - 3 then overflow ( `buffer `); incr (j); bufer [j`1 t b; end
else goto found; end;
end;
found:

`); print-d(`<`);

This code is used in section 214.

217. ( Copy a control code into the buffer 217) z
begin if j > long-buf_size - 4 then overflow (`buffer `); buJer [j + l] + "@"; bufer [j + 21 t byte-mem[w? k]; j + j + 2; in&(k); end

This code is used in section 216.

.

$218 WEAVE

PHASE TWO PROCESSING

97

218. Phase two processing. We have assembled enough picccs of the puzzle in order to be ready to
specify the processing in WEAVE's main pass over the source file. Phase two is analogous to phase one, except that more work is involved because we must actually output the TJ$ material instead of merely looking at the WEB specifications.
(Phase II: Read all the text again and translate it to T@ form 218 ) f reset-input; ptintnl( `WritingUtheUoutputufile. . . `); module-count +- 0; copy-limbo; finish-line ; fEush_bufler (0, j&e); { insert a blank line, it looks nice } while Tinput-has-ended do ( Translate the current module 220)
This code is used in section 261.

219. The output file will contain the control sequence \Y between non-null sections of a module, e.g.,
between the w and definition parts if both are nonempty. This puts a little white space between the parts when they are printed. However, we don't want \Y to occur between two definitions within a single module. The variables out-line or out-ptr will change if a section is non-null, so the following macros `save-position' and `emit-spuce-if-needed' are able to handle the situation:
define save-position E save-line +- out-line; save-place +- out-ptr define emitspace-i/-needed GE
if (save-line # out-line) V ( save-place # out-ptr) then out,2(0\")(oY")
(Globals in the outer block 9) +E save-line : integer ; {former value of out-line } save-place: sixteen-bits; {former value of out-ptr }

220. ( Translate the current module 220 ) z begin incr (module-count ); ( Output the code for the beginning of a new module 221);
. suve-position ; ( Translate the TJ$ part of the current module 222); ( Translate the definition part of the current module 225 ); ( Translate the PASCAL part of the current module 230); ( Show cross references to this module 233); ( Output the code for the end of a module 238); end
This code is used in section 218.

221. Mod&s beginning with the WEB control sequence `&' start, jn the output with the w control
seqwmcc `\M', followed by the module number. Similarly, `a*' ~r~otlulcs lead to the control sequence `\N'. If
this is a changctl module, we put * jnst before the module number.

( Output the code for the beginning of a new module 321) f out ("\"): if bufleer [toe - I] # I'*`( then out ("M") else begin out ("N"); print ( '* `, module-count : 1) ; update-terminal end;
out-mod (module.count ); out.2 (`I. ")( "U")

{ print, a progress report }

This code is uucd in section 220.

I 98 PHASE TWO PROCESSING

W.E A V E

$222

222. In the T@ part of a module, we simply copy the source text, except that index entries a.re not copied

' and PASCAL text within I . . . 1 is translated.

( Translate the TEX part of the current module 222 ) E repeat next-control + copy-TeX; case next-control of
outl1 I I': begin init-stack; output-PASCAL; end;
"c!": (`W');
octal: ( Translate a.n octal constant appearing in TJ$ text 223 ); hex:(T ransIate a hexadecimal constant appearing in T@ text 224 ); TeX-string , xref-roman, xref-wildcard, xref-typewriter , module-name : begin lot t lot - 2;
next-control t get-next; { skip to CD } if next-control = TeX-string then err-print ('!uTeXUstringUshould,be,inuPASCALUtextUonlyO); end;
begin-comment, end-comment, check-sum, thin-apace, math-break, line-break, big-line-break, no-line-breuk,join,pseudo-semi: err-print ('!,YouUcan"tUdoUthat,in,TeX,text');
othercases do-nothing endcases;
until next-control 2 format

This code is used in section 220.

223. ( Translate an octal constant appearing in Tj$ text 223 ) E begin out3("\")("O~`)("~"); while (bufier [Zoc] 2 "0") A (bufler [Zoc] 5 "`7") do begin out (bufler [Zoc]); incr (Zoc); end; { since bufler [Zimit] = `lU", this loop will end } out (9"); end
This code is used in section 222.

224. ( Translate a hexadecimal const<ant appearing in TJ$ text 224 ) z begin out3 ("\")( "H")( "("); while (( bufler [lot] > "0") A (b?rfler [Zoc] < "9")) V (( bufler [Zoc] >_ "A") A (bufler [lot] 5 "F")) do begin out (bufler [lot]); incr (Zoc); end; out ("1"); end
This code iu used in section 222.

$225 WEAVE

PHASE TWO PROCESSING

99

225. When we get to the following code we have next-control 2 format, and the token memory is in its initial empty state.
( Translate the definition part of the current module 225 ) E if next-control 5 definition then { definition part non-empty } begin emit-space-if-needed; save-position; end; while next-control 5 definition do {format or definition } begin init-stack ; if next-control = definition then (Start a macro definition 227) else ( Start a format definition 228); outer-parse ; finish_PASCA L; end
This code is used in section 220.

226. The finish-PASCAL procedure outputs the translation of the current scraps, preceded by the control sequence `\P'and followed by the control sequence `\par'. It also restores the token and scrap memories to their initial empty state.
A force token is appended to the current scraps before translation takes place, so that the translation will normally end with \6 or \7 (the T&C macros for force and big-force). This \6 or \7 is renlaced by the concluding \par or by \Y\par.
procedure finish-PASCAL; { finis1 res a definition or a PASCAL part } ' var p: text-pointer ; { translation of the scraps } begin out2 ("\")( "P"); app-tok (force); app-comment ; p t translate ; app (p + tok-flag ); make-output ; { output the list } if out-ptr > 1 then
if out-buf [out-ptr - l] = "\I' then if out-buf [out-ptr] = "6" then out-ptr +- out-ptr - 2 else if out-buf [out-ptr] = "7" then out-buf [out-ptr] t "Y";
out4 ("\")( "pl')("a")("r"); finish-line; stat if text...ptr > max-txt-ptr then max-txt-ptr +- text-ptr ; if tok-ptr > mux-tok-ptr then max-tok-ptr +- tok-ptr ; if scrap-ptr > max-scr-ptr then max-scr-ptr t scrap-ptr ; tats
tok-ptr +-- 1; text-ptr t 1; scrap-ptr t 0; ( forget the tokens and the scraps } end;

227. ( Start a macro definition 227 ) z begin SC,!? ("\")( "D")( intro); { this will produce `define ' } next-control i- get-next; if next-control # identifier then err-print ( `!,ImproperUmacroUdefinition') else scl (id-Jag + id-lookup (normal))( muth); next-control t get-next ; end
Tlliv code is used in section 225.

100 PHASE TWO PROCESSING

WEAVE

$228

228. ( Start a format definition 228) = begin SC,?? ("\I')( l'F")( intro); { this will produce `format ' }
next-control +- get-next; if next-control = identifier then
begin scl (id&g + id-lookup (normal)) (math); next-control + get-next ; if next-control = equivalence-sign then
begin SC,!? ( ll\`t)( "S")( math); { output an equivalence sign } next-control +-- get-next; if next-control = identifier then
begin scl (id-flag + id-lookup (normal)) (math); sc0 (semi); { insert an invisible semicolon > next-control i-- get-nezt ; end;
end;
end; if scrap-ptr # 5 then err-print ( * !UImproper,,f ormat,def inition'); end
This code is used in section 225.

229. Finally, when the TJ$ and definition parts have been treated, we have next-control 2 begin-Pascal. We will make the global variable this-module point to the current module name, if it has a name.
( Globals in the outer block o ) +z this-module : name-pointer; { the current module name, or zero)

230. ( Translate the PASCAL part of the current module 230) E this-module +- 0; if next-control 5 module-name then begin emit-sljace-if-needed; G&stack ; if next-control = begin-Pascal then next-control t get-next else begin thins-module t cur-module; (Check that = or - follows this module name, and emit the scraps to start the module definition 231); end; while next-control < module-name do begin outer-purse; (Emit the scrap for a module name if present 232); end;
fit&h-PASCAL; end
This code is used in sectiou 220.

$231 WEAVE

PHASE TWO. PROCESSING

231. (Check that = or - follows this module name, and emit the scraps to start the module 1 definition 231) G
repeat nextcontrol t get-next ; until next-control # "+"; {allow optional `+=`} if (next-control # tt=ll) A (next-control # equivnlence-sign) then
err-print ( '! UYouUneedUanu=u sign,after,theUsectionUname') else next-control t get-next; if out-ptr > 1 then
if (out-buf [out-ptr] = llYtt) A (out-buf [out-ptr - I] = "\") then begin app (backup);. { the module name will be flush left } end;
scl (mod&g + this-module) (mod-scrap); cur-xref +- xref [this-module]; if num (cur-xref ) # module-count -I- def-fag then
begin sc3 (math-reZ)( "+`I)( ">")( math); { module name is multiply defined } this-module t- 0; { so we won't give cross-reference info here } end;
SC,!? ("\")( "S")( math); { output <an equivalence sign } scl (force)(semi); ( this forces a line break unless `@+' follows }
This code is used in section 230.

101

2 3 2 . ( E m i t t he scrap for a module name if present 232 ) f if next-control < module-name then begin err-print ( '! uYouucan s `t,,do,thatUinUPASCALUtext `); next-control t get-next ; end else if next-control = module-name then begin acl (mod-flag + cur-modufe)( mod-scrap); next-control +- get-next; end
This code is used in section 230.

233. Cross references relating to a named module are given after the module ends.
( Show cross references to this module 233 ) f if this-module > 0 then begin (Rearrange the list pointed to by cur-xref 235); footnote (def-fZag); footnote (0); end
This code is used in section 220.

234. To rearrange the o&r of the linked list of cross references, we need four more variables that point to cross rcferencc entries. We'll end up with a list pointed to I>y cur-xref .
( Globals in the outer block o ) +nextxref , this-xrcf , first-xref , mid-xref : xref-number ; {pointer variables for rearranging a list }

102 PHASE TWO PROCESSING

WEAVE .

$235

235. We want to rearrange the cross reference list so that all the entries with def-flag come first, in ascending order; then come all the other entries, in ascending order. There may be .no entries in either one
or both of these categories.

( Rearrange the list pointed to by cur-xref 235 ) E first-xref t xref [this-module]; this-xref t xlink (first-xref ); { bypass current module number } if num (this-xref ) > def-flag then begin mid-xref t this-xref ; cur-xref +- 0; { this value doesn't matter } repeat next-xref t xlink (this-xref ); xlink (this-xref ) t cur-xref ; cur-xref t this-xref ;
this-xref + next-xref; until num (this-xref ) 5 def-flag ; xZink(first-xref ) t cur-xref ;
end else mid-xref t 0; { first list null }
cur-xref +- 0; while this-xref & 0 do
begin next-xref t xlink (this-xref ); xlink (this-xref ) t cur-xref ; cur-xref +- this-xref ; this-xref t next-xref ;
end; if mid-xref > 0 then xlink (mid-xref ) +-- cur-xref else xlink (first-xref ) t cur-xref ; cur-xref + xlink (first-xref )

This code is wed in section 233.

236. The footnote procedure gives cross reference information about multiply defined module names (if the fZag parameter is def-flag), or about the uses of a module name (if the Jag parameter is zero). It assumes that cur-xref points to the first cross-reference entry of interest, and it leaves cur-xref pointing to the first element not printed. Typical outputs: `\A"section 10.1.`; `\Uusections 370 and 1009. `; `\A,sections 8, 27\*, and 64.`.
procedure footnote (flag : sixteen-bits); { outputs module cross-references } label done, exit; var q: xref-number ; { cross-reference pointer variable } begin if num( cur-xref ) 5 flag then return; finzkh-line ; out (I'\ `I); if fZag = 0 then out (YJtt) else out ("A"); out4 ("lr't)(tts't)(`tetr)(rtc't); out4 (ttt")(`titt)(tto't)(t'nt'); ( Output ,211 th e module numbers on the reference list cur-xref 237 );
011t (`1 . `1); exit: end;

I

237 WEAVE

PHASE TWO. PROCESSING

103

237. The following code distinguishes three cases, according as the number of cross references is one, two, or more than two. Variable q points to the first cross reference, and the last link is a zero.
( Output all the module numbers on the reference list cursref 237 ) s q +- cur-xref ; if num (zlinlc (q)) > Jug then out (now); { plural } out p-`1); loop begin out-mod( num (cur-xref ) - flag); cur-zref +- xlink (cur-xref ); { point to the next cross reference to output } if num (cur-xref ) 5 `flag then goto done; if (num( xlink (cur-zref )) > flag) v (cur-xref # zlink (q)) then out (`I, `I); { not the last of two } out ( y); if num(xZink(curzref)) 5 flag then out4 ("a't)(`tnl')(`ld't)("-l'); {the last } end;
done :
This code is used in set tion 230.

238. ( Output the code for the end of a module 238 > f out3("\tt)(1'ft1)("it'); finish-line; flush-bufler (0,faZse);
This code is used in section 220.

{insert a blank line, it looks nice}

104 PHASE THREE PROCESSING

WEAVE ..

$239

239. Phase three processing. We are nearly finished! WEAVE's only remaining task is to write out the `index, after sorting the identifiers and index entries.

( Phase III: OutSput the cross-reference index 239 ) G phase-three +- true ; print-nZ ( `Writinguthe,index. . . `); if change-exists then begin finish-line; ( Tell about changed modules 241); end;
finish-line; out4 (~~\~~)(~~i~~)(~~n~~)(~~x"); finish-line; (Do the first pass of sorting 243); ( Sort and output the index 250); out4 ("\`t)(ttf'l)("ilt)("n"); finish-line; (Output all the module names 257); out4 ("\ll)("c'l)(llo")("n"); finish-line; print(`Done. `);

This code is used in section 261.

240. Just before the index comes a list of all the changed modules, including the index module itself.
(Globals in the outer block 9) +E k-module: 0 . . max-modules ; { runs through the modules }

241. ( Tell about changed modules 241) z begin { remember that the index is already marked as changed } k-module t 1; while 1 changed-module [k- module] do incr (k-module); out4 ("\")("c")("h")("L'l); out-mod(k-module); repeat repeat incr (k-module) until changed-module [k-module]; OUt2(",")("u"): out-mod (k-module ); until k-module = module-count; out (1'. 1'); end
This code is used in section 239.

242. A left-to-right radix sorting method is used, since this makes it easy to adjust the collating sequence . and since the running time will be at worst proportional to the total length of all entries in the index. We
put the identifiers into 102 different lists based on their first characters. (Uppercase letters are put into the same list as the corresponding lowercase letters, since we want to have `t < TeX < to'.) The list for character c begins at location bucket [c] Cand continues through the blink array.
( Globals in the out,cr block o ) +E bucket: array [ASCII-code] of name-pointer; next-name: namc..pointer; { &ccessor of cur-name when sorting } c: ASCII-code ; { index into bucket } h: 0 . . hash-size; { index into hash } blink: array [0 . . maz-names] of sixteen-bits ; { links in the buckets }

$243 WEAVE

PHASE THREE PROCESSING

105

243. To begin the sorting, we go through all the 1 lash lists and put each entry having a nonempty crossreference list into the proper bucket.
(Do the first pass of sorting 243 ) s for c +- 0 to 127 do bucket [c] +- 0; for h +- 0 to hash-size - 1 do begin next-name +- hush [h]; while next-name # 0 do begin cur-name t next-name ; next-nume +- link [cur-name]; if zref [cur-name] # 0 then begin c t byte-mem [cur-name mod 2020, byte-start [cur-nume if (c < "2") A (c 2 "At') then c +- c + `40; blink [cur-name ] +- bucket[c]; bucket [c] +-- cur-nume; end; end; end
This code is used in section 239.

244. During the sorting phase we shall USC the cut and trans. arrays from WEAVE's parsing algorithm and rename them depth and head. They now represent a stack of identifier lists for all the index entries that have not yet been output. The variable sort-@ tells how many such lists are present; the lists are output in reverse order (first sort&r, then sort&r - 1, etc.). The jth list starts at, heud[j], and if the first k characters of all entries on this list arc known to be equal we llave depth[j] = k.
define depth E cut { reclaims memory that is no longer needed for parsing } define heud z truna { ditto } define sort-ptr E scrap-ptr {ditto} define mux-sorts z mux-scrups { ditto }
( Glob& in the outer block 9 ) +G cur-depth: eight-bits; { depth of current buckets} cur-byte: 0 . . mux-bytes; {index into byte-mem } cur-bank: 0 . . ww - 1; {row of byte-mem } cur-vul: sixteen-bits ; { current cross reference number }
stat mux-sort-ptr: 0 . . mnx-sorts; tats { largest value of sort-ptr }

245. ( Set initial values 10) +r stat mux-sort-ptr t 0; tats

246. The desired alphabetic order is specified by the collute array; namely, collate [0] < collute [l] < * - * < collnte [loo].
(Globals in the outer block O) $3 collate: array (0 . . 1001 of ASCII-code ; { collation order }

247. ( Local variables for initialization 16) +r c: ASCII-code ; { used to initialize collute }

106 248.

PHASE THREE PROCESSING

WEAVE

.

We use the order null < u < other characters < _ < A = a < - -- < Z = z < 0 < - -a < 9.

( Set initial values 10 ) +collate [0] 4- 0; collate [I] 4- "U"; for c t 1 to `tU1l - 1 do collate [c + 11 + c; for c t `lU1l + 1 to "0" - 1 do coZZute[c] t c; for c +- %I1 + 1 to "A" - 1 do coZZute(c - lo] +=- c;
for c 4- "Ztl + 1 to "-" - 1 do coZZute[c - 361 +-- c:
coZZate["-I'- 361 t "-" + 1; for c 4- llztf + 1 to 126 do coZZute[c - 631 +-- c;
collate [64] t "-"; for c t "a" to "z" do collate [c - "a" + 651 + c; for c t ltOfv to "9" do collate [c - "0" + 911 + c;

$248

249. Procedure unbucket goes through the buckets and adds nonempty lists to the stack, using the collating sequence specified in the collate array. The parameter to unbucket tells the current depth in the buckets. Any two sequences that agree in their first 255 character positions are regarded as identical.
define infinity = 255 { 00 (approximately) }
procedure unbucket (d : eight-bits); { empties buckets having depth d } var c: ASCII-code; { index into bucket } begin for c +- 100 downto 0 do if bucket [collate [cl] > 0 then begin if sort-ptr > mux-sorts then overflow (`sorting'); incr (sort-ptr ); stat if sort-ptr > mux-sort-ptr then mux-sort-ptr + sort-ptr; tats if c = 0 then depth[sort-ptr] +- infinity else depth[sort-ptr] t d; head [sort-ptr] +- bucket [collate [cl]; bucket [collute [cl] +- 0; end;
end;

250. (Sort and output the index 250) E sort-ptr t 0; unbucket (1); while sort-ptr > 0 do begin cur-depth t cut [ sort-ptr 1; if (bZink[heud[sort-ptr]] = 0) V (cur-depth = infinity) then ( Output index entries for the hst at sort-ptr 252 ) else ( Split, tile list at sort&r irito further hsts 251 ); end
This code is used in section 239.

$251 WEAVE

PHASE THREE PROCESSING

251. ( Split the list at sort-ptr into further lists 251) z begin nest-name t head[sort-ptr]; repeat cur-name t nezt-nam'e ; nezkname t blink [cur-name]; cur-byte t byte-start [ cur-name] + cur.depth; cur-bank t cur-name mod ww; if cur-byte = byte-start [cur-name + ww] then c + 0 {we hit the end of the name } else begin c t byte-mem (cur-bank, cur-byte]; if (c 5 "Z") A (c > "AI') then c t c + `40; end;
blink [cur-name] t bucket [cl; bucket [c] +- cur-name; u n t i l nezt-nume = 0 ; . deer (sort&r); unbucket (cur-depth + 1); end
This code is used in section 250.

2 5 2 . ( Ou t up tindex entries for the list at sort-ptr 252 ) E begin cur-name t head [sort&r]; debug if trouble-shooting then debug-help; gubed repeat out2 (ll\lt)(lt: `0; ( Output the name at cur-name 253); ( Output the cross-references at cur-name 254 ); cur-name t blink [cur-name]; until cur-name = 0; deer ( s o r t - p t r ) ; end
This code is used in section 250.

253. ( Output th e name at cur-name 253 ) I case ilk [cur-name] of normal: if Zength( cur-name ) = 1 then out2 ("\I') (" I ") else out2 ("\")( "\"); reman: do-nothing; wildcard: out2 ("\")( "9"); typewriter: out2("\")("."); othercases out,2 ("\")(I'&") endcases;
out-name (cur-name)
This code is used in section 252.

254. Section numbers that are to be underlined are enclosed in `\ [ . . . ] `.
( Output the cross-references at cur-name 254 ) E (Invert, the cross-reference list at cur-name, making cur-xref the head 255); repeat out2 (" , ")( "u"); cur-ual t num (cur-zref ); if cur-val < de/-flag then out-mod (cur-val) else begin out% ("\")(" [`I); out-mod(cur-val - de!-flag); out ("I "); end; cur-zrej t zlink (cur-zref ); until cur-2re/ = 0; out (" . I'); finish-line
This code is used in section 252.

107

108 PHASE THREE PROCESSING

WE. AVE

$255

255. List inversion is best thought of as popping elements off one stack a,n.d pushing them onto another. In this case cur-xref will be the head of the stack that we push things onto.
( Invert the cross-reference list at cur-name, making cur-xref the head 255) 3 this-zref + xref [cur-name]; cur-xref t 0; repeat next-xref t xlink (this-xref ); xlink (this-xref ) + cur-xref ; cur-xref t this-xref ; this-xref +- next-xref ; until this-xref = 0
This code is used in section 254.

256. The following recursive procedure walks through the tree of module names and prints them.
procedure mod-print (p : name-pointer); {print all module names in subtree p } begin if p > 0 then begin mod-print (flink [p]); out2 ("\")(" : I!); tok-ptr t 1; text-ptr t 1; scrap-ptr + 0; init-stack; app(p + mod-flag); make-output; footnote (0); { cur-xref was set by make-output }
finish-line ;
mod-print (rfink [p]); end; end;

257. ( Output all the module names 257) G mod-print (root)
This code is used in section 239.

258 WEAVE

DEBUGGING

109

258. Debugging. The PASCAL debugger with which WEAVE was developed allows breakpoints to be ' set, and variables can be read and changed, but procedures cannot be executed. Therefore a `debug-help'
procedure has been inserted in the main loops of each phase of the program; when ddt and dd axe set to appropriate values, symbolic printouts of various tables will appear.
The idea is to set a breakpoint inside the debug-help routine, at the place of `breakpoint :' below. Then when debug-help is to be activated, set trouble-shooting equal to true. The debug-help routine will prompt you for values of ddt and dd, discontinuing this when ddt 5 0; thus you type 2n + 1 integers, ending with zero or a negative number. Then control either passes to the breakpoint, allowing you to look at and/or change variables (if you typed zero), or you exit the routine (if you typed a negative value).
Another global variable,- debug-cycle, can be used to skip silently past calls on debug-help. 3f you set debug-cycle > 1, the program stops only every debug-cycle times debug-help is called; however, any error stop will set debug-cycle to zero.
( Globals in the outer block 9) +Z debug trouble-shooting: boolean; (is debug-help wanted? }
ddt : sixteen-bits ; {operation code for the debug-help routine } dd: sixteen-bits; { operand in procedures performed by debug-help } debug-cycle : integer ; { threshold for de bug-help stopping } debug-skipped: integer ; { we have skipped this many debug-help calls } term-in: textJ?Ze ; { the user's terminal as an input file }
gubed

259. The debugging routine needs to read from the user's terminal.
( Set initial values 10) +r debug trouble-shooting t true; debug-cycle t 1; debug-skipped t 0; tracing t 0; trouble-shooting t false; debug-cycle +-- 99999; { use these when it almost works } reset (term-in, 'TTY: ', `/ I `); {open term-in as the terminal, don't do a get } gubed

110 DEBUGGING
I 260. define breakpoint = 888 { place where a breakpoint is desirable }
I' ' debug procedure debug-help; {routine to display various things } label breakpoint, exit; var k: sixteen-bits ; { index into various arrays } begin incr (debug-skipped); if debug-skipped < debug-cycle then return; debug-skipped t 0; loop begin write (term-out, `#`); update-terminal; { prompt } read(term-in, ddt); { read a list of integers } if ddt < 0 then return else if ddt = 0 then begin goto breakpoint; O\ {go to every label at least once } breakpoint: ddt t 0; O\ end else begin read (term-in, dd); case ddt of 1: print-id (dd); 2: print-text (dd); 3: for k + 1 to dd do print (xchr [bufier [k]]); 4: for k t 1 to dd do print(xchr [mod-text [ICI]); 5: for k t 1 to out-ptr do print (xchr [ out-buf [Cc]]); 6: for k +- 1 to dd do begin print-cat (cat [k]); print ( `U'); end;
othercases print ( `? `) endcases;
end; end; exit: end; gubed

WEAVE

5260

5261

WEAVE

THE MAIN. PROGRAM

111

261. The main program. Let's put it all together now: WEAVE starts and ends here. The main procedure has been split into three sub-procedures in order to keep certain PASCAL compilers
from overflowing their capacity.
procedure Phase-l; begin (Phase I: Read all the user's text and store the cross references 109); end;
procedure Phase-II; begin (Phase II: Read all the text again and translate it to TJ$ form 218 ); end;
begin initialize ; {beginning of the main program } print-Zn (banner); { print a "banner line" } ( Store all the reserved words 64 ); Phase-I; Phase-II; ( Phase III: Output the cross-reference index 239 ); ( Check that all changes have been read 85 ); end-of- W&AI/E: stat ( Print statistics about memory usage 262 ); tats { here files should be closed if the operating system requires it } (Print the job history 263); end..

262. (Print statistics about memory usage 262) E

print-nZ( `Memoryuusage,statistics:,,`, name-ptr : 1, `,-names ,U', xref-ptr : 1,

`,cross,ref erences ,U', byte-ptr [0] : 1);

for cur-bank +- 1 to ww - 1 do print (*+ `, byte-ptr [cur-bank] : 1);

print ( `Ubytes ; `); print-nZ( `parsing,,requiredU', max-scr-ptr : 1, `,scraps ,U', max-txt-ptr : 1,

`,texts ,"I, max-tok-ptr : 1, `,,tokens,,,`, max-stack-ptr : 1, `ulevels; `I;

print-n1 ( * sortingUrequiredU', max-sort-ptr : 1, `Ulevels. `)

,

This code is used in section 261.

2 6 3 . Some implcmcntations may wish to pass the history value to the operating system so that it can be used to govern whether or not other programs are started. Here we simply report the history to the user.
(Print the job history 263 ) G case history of spotless : print-d ( ' (N o,errors,wereUf ound. ) `); harmless-message : print-n1 ( ' (Did,you,see,the,warningumessageuabove?) `); error-message: print-n1 ( '(Pardon-me ,,but,IPthink,ILspotted,somethingUwrong.)'); j&al-message: print-nZ(' (That,wasUaufatalUerror ,,myUfriend. > `); end { there are no other cases }
This code is uscd~in section 261.

112 SYSTEM-DEPENDENT CHANGES

W. EAVE

5264

264. System-dependent changes. This module should be replaced, if necessary, by changes to the
program that are necessary to make WEAVE work at a particular installation. It is usually best to design your change file so that all changes to previous modules preserve the module numbering; then everybody's version will bc consistent with the printed program. More extensive changes, which introduce new modules, can be inserted here; then only the index itself will get a new module number.

$265 WEAVE

INDEX

113

2 6 5 . I n d e x . If you have read and understood the code for Phase III above, you know what is in this index
' and how it got here. All modules in which an identifier is used are listed with that identifier, except that
reserved words are indexed only `when they appear in format definitions, and the appearances of identifiers in module names are not indexed. Underlined entries correspond to where the identifier was declared. Error messages, control sequences put into the output, and a few other things like "recursion" are indexed here too.

\): 186.
\*: 130. \,: 162, 163, 186. \ . * . 189, 253. \ :: 252, 256. \ =: 189.
\[: 254. \u: 186, 189, 193. \#: 186, 189. \$: 186, 189. \%: 186, 189. \&: 189, 209, 253.
\ `: 189. \\: 189, 209, 253. \ -: 186, 189.
\l : 189.
\(: 189. \3: 189. \-: 189, 193.
\I: 186. \I: 209, 253. \-: 131, 189. \A: 236. \ast: 186.
\B: 186. \c: 1 9 8 .
\con: 239. \D: 227. \E: 186. \F: 2 2 8 . \f i: 238.
\fin: 2 3 9 . \c: 1 8 8 .
\H: 1 9 6 , 2 2 4 .
\I: 188. \in: 186. \inx: 239.
\J: 1 8 6 . \K: 188. \L: 188.
\M: 221. \N: 221.
\ o : 196 2 2 3 . \P: 2 1 2 , 2 2 6 .
\R: 188.
\S: 188, 228, 231.

\T: 186.
\to: 186. \U: 236. \v: 188. \w: 1 8 8 . \X: 213. \Y: 212, 219, 226, 231.
\l: 211, 212.
\2: 2 1 1 , 2 1 2 . \3: 2 1 1 , 2 1 2 . \4: 2 1 1 , 2 1 2 . \5: 2 1 1 , 2 1 2 . \S: 211, 212, 226.
\7: 211, 212, 226. \9: 2 5 3 . Ql: 8 8 , 1 7 7 . 02: 8 8 , 1 7 7 . u: 13-0>206-.--.--3* 208 alpha: Ml, 142, 143, 149, 192, 193. alpha-cases : 149, 150. Ambiguous prefix: 69. and-sign : a, 64, 188. aPP : 118, 151, 152, 153, 155, 156, 158, 159,
160, Kl, 162, 163, 164, lG5, 167, 168, 170, 180, 184, 186, 189, 190, 195, 196, 198, 207, 208, 226, 231, 256.
app-comment : 183, 184, 105, 197, 198, 226. app-hex: 183, 186, 196. app-octal: 183, 186, 106. app-tok: LX, 137, 138, 148, 189, 190, 196,
197, 226.
append-xref : 50, 5 1 . appl : l& 151, 152, 153, 155, 156, 159, 160, 162,
163, lG4, 165, 168, 170, 174, 180, 195. appZ : l4& 153, 156, 158, 161, 163, 165, 167. npp9 : l48, 158, 164.
array-like: 42, 64, 191, 192. ASCII code: 1 1 , 8 6 . ASCII-code : ll, 13, 27, 28, 37, 65, 73, 87, 89, 91,
121, 127, 132, 136, 208, 242, 246, 247, 249.
6: 1 2 2 , 2 0 8 . bat kup : 14J, 142, 143, 147. IGO, 167, 192, 193,
208, 231. bal: r>l, 912, Hz, lJ_G_, 1 3 7 , 1 3 8 , 1%.
bnnner : L, 261. begin: 3.

114 INDEX
begin-comment: 86, 87, 97, 186, 222. begin-like : 42, 64, 193. begin-Pascal: &3, 87, 117, 229, 230. beginning: M, 142, 143, 150, 152, 164, 170, 193. big-cancel: h&l, 142, 147, 186, 208, 212. big-force : l& 142, 147, 186, 208, 212? 226. big-line-break: 86, 87, 186, 222. blink: 242, 243. 250, 251, 252. boolean: 28, 29, 45, 71, 74, 93, 122, 143, 258. break: 22.
break-out: 125, 126, 121. break-space: I& 143, 147, 152, 155, 156, 160,
164, 168, 170, 200, 208, 211, 212. breakpoint : 258, Z22. bucket: 242, 243, 249, 251. buf-size : t3, 28, 73, 74, 75, 79, 123. bufer: 27. 28, 31, 32, 55, 58, 59, 61,62,63, 74, 76,
78? 79, 80. 81, 82, 83, 84: 85, 89, 90,91, 92, 93, 95. 97, 98, 99, 100, 103. 104, 106, 107, 110, 123, 132, 133. 134: 135, 13G, 137: 179, 182, 183, 189, 190, 196. 208, 214, 216, 217, 221, 223, 224, 260. byte-mem : 36, 37, 38, 39, 40, 43, 44, 52, 58, 61, 62, 66, 67, 68, 69, 131, 208, 209, 214, 215, 216, 217, 243, 244, 251. byte-ptr : 38, 39, 41, 62, 67, 262. byte-start: 36, 37, 38, 39, 41, 44, 50, 55, 61, 62, 67, 68, 93, 114. 131, 209, 214, 243, 251. c: G-G9 G-9-7 8-73 8-9-, 9-0-: 9-17 9-5, 1-27, 1--3--27 -1374 -1376 140, 172-, -,174-7 242-, 247-*2~19 cancel: Ia, 142, 143, 147, 153, 155, 156, 159, 160, 162, lG3, 164, 165, 193, 197, 200, 208, 211, 212. ' carriage-return: l5, 17, 28. case-head: l40, 143, 149, 153, 154, 162, 163, 165. caee-like: 42, 64. 193. Casey: l4lJ, 142, 143, 149, 153: 165, 193. cat : 1-4-4'149, 150. 151, 152: 153, 154, 155, 156, 158, 159, 160, 161, 162, 163, 164, 165, 167, 168, 170, 172, 174, 17G. 178, 179, 180, 181, 183, 184, 194, 195, 197, 244, 250, 260. Change file ended. . .: 77, 79, 84. Change file entry did not match: 85. chcmge-b,ufler : `13, 74, 75, 78, 79, 83, 85. chonie- changing: 72, 79, 81, 84. chnnge-exists : 45, 109, 110, 239. chnngc-jile: 2, 23, 24, 32, 71, 73, 76, 77, 79, 84. c hnnge-limit : 73. 74, 75, 78, 79, 83, 85. chonged_motl~lle --`4@, . 82, 109, 110, 130, 241. chrlnging : 32, 71, 72, 73, 75, 79, 81, 82, 85. char: 12, 14. ch,nr-like : 42, 6 4 , 1 9 1 .
check-change: 7J. 83. check-sum: 83, 87, 186, 222.

WEAVE $265
chr: 12, 13, 17, 18. clause: &I, 142, 143, 149, ,151, 153, 154, f56, 193. close: l40, 142, 143, 152, 153, 160, 162, 163,
164, 167, 186, 193. collate: 246, 247, 248, 249. colon: l4J 142, 143, 148, 151, 160, 163, 167,
170, 186. comment: -14*2 comment-scrap : 184, 186. c o m p r e s s : 97. cond: b& 142, 143, 149, 193. confusion: 34. const-like : 42, 64, 191, 192. continue : 3, 75, 76. Control codes are forbidden...: 106. Control text didn't end: 106. control-code: 87, 88, 90, 93, 100, 135. copy-co?ment : 132, l36, 198. copy-limbo : 132, 218. copy-TeX: 132, l34, 222. count: 6-9* cur-bank: 214, 251, 262. cur-byte : 244, 251. cur-depth: 244, 250, 251. cur-end: 201, 202, 204, 205, 206. cur-mod-name : 20& 214, 215, 216. cur-mode : 201, 202, 204, 20G, 208, 211? 212. cur-module: Ci3, 101, 117, 230, 232. cur-name: 63, 206, 209, 213, 214, 242, 243, 251,
252, 253, 255. cur-state: 202, 204, 205. cur-tok : 201, 202, 204, 205, 206. cur-val: 244, 254. cur-xref: 118, 119, 213, 231, 234, 235, 236, 237,
254, 255, 256. d: 9-5-, 1-27, 1-772 1-774 2--4-9-* d d : 258, 2 6 0 . ddt: 258, 260. debug: 3-, 4-33-0 ,31-388-795-.'14- 0- 1-476 1-478 1-779
-17,8 1-8,1 1-8,2 2-0-6- 2-52--->25-8.725-9-726-0debug-cycle: 31 3 2-578 259, 260. de bug-help : 30, 31, 95, 206, 252, 258, 2tKJ. debug-skipped: 31, 258, 259, 260. deer: 5, 28, 92, 98, 103, 122, 127, 130, 135, 137,
138, 205, 251, 252. def_flay : 4G, 48, 50, 51, 93, 100, 111, 113, 115,
117, 119, 130, 213: 231, 233, 235, 236, 254. dejinition: 86, 87, 115, 225.
depth: 24q, 249. dig : K&l, 130. div-like : 42, 64, 191, 192. do-like : 42, 64, 191, 192.

265

WEAVE

do-nothing: 6, 95, 113, 149, 150, 186, 189, 222, 253.
done : 5, 75, 76, 90, 91, 92, 95, 103, 104, 122, 134, 135, 136, 137, 138, 175, 179, 236, 237.
Double Q required. . . : 133. Double 0 should be used. . . : 189.
double-dot: 86, 97, 186. easy-cases : 183, 185, 186. eight-bits: 36, 58, 87, 90, 91, 95, 108, 112, 122,
134, 136, 140, 144, 172, 174, 178, 198, 206, 208, 244, 249. else: 7.
else-like: 42, 64, 193. elsie : l4J 142, 143, 149, 156, 193.
emit-space-if-needed: 219, 225, 230. end: 3, 7. end-comment: 86, 87, 97, 186, 222.
end-field: 201, 202. end-like : 42, 64, 193. end-o/_ WEAVE: 2, 33, 261. end-translation: 141, 147. 20 I. 207, 208, 212. endcases: 1.
eof : 28.
eoln: 2 8 .
equal: 66, 67, 68. equivalence-sign: l5, 97, 116, 188, 228, 231. err-print: 3l, 66, 69, 72, 76, 77, 79, 80, 84, 85,
87, 99, 103, 104, 106, 107, 133, 136, 137, 189, 197, 222, 227, 228, 231, 232. error: 28, 3l, 33. error-message : 0, 263. exit: 3, 6, 50, 74, 75, 79, 89, 111, 123, 127, 132, 183, 208, 236, 260. exp : l40, 142, 143, 149, 186. exponent: 93, 98, 186. extension: G6, 6 8 , G9. E x t r a Q>: 8 7 . j: 2.. jalse : 28, 29, 72. 73, 74. 79: 81, 94, 96, 109, 110, 122, 123, 127, 218, 238. 259. fatal -error : 33, 34, 35. Jatal-message : 0, 263.
final-limit: 28. finish-line : l23, 124, 132, 134, 135, 212, 218, 226,
236, 238, 239, 254, 256.
jinish-PASCAL: 2 2 5 , 2?, 2 3 0 .
first-text-char: 12, 18.
first-xrej: 234, 235. jive-case.9 : 149, j5tJ jlag : 236, 2 3 7 . Jlush-bufler : l-22, 123. 127, 128, 218, 238. footnote: 233, 236, 256.

INDEX

115

for-like : 42, 64, 191, 192. Jorce : Ml, 142, 143, 146, 147, 153, 155, 156,
160, 161, 167, 186, 192, 193, 198, 200, 208, 212, 226, 231. force-line : 86, 87, 186.
form-feed: l5, 28. format: 86, 87, 111, 112, 113, 115, 183, 198,
222, 225. forward: 30, 207.
found: 5, 58, 60, 61, 66, 95, 96, 148, 149, 150, 151, 175, 179, 208, 216.
freeze-text: l7l, 172, 180, 184, 195, 198, 208. get: 28, 259. get-line : 71, 82, 89, 90, 91, 95, 103, 123, 132,
134, 136. get-next: 93, 95, 108, 111, 113, 115, 116, 117, 183,
222, 227, 228, 230, 231, 232. get-output: 206, 207, 208, 211, 212. goto-like: 42, 64, 191, 192.
greater : G6, 68, 69.
greater-or-equal: l5, 97, 188. g u b e d : 3.
h : 56, 5 8 , 212.
harmless-message : 9, 263.
hash: 38, 55, 57, 60, 242, 243. has h-size : 8, 55, 56, 57, 58, 59 242, 243. head: 241, 249, 250, 251, 252. hex: 86, 87, 100, 186, 222. hi-ptr : 144, 176, 178, 179. history : 2, 10, 263. Hmm... n of the preceding.. .: 80.
i: -176 -58, -1-7,2 -1,74- -1-7- -9id-first : 55, 58, 59, 61, 62, 63, 93, 98, 99, 106,
107, 189, 190. idJag : b4& 192, 206, 227, 228. id-lot : 55, 58, 59, 61, 62, 64, 93, 98, 99, 106,
107, 189, 190. id-lookup: 55! 58, 63, 93, 111, 113, 116, 191,
227, 228. identifier : 53. 98, 111, 113, 116, 185, 206, 208,
209, 227, 228. id,2 : G3, 64. id3 : GJ, 6 4 .
id4 : GJ, 6 4 .
id5: 63, 64.
idt;: 6 3 , 6 4 . it17: GJ, 6 4 .
it@: 6 3 , 64. idS: 63, G 4 . if_like : $2, G4, 193.
ignore : &Xi, 87, 88, 186.

116 INDEX
ilk: 36, 37, 42, 43, 55, 58, 60, 62, 111, 116, 191, 192, 253.
Illegal control code...: 215. Illegal use of Q...: 137. Improper format definition: 228. Improper macro definition: 227.
in-like : 42. Incompatible section names: 66.
incr : 6, 28, 50, 59, 61, 62, 67, 68, 69, 76, 77, 79, 83, 84, 89, 90, 91, 92, 95, 97, 98, 99, 100, 103, 104, 106, 107, 110, 122, 125, 130, 133, 135, 136, 137, 148, 149, 150, 171, 176, 184, 189, 196, 204, 206, 214, 215, 216, 217, 220, 223, 224, 241, 249, 260.
indent: Ml, 142, 143, 147, 151, 160, 165,193, 208. infinity : 249, 250. init-stack: 202, 222, 225, 230, 256. initialize : 2, 261. inner: 200, 2& 206, 212. inner-tok-flag : 146, 198, 206, 207. Input ended in mid-comment: 136. I n p u t e n d e d i n s e c t i o n n a m e : 103. Input line too long: 28. input-has-ended: 71, 79, 81, 83, 89, 90, 91, 95,
103, 109, 132, 134, 136, 218. input -In : 28, 76, 77, 79, 83, 84. integer: 14, 71, 79, 121, 130, 172, 174, 219, 258. intro : MO, 142, 143, 148, 150, 157, 160, 162, 163,
165, lG7, 170, 192, 193, 227, 228. j: G6, @ ,9-5 ,1-22,1-46, 1-72, 1-74, 1-79, 1-873 2-0*8 join : @, 87, 186, 222. `jump-out: 2, 33.
k: 31, 4-4, 5-8, G-G, G-9, 7-4, 7-5, 7-9.-, 9-5, 1-22l1-23,1-2-.7--, -1330 1-31, 1-72, 1-74, 1--7-8--, 1-7-9- -2, 0-8 ,26-0-
k-limit : 208, 214, 216. k-module : 240, 241. 1: 3-l) 58) Ge, (XJ. last-text-char: l2, 16, 18. lbrace : hi&?, 147. leJt-arrow : l5, 97) 188. length: 38, GO, 209, 253. less : @, 67, 68, G9. less-or-equal: l5, 9 7 ) 188. lhs : ll4, 116. limit: 28, 32, `7l, 74, 76, 77, 78, 80, 81, 82, 83, 84,
85, 89, 90, 91, 95, 97, 99, 103, 106, 107, 123, 132, 133, 134, 135, 136, 208, 214, 2X, 223. line: 32, 7l, 72, 76, 77, 79, 81, 83, 84, 85, 182. Line had to be broken: 128. line-break: @, 87, 186, 222.
line-feed: l5, 28. line-length: 8, 121, 122, 125, 127.

WEAVE

$265

lines-dont-match: 74, 79.
link: 36, 37, 38, 43, 60, 243.
llink: 43, 66, 67, 69, 119, 256. lo-ptr : l44, 172, 175, 176, 178, 179, 180, 181. lot : 28, 32, 7l, 7G, 80, 81, 82, 84, 85, 89, 90, 91,
92, 95, 97, 98, 99, 100, 103, 104, 106, 107, 110, 113, 132, 133, 134, 135, 136, 137, 182, 196, 208, 214, 221, 222, 223, 224. long-buf-size : 8, 27, 28, 31, 55, 58, 71, 179, 183, 208, 216, 217. longest-name : 8, 65, 66, 69, 95, 103, 105. l o o p : 5. loop-like: 42, 64, 193.
m : 5 0 , 130. make-output: 207, 208, 213, 226, 256. mark-error : 9, 31, 215, 216.
mark-fatal: 9, 33. mark-harmless: $3, 105, 119, 128, 181, 182. math : 139, 140, 142, 143, 148, 150, 151, 158,
160, 162, 163, 167, 170, 179, 180, 186, 188, 192, 227, 228, 231. math-bin: 141, 142, 147, 192, 208, 210. math-break: 86, 87, 186, 222. mat h-op : l4l, 143, 147, 162, 163, 208. math-rel: Ml, 142) 146, 147, 192, 208, 210, 231. max-bytes : 8, 37, 39, 44, 58, 62, 66, 67, 69, 131, 208, 244. max-modules : 8, 45, 46, 110, 240. max-names: t3, 37, 38, 62, G7, 69, 242. max-refs : 8, 47) 50. max-scr-ptr: l44, 145, 187, 197, 199, 226, 262. max-scraps: t3, 144, 172, 174, 178, 179, 187, 197, 199, 244. max-sort-ptr : 244, 245, 249, 262. max-sorts : 244, 249. max-stack-ptr: 202, 203, 204, 262.
max-texts : t3, 52, 175, 179, 187, 199. max-tok-ptr : 53, 54, 175, 187, 199, 207, 226, 262. max-toks: 8, 53, 13G, 146, 175, 179, 180, 187,
189, 198, 199. max-txt-ptr : 53, 54, 175, 187, 199, 207, 226, 262.
mid-xreJ: 231, 2 3 5 . Missing "I". . .: 19'7. mod-check: 119, 120. mod-&g : h& 206, 23 1, 2i2, 256. mod-lookup: 65) G6, 101, 102. mod-name : 206, 208. mod-print: 256, 257. modscrap: b& 142, 143, 149, lG7, 231, 232.
mod-text: G5, GG, 67, GB, 69, 95, 101, 102, 103, 104, 105, 260.
mod-xref-switch: 46, 48, 49, 51, 117.

$265 WEAVE

mode: 2Ol, 208.

mode-field: 201, 202. module-count : 45, 50, 51, 82, 109, 110, 181, 218,
220, 221, 231, 241.
module-name: 86, 87, 93, 100, 113, 117, 222, 230, 232.

n : 5 0 , 79,178.

Name does not match: 69. name-pointer: 38, 39, 44,50,51,58,63,66, 69,93,
111, 114, 119, 131, 183, 192, 208, 229! 242, 256.

name-ptr : 38, 39, 41, 44, 58, 60, 62, 67, 262. Never defined: <section name>: 119. Never used: <sect ion name>: 119.

new-line: 20, 31, 32, 33, 128. new-mod-xrej: 5l, 117. new-module: 86, 87, 90, 95, 134. ne w-xref : 50, 111, 113, 116. next-control: 108, 111, 112, 113, 115, 116, 117,
183, 185, 186, 189, 191, 197, 198, 207, 222, 225, 227, 228, 229, 230, 231, 232.

next-name : 242, 243, 251. next-xref : 234, 235, 255. nil: 6.

nil-like: 42, 64, 191, 192. no-line-break: 86, 87, 186, 222. no-underline : 86, 87, 100, 113. normal: 42, 58, 60, 111, 116, 191, 192; 227,
228, 253.
not-equal: l5, 97) 188.

not-Jound: 5. not-sign : l5, 64, 188. num: 4G, 49, 50, 51, 119, 213, 231, 235, 236,

237, 254.

num-field: 4 6 , 48.

octal: 86, 87, 186, 222.

omega : 140, 142, 143, 151, 192, 193, 195.

oot: 125.

oot1: 125.

ooti?:

125.

oot3 : 125.

ooq: &

oot5: L2J.

open : 139, L4J, 142, l43, 150, 186.

open-input: 24, 81.

opt: 139, l& 142, 143, 147, 159, 163, 186,

208, 211.

or-sign : l5, 64, 188.
ord: 13. other-line : 71, 72, 81, 85.
othercases: 1.

others: 7.

INDEX

117

out : l25, 130, 131, 133, 135, 208, 209, 210, 211, 212, 213, 214, 221; 222, 223, 224, 236, 237, 241, 254.
out-buJ : l2l, 122, 124, 125, 126, 127, 128, 212, 226, 231, 260.
out-line: &I, 122, 124, 128, 219. out-mod: l30, 213, 221, 237, 241, 254. out-name: l3l, 209, 253. out-ptr: l21, 122, 123, 124, 125, 127, 128, 135,
212, 219, 226, 231, 260. outdent: ha, 143, 147, 153, 155, 156, 160, 162,
163, 164, 208. outer: 200, 2ol) 202, 211, 212. outer-parse : 198, 225, 230. outer-xref : llJ 115, 117, 198.
output-PASCAL: 2Q7, 214, 222. output-state: 201, 202. out2 : mi, 130, 210, 211, 212, 213, 219, 221, 226,
241, 252, 253, 254, 256. out3 : 125, 210, 223, 224, 238. out4 : l25, 226, 236, 237, 239, 241. out5 : 125, 210. overflow: 35, 50, 62, 67, 110, 136, 175, 180, 187,
199, 204, 216, 217, 249. p: 44 ,5-0,5-175-8,66-76-971-11711-9713-17146, 183,
-1792 1-9,7 1-978 204, 226. param: & PASCAL text. : . didn't end: 216. PASCAL-parse: 183, 186, 192, 196, 197, 198. PASCAL-translate: l97, 198, 207. PASCAL-xref: 111, 112, 113, 183, 198.
per-cent: 122.
Phase-I: gj.
P h a s e - I I : 261. phase-one : 29) 31, 109. phase-three : 2J, 109, 213, 239.
pop-level: 205, 206. PPZ l44, 148, 149) 150, 151, 152, 153, 154, 155,
156, 157, 158, 159, 160, 161, 162, 163, lG4, 165, 166, 167, 168, lG9, 170, 173, 175, 176, 178, 179.
p r e f i x : 6& 6 8 . prefix-lookup: G9, 101. prime-the-change-bufler : 75, 81, 84. print: 20, 31, 32, 33, 44) 105, 11.0, 119, 128,
140, 146, 147, 178, 181, 182, 215, 216, 221, 239, 260, 262. print-cat: M&I, 178, 181, 260. print-id: 44, 119, 146, 215, 216, 260. print-in: 20, 32, 128, 181, 261. printnl: 20, 28, 105, 119, 128, 1.78, 181, 182, 215, 216, 218, 239, 2G2, 263.
print-text: 144, 2G0.

118 INDEX
proc : 140, 142, l43, 149, 162, 163, 164, 193. proc-like : 42, 64, 111, 193. prod: 148, l78, 183.
production : 148.
production-end: 148. productions, table of: 143. pseudo-semi : 86, 87, 186, 222. push-level: 204, 206, 208. q: 50, 5I, 66, 69, 198, -236. 7: 5l, 6 9 , 146.
rbrace: 146. read: 260.
read-in: 28. record-head: l4J, 142, 143, 149, 193. record-like : 42, 64, 193. recursion: 119, 207, 256. red: 148,, 172, 174. reduce : 148, 151, 152, 153, 155, 156, 158, 159, 160,
161, 162, 163, 164, 165, 167, 168, 170, 172, 178. repeat-like : 42, 64, 193. res-flag : @, 192, 193, 206. res-word: 206, 208, 209. reserved: 42, 50, 60. reset: 24, 259. reset-input: 8l, 109, 218. restart: 5, 82, 95, 100, 206. ieswitch: 158,3, 185, 191, 208, 212. return: 5, 6. rewrite : 21, 26. rhs : ll4, 116. rlink : 43, 66, 67, 69, 119, 256. ' roman: 42, 111, 253. root: 43, 66, 69, 120, 257.
save-base : 197. save-limit : 208, 214.
save-line : 219. save-lot: 222, 214. save-mode : 208, 212.
save-next-control: 207.
save-place : g@. save-position: -: 219 220, 225.
save-text-ptr : ?clJ saveltok-ptr : glJ. scanning-hex : 93, 94! 95, 96, 100. scrap-base: 141, 145, 173, 178, 179, 180, 181,
194, 195, 197. scrap-ptr : 144. 145, 176, 178, 179, 183, 184, 187,
194. 195, 197, 199, 22G. 228, 244, 25G. .9cO: Wl, 18G, 193: 194, 195, 228. SC1 : KM, 18G, 189, 13l. 192, 193, 106, 227,
228, 231, 232. sc2: l&4, 186, 188, &Z, X3, 227, 228, 231.

WEAVE $265
sc3: 184, 186, 192, 193, 231. sc4: l& 186, 193. Section name didn't end: 104. Section name too long: 105. semi: 139, l4J 142, 143, 149, 161, 163, 186,
194, 195, 228, 231. set-element-sign : l5, 64, 186.
sidl : 6 3 .
sid2: 63. sid3: 63.
sid4: 63. s i d 5 : Sg. sid6: 63.
sid7: 63.
sid8: 63. sid9: 63. simp : l4J 142, 143, 148, 150, 151, 158, 160, 161,
162, 167, 170, 186, 189, 190, 192, 196. sixteen-bits: 3Ji, 37, 48, 50, 53, 55, 66, 69, 172,
174, 201, 206, 207, 219, 236, 242,244, 258, 260. skip-comment: 9l, 112, 132, 136. skip-limbo: 89, 109, 132. skip-TeX: 90, 113, 132. Sorry, x capacity exceeded: 35. sort-ptr: 244, 249, 250, 251, 252.
special string characters: 189. split procedures: 149, 183, 261. spotless: 9, 10, 263. sq: 1 4 8 , m. squash: l48, 151, 152, 154, 157, IGO, 161, 162,
163, 166, lG7, lG9, 170, 174, 178. stack : 201, 202, 204, 205. stack-ptr : 201, 22, 204, 205. stack-size: t3, 202, 204. s t a t : 3. stmt : I@, 143, 149, 152, 153, 155, 156, 159, lG0,
161, 162, lG4, iG7, 168, 169, 170. string: 93, 99, 185.
String constant didn't end: 99. string-delimiter: 208, 216. sub-cases: 183, 191, 192. systcrn dopcntlcncic~s: .l, 2, 4, 7, 12, 17, 20, 21, 22,
24: 2~3, 28, 32, 33, 259, 2G0, 2G1, 2G3, 264. 30: J8cJ 81 : 184. 92: 1886. at?: 184.
84 : g3J
t: 58.
tab-mark: &, 32, 87, 89, 92, 95, 103, 104, 123, 133, 135.
t a t s : 3.

$265 WEAVE

temp-line: 7I, 72.

term-in: 258, 259, 260.

term-out: 20, 21, 22, 260.

'

terrninator : 139, l4& 142, 143, 149, 152, 153, 160, 161, 164, 166, 167, 179, 194, 195.

TeX string should be...: 222.
tex-file : 2, 25, 26, 122, 124. TeX-string : @, 87, 93, 100, 185, 222. text-char: l2, 13, 20. text-file : l2, 20, 23, 25, 28, 258. text-pointer: 52, 53, 144, 146, 179, 197, 198,
204, 207, 226. text-ptr : 53, 54, 146, 171, 172, 175, 179, 180, 184,
187, 195, 198, 199, 207, 208, 226, 256. thin-space : 86, 87, 186, 222.

This can't happen: 34.

this-module: 229, 230, 231, 233, 235.

this-xref : 234, 235, 255.

to-like : 42, 64, 191, 192.

tok-field: 201, 202.

tok-flag: l4& 148, 195, 198, 206, 226.

tok-mem: 53, 136, 146, 148, 201, 202, 206, 213.

tok-ptr : 53, 54, 136, 137, 148, 171, 175, 179, 180,

187, 189, 198, 199, 207, 226, 256.

tok-start : 52, 53, 54, 144, 146, 171, 204.

tracing : 88, l77, 178, 181, 182, 259.

trans : 144, 148, 172, 176, 179, 183. 184. 195,

197, 244.

translate : 149, 179, 180, 197, 226.

.

trouble-shooting : 95, 206, 252, 258, 259.

true : 6, 28, 29, 71, 72, 74, 79, 81, 82, 83, 85, 93,

100, 109, 110, 122, 127, 128, 239, 258, 259.

typewriter: 42, 111, 253.

unbucket : 249, 250, 251.

underline : 86, 87, 100, 113.

Unknown control code: 87.

until-like : 42, 64, 193.

up-to: 95.
update-terminal: Z, 31, 110, 221, 260. var-head: l40, 142, 143, 148, 149, 162, 163,
170, 193. var-like : 42, 64, 111, 193. verbatim: 86, 87, 100, 107, 185, 189.

Verbatim string didn't end: 107.
w: 4-47 5-87 6-67 6-93 1-3--1-9 2-0*8 WLSAVZ: 2.

WEB file ended...: 79.
we b-file : 2, 23, 24, 32, 71, 73, 79, 83, 85. Where is the match...: 76, 80, 84. wi: 40, 41. wildcard: 42, 111, 253. write : 20, 122, 124, 260.

. INDEX 119 write-ln: 20, 122. ww: 8, 37, 38, 39, 40, 41, 44, 50, 58, 61, 62,66, 67,
68, 69, 131, 208, 209, 214, 243, 244, 251, 262. xchr : l3, 14, 16, 17, 18, 32, 44, 105, 122, 128,
146, 147, 182, 260. xclause: 6 . xlin k : 46, 50, 51, 119, 213, 235, 237, 254, 255.
xlink-field: 46, 48. xmem: 46, 48. xord: l3, 16, 18, 28. xref: 36, 37, 46, 49, 50, 51, 62, 67, 119, 213,
231, 235, 243, 255. xref-number : 47, 48, 50, 51, 118, 234, 236. xref-ptr : 46, 48, 49, 50, 51, 262. xref-roman : 86, 87, 93, 100, 111, 113, 186, 222. xref-switch : 46, @, 49, 50, 93, 100, 111, 113, 115. xref-typewriter : 86, 87, 93, 111, 113, 186, 222. xref-wildcard: 86, 87, 93, 111, 113, 186, 222. You can't do that...: 222, 232. You need an = sign...: 231.

120 NAMES OF THE SECTIONS

WEAVE 265

( Append a string scrap 189 ) Used in section 185. ( Append a Tljx string scrap 190 ) Used in section 185. (Append an identifier scrap 191) Used in section 185. (Append the scrap appropriate to next-control 185) Used in section 183.
(Append terminator if not already present 194) Used in sections 193, 193, and 193. (Cases for alpha 151 ) Used in section 150.
( Cases for beginning 152 ) Used in section 150. ( Cases for case-head 153 ) Used in section 149.
( Cases for Casey 154) Used in section 149. ( Cases for clause 155 ) Used in section 149. ( Cakes for cond 156) Used in section 149. ( Cases for elsie 157 ) Used in section 149.
( cases for exp 158 ) TJsed in section 149. ( Cases for intro 159) Used in section 150.
( Cases for math 160 ) Used in section 150. ( Cases for mod-scrap 161) Used in section 149. ( Cases for open math 163 ) Used in section 162. ( ch.ses for open 162 ) Used in section 150.
( cases for proc 164 ) Used in section 149. ( Cases for record-head 165 ) Used in section 149. ( Cases for semi 166 ) Used in section 149. ( cases for simp 167 ) Used in section 150. ( cases for stmt 168 ) Used in section 149. ( Cases for terminator 169 ) Used in section 149. ( C~zscs for var-head 170) Used in section 149.
( Cases involving nonstandard ASCII characters 188 ) Used in section 186. ( Cases that generate more than one scrap 193 ) Used in section 191. ( Change pp to max( scrap-base ,pp +d) 173 ) Used in sections 172 and 174. ( Check for overlong name 105) Used in section 103.
( Check that all changes have been read 85 ) Used in section 261. (Check that = or s follows this module name, and emit the scraps to start the module definition

231)

Used in section 230.
( Clear bal <and goto hne 138 ) Used in sections 136 and 137. ( Combine the irreducible scraps that remain 180) Used in section 179. ( Compare name p with current identifier, goto found if equal 61 ) Used in section 60. ( Compiler directives 4 ) Used in sect,ion 2. ( Compress two-symbol combinations like ` : =' 97 ) Used in section 95.
( Compute the hash code h 59 ) Used in section 58. ( Compute the name location p 60) Used in section 58. (Constants in the outer block 8) Used in section 2. ( Copy a corhol code irlto the buffer 217 ) Used in section 216. ( Copy special things when c = "@I', `I\", "{I', "3"; goto done at, end 137) Used in section 136. ( Copy the PASCAL text into bufler [ (limit + 1) . . j] 216) Used in section 214. ( Copy up to ` 1' or control code, goto tfone if finished 135) Used in section 134. ( Copy up to control cock, return if finished 133) Used in section 132.
(Declaration of subprocedurcs for translate 150) Used in section 179. (Declaration of the app-comment proccdurc 195 ) Used in section 183.
( Dzclnration of the app-octal and app-hex proccdurcs 196) Used in section 183. (Dcclarnt,ion of the easy-cases procedure 186) TJsed in section 183.
(Dcclarat,ion of the sub-cases proccdurc 192) Used in wction 183. (Do sl'cci;ll things when c = "@ ", "\I', "{", ")`I; goto done at end 92) IJsed in section 91. ( Do t)hc first p ass of sorting 243 ) Used in section 239.

$265 WEAVE

NAMES OF THE SECTIONS 121

( Emit the scrap for a module name if present 232 ) Used in section 230. (Enter a new module name into the tree 67 ) Used in section 66. (Enter a new name into the table at position p 62 ) Used in section 58. (Error handling procedures 30, 31, 33 ) Used in section 2. ( Get a string 99) Used in section 95. ( Get an identifier 98 ) Used in section 95. ( Get control code and possible module name 100 ) Used in section 95. ( Globals in the outer block 9, 13, 20,23, 25, 27, 29, 37, 39, 45, 48, 53, 55, 63, 65, 71, 73,93, 108, 114, 118, 121, 129, 144,
177, 202, 219, 229, 234,240, 242, 244, 246, 258 ) Used in section 2.
( Go to found if c is a hexadecimal digit, otherwise set scanning-hex t false 96) Used in section 95. (If end of name, goto done 104) Used in section 103. (If semi-tracing, show the irreducible scraps 181) Used in section 180. (If the current line starts with Qy, report any discrepancies and return 80) Used in section 79. (If tracing, print an indication of where we are 182 ) Used in section 179. ( Invert the cross-reference list at cur-nume , making ci1r-%ref the head 255 ) Used in section 254. ( Local variables for initialization 16, 40, 56, 247 ) Used in section 2. ( Look ahead for strongest line break, goto reswitch 212 ) Used in section 211. (Make sure that there is room for at least four more scraps, six more tokens, and four more texts 187)
Used in section 185.
(Make sure that there is room for at least seven more tokens, three more texts, and one more scrap 199
Used in section 198.
( Make sure the entries cat [pp . . (pp + 3)] are defined 176 ) Used in section 175. (Match a production at pp, or increase pp if there is no match 149) Used in section 175. (Move bufler and limit to change-bufler and change-limit 78) Used in sections 75 and 79. ( Output a control, look ahead in case of line breaks, possibly goto reswitch 211) Used in section 208. (Output a \math operator 210) Used in section 208. (Output a module name 213 ) Used in section 208. ( Output all th e module names 257 ) Used in section 239. ( output all tlle module numbers on the reference list cur-xref 237 ) Used in section 236. ( Output an identifier 209) Used in section 208. ( Output index entries for the list at sort-ptr 252 ) Used in section 250. ( Output the code for the beginning of a new module 221) Used in section 220. ( Output the code for the end of a module 238 ) Used in section 220. ( Output the cross-references at cur-name 254 ) Used in section 252. ( Output the name at cur-name 253) Used in section 252. ( Output the text of the module name 214 ) Used in `section 213. (Phase I: Read all the user's text and store the cross references 109) Used in section 261. (Phase II: Read ,211 the text again and translate it to l'~$ form 218 ) Used in section 261. ( Phase III: Output the cross-reference index 239 ) Used in section 261. (Print error location based on input buffer 32 ) Used in section 31. (Print error messages about unused or undefined module names 120) Used in section 109. (Print statistics about memory usage 262) Used in section 261. (Print the job history 263 ) Used in sect,ion 261. (Print token r in symbolic form 147) Used in section 146. (Print warning message, break the line, return 128 ) Used in section 127. (Process a format definition 116) Used in section 115.. (Put module name into mod-text [I . . k] 103) Used in section 101. ( Read from change-/ile ;uld maybe turn off chunging 84 ) Used in section 82. ( R,cad from web-file and maybe turn on changing 83 ) Used in section 82. ( Itctarrange the list pointed to by cur-xrcf 235 ) Used in section 233. ( I~ctlucc the scraps using the productions until no more rules apply 175) Used in section 179.
( h.n a verbatim string 107 ) IJsed in sec'tion 100.

122 NAMES OF THE SECTIONS
( Scan the module name and make cur-module point to it 101) Used in section 100. ' ( Scan to the next CD 106 ) Used in section 100.
( Set initial vahres 10, 14, 17, 18, 2i, 26, 41,43, 49, 54, 57, 94, 102, 124, 126, 145, 203, 245, 248, 259 ) ( Set c to the result of comparing the given name to name p 68 ) Used in sections 66 and 69. ( Show cross references to this module 233 ) Used in section 220. ( Skip next character, give error if not `a' 215 ) Used in section 214. ( Skip over comment lines in the change file; return if end of file 76 ) Used in section 75. ( Skip to the next nonblank line; return if end of file 77 ) Used in section 75. ( Sort and output the index 250) Used in section 239. ( Special control codes allowed only when debugging 88 ) Used in section 87. ( Split the list at sort-ptr into further lists 251) Used in section 250. ( Start a format definition 228 ) Used in section 225. ( Start a macro definition 227) Used in section 225. ( Store all the reserved words 64) Used in section 261. ( Store cross reference data for the current module 110 ) Used in section 109. ( Store cross references in the definition part of a module 115) Used in section 110. ( Store cross references in the PASCAL part of a module 117) Used in section 110. ( Store cross references in the T@ part of a module 113 ) Used in section 110. ( Tell about changed modules 241) Used in section 239. ( Translate a hexadecimal constant appearing in TJ$ text 224 ) Used in section 222. ( Translate an octal constant appearing in T# text 223 ) Used in section 222. ( Translate the current module 220) Used in section 218. ( Translate the definition part of the current module 225 ) Used in section 220. ( Translate the PASCAL part of the current module 230) Used in section 220. ( Translate the T@ part of the current module 222 ) Used in section 220. ( Types in the outer block 11, 12, 36, 38, 47, 52, 201) Used in section 2.

WE. AVE

$265

Used in section 2.

Appendix E

123

The TANGLE processor
(Version 2.0)

Section

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

Thecharacterset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

Input andoutput . Reporting errors to

.... the

.... user

.

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

19 29

Datastructures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

ii

Searching for identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Searching for module names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

Stacks for output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Producingtheoutput . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

77 94

The bigoutputswitch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

Introduction to the input phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

123

Inputting the next token . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143

Scanning a numeric definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156

Scanning a macro definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163

Scanningamodulc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171

Debugging.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . iii

Thenminprogram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . System-depcndent changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

188 189

Page
124 128 132 134 136 139 144 146 149 154 161 166 173 177 180 183 186 188
190
191

124 INTRODUCTION

T A N G L E 51

.

1. Introduction. This program converts a WEB file to a PASCAL file. It was written by D. E. Knuth in

September, 1981; a somewhat similar SAIL program had been developed in March, 1979. Since this program

describes itself, a bootstrapping process involving hand-translation had to be used to get started.

For large WEB files one should have a large memory, since TANGLE keeps all the PASCAL text in memory

(in an abbreviated form). The program UPCS a few feat,ures of the local PASCAL compiler that may need to

be changed in other installations:

1) Case statements have a default. 2) Input-output, routines may need to be adapted for USC with a particular character set and/or for printing
messages on the tiger's terminal.

These features are also present in the PASCAL version of T@, where they are used in a similar (but more complex) way. System-dependent portions of TANGLE can be identified by looking at the entries for `system
dependencies in the index below. The "banner line" defined here should be changed whenever TANGLE is modified.

define banner - `ThisUis,TANGLE,uVersionu2.0'

2. The program begins with a fairly normal header, made up of pieces that will mostly be filled in later. The WEB &put comes from files web-file and change-file, the PASCAL output goes to file pnscal-file, and the string pool output goes to file pool.
If it is necessay to abort the job because of a fatal error, the program calls the `jump-out' procedure, which goes to the label end-of-TANGLE.
define end-of-TANGLE = 9999 { go here to wrap it up}
( Compiler directives 4 ) program TANGLE (web& e 7 change-file, pascal-file , pool);
label end-of-TANGLE; {go here to finish} const ( Constants in the outer block 8) * type ( Types in the outer block 11) var ( Glob& in t,he outer block 9)
( Error handling procedures 30 ) procedure initialize ;
var ( Local vcariablcs for initialization 16 ) begin ( Set initial values IO) end;

3. Some of this code is optional for use when debugging only; such material is enclosed between the delimiters debug and gubed. Ot.hcr parts, delimit&l by stat and tats, (arc optionally inch&d if statistics about TANGLE's memory usage are desired.
define debug f Q( {chalqc tllis to `debug = ' when debugging } define gubed z @) { change this to `gubed zz ' when debugging } format debug = begin format gubcd = end
define stcit -r @( { cll;ulgc~ this to `stat - ' whc~ gathering usage statistics } define tats z @) { change this to `tnts z ? when gathering usage statistics } format stat f begin format tats st end

4 TANGLE

INTRODUCTION

125

4. The PASCAL compiler used to develop this system has "compiler directives" that can appear in com' ments whose first character is a dollar sign. In production versions of TANGLE these directives tell the compiler that it is safe to avoid range checks and to leave out the extra code it inserts for the PASCAL debugger's benefit, although interrupts will occur if there is arithmetic overflow.
( Compiler directives 4 ) E oWz$C-, A-t, D-Q) { no range check, catch arithmetic overflow, no debug overhead } debug @{@&$C+, D-t@) gubed {but turn everything on when debugging}
This code is used in section 2.

5. Labels are given symbolic names by the following definitions. We insert the label `exit:' just before the `end' of a procedure in which we have used the `return' statement defined below; the label `restart' is occasionally used at the very beginning of a procedure; and the label `reswitch' is occasionally used just prior to a case statement in which some cases change the conditions <and we wish to branch to the newly applicable case. Loops t,hat are set up wit,h the loop construction defined below are commonly exited by going to `done'or to `found'or to `not-found `, (and they are sometimes repeatfed by going to `continue `.
define esit = 10 { go here to leave a procedure } define restart = 20 { go here to start a procedure again } define reswitch = 21 { go here to start a case statement again } define continue = 22 { go here to resume a loop } define done = 30 { go here to exit a loop } define found = 31 { go here when you've found it } define not-found = 32 {go here when you've found something else }

6. Here are some macros for common programming idioms. define incr (#) E # +-- # + 1 { increase a v<ariable by unity } define deer (#) G # +- # - 1 { decrease a v<ariable by unity } define loop s while true do { rcpcnt over and over until a goto happens } define do-nothing E {empty statement } define return 3 goto exit { terminaie a procedure call } format return = nil format loop E xclauae

126 INTRODUCTION

T A N G L E $7

7. WC assume that case statements may include a default case that applies if no matching label is found. ' Thus, we shall use constructions like

case z of
1: ( code for x = 1 ); 3: ( code for z = 3 ); othercases (code for x # 1 and x # 3 ) endcases

since most PASCAL compilers have plugged this hole in the language by incorporating some sort of default mechanism. l?or example, the compiler used to develop WEB and T'J$ allows `others :' as a default label, and other PASCALs allow syntaxes like `else'or `otherwise'or `otherwise:`, etc. The definitions of othercases and endcases should be changed to agree with local conventions. (Of course, if no default mechanism is available, the case statements of this program must be extended by listing all remaining casts. The author would have taken the trouble to modify TANGLE so that such extensions wcrc done automatic(ally, if he had not wanted to encourage PASCAL compiler writers to make this important change in PASCAL, where it belongs.)
define othercasea G others: { default for cases not listed explicitly } define endcaaea z end {follows the default case in an extended case statement } format othercases E else format endcaaea G end

8. The following parameters are set big enough to handle TJ$, so they should be sufficient for most applications of TANGLE.
( Constants in the outer block 8) E bzlf_aize = 100; { maximum length of input line } maz-bytea = 45000; { l/zou, times the number of bytes in identifiers, strings, and module names; must be less than 65536) maz-toka = 50000; { l/zz times the number of bytes in compressed PASCAL code; must bc less than 65536) maz-name3 = 4000; { number of identifiers, strings, module names; must be less than 10240)
* maz-texts = 2 0 0 0 ; { number of replacement texts, must be less than 10240 } haah-size = 353; { should be prime } longe,d-name = 400; { module names shouldn't be longer th,an this } line-length = 72; { I.I`11es of PASCAL output have at most this many characters } out-tuf_size = 144; {length of output buffer, should 1)~ twice line-length } Aack-size = 50; { number of simultaneous levels of macro expansion } m n z - i d - l e n g t h = 1 2 ; { long identifiers are chopped to this length, which must not exceed line-length } unambig-length = 7; { idcntificrs must be unique if chopped to this length } {note that 7 is more strict than PASCAL's 8, but this can be varied }
This code is used in sectiou 2.

9 TANGLE

INTRODUCTION

127

9. A glob;tl vCariable called history will contain one of four values at the end of every run: spotless means that no unusual messages were printed; harmleaa~measage means that a message of possible interest was printed but no serious errors were detected; error-measuge means that at least one error was found; f&al-message means that the program terminated abnormally. The valluc of history does not influence the behavior of the program; it is simply computed for the convcniencc of systems that might want to use such information.
define spotless = 0 { history value for normal jobs } define harmZeaa~meaaage = 1 { history value when non-serious info was printed } define error-message = 2 { history value when an error was noted } define /utaLmeaaage f 3 { history value when we had to stop prematurely }
define mark-harmless I if history = spotless then history t harmless-message
define mark-error E history +- error-message define mark.Jatal c history t fatul~meaaage
( Globals in the outer block 9 ) s history: spotless . . futul-message; {how bad was this run? }
See also sections 13, 20, 23, 25, 27, 29, 38, 40, 44, 50, 65, 70, 79, 80, 82, 86, 94, 95, 100, 124, 126, 143, 156, 164, 171, 179,
and 185.
This code is used in section 2.

10. ( Set initial values 10 ) Z history +-- spotless;
See also sections 14, 17, 18, 21, 26, 42, 46, 48, 52, 71, 144, 152, and 180.
This code is used in section 2.

128 THE CHARACTER SET

TANGLE
.

ll

11. The character set. One of the main goals in the design of WEB has been to make it readily portable

' between a wide variety of computers. Yet WEB by its very nature must use a greater variety of characters than

most computer programs deal with, and character encoding is one of the areas in which existing machines

differ most widely from each other.

To resolve this problem, all input to WEAVE and TANGLE is converted to an internal seven-bit code that is

essentially standard ASCII, the "American Standard Code for Information Interchange." The conversion is

done immediately when each character is read in. Conversely, characters are converted from ASCII to the

user's external representation just before they arc output.

Such an internal code is relevant to users of WEB only because it is the code used for preprocessed constants

like "A". If you are writing a program in WEB that makes use of such one-character constants, you should

convert your input to ASCII form, like WEAVE and TANGLE do. Otherwise WEB's internal coding scheme does

not affect you.

Here is a table of the standard visible ASCII codes:

0I234 567

`040

'050

'060

'070

'100

'II0 H I J K L M N 0

'120' P Q R S T U V W

'IS0 x Y 2 E \ 1 - -
`140 ' a b C d e f g
'150 h i j k 1 m n 0 '160 p 9 r 8 t U v W

`170

x

Y

Z

c

I

3

-

(Actually, of course, code '040 is [an invisible blank space.) Code `136 was once as an upward arrow (t), and code `137 w<as once a left arrow (+), in 01&w times when the first draft of ASCII code w;1s prepared; but WEB works with today's standard ASCII in which those codes represent circumflex and underline as shown.
( Types in the outer block 11) ASCII-code = 0 . . 127; { seven-bit numbers, a subrange of the integers }
SW also sections 12, 37, 39, 43, and 78.
This code is used in section 2.

I2 TANGLE

THE CHARACTER SET 129

12. The original PASCAL compiler wCas designed in the late GOs, when six-bit character sets were common,
so it did not make provision for lowercase letters. Nowadays, of course, we need to deal with both capital and small letters in a convenient way, so WEB assumes that it is being used with a PASCAL whose character set
contains at least the characters of standard ASCII as listed above Some PASCAL compilers use the original name char for the dat,a type (associated with the characters in t'ext files, while other PASCALs consider char
to be a 64-element subrange of a larger data type that has some other name. In order to accommodate this difference, we shall use the name text-char to stand for the data type of
the characters in the input and output files. We shall also assume that text-char consists of the elements chr (first-text-chur) through chr(Zast-text-char), inclusive. The following definitions should be adjusted if necessary.
define text-char 3 char { the data type of characters in text files } define first-text-char = 0 {ordinal number of the smallest element of text-char } define last-text-char = 127 {ordinal number of the largest element of text-char }
(Types in the outer block II ) +z text-file = packed file of text-char;

13. The WEAVE and TANGLE processors convert, between ASCII code and the user's external character set by means of arrays xord and xchr that are analogous to PASCAL's ord and chr functions.

(Globals in the outer block Q) +r xord: array [text-char] of ASCII-code; xchr: array [ASCII-code] of text-char;

{ specifies conversion of input characters } { specifies conversion of output characters }

130 THE CHARACTER SET

TANGLE I4

14. If we assume that every system using WEB is able to read and write the visible characters of stan-
dard ASCII (although not necessarily using the ASCII codes to represent them), the following assignment statements initialize most of the xchr array properly, without needing any system-dependent changes. For example, the statement xchr [O'lOl] : = 'A' that appears in the present WEB file might be encoded in, say, EBCDIC code on the external medium on which it resides, but TANGLE will convert from this external code to ASCII and back again. Therefore the assignment statement XCHR [65] : = 'A' will appear in the corresponding PASCAL file, and PASCAL wili compile this statement so that xchr [65] receives the character A in the external (char) code. Note that it would be quite incorrect to say xchr [@ `1011 : ="A", because "A" is a constant of type integer ,. not char, and because we have "A" = 65 regardless of the ext,ernal character set.

( Set initial values 10) +r

xchr `401 t `,,*; ichr[`41] t `! `; zchr[`42] t "I'; xchr[`43] + `#`; xchr[`&] + `$`;

xchr `451 t `x0; xchr[`46] t `&`; xchr[`47] + "";

xchr `501 t `( `; xchr[ `511 + `> l ; zehr[`52] + **`; xchr `531 t `+`; xchr[`5.#] t- `,*;

xchr `551 t `-`; xchr[`56] +- l .`; xchr[`57] + `/`;

xchr `601 t '0'; xchr[`61] +- '1'; xchr[`62] + -2'; xchr `631 + `3'; xchr[`6,#] + `4 ';

xchr `651 t `5'; xchr [ `661 +- `6'; xchr [ `671 + `7';

xchr xchr

`701 `751

t `8 '; xchr[`71] + ' t `=`; xchr[ `61 t

9`>' ;`; xxcchhrr[`[_7`727]].

+ `:`; x + `?`;

c

h

r

`731

t ' ; `; xchr[ `741 + `<`;

xchr `IOU] +-- `Q'; xchr `lOl] +-- `A'; xchr [ `IO,??] + `B'; xchr [ `1031 + `C'; xchr `1041 + l D';

xchr `IUFi] i-- `E'; xchr `1061 +- `F '; xchr[`107] + `G';

xchr `IIO] +- `H'; xchr `I l l ] + `I'; x c h r `fl2] t `J `; xchr [`I131 + 'K'; xchr `114] + .L';

xchr `1151 t 'M'; xchr `1161 + `N'; xchr `1171 + `0 ';

xchr `120] + `P'; xchr `121] + `q'; x c h r X22] + `R'; xchr [ `1231 +- 'S'; xchr `1241 + `T';

xchr `1,251 t 'U'; xchr `1261 + `V'; xchr `127] t `W';

xchr `1301 + 'x'; xchr [`I311 + `Y'; xchr `fJ,!i?] t 'Z'; xchr [ `1331 + ' [ `; xchr `1341 + `\`;

xchr `1351 t `1 `; xchr [ `1361 + l -*; xchr `1371 +- `-`;

xchr `1401 t `. `; xchr[ `1411 + *a'; xchr `I,/,!?] t 'b'; xchr[ `1431 t- `c *; xchr `1441 + 'd';

xchr `1451 t `e'; xchr[`1,#6] + 'f '; x&r `1471 + `g ';

[xchr `154 + 'h'; xchr [ `1.51 +- *i'; x c h r `15,2] t `j `; xchr[ `1531 + 'k'; xchr `1541 + '1';

1xchr `1551 + 'm'; xchr[ `156 + *n'; xchr `1571 +- `0';

[xchr `ISO] t `p*: xchr [ `161 t *q'; xchr `1621 t `r'; xclkr [ `1631 + `s'; xchr `1 6 4 +- 3';

1. xchr `1651 +- `u'; xchr[ `166 + `v'; xchr `1671 + `w `;

txchr[`l70] t `x'; xchr[`f7f
xchr[`f75] + `II'; xchr[`f76 xchr[O] t `L?`; xchr[`f77]

+ . ,-

`.y- '.;*1 `; {

xchr thcsc

`1721 t `z'; xchr [ ASCII codes arc not

`1731 used

+ }

`{`; zchr

`1741 + ' I `;

15. Some of the ASCII codes below `40 havc been given symbolic names in WEAVE ancl TANGLE because they arc used with a special meaning.
define und-sign = `4 { quivaltmt to `and' } define roof sign = `Fi { equivalent to `not'} define set-clement-sign = `6 {tyuivalcnt to `in'} define tch. wirk = `11 { ASCII coclc us;c~l as tnl)-skip } define fine-Itled = `1% { ASCII cotlc throw11 arwy at cd of l.ir1c } define forrrc-Jecd = `14 { AS(X cotlr usctl at end of page } define carriage-return = `f5 { ASCII code used at end of line } define Zejt-arrow = `30 { cquivdcrlt to `: ='} define not-equal = `32 { c+vdCIlt to `<>`} d e f i n e less-or-equal = `34 { c~quivdcrlt to `<='} define grenter-or-equal = `35 { equivalent to `>=' } define equivalence-sign = `36 { c+valwt to `==' } define orign = `37 { cquivalc~nt to `or'}

!W TANGLE

THE CHARACTER SET 131

16. When we initialize the xord array and the remaining parts of xchr, it will be convenient to make use of an index variable, i.
( Local variables for initialization 16 > E i: 0 . . last-text-char; See also sections 41, 45, aud 51. This code is used in section 2.

17. Here now is the system-dependent part of the character set. If WEB is being implemented on a gardenvariety PASCAL for which only standard ASCII codes will appear in the input and output files, you don't need to make any changes here. But at MIT, for example, the code in this module should be changed to

for i + 1 to `37 do xchr [i] + chr (i);

`40.WEB's character set is essentially identical to MIT's, even with respect to characters less than Changes to the present module will make WEB more friendly on computers that have an extended character set, so t,hat one can type things like # instead of <>. If you have an extended set of characters that are easily incorporated into text files, you can assign codes arbitrarily here, giving an xchr equivalent to whatever characters the users of WEB are allowed to have in their input files, provided that unsuitable characters do not correspond to special codes like carriage-return that are listed above.
(The present file TANGLE. WEB does not contain any of the non-ASCII characters, because it is intended to be used with all implementations of WEB. It was originally created on a Stanford system that has a convenient extended character set, then "sanitized" by applying another program that transliterated all of the non-standard characters into standard equivalents.)
( Set initial values 10 ) +r f o r i t 1 t o `3 7 d o xchr(i] t `"*;

18. The following system-independent code makes the xord array contain a suitable inverse to the information in xchr.
( Set initial values 10) +for i +-- first-text-ch ur to lust-text-char do xord[chr(i)] +-- '40; for i +- 1 to `176 do xord[xchr[i]] t i;

132 INPUT AND OIJTPUT

TANGLE 19

19. Input and output. The input conventions of this program are intended to be very much like those
of w (except,, of course, that they are much simpler, because much less needs to be done). Furthermore they (are identical to those of WEAVE. Therefore people who riced to make modifications to all three systems should be able to do so without too many headaches.
We use the standard PASCAL input/output procedures in several places that T@ cannot, since TANGLE
does not have to deal with files t,hat are named dynamically by the user, and since there is no input from the terminal.

20. Terminal output is done by writing on file term-out, which is assumed to consist of characters of type
text-char: define print (#) E write (term-out, #) { `p rint ' means write on the terminal } define print-172(#) G write-h (term-out, #) { `print'and then start new line} define new-line G write-ln (term-out) { start new line } define print.d (#) G { print information starting on a new line } begin new-line ; print (#); end
( Globals in the outer block Q ) +E term-out: text-file; { the terminal as an output file }

21. Different systems have different ways of specifying that the output on a certain file will appear on the user's terminal. Here is one way to do this on the PASCAL system that was used in TANGLE's initial
development:
( Set initial values 10 ) +rewrite (term-out, `TTY: `); { send term-out output to the terminal }

22. The update-terminal procedure is called when we want to make sure that everything we have output
to the terminal so far has actually left the computer's internal buffers and been sent.
define update-terminal E breuk(term-out) {empty the terminal output buffer }

23. The main input comes from web-file; this input may be overridden by changes in change-file. (If
* cliclnge-file is empty, there are no changes.)

( Glohals in the outer block 9 ) -i-E web-Jile : text-jile; { primary input }
change-file: text-jile; { updates }

'

24. The following code opens the input files. Since these files were listed in the program header, we assume that the PASCAL runtimc system has already checked that suitable file names have been given; therefore no atltlitional error chocking needs to be done.
procedure opin-input ; { prepare to read web-file and change-file } begin reset (web-file); reset (change-file); end:

25. The main output goes to pa?rculJiZe, and string pool constants are written to the pool file.
(Globals in the outer block 9) +r pu,9cuLfile : tcrt Jile ; pool: text-Jile ;

26 TANGLE

INPU.T AND OUTPIJT

133

26. The following code opens pascaLfile and pool. Since these files were listed in the program header, we
assume that the PASCAL runtime system has checked that suitable external file names have been given.
( Set initial values 10 ) +r rewrite (puscal-file); rewrite (pool);

27. Input goes into an array called bufler . ( Globals in the outer block 9 ) +E bufler: array [0 . . buf-size ] of ASCII-code ;

28. The input-h procedure brings the next line of input from the specified file into the bufler array and
returns the value true, unless the file has already been entirely read, in which case it returns f&e. The conventions of I&X are followed; i.e., ASCII-code numbers representing the next line of the file are input into bufler [0], bufler [I], . . . , bufler[limit - I]; t rai1ing blanks are ignored; and the global variable limit is set to the length of the line. The value of limit must be strictly less than buf-size.
We assume that none of the ASCII-code values of bufler [j] for 0 < j < limit is equal to 0, `177, line-feed, form-feed, or carriage-return.
function input-h (var f : text-file): boolean; { inputs a line or returns false } var final-limit : 0 . . buf-size ; { limit without trailing blanks } begin limit + 0; final-limit t 0; if eof(f) th en input-h t false else begin while ~eoln (f) do begin buJer[Zimit] t xord[fr]; get(f); incr(Zimit); if bufler [limit - I] # ",," then final-limit +- limit; if limit = buf-size then begin while leoln(f) do get(f); deer (limit ); { keep buJer [ buf-size ] empty } print31 ( '! ,Input~lineutooUlong '); lot +-- 0; error; end; end;
read-h (f ); limit t finulJimit ; input-h t true ; end; end;

134 REPORTING ERRORS TO THE USER

TANGLE ii29

.

29. Reporting errors to the user. The TANGLE processor operates in two phases: fir& it inputs the

' source file and stores a compressed representation of the program, then it produces the PASCAL output from

the compressed representation. '

The global variable phase-one tells whether we are in Phase I or not.

( Globals in the outer block 9 ) +r phase-one : boolean; { true in Phase I, false in Phase II }

30. If an error is detected while we are debugging, we usually want to look at the contents of memory. A special procedure will be declared later for this purpose. ( Error handling procedures 30 ) GE
debug procedure debug-help; forward; gubed
See also sections 31 and 34.
This code is used in section 2.

31. During the first phase, syntax errors are reported to the user by saying

`err-print ( l ! ,ErrorUmessage `)`,

followed by `jump-out' if no recovery from the error is provided. This will print the error message followed
by an indication of where the error was spotted in the source file. Note that no period follows the error message, since the error routine will automatically supply a period.
Errors that are noticed during the second phase are reported to the user in the same fashion, but the error
message will be followed by an indication of where the error was spotted in the output file. The actual error indications <arc provided by a procedure called error.

define err-print (#) E begin new-line ; print (#); error ; end

( Error handling procedures 30 ) +S

.

procedure error; { prints ' . ' and location of error message }

var j: 0 . . out-buf-size; {index into out-buf }

k, I: 0 . . bflf-size; {indices into bllfler }

begin if phuse-one then ( Print error location based on input buffer 32 )

else (Print error location based on output buffer 33);

updute-terminal; mark-error;

debug debug-help; gubcd

end;

32 TANGLE

REPORTING ERRORS TO THE USER 135

32. The error locations during Phase I can bc indicated by using the global variables Zoc, line, and changing, which tell respectively the first unlooked-at position in bufler, the current line number, and whether or not the current line is from change-file or web-file. This routine should be rnn~lificcl on systems whose standard text editor has special line-numbering conventions.
(Print error location based on input buffer 32 ) 3 begin if changing then print ( '. U (changeUf i leU `) else print ( '. U ( `); print-ln( `1. `, line : 1, `) `); if lot 2 limit then 1 +-- limit else 1 +-- 20~; for k + 1 to 1 do if bufier[k - I] = tab-mark then print (`"`) else print (zchr [bufler [k - 111); {print the characters already read} new-line ; for k t 1 to I do print (`,, `); { space out the next line } for k + t + 1 to limit do print (zchr [bufier [k - 111); {print the part not yet read} print( `,,`); {t ihs sp ace separates the message from future asterisks } end
This code is used in section 31.

33. The position of errors detected during the second phase can be indicated by outputting the phrtiallyfilled output buffer, which contains out-ptr entries.
(Print error location based on output buffer 33 ) z begin print-ln ( '. U (1. `, line : 1, `> `); for j +- 1 to out-ptr do print (zchr [ out-buf [j - 111); { print current partial line } print ( ' . . . U'); { indicate that this information is partial } end
This code is used in section 31.

34. The jump-out procedure just cuts across all active procedure levels and jumps out of the program. This is the only non-local goto statement in TANGLE. It is used when no recovery from a particuhar error has been provided.
Some PASCAL compilers do not implement non-local goto statement's. In such cases the code that appears at label end-of_Z'AiVGLll should .be copied intro the jump-out procedure, followed by a call to a system procedure that terminates the program.
define fatal-error (#) z begin new-line ; print (#); error ; mark-fatal; jump-out ; end
( Error handling procedures 30 ) +r procedure jump-out;
begin goto end-of-TANGLE; end;

35. Sornctimcs the program's behavior is far different from what it should be, and TANGLE prints an error mcssago t1m.t is really for tllc TANGLE maintcnancc person, not the user. In such cases the program says covfusion ( `indication,of ,wheretiweUare `).
define confusion (#) 2 futal-error ( '!,Thisucan' `t,happenU( `, #, `> `)

36. An overflow stop occurs if TANGLE's tables aren't large enough. define over/lo~o (#) z futnl-error ( ' ! Jerry ,L_l', #, `,capacityuexceeded')

I 136 DATASTRUCTURES

TANGLE 37

3 7 . Data s t r u c t u r e s . Most of the user's PASCAL code is packed into seven- or eight-bit integers in two large arrays called byte-mem and tok-mem. The byte-mem array holds the names of identifiers, strings, and modules; the to&mem (array holds the replacement texts for macros <and modules. Allocation is sequential, since things are deleted only during Phase II, and only in a last-in-first-out manner.
Auxiliary arrays byte-stud and tok-start are used as directories to byte-mem and talc-mem, and the link, ilk, equizr , and text-link arrays give further information about names. These auxiliary arrays consist of sixteen-bit items.
( Types in the outer block 11) +E eight-bits = 0 . . 255; { unsigned one-byte quantity } sixteen-bits = 0 . . 65535; { unsigned two-byte quantity }

38. TANGLE has been designed to avoid the need for indices that are more than sixteen bits wide, so that it can be used on most computers. But there are programs that need more than 65536 tokens, and some programs even need more than 65536 bytes; m is one of these. To get around this problem, a slight complication has been added to the data structures: byte-mem and tok-mem are two-dimensional arrays, whose first index is either 0 or 1. (For generality, the first index is actually allowed to run between 0 and ww - 1 in byte-mem, or between 0 and zz - 1 in tok-mem, where ww and zz are set to 2 and 3; the program will work for any positive values of ww and zz, and it can be simplified in obvious ways if ww = 1 or zz = 1.)
define ww = 2 {we multiply the byte capacity by approximately this amount } define zz = 3 {we multiply the token capacity by approximately this amount }
( Globals in the outer block 9) +S byte-mem: packed array [0 . . ww - 1,O . . mux-bytes] of ASClIxo~e; { characters of names } tok-mem: packed array (0 . . zz - 1,O . . max-toks] of eight-bits; { tokens } byte-stud: array [0 . . mux-names] of sixteen-bits ; { directory into byte-mem } tok-start: array [0 . . mux-texts] of sixteen-bits; { directory into tok-mem } link: array (0.. mux-names] of sixteen-bits ; { hash table or tree links } ilk: array [O . . mux-numes] of sixteen-bits ; { type codes or tree links } eqzliv : array [0 . . mux-names] of sixteen-bits ; { info corresponding to names } text-link: array [O . . mux-texts] of sixteen-bits ; { relates replacement texts }

The names of identifiers are found by computing a hash address h and then looking at strings of i& signified by hhjh], link[hush[h]], Zink[link[hash[h]]], . . . , until either finding the desired name or encountering a zero.
A `nume-pointer ' variable, which signifies a name, is <an index into byte-start. The actmal sequence of characters in the nmnc pointed to by p appears in positions byte-sturt [p] to byte-stud [p + ww] - 1, inclusive, in the segment of byte-mcm whose first index is p mod ww. Thus, when ww = 2 the even-numbered name bytes appear in byte-mem[O,* ] and the odd-numbered ones appear in byte-mem[l, *]. The pointer 0 is used for undefined module names; we don't want to use it for the names of identifiers, since 0 stands for a null pointer in a linked list.
Strings arc treated like identifiers; the first character (a double-quote) distinguishes a string from <an alphabetic name, hut for TANGLE's purposes strings behave like numeric macros. (A `string' here refers t,o the strings tlc~limited by tlon~)lo-qllotcs that TANGLE processes. PASCAL string constauts delimited by single-quote marks are not given such special treatment; they simply appear as sequences of characters in the PASCAL texts.) The total number of strings in the string pool is called string-ptr , cand the total number of names in byte-mem is called name-@. The total number of byt,es occupied in byte-mem[w, *] is called byte&r [w].
We usually have byte-dart [name-p& + w] = byte-ptr[( name-ptr + w) mod ww] for 0 < w < ww, since t,hcsc arc the starting positions for the next ww names to be stored in byte-men?.
define length (#I) -_. byte-sttrrt [#I + ww] - byte-start [#] { the length of a name }
(Types in the outer block II ) +r numc -pointer = 0 . . mux-numes ; { identifies a name }

940 TANGLE

DATA STRUCTURES

40. (Globals in the outer block 9) +E ' name-ptr : name-pointer ; ( first unused position in byte-start }
string-ptr : name-pointer ; {next number to he given to a string of length # 1) byte-ptt: array [O . . ww - l] of 0 . . mar-bytes; {first unused position in byte-mem } pool-check-sum: integer ; { sort of a hash for the whole string pool }

137

41. ( Local variables for initialization 16 ) 4-Z wi: o..w?P-1; { to initialize the byte-mem indices }

4 2 . ( Set initial values 10) +r for wi + 0 to ww - 1 do begin byte-start [wi] t 0; byte-ptr [wi] t- 0; end;
byte-start[ww] 4- 0; { this makes name 0 of length zero }
name-ptr t 1; string-ptr +- 128; pool-check-sum + 271828;

43. Replacement texts are stored in tok-mem, using similar conventions. A `text-pointer' variable is an index into tok-start, and the replacement text that corresponds to p runs from positions tok-stnrt[p] to tok-start [p + zz] - 1, inclusive, in the segment of tok-mem whose first index is p mod zz. Thus, when zz = 2 the even-numbered replacement text,s appear in tok-mem [0, *] and the odd-numbered ones appear in tok-men? [l, *]. Furthermore, textJink[p] is used to comlect pieces of text that have the same name, as we shall see later. The pointer 0 is used for undefined replacement texts.
The first position of tok-mem[z, *] that is unoccupied by replacement text is called tok-ptr [z], and the first unused location of tok-start is called text-ptr. We usually have the identity tok-startjtext-ptr + z] = tok-ptr [(text-ptr + z) mod zz], for 0 5 z < zz, since these are the starting positions for the next ww replacement texts to be stored in tok-mem.
( Types in the outer block 11) +r text-pointer = 0 . . mux-texts; {identifies a replacement text }
4 4 . It is convenient to maintain a variable z that is equal to text-ptr mod ZZ, so that we always insert tokens into segment z of tok-mem.
( Globals in the outer block 9) +Z text-ptr : text-pointer ; {first unused position in tok-start } tok-ptr: array [0 . . zz - l] of 0.. mux-toks; {first unused position in a given segment of tok-mem } 2: 0 . . 2% - 1; { current segment, of tok-mem } stat max-tok-ptr : array [O . . zz - I] of 0 . . max-toks; {largest values assumed by tok-ptr } tats

45. ( Local variables for init,ialixation 16 ) +E zi: O..Z% - 1 ; { to initialize the tok-mem indices }

46. ( Seta initial values 10) +r for zi +- 0 to zz - 1 do
begin tokAart[zi] t 0; tok-ptr[zi] +- 0; end;
tok-start [zz] +- 0; { this nu&cs rcplaccment text 0 of length zero } text-ptr t 1; z t 1 mod z.z;

138 DATA STRUCTURES 47. Four types of identifiers are distinguished by their ilk :

TANGLE .

47

normal identifiers will appear in the PASCAL program as ordinary identifiers since they have not been defined to be macros; the corresponding value in the eqtliv array for such identifiers is a link in a secondary hash table that is used to check whether any two of them agree in their first unambig-length characters after underline symbols are removed and lowercase letters are changed to uppercase.

numeric identifiers have been defined to be numeric macros; their equiv value contains the corresponding numeric value plus 2l5 . Strings are treated as numeric macros.

simple identifiers have been defined to be simple macros; their equiv value points to the corresponding replacement text.

parametric identifiers have been defined to be parametric macros; like simple identifiers, their equiw value points to the replacement text.

define normal = 0 { ordinary identifiers have normal ilk } define numeric = 1 { numeric macros and strings have numeric ilk } define simple = 2 { simple macros have simple ilk } define parametric = 3 { parametric macros have parametric ilk }

40. The names of modules are stored in byte-mem together with the identifier names, but a hash table is not used for them because TANGLE needs to be able to recognize a module name when given a prefix of that name. A conventional binary seach tree is used to retrieve module names, with fields called llink and rlink in place of link and ilk. The root of this tree is rZink[O]. If p is a pointer to a module name, equiv [p] points to its replacement text, just as in simple and parametric macros, unless this replacement text has not yet been defined (in which case equiv [p] = 0).
define Uink c link { left link in binary search tree for module names } define rlink G ilk { right link in binary search tree for module names }
( Set initial values 10 ) +r rZink[O] +- 0; { the binary search tree starts out with nothing in it } equiw [O] +- 0; { the undefined module has no replacement text }

49. Here is a little procedure that prints the text of a given name.
procedure print-id(p : nnrrre-pointer); { print identifier or module name } var k: 0 . . mnx-bytes; {index into byte-mem } w : 0 . . ww - 1; {segment of byte-mcm } begin if p > name-ytr then print (`IMPOSSIBLE') else begin w t p mod ww; for k - byte-start [p] to byte-start [p + ww] - 1 do print (xchr *[byte-mem [w, k]]); end; end;

50 TANGLE

SEARCHING FOR IDENTIFIERS

139

50. Searching for identifiers. The hash table described above is updated by the id-lookup procedure,
which finds a given identifier and returns a pointer to its index in byte-start. If the identifier w(as not already present, it is inserted with a given ilk code; and an error message is printed if the identifier is being doubly defined.
Because of the way TANGLE's scanning mechanism works, it is most convenient to let id-lookup search for an identifier that is present in the bufier array. Two ot.her global variables specify its position in the buffer: the first character is bufer [id-first], and the last is bufler [id-Zoc - 11. Furthermore, if the identifier is really a string, the global variable double-chars tells how many of the characters in the buffer appear twice (namely @@ and ""), since this additional information makes it easy to calculate the true length of the string. The final double-quote of the string is not included in its "identifier," but the first one is, so the string length is id-lot - id-first - double-chars - 1.
We have mentioned that normal identifiers belong to two hash tables, one for their true names as they appear in the WEB file and the other when they have been reduced to their first unurnbig-length characters. The hash tables are kept by the method of simple chaining, where the heads of the individual lists appear in the hash and chop-hash arrays. If h is a hash code, the primary hash table list starts at hush[h] and proceeds through link pointers; the secondary hash table list starts at chop-hush[h] and proceeds through equiv pointers. Of course, the same identifier will probably have two diffcrcnt v(alues of h.
The id-lookup procedure uses an auxiliary array called chopped-id to contain up to unnmbig-length characters of the current identifier, if it is necessary to compute the secondary hash code. (This array could be declared local to id-lookup, but in general we are making all array declarations global in this program, because some compilers and some machine architectures make dynamic array allocation inefficient.)
( Giobals in the outer block 9) +r id-first: 0 . . huf-size ; {where the current identifier begins in the buffer } id-Zoc : 0 . . buf-size ; {just after the current identifier in the buffer } double-chars : 0 . . buj-size ; { correction to length in case of strings >
hush, chop-hash: array [0 . . hash-size] of sixteen-bits; {heads of hash lists} chopped-id: array (0 . . unumlig-length] of ASCII-code; {chopped identifier }

51. Initially all the hash lists are empty.
(Local variables for initialization 16) +Z h: 0 . . hash-size; { index into hash-head arrays }

52. (Set initial values 10) +F for h + 0 to hush-size - 1 do begin hash[h] +-- 0; chop-haHh[h] +-- 0; end;

140 SEARCHING FOR IDENTIFIERS

T A N G L E $53

53. Here now is the main procedure for finding identifiers (and strings). The parameter t is set to normul

' except when the identifier is a macro name that is just being defined; in the latter case, t will be numeric,

simple, or parametric.

function id-lookup (t : eight-bits): name-pointer ; label found, not-found; var c: eight-bits; { byte being chopped }
i: 0 . . buf_size; { index into bufler } h: 0 . . hash-size ; { hash code }

{ finds current identifier }

k: 0 . . mas-bytes; {index into byte-mem } w : 0 . . ww - 1; {segment of byte-mem } 1: 0 . . buf-size; { length of the given identifier } p, q: name-pointer ; { where the identifier is being sought } 3 : 0 . . unambig-length; { index into chopped-id } begin 1 +-- id-lot - id-first; { compute the length }

( Compute the hash code h 54); ( Compute the name location p 55 ); if (p = name-ptr) V (t # normal) then (Update the tables and check for possible errors 57) id-lookup + p; end;

54. A simple hash code is used: If the sequence of ASCII codes is crc2 . . . c,, its hash value will be (2n-`cl + 2n -2c2 + . . . + cn) mod hash-size.

( Compute the hash code h 54 ) E h t bufler [id-first]; i t id-first + 1; while i < id-lot do begin h t (h + h + bufler ii]) mod hash-size; incr (i); end
This code is used in section 53.
* 55. If the identifier is new, it will be placed in position p = name-ptt, otherwise p will point to its existing location. ( Compute the name location p 55 ) f
p +- hash [h]; while p # 0 do
begin if length(p) = 1 then ( Compare name p with current identifier, goto found if equal 56); p t link[p]; end; p + name-ptr; { the current idcntificr is new } link[p] t haxh[h]; hash[h] + p; { insert p at beginning of hash list } jound:
This code is used in section 53.
56. ( Compare name 1~ with current identifier, goto found if equal 5~) s begin i +- id-/irst ; k t- byte-start [p]; w t p mod WW; while (i < id&c) A (bufler [i] = byte-mem[w, k]) do b e g i n incr(i); incr(k); end; if i = id.loc then goto found; { all characters agree } end
This co& is nscd in section 55.

57 TANGLE

SEARCHING FOR IDENTIFIERS 141

57. (`IJpdatc the tables and check for possible errors 57 ) begin if ((p # name-ptr ) A (t # normal) A (ilk [p] = normal)) V ((p = name-ptr) A (t = normal) A (bufler [id-first] # """")) then ( Compute th e secondary hash code h and put the first characters into the auxiliary array chopped-id 58 ); if p # name-ptr then ( Give double-definition error and change p to type t 59) else (Enter a new identifier into the table at position p 61); end
This code is used in section 53.

58. The following routine, which is called into play when it is necessary to look at the secondary hash table, computes the same hash function as before (but on the chopped data), and places a zero after the chopped identifier in chopped-id to serve as a convenient sentinel.
( Compute the secondary hash code h and put the first characters into the auxiliary array chopped-id 58) s begin i +- id-first; s t 0; h t 0; while (i < id-lot ) A (s < unambig-length) do begin if buJer [i] # `t-9' then begin if bufler [i] 2 "a" then chopped-id[s] + bu#er [i] - '40 else chopped-id [s] t bufler [i]; h + (h + h + chopped-id [s]) mod hash-size ; incr (a); end; incr (i); end; chopped-id [s] t 0; end
This code is used in section 57.

59. If a macro has appeared before it was defined, TANGLE will still work all right; after all, such behavior is typical of the replacement texts for modules, which act very much like macros. However, an undefined numeric macro may not be used on the right-hand side of another numeric macro definition, so TANGLE finds it simplest to make a blanket rule that macros should be defined before they are used. The following routine gives an error message and also fixes up any damage that may have been caused.
( Give double-definition error and change p to type t 59) = { now p # name-ptr `and t # normal }.
begin if ifk[p] = normal then begin err-print ('!,This,identifieruhasualreadyuappeared'); ( Remove p from secondary hash table 60 ); end
else err-print ( ' !LThisbidentifierUuasl defined,,before') ilk[p] +- t; _ end
This code is usctl in section 57.

60. VC'hen WC have to remove a secondary hash entry, because a normul identifier is changing to another ilk, the hash code h and chopped identifier have already been computed.
( Remove p from secondary hash table 60 ) q + chop-hash [h]; if q = p then chop-hash[h] +- equiv[p] else begin while equiv [q] # p do q t- equiv[q]; cquiv [q] f- cquiv (p]; end
`I'llis coder ix uwd in section 59.

142 SEARCHING FOR IDENTIFIERS

TANGLE 61

61. The following routine could make good use of a gcncralized pack procedure that puts items into just
part of a packed array instead of the whole thing.
(Enter a new identifier into the table at position p 61) begin if (t = normal) A (bufler[id-first] # """") then ( Check for arnbiguit,y and update secondary hash 62 ); w +- name-ptr mod WW; k t byte-ptr[w];
tif k + 2 > maz-bytes then overflow ( `byt e,memory `);
if name-ptr > max-names - ww then overflow ( `name `); i + id-first; { g e ready to move the identifier into byte-mem } while i < id-Jot do
begin byte-mem [w, k] t bufler [i]; incr (k); incr (i); end; byte-ptr [w] +- k; byte-start (name-ptr + ww] - k; incr (name-ptr); if bufler [id-first] # """" then iZk[p] t t else (Define and output a new string of the pool 64 ); end
This code is used in section 57.

62. ( Check for ambiguity and update secondary hash 62 ) s begin q t chop-ha&[/t]; while q # 0 do begin ( Check if q conflicts with p 63);

Q +-- `?Piv [(II; end; equiv [p] t chop-hash[h]; chophaah[h] + p; end

{ put p at front of secondary list }

This code is used in section 61.

63. ( Check if q conflicts with p 63 ) E begin k t byte-start [q]; s t 0; w e q mod ww; while (k < byte-sturt [q + ww]) A (a < unum&g-length) do begin c +- byte-mem [w, k]; if c # I'-" then begin if c 2 "a" then c +- c - `40; { convert to uppercase } if chopped.id[a] # c then goto not-found;
incr (a); end; incr (k); end; if (k = byte.Anrt [(I + WW]) A (choppeLid[a] # 0) then goto not.Jound; print-n1( * !,Identif ierLconflict,withu'); for k t- byte-sturt [q] to byte-start [q + ww] - 1 do print (schr (byte-mcm [w, k]]); e77or; (I +-- 0; { only OILC conflict will be printecl, since equiv [0] = 0 } not-found: end
This code is used in section 62.

64 TANGLE

SEARCHING FOR IDENTIFIERS 143

64. We compute the string pool check sum by working modulo a prime number t'hat is large but not so ' large that overflow might occur.
define check-sum-prime E `3777777671 ( 229 - 73 )
Define and output a new string of the pool 64) 3 begin ilk [p] +- numeric; { strings are like numeric macros } if 2 - double-chars = 2 then (this &ring is for a single character }
equiv[p] +- bufler [idfirst + l] + `100000 else begin equiw [p] + string-ptr + `100000; 1 t 1 - double-chars - 1;
if I > 99 then err-print ( ' !uPreprocessedustringuisutooulong'); incr (string-ptr); write (pool, zchr ["Ott + 1 div IO], zchr ["O" + I mod lo]); { output the length } pool-check-sum t pool-check-sum + pool-check-sum + 1; while pool-check-sum > check-sum-prime do pool-check-sum t pool-check-sum - check-sum-prime; i t id-first + 1; while i < id-foe do
begin write (pool, xchr [auger [;I]); { output characters of string } pool-check-sum + pool-check-sum + pool-check-sum + buffer [i]; while pool-check-sum > check-sum-prime do pool-check-sum + pool-check-sum - check-sum-prime; if (buJer[i] = tttttt't) V (bufler [i] = l'@") then i + i + 2
{ omit second appearance of doubled character } else incr (i); end; write -In (pool) ; end; end
This code is used in section 61.

144 SEARCHING FOR MODULE NAMES

TANGLE 65

65. Searching for module names. The mod-lookup procedure finds the module name mod-text [I . . 11 in the search tree, after inserting it if necessary, and returns a pointer to where it was found.
( Globals in the outer block 9 ) +r mod-text: array (0 . . longest-name] of ASCII-code; {name being sought for }

66. According to the rules of WEB, no module name should be a proper prefix of another, so a "clean" comparison should occur between any two names. The result of mod-lookup is 0 if this prefix condition is
violated. An error message is printed when such violations are detected during phase two of WEAVE.

define leas = 0 { the first name is lexicographically less than the second } define equal = 1 { the first name is equal to the second } define greater = 2 { the first name is lexicographically greater than the second } define prefix = 3 { the first name is a proper prefix of the second }
define eztenaion = 4 { the first name is a proper extension of the second }

function mod-lookup (I : sixteen-bits): name-pointer ; { finds module name } label found; var c: leas . . extension; { comparison between two names } j: 0 . . longest-name; {index into mod-tezt } k: 0 . . max-bytes; {index into byte-mem } w : 0 . . ww - 1; {segment of byte-mem } p: name-pointer ; { current node of the search tree } q: name-pointer; { father of node p }
begin c t greater; q +- 0; p t rlink[O]; { rlink [0] is the root of the tree} while p # 0 do
begin ( Set c to the result of comparing the given name to name p 68);

Q +- P; if c = leas then p t lZink[q] else if c = greater then p t rlink[q]
else goto found; end; (Enter a new module name into the tree 67 ); found: if c # equal then begin err-print ( `!LIncompatibleUsectionUnames'); end;
motl-lookup +-- P; end:

p + 0;

67. (Enter a new module name into the tree 67 ) EZ' w +- name-ptr mod ww; k t byte-ptr [w]; if k + 1 > max-hyte.s then owerjZow ( `byteUmemory `); if nnme-ptr > max-names - ww then overflow ( `name `); p t nnnie-ytr; if .c = leu,~ then flink[q] +- p else rlink[q] +-- p; lfink [p] t 0; rlink [p] t 0; c t equal; equiv [p] t 0; for j e 1 to 1 do byte-rnem[w, k + j - I] t mod-text [j]; Dyte-ptr [w] t k + I; byte-start [name-ptr + ww] t- k + I; incr (name-ptr);
This code is wed in section 66.

W TANGLE

SEARCHING FOR MODULE NAMES

68. ( Set c to the result of comparing the given name to name p 68 ) 3 begin k c byte-start [p]; w t p mod UW; c t equal; j t 1; while (k < byte-start [p + uw]) A (j 5 I) A (mod-text [j] = byte-mem [w, Cc]) do begin incr (k); incr (j); end; if k = byte-start [p + WW] then if j > 1 then c +- equal else c f- extension else if j > 1 then c t prefiz else if mod-text [j] < byte-mem[w, k] then c t less else c +-- greater; end
This code is used in sections 66 and 69.

145

69. The prefix-lookup procedure is supposed to find exactly one module name that has mod-text [I . . 11 as a prefix. Actually the algorithm silently accepts also the situation that some module name is a prefix of mod-text [l . . Z], b ecause the user who painstakingly typed in more than neccssuy probably doesn't want to be told about the wasted effort.
function prefix-lookup (I : sixteen-bits): name-pointer; { finds name extension } var c: less . . extension; { comparison between two names } count: 0 . . max-names ; { the number of hits } j : 0 . . longest-name ; { index into mod-text }
k: 0 . . max-bytes; {index into byte-mem ) UJ: 0 . . ww - 1; {segment of byte-mem } p: name-pointer; { current node of the search tree } q: name-pointer ; ( another place to resume the search <after one branch is done } r: name-pointer; { extension found } begin q t 0; p +- rlink[O]; count t 0; r t- 0; {begin search at root of tree } while p # 0 do begin ( Set c to the result of comparing the given name to name p 68 ); if c = leas then p t llink[p] else if c = greater then p +- rfink[p]
else begin r e p; incr (count); q t rZink[p]; p +- flink [p]; end;
if p = 0 then begin p t q; q t 0; end;
end; if count # 1 then
if count = 0 then err-print ( ' !,Name,does,notumatch `) else err-print ( ' ! ,AmbiguousLpref ix `); prefix-lookup +-- r; { the rctsult, will bc 0 if there was no match } end;

146 TOKENS

TANGLE 70

7 0 . T o k e n s . Replacement texts, which represent I'ASCAL code in a compressed format, appear in tok-mem as mentioned above. The codes in these texts are called `tokens'; some tokens occupy two consecutive eight-bit byte positions, arid the others take just one byte.
If p > 0 points to a replacement text, tok-start [p] is the tok-mem position of the first eight-bit code of that text. If text-Zink[p] = 0, tllis is the replacement text for a macro, otherwise it is the replacement text for a module. In the latter case text-Zink[p] is either equal to module-flag, which means that there is no further text for this module, or text-Zink(p] p oints to a continuation of this replacement text; such links are created when several modules have PASCAL texts with the same name, and they also tie together all the PASCAL texts of unnamed modules. The replacement text pointer for the first unnamed module appears in text-link [O], and the most recent such pointer is last-unnamed.
define module-jlag G max-texts {final link in module replacement texts }
( Globals in the outer block 9) +r last-unnamed: text-pointer ; { most recent replacement text of unnamed module }

71. (Set initial values 10) +E last-unnamed t 0; text-Zink[O] t- 0;

72. If the first byte of a token is less than `ZOO, the token occupies a single byte. Otherwise we make a sixteen-bit token by combining two consecutive bytes a (and 6. If `ZOO 5 u < `250, then (a - `200) x 28 + 6 points to an identifier: if `,??,50 5 a < `920, then (a - `250) x 28 + b points to a module name; otherwise, i.e., if '320 5 a < `400, then (a - '320) x 28 + 6 is the number of the module in which the current replacement text appears.
Codes less than '200 are `I-bit ASCII codes that represent themselves. In particular, a single-character identifier like `2'will be a one-byte token, while all longer ident,ifiers will occupy two bytes.
Some of the 7-bit ASCII codes will not be prcscnt, however, so we can use them for special purposes. The following symbolic names are used:
param denot,es insertion of a parameter. This occurs only in the replacement texts of parametric macros, outside of single-quoted strings in those texts.
begin-comment denotes @{, which will become either { or [. end-comment denotes @}, which will become either 3 or I. octal denotes the Q' that precedes an octal constant. hex &notes the @`I that precedes a hexadecimal constant. check-sum denotes the O$ that &notes the string pool check sum. join denotes the concatenation of adjacent items with no space or line breaks allowed bctwcen them (the
@& operation of WEB). double-dot denotes `. . ' in PASCAL. verbutim denot,es the Q= that begins a verbatim PASCAL string. It is also used for the end of the string. force-line denotes the @\ that forces a new line in the PASCAL output.
define param = 0 { ASCII ml1 code will not appear} define verbatim = `,5' { extended ASCII alpha should not appear } define jorce-line = `3 { extended ASCII beta should not appear } define begin-comment = `If { ASCII tab mnrk will not appear }
define end-comment = `I,!? { ASClI line feed wilI not appear } define octul = `14 {ASCII form feed will not appear } define hex = `15 {ASCII carriage return will not appear } define double-dot = `40 { ASCII space will not appear except in strings } define check-sum = `175 { wi 11 not bc ~o~lfilsed with right brace } define join = `177 { ASCII delete will not appear }

73 TANGLE

. TOKENS 147

73. The following procedure is used to enter a two-byte value into tok-mem when a replacement text is being generated.
procedure store-two-bytes (5 : &teen-bits); { stores high byte, then low byte } begin if tok-ptr [z] $ 2 > mazAoks then ouet$ow (`token'); tok-mem [z, tok-ptr [z]] t x div `400; { this could be done by a shift command } tok-mem[z, tok-ptr [z] + l] +- xmod `400; { this could be done by a logical and } tok-ptr [z] + tok-ptr [z] + 2; end;

74. When TANGLE is being operated in debug mode, it has a procedure to display a replacement text in symbolic form. This procedure has not been spruced up to generate a real great format, but at least the results are not as bad as a memory dump.
d e b u g p r o c e d u r e print-repZ(p : t e x t - p o i n t e r ) ; var k: 0 . . max-toks; { index into tok-mem }
a: sixteen-bits ; { current byte(s) } zp: o..zz-1; { segment of tok-mem being accessed } begin if p 2 text-ptr then print ( `BAD `) else begin k +-- tok-start [p]; zp t pmod zz; while k < tok-start [p + zz] do
begin a + tok-mem[zp, k]; if a 1 `200 then ( Display two-byte token starting with a 75 ) else (Display one-byte token a 76); incr (k); end;

75. ( Display t wo-byte token starting with a 75 ) G begin incr (k); if a < `ET0 then { identifier or string } begin u +- (u - `!?OO) * `400 t tok-mem[zp, k]; print-id(u); if byte-mem [u mod ww , byte-start [u]]. = "`1"1' then print ( l " `) else print ( `U `); end else if a < `320 then { module name} begin print ( `CX `); printd( (a - `,250) * `400 + tok-mem[zp, k]); print (`9> `);
end else begin a t (a - `320) * `400 + tok-mem [zp, k]; { module number }
print( `Q', xchr["("],u : 1, `Q', xchr["3"]); { can't use right brace between debug and gubed } end;
end
This code is used in section 74.

148 TOKENS

TANGLE

76. (Display one-byte token a 76) E case a of begin-comment : print ( `Q ', zchr ["("I); end-comment: print ( `Q', zchr ["3"]); { can't use right brace between debug and gubed } octal: print(`@"`); hez : print ( `62" `); check-sum: print ( `9$ `); purum: print (`II'); "@": print ( `QQ `); verbatim: print ( `@I= `); force-line : print ( `O\ `); othercases print (zchr [a]) endcases
This code is used in section 74.

76

77 TANGLE

STACKS. FOR OUTPUT

149

7 7 . S t a c k s f o r o u t p u t . Let's make sure that our data structures contain enough information to produce . ' the entire PASCAL program as desired, by working next on the algorithms that actually do produce that
program.

78. The output process uses a stack to keep track of what is going on at different "levels" as the macros are being expanded. Entries on this stack have five parts:
end-field is the tok-mem location where the replacement text of a particular level will end; byte-field is the tok-mem location from which the next token on a particular level will be read; name-field points to the name corresponding to a particular level; repl-field points to the replacement text currently being read at a particular level. mod-field is the module number, or zero if this is a macro.
The current values of these five quantities are referred to quite frequently, so they are stored in a separate place instead of in the stuck array. We call the current values cur-end, cur-byte, cur-name, cur-repl, and cur-mod.
The global variable stack-ptr tells how many levels of output are currently in progress. The end of all output occurs when the stack is empty, i.e., when stuck-ptr = 0.
( Types in the outer block 11) +g output-state = record end-field: sixteen-bits; { ending location of replacement text }
byte-field: sixteen-bits ; {present location within replacement text } name-field: name-pointer ; { byte-start index for text being output } repl-field: text-pointer ; { tok-start index for text being output } mod-field: 0 . . `27777; { module number or zero if not a module } end;

79. define cur-end G cur-stute.end$eld { current ending location in tok-mem } define cur-byte s cur-state. byte-field { 1ocation of next output byte in tok-mem > define cur-name G cur-stute.nume-field {pointer to current name being expanded} define cur-repl EZ cur-state .repLfieZd { pointer to current replacement text } define cur-mod s cur-state.mod-field - { current module number being expanded }
( Globals in the outer block 9 ) +r cur-state : output.Aate ; { cur-end, cur-byte, cur-nume, cur-rep1 ) stuck: array [1 . . stuck-size] of output-state; { info for non-current levels } stuck-ptr: 0 . . stuck-size; { first unused location in the output state stack }

80. It is convenient to keep a global variable zo equal to cur-repl mod zz.
(Globals in the outer block 9). += 20: o..zz - 1 ; { the segment of tok-mem from which output is coming }

81. Parameters must <also be stacked. They arc placed in tok-men? just above the other replacement texts, and dummy par;lmctcr `I~.~IICS' are placed in byte-stnrt just after the other names. The vcariables text-ptr and tok-ptr [z] cssc~ntially serve <as par~amctcr stack pointers during the output phase, so there is no need for
a separate data structure to handle this prohlcm.

82. There is an implicit stack corresponding to meta-comments that are output via Q( and @). l3ut this stack need not be represented in detail, because we only need to know whether it is empty or not. A global variable brace-level tells how many items would be on this stack if it were present.
( Globals in the outer block 9) +Z brute-level: eight-bits; { current depth of Q( . . . Q} nesting )

150 STACKS FOR OUTPUT

TANGLE

83

83. To get the output process started, we will perform the following initialization steps. We may assume that text-link: [0] is nonzero, since it points to the PASCAL text in the first unnamed module that generates code; if there are no such modules, there is nothing to output, and an error message will have been generated before we do any of the initialization.
(Init,ialize the output stacks 83 ) f stack-ptr +- 1; brace-level +- 0; cur-name t 0; cur-rep2 t text-Zink[O]; zo t cur-repl mod zz; cur-byte +- tok-start [cur-repl]; cur-end t tok-start [cur-repl + zz]; cur-mod t- 0;
This code is used in section 112.

84. When the replacement text for name p is to be inserted into the output, the following subroutine is called to save the old level of output and get the new one going.

procedure push-level (p : name-pointer); { suspends the current level }

begin if stack-ptr = stack-size then overfEow(`stack')

else begin stack [stack-ptr] t cur-state; { save cur-end, cur-byte, etc. }

incr

(stack-ptr);

cur-name

+-

p;

cur-repl

t

equiv

[p];

zo

t

cur-repl

mod

zz

. 7

cur-byte +- tok-start [cur-repl]; cur-end +- tok-start [cur-repl + zz]; cur-mod +-- 0;

end;

end;

85. When we come to the end of a replacement text, the pop-level subroutine does the right thing: It either moves to the continuation of this replacement text or returns the state to the most recently stacked level. Part of this subroutine: which updates the parameter stack, will be given later when we study the parameter stack in more detail.
procedure pop-level; { do this when cur-byte reaches cur-end }
label exit; begin if text-Zink[ cur-repl] = 0 then { end of macro expansion }
begin if ilk [ cur-name] = parametric then ( Remove a parameterfrom the parameter stack 91); end else if text-link [cur-repl] < module-flag then { link to a continuation }
begin cur-repl +- text-link [ cur-rejl]; { we will stay on the same level } zo +- cur-repl mod zz ; cur-byte + tok-start [ cur-repl]; cur-end t tok-start [cur-repl + zz]; return;
end; deer (stack-ptr ); {WC will go down to the previous level } if stack-ptr > 0 then
begin cur-state t stack [stack-ptr]; zo t cur-repl mod zz;
end; exit: end;

86. The heart of the output procedure is the get-output routine, which produces the next token of output that is not a rcfcrcncc to a macro. This procedure handles all the stacking cand unstacking that is necessary. It returns the value number if the next output has it numeric value (the value of a numeric macro or string), in which case cur-vul 1liM been set to tho nurnbcr in question. The procedure also returns the value module-number if the next output l)cgins or ends the replacement text of some module, in which case cur-vnl is that n~odulc's number (if beginning) or the negative of that value (if ending). And it returns the value identi/ier if the next output is an identifier of length two or more, in which case cur-val points to that identifier name.
define number z `200 {code returned by get-output when next output is numeric > define moduZe_numher = `201 { code returned by get-output for module numbers } define identijicr = `202 { co d c returned by gf:t-output for identifiers }
( Glob& in the ou tcr block 9 ) +E cur-val: integer; { additional information corresponding to output token }

87 TANGLE

STACFS FOR OUTPUT

87. If get-output finds that no more output remains, it returns the value zero.
function get-output: sixteen-bits; {returns next token after macro expansion } label restart, done ,found; var a: sixteen-bits ; { value of current byte } 6: eight-bits; {byte being copied } bal : aixt een-bits; { excess of ( versus ) while copying a parameter } k: 0 . . max-bytes; {index into byte-mem } w : 0 . . ww - 1; {segment of byte-mem } b e g i n r e s t a r t : i f stackptr = 0 t h e n
begin a +- 0; goto found; end; if cur-byte = cur-end then begin cur-val t -cur-mod; pop-level;
if cur-val = 0 then goto restart; a t module-number; goto found; end; a t tok-mem[zo, cur-byte]; incr (cur-byte); if a < `200 then { one-byte token } if a = param then ( Start scanning current macro parameter, goto restart 92 ) else goto found; a t (a - `200) * `400 + tok-mem[zo, cur-byte]; incr (cur-byte); if a < `24000 then { `24000 = ( `250 - `200) * `400 } (Expand macro a and goto found, or goto restart if no output found 89); if a < `50000 then { `50000 = ( `320 - `200 ) * `400 } ( E x p a n d m o d u l e a - `%/OOO, goto r e s t a r t 8 8 ); cur-val t a - `50000; a t module-number; cur-mod + cur-val;
jound: debug if trouble-shooting then debug-help; gubed get-output t a; end;

151

88. The user may have forgotten to give any PASCAL text for a module mame, or the PASCAL text may have been associated with a different name by mistake.
( Expand n~odule a - `jOOO, goto restart 88 ) G begin a t- a - `24OOO; if equiv [a] # 0 then push-level(a) else if u # 0 then begin print-nZ ( * ! ,Nothpresent : L< `); print-id(u); print ( `> `); error; end; got0 restart; end
This code is llsed in wction 87.

152 STACKS FOR OUTPUT

TANGLE

89. (Expand macro a and goto found, or goto restart if no output found 89) z ' b e g i n c a s e iZk(a] o f
normal: begin cur-val t a; a' +-- identifier; end;
numeric : begin cur-vu1 t equiv [a] - `100000; a +- number; end;
simple: begin push-level (a); goto resturt ; end;
parametric : begin (Put a parameter on the parameter stack, or goto restart if error occurs 90); p u s h - l e v e l ( a ) ; goto restart; end;
othercases confusion ( `output `) endcases;
goto found; end
This code is used in section 87.

89

90. We come now to the interesting part, the job of putting a parameter on the parameter stack. First we pop the stack if necessary until getting to a level that hasn't ended. Then the next character must be a ` (`; <and since parentheses are balanced on each level, the entire parameter must be present, so we can copy it without difficulty.
(Put a parameter on the parameter stack, or goto restart if error occurs 90) G while (cur-byte = cur-end) A (stack-ptr > 0) do pop-level; if (stack-ptr = 0) V (tok-mem[zo, cur-byte] # I'(") then begin print-nZ ('! ,No,parameterUgivenuf o r , , `) ; p r i n t - i d ( a ) ; e r r o r ; goto restart ; end; (Copy the parameter into tok-mem 93); equiv [name-ptr] c text-ptr ; ilk [nume-ptr] t simple; w t name-ptr mod ww; k t byte-ptr [w]; debug if k = max_bytes then overflow ( `byte,memory `); byte-mem[w, k] t `I#"; incr(k); byte-ptr[w] + k; gubed { this code has set the parameter identifier for debugging printouts } if name-ptr > max-names - ww then overflow ( `name `); byte-start [name-ptr + ww] +- k; incr (name-ptr); if text-ptr > max.-texts - zz then overflow ( `text `); text-link [text&r] t 0 ; to/c-stnrt[text-ptr + z] t tokptr[z]; incr ( t e x t - p t r ) ; z + t e x t - p t r m o d zz
This code is used in section 89.

91. The pop-level routine undoes the effect of par(ameter-pushing when a parameter macro is finished:
(Remove a parameter from the parameter stack 91) E begin deer (nclme-ptr ): deer (text-ptr ); z t text-ptr mod zz ;
tat,?stat if tok-ptr [z] > max-tok-ptr [.z] then mnx-tok-ptr (z] +-- tok-ptr (z]; { thcl mx-&[llm~ v;~luc; of tok-ptr occurs just before parantetor popping } tok-ptr (z] t tok-start [text-ptr]; debug deer (byte-ptr [ name-ptr mod ww]); gubed end
This code is used in section 85.

92 TANGLE

STACKS FOR OUTPUT 153

92. When a parameter occurs in a replacement text, we treat it as a simple macro in position (name@ -1):
( Start scanning current macro parameter, goto restart 92) 3 begin push-level (name-ptr - 1); goto restart; end
This code is used in section 87.

9 3 . Similarly, a param token encountered as we copy a parameter is converted into a simple macro call for name-ptr - 1. Some care is needed to handle cases like macro (#; print ( `#) `)); the # token will have been changed to param outside of strings, but we still must distinguish `real' parentheses from those in strings.

define app-repl (#) s begin if tok-ptr [z] = max-toks then overflow (`token');
tok-mem [z, tok-ptr [z]] t #; incr (tok-ptr [xl); end

( Copy the parameter into tok-mem 93 ) E

bal + 1; incr (cur-byte); { skip the opening `('}

loop begin b t tok-mem [zo, cur-byte]; incr (cur-byte );

if b = param then store-two-bytes (name-ptr + `77777)

else begin if b 1 `200 then

begin app-repZ(b); b c tok-mem [zo , cur-byte]; incr (cur-byte);

end

else case b of tt ( Il.* incr (bal);

"> `I: begin deer (bal);

if bal = 0 then goto done;

end;

""I: repeat app-repZ(b); b t tok-mem [zo, cur-byte]; incr (cur-byte);

until b = (1 "1; { copy string; don't change bal }

.

othercases do-nothing

endcases;

UPP-rePl (b); end; end; done:
This code is used in section 90.

154 PRODUCING THE OUTPUT

TANGLE

94

9 4 . P r o d u c i n g t h e o u t p u t . The get-output routine above handles most of the complexity of output
generation, but there are two further considerations that have a nontrivial cffcct on TANGLE's (algorithms. First, we want to make sure that the output is broken into lilies not exceeding line-length characters per
line, where these breaks occur at valid places (e.g., not in the middle of a string or a constant or an identifier, not between `<' and `>`, not at a `@&' position where quantities arc being joined together). Therefore we assemble the output into a buffer before deciding where the line breaks will appear. However, we make very little attempt to make "logical" line breaks that would enhance the readability of the output; pcoplc are supposed to read the input of TANGLE or the wed output of WEAVE, but not the tangled-up output. The only concession to readability is that a break <after a semicolon will be made if possible, since commonly used "pretty printing" routines give better results in such cases.
Second, we want to decimalize non-decimal constants, and to combine integer quantities that are added or subtracted, because PASCAL doesn't allow constant expressions in subrange types or in case labels. This means we want to have a procedure that treats a construction like (E-15+17) as equivalent to `(E+2)`, while also leaving `(lE-15+17)' and `(E-15+17*y)' untouched. Consider also `-15+17.5' versus `-15+17. .5'. We shall not combine integers preceding or following *, /, div, mod, or @&. Note that if y has been defined to equal -2, we must expand `x*y' into `x* (-2)`; but `x-y' can expand into `x+2' and we can even change `x - y mod z' to `x + 2 mod z' because PASCAL has a nonstcandard mod operation!
The following solution to these problems has been adopted: An array out-buf contains characters that have been generated but not yet output, and there are three pointers into this array. One of these, out-ptr, is the number of characters currently in the buffer, and we will have 1 < out@ 5 line-length most of the time. The second is break@: which is the largest value 5 out&r such that we are definitely entitled to end a line by outputting the characters out-buf [I . . (break-ptr - l)]; we will always have break-ptr 5 line-length. Finally, semi-ptr is either zero or the largest known value of a legal break after a semicolon or comment on the current line; we will always have semi-ptr 5 break-ptr .
( Globals in the outer block 9 ) +out-buf : array [0 . . out-buf-size] of ASCII-cocle ; { assembled characters } Out-ptr : 0 . . out-buf-size ; { first available place in out-buf } break-ptr : 0 . . out-buf-size ; { last breaking place in out-buf } semi-ptr: 0 . . out-buf-size; {last semicolon breaking place in out-buf }

.

95 TANGLE

PRODUCING. THE OUTPUT

155

95. Besides having those three pointers, the output process is in one of several states:
num-or-id means that the last item in the buffer is a number or identifier, hence a blank space or line break must be inserted if the next item is also a number or identifier.
un breakable means that the last item in the buffer wcas followed by the @& operation that inhibits spaces between it and the next item.
sign means that the last item in the buffer is to be followed by + or -, depending on whether out-app is positive or negative.
sign-vu1 means that the decimal equivalent of 1 out...val 1 should be appended to the buffer. If out-val < 0, or if out-val = 0 and last-sign < 0, the number should be preceded by a minus sign. Otherwise it should be preceded by the character out-sign unless out-sign = 0; the out-sign variable is either 0 or II Ll11 or o+tt .
sign-val-sign is like sign-val, but also append + or - afterwards, depending on whether out-app is positive or negative.
sign-val-val is like sign-val, but also append the decimal equivalent of out-app including its sign, using last-sign in case out-app = 0.
mist means none of the above.
For example, the output buffer and output state run through the following sequence as we generate characters from `(x-15+19-2)`:

output

out-buf

out-state
mist num-or-id
sign sign-val sign-val-sign sign-val-vu1 sign-yal-sign sign-val-vu1
mist

out-sign
II+ 11 ll+ 11 11 + 11 ll+ 1t
II + II

out-vu1
-15 -15 -15 +4 +4

out-app
-1
+1 $19 -1 -2

last-sign
-1 -15 +l +1 -1 -2

At each st,age WC have put as much into the buffer as possible without knowing what is coming next. Ex~amplcs like `x-0.1' indicate why last-sign is necdcd to cassociatc the proper sign with an output of zero.
In states num-or-id, unbreakable, and mist the last item in the buffer lies between breuk-ptr and out-ptr -1, inclusive; in the other states we have break-ptr = out-ptr.
The numeric values assigned to num-or-id, etc., have been chosen to shorten some of the program logic; for example, the progr;lln makes use of the fact that sign + 2 = sign-val-sign.
define mist = 0 { state associated with special characters } define num-or-id = 1 { state associated with numbers and identifiers} define sign = 2 {stato associated with pending + or - } define sign-val = num -or-id + 2 { state associated with pending sign and value } define sign-val-sign = sign + 2 { sign-val followed by another pending sign } define sign-val-val = sign-vu2 + 2 { sign-vu1 followed by another pending value } define unbreakable = sign-val-vu1 + 1 { state associated with UC }
( Globals in the outer block o ) +E out-state : eight-bits ; {current status of partial output } out-vu1 , out-app : integer ; { pending values } out-sign : ASCII-code ; {sign to USC if appending out-val 2 0 > last-sign : -- 1 . . +l; { sign to use if appending a zero }

156 PRODUCING THE OUTPUT

TANGLE .

96. During the output process, line will equal the number of the next line to be output.

' ( Initialize the output buffer M > e out-state +-- mist; out-ptr +-- 0; break-ptr t 0; semi-ptr t 0; out-6uf[O] +- 0; line + 1;

This code is used in section 112.

96

97. Here is a routine that is invoked tihen out-ptr > line-length or when it is time to flush out the final line. The fZush_bufler procedure often writes out the line up to the current break-ptr position, then moves the remaining information to the front of out-buf . However, it prefers to write only up to semi-ptr , if the residual line won't be too long.
d e f i n e c h e c k - b r e a k zz if out-ptr > line-length then flush-6uJer
procedure flush-6uJer ; {writes one line to output file } var k: 0 . . out-buf-size ; { index into out-buf } b: 0 . . out-buf-size; {value of break-ptr upon entry } begin b +- break-ptr ; if (semi-ptr # 0) A (out-ptr - semi-ptr 5 line-length) then 6reak-ptr + semi-ptr; for k t 1 to break-ptr do write (Pascal-file, zchr[out-buf [k - I]]); write_ln(pascaZ_file); incr(line); if line mod 100 = 0 then begin print ( ' . `); if line mod 500 = 0 then print (line : 1); update-terminal; { progress report }
end; if break-ptr < out-ptr then
begin if out-buf [ break-ptr] = `lulV then begin incr (break-ptr ); { drop space at break } if break-ptr > b then b t break-ptr ; end;
for k +- break-ptr to out-ptr - 1 do but-6uf [k - breuk-ptr] t out-buf [k];
end; out-ptr +- out-ptr - break-ptr ; break-ptr t b - break-ptr ; semi-ptr t 0; if out-ptr > line-length then
begin err-print ( ' ! ,LongUlineUmustUbeUtruncated `); out-ptr t line-length; end;
end;

98. ( Empty the last line from the buffer 08 ) F breuk-ptr +- out-ptr ; semi-ptr +- 0; flush-bufler ; if brace-level # 0 then err-print ( ' !uProgram,endeduat~braceUlevelU',
This code is used in section 112.

brace-level : 1);

99 TANGLE

PRODUCING THE OUTPUT 157

99. Another simple and useful routine appends the decimal equivalent of a nonnegative integer to the output buffer.

define app (#) = begin out-buf [out-ptr] t #; incr (out-ptr );
end

{append a single character }

procedure app-vu2 (v : integer ); { puts v into buffer, assumes v 1 0 } var k: 0 . . out-buf-size; { index into out-buj } begin k +- out-buf-size; { first we put the digits at the very end of out-6uf }
repeat out-buf [k] +- v'mod 10; v +- v div 10; deer (k); until v = 0;
repeat incr (k); app (out-6uf [k] + "0"); until k = out-buf-size ; { then we append them, most significant first }
end;

100. The output states are kept up to date by the output routines, which are called send-out, send-val, and send-sign. The send-out procedure has two parameters: t tells the type of information being sent and v contains the information proper. Some information may also be passed in the array out-contrib.
If t = mist then v is a character to bc output. If t = str then v is the length of a string or something like `<>'in outxontrib. If t = ident then v is the length of an identifier in out-contrib. If t = frac then v is the length of a fraction and/or exponent in out-contrib.
define str = 1 { send-out code for a string } define ident = 2 { send-out code for an identifier} define frac = 3 { send-out code for a fraction }
( Globals in the outer block 9) +E dut-contrib: array [l . . line-length] of ASCII-code ; {a contribution to out-buf }

101. A slightly subtle point in the following code is that the user may ask for a join operation (i.e., @a) following whatever is being sent out. We will see later that join is implemented in part by calling send-out (frac , 0).
procedure send-out (t : eight-bits; v : sixteen-bits); {outputs v of type t } label restart; var k: 0 . . line-length; {index into out-contrib } begin ( Get the buffer ready for appending the new information 102); if t # mist then
for k + 1 to v do app( out-contrib[k]) else upp (v); check-break; if (t = mist ) A ((v = `I ; It) V (v = ">`I)) then
begin semi-ptr t out-ptr; 6reak-ptr t out-ptr;
end; if t > ident then out-state t- num-or-id {t = ident or frac } else out-state t mist {t = str or mivc }
end;

158 PRODTJCING THE OUTPUT

TANGLE
.

$102

102. Here is where the buffer states for signs and values collapse into simpler states, because we are about

' to append something that doesn't combine with the previous integer constants.

We use an ASCII-code trick: Since ", *' - 1 = I'+" and " ," + 1 = "-`I, we have ", " - c = sign of c, when

(cl = 1.

( Get the buffer ready for appending the new information 102) G restart: case out-state of
num-or-id: if t # frac then begin break-ptr t out-ptr ; if t = ident then uyp (ItU1'); end;
sign: begin app ( `I, `I - out-app); check-break; break-ptr t out-ptr ; end;
sign-val, sign-val-sign : begin (Append out-vaf to buffer 103 ); out-state t out-state - 2; got0 restart; end;
sign-val-val: ( Reduce sign-val-vaf to sign-val and goto restart 104 ); miac: if t # frac then break-ptr t out-ptr ;
othercases do-nothing { this is for unbreakable state } endcases

This code is used in section 101.

1 0 3 . ( A p p e n d o u t - d t o b u f f e r 103) z if (out-val < 0) v (( out-val = 0) A (lust-sign < 0)) then app (`I-") else if out-sign > 0 then app( out-sign); app-vu1 (aba (out-val)); check-break;
This code is lwed in sections 102 and 104.

104. ( Reduce sign-val-vul to sign-val and goto restart 104 ) 3 begin if (t = fruc) V ((C ont ribu tion is** or / or DIV or MOD 105)) then begin ( Append out-vnl to buffer 103 );
out-sign t I'+"; out-vu1 4- out-app; end else out-vu1 +-- out-val + out-app; out-state +- sign-val; got0 restart;
end
This code is used in section 102.

105. ( Contribution is * or / or DIV or MOD 105) 3 ((t = ident) A (v = 3) A (( (out-contrib (11 = 'ID") A (out-contrib [2] = "I") A (out-contrib [3] = "VI')) V (( out-contrib [l] = "M") A (out-contrib [2] = "0") A (out-contrib [3] = "D")))) V ((t = mist) A ((v = `I*") V (w = "/")))
This co_dc is used in section 104.

5106 TANGLE

PRODUCING THE OUTPUT 159

106. The following routine is called with v = fl when a plus or minus sign is appended to the output. It extends PASCAL to allow repeated signs (e.g., `-- ' is equivalent to `+`), rather than to give an error message. The signs following `E' in real constants are treated as part of a fraction, so they are not seen by this routine.
procedure send-sign (v : integer); begin case out-state of sign, sign-val-sign : out-app c out-app * v; sign-val: begin out-app t v; out-state t sign-val-sign; end; aign~val~val: begin out-vu1 t out-vu1 + out-app; out-app + v; out-state + sign-val-sign; end; othercases begin break-ptr +- out-ptr ; out-app t v; out-state +- sign; end endcases; last-sign + outxpp; end;

107. When a (signed) integer value is to be output, we call send-val.

define bad-case = 666 { this is a label used below }

procedure send-vu1 (v : integer ); { output the (signed) value 21) label bad-case, { go here if we can't keep v in the output state }

,

exit;

begin case out-state of

num-or-id: begin ( If previous output was DIV or MOD, goto bad-case 110);

out-sign t "U1l; out-state t sign-val; out-vu1 t v; break-ptr +- out-ptr ; last-sign t +l;

end;

miac: begin (If previous output wits * or /, goto bad-case log);

out-sign 4- 0; out-state t sign-vul; out-val +- v; break-ptr t out-ptr ; last-sign + +l;

end;

(Handle cases of othercases goto

send-vu1 when bad-case

out-sta. te

contains

a

sign

108)

endcases;

return;

bad-case : ( Append the decimal value of II,. with parentheses if negative 111);

exit: end;

108. ( Handle cases of send-vu1 when out-state contains a sign 108 ) sign: begin out-sign t `*+`I; out-at&e t sign-vul; out-val + out-app * V;
end; ,qign-val: begin out-state t sign-val-val; out-app t v;
err-print ('!,Two,numbersuoccurred,withoutua,sign,between"them0);
end; sign-val3ign : begin out-state t Yign-vul-val; out-app t out-app * v;
end: sign-val-val: begin out-val +- out-vnl + out-app; out-app + v;
err-print ('!,Two,numbers,occurred,withoutua,sign,between~them');
end;
Thiu code is used in section 107.

160 PRODUCING THE OUTPUT

TANGLE .

109. ( If previous output was * or /, goto bad-case 109 ) E

if (out-ptr = break-ptr + 1) A (( out-buf [break-ptr] = "***) V (out-buf [break-ptr] = `*/*`)) then

goto bad-case

This code is used in section 107.

$109

110. (If previous output was DIV or MOD, goto bad-case 110) z if (out-ptr = break-ptr + 3) V (( out-pt r - b reak-ptr + 4) A (out-buf [break-ptr] = *lU**)) then if ((out-auf [out-ptr - 31 = "D") A (out-buf [out-ptr - 21 = "I") A (out-buf [out-ptr - l] = *`V"))V (( out-buf [out-ptr - 31 = **M**) A (out-buf [out-ptr - 21 = "Of*) A (out-buf [out-ptr - I] = "D")) then
goto bad-case
This code is used in section 107.

1iI. (Append the decimal value of v, with parentheses if negative 111) s if v 2 0 then begin if out-state = num-or-id then begin break-ptr + out-ptr ; app ( "U"); end; app-vu1 (v); check-break; out-state t num-or-id; end else begin app ( l1 (II); app ( **-*1); app-val( -II); app (`I) `I); check-break; out-state t-- miac;
end
This code is used in section 107.

5112 TANGLE

THE BIG OUTPUT SWITCH 161

112. The big output switch. To complete the output process, we need a routine that takes the results ' of get-output and feeds them to send-out, aend-val, or send-sign. This procedure `send-the-output ' will be
invoked just once, as follows: '
(Phase II: Output the contents of the compressed tables 112) G if text-Zink[O] = 0 then begin print-n1 ( ' ! ,No,output,was;specif ied. `); mark-harmleas; end else begin print-nZ( `WritingUthe,output,f ile `); update-terminul; (Initialize the output stacks 83 ); (Initialize the output buffer 96); send-the-output; (Empty the last line from the buffer 98 ); print-nl( `Done. `); end
This code is used in section 182.

113. A many-way switch is used to send the output:
define get-fraction = 2 { this label is used below }
procedure send-the-output; label get-fraction, { go here to finish scanning a real constant } reawitch , continue ; var cur-char : eight-bits ; { the latest character received } k: 0 . . line-length; {index into out-contrib } j : 0 . . max-bytes; {index into byte-mem } w : 0 . . ww - 1; {segment of byte-mem } n: integer ; { number being scanned } begin while stack-ptr > 0 do begin cur-char c get-output; reawitch: case cur-char of 0: do-nothing; { this case might arise if output ends unexpectedly } ( Cases related to identifiers 110) ( Cases related to constants, possibly leading to get&action or reawitch 119 ) II +(1 , "-I': send-sign("," - cur-char); ( Cases like <> <and : = 114 ) " `I': (Send a string, goto reawitch 117); (Otl ler prin ta ebl c 1laracters II:,): send-out (miac, cur-char); ( Cases involving 6{ cand d) 121) join : begin send-out (frat, 0); out-state + unbreakable; end; verbatim: ( Send verbatim string 118);' force-line: ( Force a line break 122); othcrcases err-print (' !,Can"tUoutputUASCIIUcodeU', cur-char : 1) endcases; got0 continue ; get-fraction: (Special code to finish real constant,s 120); continue : end;
end;

162 THE BIG OUTPUT SWITCH

TANGLE .

$114

114. (Cases like <> and := 114) z

and-sign: begin out-contrib [l] t "A"; out-contrib [2] + "N"; out-contrib [3] + "D"; .aend-out (ident, 3);

end;

not-sign: begin out-contrib [I] c 'IN"; out-contrib [2] +- "0"; out-contrib [3] +- "T"; send-out (ident, 3);

end;

set-element-sign: begin out-contrib [l] +-- "I"; out-contrib [2] +-- "N"; send-out (ident, 2); end;

or-sign : begin out-contrib [l] e tlO"; out-contrib (21 + "R"; send-out (ident, 2);

end;

left-arrow : begin out-contrib [l] t " : "; out-contrib [2] +- "="; send-out (atr ,2);

end;

not-equal: begin out-contrib [l] t "c"; out-contrib [2] t ">"; send-out (atr ,2);

end; leas-or-equal: begin out-contrib [l] e "c"; out-contrib [2] +- "="; send-out (atr ,2);

end;

greater-or-equal: begin outxontrib [l] t ">"; out-contrib [2] + "=`I; send-out (atr ,2);

end;

equivalence-sign: begin out-contrib [I] t "=I'; out-contrib [2] t- "="; send-out (atr ,2);

end; double-dot : begin out-contrib [ l] t ". "; out-contrib [2] +- " . "; send-out (atr ,2);

end;

This code is used in section 113.

115. Please don't ask how all of the following characters can actually get through TANGLE outside of strings. It seems that " " I"' and `I(" cannot actually occur at this point of the program, but they have been included
just in case TANGLE changes. If TANGLE is producing code for a PASCAL compiler that uses ` ( . ' and ` . > ' instead of square brackets
(e.g., on machines with EBCDIC code), one should remove " [" and "I" from this list and put them into the preceding module in the appropriate way. Similarly, some compilers want `-'to be convcrtcd to `~3'.

( Other printable characters 115 ) z

1II II 1, II II II

1') lI$ll) ll~ll, ll&ll, "('1, '1)") I,,', II, tt, ll/ll, '1: II, 11; I') "(11, l'=") ">'I, I'?", "@", tl[ll, I'\", I'] II, 'I-l',

*7

) "#

II II VI* II) ll(l1, II 1 II -,
This code is used in section 113.

I

$116 TANGLE

THE I3IG OUTPUT SWITCH 163

116. Single-character identifiers represent themselves, while longer ones appear in byte-mem. All must be converted to uppercase, with underlines removed. Extremely long identifiers must be chopped.
(Some PASCAL compilers work with lowercase letters instead of uppercase. If this module of TANGLE is changed, it's also necessary to change from uppercase to lowercase in the modules that are listed in the index under "uppercase" .)
define up-to (#) 5 # - 24, # - 23, # - 22,#-21,#-20,#-19,#-18,#-17,#-16,#-15,#-14,#-13, #-12,#-11,#-10,#-9,#-8,#-7,#-6,#-5,#-4,#-3,#-2,#-1,#
( Cases related to identifiers 116) E "A", up-to(ttZtt): begin out-contrib[l] t cur-char; send-out (ident, 1);
end; "a", up-to ( ftzt'): begin out-contrib [l] e cur-char - `40; send-out (ident, 1);
end; identifier: begin k c 0; j t byte-start [ cur-uaZ]; u, t cur-vu1 mod ww;
while (k < max-id-length) A (j < byte-start [cur-oal + ww]) do begin incr (k); out-contrib [k] t byte-mem [w, j]; incr (j); if out-contrib[k] 2 "a" then out-contrib[k] +- out-contrib(k] - '40 else if out-contrib [k] = II-*' then deer (k); end;
send-out (ident, k); end;
This code is used in section 113.

117. After sending a string, we need to look ahead at the next character, in order to see if there were two consecutive single-quote marks. Afterwards we go to reswitch to process the next character.

(Send a string, goto reswitch 117) G . begin k t 1; out-contrib [l] +-- If `I';
repeat if k < line-length then incr(k); out-contrib [k] t get-output;
until (out-contrib [k] = "*") V (stuck-ptr = 0); if k = line-length then err-print (' !,Stringutoo,long send-out (str , k); cur-char t get-output; if cur-char = tt'tt then out-state t unbreakable; goto reswitch;
end

`);

This code is used in section 113.

118. Sending a verbatim string is similar, hut WC don't have to look <ahead.
(Send verbatim string 118) F begin k +- 0; repeat if k < line-length then incr(k); out-contrib [k] +- get-output; until (out-contrib [k] = verbatim) V (stack-ptr = 0); if k = line-length then err-yrint( `!,VerbatimUstringUtooulong'); send-out (str , k - I); end
This code is used in section 113.

164 THE BIG OUTPUT SWITCH

TAN. GLE

$119

119. In order to encourage portable software, TANGLE complains if the constants get dangerously close to ' the largest value representable on a 32-bit computer (231 - 1).

&fine digits = I'()", 'l1'1, `VJll, `;3", "411, `I",, "6l1, "7", "8", "gl'

( Cases related to constants, possibly leading to get-fraction or reszoitch 118) z digits: begin n +- 0;
repeat cur-char + cur-chat - "0"; i f n > `1 4 6 3 1 4 6 3 1 4 t h e n err-ptint(`!,Constant,tooUbig')
else n + 10 * n + cur-char; cur-char +- get-output; until (cur-char > "9") V (cur-char < "0"); send-&(n); k c 0; if cur-char = "e" then cur-char t "E"; if cur-char = "E" then goto aet-fraction
else goto reswitch; end;
check-sum: aend-val (pool-check-sum); octal: begin n t 0; cur-char t llOtt;
repeat cur-char +- cur-char - "0"; i f n 2 `2OUOOOUOOO t h e n e r r - p r i n t (' !JonstantUtooubig') else n +- 8 * n + cur-char;
cur-char +- get-output ; until (cur-char > "7") V (cur-char < "0"); send-vu1 (n); goto reszoitch; end; hez: begin n t 0; cur-char +- "0"; . repeat if cur-char > "A" then cur-char + cur-char + 10 - "A"
else cur-char +- cur-char - "0"; if r~ > "8000000 then err-print ( `!JonstantUtooubig') else n +- 16 * n + cur-char;
cur-char +- get-output ; until (cur-char > "F") V (cur-char < "0") V ((cur-char > "9") A (cur-char < "A")); send-u&(n); goto resulitch; end;
number : send_uuZ (cur-vu/); ". ": begin k t 1; out-contrib [l] t ". "; cur-char +- get-output;
if cur-char = `I. `I then
begin out-contrib [2] t " :"; send-out (str ,2); end else if (cur-char 2 "0") A ( c u r - c h a r 5 "9") t h e n goto g e t - f r a c t i o n else begin send-out (rrrisc, I'. `I); goto reswitch;
end;
en+;
This code is used in section 113.

I.

$120 TANGLE

THE BIG OUTPUT SWITCH 165

120. The following co de appears at label `get-fraction', when we want to scan to the end of a real constant. The first k characters of a fraction have already been placed in out-contrib , and c w-char is the next character.
( Special code to finish real constants 120) z repeat if k < line-length then incr(k); out-contrib [k] + cur-char ; cur-char + get-output; if (out-contrib [k] = ttEff) A ((cur-char = fl+lt) V (cur-char = I'-")) then begin if k < line-length then incr (k); out-contrib [k] +- cur-char; cur-chur * get-output; end else if cur-char = "et1 then cur-char t "Et'* until (cur-char # "Et') A ((cur-char < "0") V (lur-char > "9")); if k = line-length then err-print ( l !uFractionUtooulong `); send-out (frac, k); goto reswitch
This code is used in section 113.

121. Some PASCAL compilers do not recognize comments in braces, so the comments must be delimited by ' (*'and `*> `. In such cases the statement `send-out (mist, "{")' that appears here should be replaced by `b e g i n out-contrib[l] t I'("; out_contrib[2] + "*"; send-out (str ,2); end', and a similar change should be made to `send-out (miec, ">")`.

( Cases involving OC and 9) 121) G

begin-comment : begin if brace-level = 0 then send-out (mist, "{")

else send-out (miac , `I [I');

incr (brace-level);

end;

end-comment: if brace-level > 0 then

begin deer (brace-level);

if brace-level = 0 then send-out (mix, 113tf)

else send-out (m&c, `I] `I);

end

else err-print ( ' ! ,ExtrauQ) `);

-

module-number: begin if brace-level = 0 then send-out (miac, "{")

else send-out (mist , " [");

if cur-ual < 0 then

begin send-out (m&c, " : I'); send-vuZ( - cur-val);

end

else begin send-val (cur-v&); send-out (mix, " : I');

end;

if brace-level = 0 then send-out (m&c, 1t31f)

else send-out (mist ? "1 `I);

end;

This code is used in section 113.

122. ( Force a line break 122 > z begin while out-ptr > 0 do begin if out-ptr 5 line-length then break-ptr t out-ptr; flush-bufler; end; out-state +- mix; end
This code is mx-4 in section 113.

166 INTRODUCTION TO THE INPUT PHASE

TAN. GLE

$123

.

123. Introduction to the input phase. We have now seen that TANGLE will be able to output the full PASCAL program, if we can only get that program into the byte memory in the proper format. The input

process is something like the output process in reverse, since we compress the text as we read it in and we

expand it as we write it out. . There are three mcain input routines. The most interesting is the one that gets the next token of a PASCAL

text; the other two are used to scan rapidly past l&X text in the WEB source code. One of the latter routines

will jump to the next token that starts with `@`, and the other skips to the end of a PASCAL comment.

124. But first we need.to consider the low-level routine get-line that takes care of merging change-file into web-file. The get-line procedure also updates the lint numbers for error messages.
( Globals in the outer block 9) +S line : integer ; {the number of the current line in the current file } other-line : integer; { the number of the current line in the input file that is not currently being read } temp-line : integer ; {used when interchanging line with other-line } limit: 0 . . buf-size ; { the last character position occupied in the buffer } Zoc: 0 . . buf-size; { the next character position to be read from the buffer } input-has-ended: boolean ; { if true, there is no more input } changing: boolean; { if true, the current line is from change-file }

125. As we change changing from true to false and back again, we must remember to swap the values of line and other-line so that the err-print routine will be sure to report the correct line number.
define change-changing E changing t Tchanging; temp-line t other-line; other-line t line; line t temp-line { line t) other-line }

126. When changing is false, the next line of change-file is kept in change-bufler [0 . . change-limit], for purposes of comparison with the next line of web-file. After the change file has been completely input, we set change-limit + 0, so that no further matches will be made.
( Globals in the outer block 9) +S changeAuger: array [0 . . buf-size] of ASCII-code; change-limit : 0 . . buf-size ; { the last position occupied in change-bufler }

127. Here's a simple function that checks if the two buffers are different.
function lines-dent-match: boolean; label e&t; var k: 0 . . buf-size; { index into the buffers } * begin lines-dont-match +-- true; if chunge-limit # limit then return; if limit > 0 then for k +- 0 to limit - 1 do if change-bufler [k] # bufler [k] then return; lines-dont-match +- f&e;
zit :- end;

$128 TANGLE

INTltODUCTION TO THE INPUT PHASE 167

128. Procedure p7i7ne_the_change_bzr sets change-bufier in preparation for the nkxt matching operation. ' Since blank lines in the change file are not used for matching, we have (change&nit = 0) A lchanging if
and only if the change file is exhausted. This procedure is called only when changing is true; hence error messages will be reported correctly.
procedure prime-the-change-bufer; label continue, done, ezit ; var k: 0 . . buj-size; { index into the buffers } begin change-limit t 0; { this value will be used if the change file ends } ( Skip over comment lines in the change file; return if end of file 129); ( Skip to the next nonbltik line; return if end of file 130); (Move bufler and limit to change-bufeer and change-limit 131);
ezit: end;

129. While looking for a line that begins with Qx in the change file, we allow lines that begin with 9, as long as they don't begin with @y or QZ (which would probably indicate that the change file is fouled up).

( Skip over comment lines in the change file; return if end of file 129) G
loop begin inct (line); if Tinput-ln (change-file) then return; if limit < 2 then goto continue; if buJer[O] # "Q" then goto continue; if (bufler [l] >_ "X1') A (bufler [I] 5 ffZ'l) then bufler [l] t bufler [l] + "z" - "Z"; if bufler [I] = "x1' then goto done; if (bufler [ I]' = "y") V (bufler [l] = "z") then begin lot + 2; err-print ( `!,WhereUisUtheUmatchingU@x?`); end;
continue : end;
done :

{ lowercasify }

This code is used in section 128.

130. Here we are looking at lines following the Qx.
( Skip to the next nonblank line; return if end of file 130) E repeat incr (line); if Tinput-In (change-file) then begin err-print ( l !,Change,f ile,,ended"af terJJx'); return; end; until limit > 0;
This code is used in section 128.

131. (Move bufler and limit to change-buffer and change-limit 131) 3 begin change-limit t limit ; for k + 0 to limit do change-bufler [k] e bu,fer [k]; end
This code is used in sections 128 and 132.

168 INTRODUCTION TO THE INPUT PHASE

TANGLE $132

132. The following procedure is used to see if the next change entry should go into effect; it is called only
when changing is false. The idea is to test whether or not the current contents of bufler matches the current contents of change-bu#er . If not, there's nothing more to do; but if so, a change is called for: All of the
text down to the @y is supposed to match. An error message is issued if any discrepancy is found. Then the procedure prepares to read the next line from change-file.

procedure check-chunge ; { switches to change-file if the buffers match}

label ezit;

var n: integer; { the number of discrepancies found }

k: 0 . . buj-size ; { index into the buffers }

begin if lines-dont-match then return;

n +-- 0;

loop begin change-changing; {now it's true }

incr (Zinc);

if Tinput-Zn (change-file) then

begin err-print ( ' !Jhange,f ileuendedubef oreuQy `); changelimit +- 0; change-changing;

{false again }

return;

end;

( If the current line starts with @y, report any discrepancies and return 133 );

(Move bufler and limit to change-bufier and change-limit 131);

change-changing; { now it's false }

incr (line );

if 1inputJn (web-file) then

begin err-print ( '!,WEBUfileLended,duringUaUchange `); input-has-ended t true; return;

end;

if lines-dont-match then incr (n);

end; exit: end;

.

133. (If the current line starts with @y., report any discrepancies and return 133) z if limit > 1 then
if buJer[O] = "@`I then

begin if (bvlfler[l] > "Xtf)

A (bufler[l] 5 "Z")

then aufler[l]

t bufler[l 11 II _ 11~11.

]+z

7

{ lowercCasify }

if (6uJer[l] = ttxtt) v (bufler[l] = lfzff) then

begin Zoc +- 2; err-print ( `!,WhereUisUtheUmatching,Oy?`);

end else if bufler[l] = "y" then

begin if n > 0 then begin lot +- 2;

err-print('!LHmm. . .u',n :1, 'Uof,,the,preceding,linesUfailedUtoUmatch');

end;

return;

end;

end

This code is used in section 132.

134. (Initialize the input system 134) E open-input ; line +- 0; other-line + 0; changing t true ; prime-the-change-bufler ; change-changing; limit +- 0; lot t 1; huger [0] e flUt'; input-has-ended +-- false;
This code is used in section 182.

$135 TANGLE

INTRODUCTION TO THE INPUT PHASE 169

135. The get-line procedure is called when lot > limit; it puts the next lint of merged input into the buffer and updates the other variables appropriately. A space is placed at the right end of the line.
procedure get-line ; { inputs the next line } label restart; begin reaturt: if changing then (Read from change-file and maybe turn off changing 137); if ychanging then begin ( Read from web-file and maybe turn on changing 136 ); if changing then goto restart; end; Zoc t 0; bu#er [limit] t `IU"; end;

136. (Read from web-file and maybe turn on changing 136) 3 begin incr (line); if ~input_Zn (web-file) then input-has-ended + true else if limit = change-limit then if bufler [O] = change-bufler[O] then if change-limit > 0 then check-change; end
This code is used in section 135.

137. ( Read from change-file and maybe turn off changing 137 ) E begin incr (line );
if Tinput-ln (change-file) then begin err-print ( ' !,ChangeUf ileuendeduwithoutuQz `); bufler [0] t- "@"; bufler [I] t "z"; limit + 2;
end; * if limit > 1 then { check if the change has ended }
if bufler[O] = "@" then begin if (6uJer [I] 2 "X'*) A (bufler [I] 5 "Z") then bufler[l] +-- bufier [I] + "z" - "Z"; { lowercasify } if (bufler [l] = "x") V (bidfleer [I] = "y") then begin Zoc + 2; err-print ( `!,WhereUisUthe,matchingUQz?`); end else if bufler [l] = "z" then begin prime-the-change-bufier; change-changing;
end;
end; end
This code is used in section 135.

138. At the end of the program, we will tell the user if the change file had a line that didn't match any rclev;ult line in we b-jile .
( Check that all changes have been read 138 ) G if change-limit # 0 then { changing is false } begin for foe t 0 to change-limit do bufler [Zoc] t change-bufler [Zoc]; limit +- change-limit; changing t true; line +- other-line; lot t change.Jimit; err-print ( `!,ChangeLfile,entryUdid,notUmatch'); end
Thiv code is uwd in section 183.

170 INTRODUCTION TO THE INPUT PHASE

TANGLE .

$139

139. Important milestones are reached during the input phase when certain control codes are sensed.
' Control codes in WEB begin with `@`, and the next character identifies the code. Some of these are of interest only to WEAVE, so TANGLE ignores them; the others are converted by TANGLE into internal code numbers by the control-code function below. The ordering of these internal code numbers has been chosen to simplify the program logic; larger numbers are given to the control codes that denote more significant milestones.

define ignore = 0 { control code of no interest to TANGLE } define control-tezt = `203 { control code for `Qt', `@-`, etc. }
define format = `20.4 { control code for `(Qf ' } define definition = `205 { control code for `Qd' } define begin-Pascal = '206 {control code for `Qp' } define module-nume = `207 { control code for `(9~' } define new-module = `210 {control code for `QU' and `Q*' }

function control-code (c : ASCII-code): eight-bits ; { convert c after Q }

begin case c of

"@`I: control-code t `I@"; { `quoted'at sign }

" *`I: control-code t octal; {precedes octal constant }

"""": control-code t hez; {precedes hexadecimal constant } 11$1l: control-code t check-sum; { string pool check sum } `tU", tab-mark: control-code t new-module ; {beginning of a new module }

"*`I: begin print (`* `, module-count + 1 : I); update-terminal; {print a progress report }

control-code t new-module ; {beginning of a new module }

end;

'ID", "d": control-code t definition; {macro definition } It F II, II f": control-code t format; { format definition }

I'{": control-code t begin-comment; { begin-comment delimiter }

"3": control-code t end-comment; { end-comment delimiter }

11 P "T

1I1I,7

I1I1Pt0II.*

control-code t begin-Pascal; II - II 11 * II 791 .* Il.* control-code +

{ PASCAL text in unnamed module} control-text; { control text to be ignored

}

"&": coitrol-Lode t j o i n ; { concatenate two tokens }

"<": control-code t module-name ; { beginning of a module name }

`I=": control-code t verbatim; { beginning of PASCAL verbatim mode } . 11\11: control-code t force-line ; {force a new line in PASCAL output }

othercases control-code t ignore { ignore all other cases }

endcases;

end;

$140 TANGLE

INTRODUCTION TO THE INPUT PHASE 171

140. The skip-ahead procedure reads through the input at fairly high speed until finding the next nonignorable control code, which it returns.
function skip-ahead: eight-bits; * { skip to next control code } label done ; var c: eight-bits; { control code found } begin loop begin if Zoc > limit then begin get-line ; if input-has-ended then begin c +- new-module; goto done; end; end;
buJer[limit + l] t- I'@"; while bufier [lot] # "@" do incr (10~); if lot 5 limit then
begin lot + lot + 2; c t control-code (bufer [lot - 11); if (c # ignore) v (bufier [Zoc - l] = ">") then goto done; end; end; done: skip-ahead + c; end;

141. The akip:comment procedure reads through the input at somewhat high speed until finding the first unmatched right brace or until coming to the end of the file. It ignores characters following `\' characters,

since all braces that aren't nested are supposed to be hidden in that way. For example, consider the process of skipping the first comment below, where the string containing the right brace has been typed as ' \ . \> ' in the WEB file.

procedure skip-comment; { skips to next unmatched 0'}
label exit ; var bal: eight-bits ; { excess of left braces }
c: ASCII-code ; { current character } begin bal t 0;

loop begin if lot > limit then

begin get-line ; if input-has-ended then
begin err-print ( `!JnputUended,inUmid-comment

`); return;

end;

end; c t bufler [Zoc]; kncr (Zoc); (Do special things when c = "Q", "\", "(", "3"; return at end 142);

end; exit: end;

172 INTRODUCTION TO THE INPUT PHASE
142. (Do special things when c = rl@ll, "\", 11(`1, ")"; return at end 142) z if c -- ll@l' then begin c +- bufer [foe]; if (c # *U'l) A (c # tab-m&k) A (c # "*") A (c # llzll) A (c # llZ1l) then incr(loc) else begin err-print ( '!USectionuendeduin,mid-comment `); deer (10~); return; end end else if (c = ll\ll) A (bu,,@er [lot] # "@`*) then incr (foe) else if c = 11(11 then incr (bal) else if c = `Ott then begin if bal = 0 then return; deer (bal); end
This code is used in section 141.

TAN. GLE $142

9143 TANGLE

INPUTTING THE NEXT TOKEN 173

1 4 3 . I n p u t t i n g t h e n e x t t o k e n . As stated above, TANGLE's most interesting input procedure is the ' get-next routine that inputs the next token. However, the procedure isn't especially difficult.
In most cases the tokens output by get-nezt have the form used in replacement texts, except that twobyte tokens are not produced. An identifier that isn't one letter long is represented by the output `identifier', and in such a case the global variables id-first and id-lot will have been set to the appropriate values needed by the id-lookup procedure. A string that begins with a double-quote is also considered a~1 identifier, and in such a case the global variable double-chars will also have been set appropriately. Control codes produce the corresponding output of the control-code function above; and if that code is module-nume, the value of cur-module will point to the byte-start entry for that module name.
Another global variable,- scanning-hex, is true during the time that the letters A through F should be treated as if they were digits.
(Globals in the outer block 9) t= cur-module: name-pointer; { name of module just scanned } scanning-hex: boolean; { are we scanning a hexadecimal constant? }

144. ( Set initial values 10 ) +E scanning-hex + false ;

145. At the top level, get-next is a multi-way switch based on the next character in the input buffer. A new-module code is inserted at the very end of the input file.
function get-next: eight-bits; {produces the next input token ) label restart, done, found; var c: eight-bits; { the current character } d: eight-bits ; { the next character } j, k: 0 . . longest-name; {indices into mod-text } begin restart: if lot > limit then begin get-line ; if input-has-ended then begin c + new-module; goto found; end;
end; c +- brrfler [lot]; incr (lot); if scanning-hez then ( Go to found if c is a hexadecimal digit, otherwise set scanning-hex +- pulse 140); case c of llA'l, upto ( llZ1l), llall, up-to ( llz'l): ( Get an identifier 148); ll'lllrl: ( Get a preprocessed string 149); ll@tr: (Get control code and.possible module name 150); ( Compress two-symbol combinations like ` : ='147 ) 11 11 tab-murk: goto restart ; { ignore spaces and tabs } ll~llr b e g i n skz'p-comment ; g o t 0 r e s t n r t ;
end; othercases do-nothing endcases; found: debug if trouble-shooting then debug-help; gubed get-next + c; end;

146. ( Go to found if c is a hexadecimal digit, otherwise set scanning-hex t false 146) E if ((c >_ "0") A (c 5 11911)) V ((c > "At') A (c 5 llF1l)) then goto found else scanning-hex +- false
This code in used in section 145.

174 INPUTTING THE NEXT TOKEN

TANGLE $147

147. Note that the following code substitutes @( and 9) for the respective combinations `(*' and `*) `. Explicit braces should be used for T# comments in PASCAL text.
define compress(#) s begin c + #; incr (foe); end
( Compress two-symbol combinations like ` : =' 147 ) 3 I'. `I: if buJer[loc] = `I. " then compress (double-dot )
else if bufler [lot] = ") " then compress ("J I'); .. .`1 11. if bufler [lot] = ft=ll then compress(left-arrow); 11=11: i f bufier[loc] = 11=11 then compress (equivalence-sign); `0": if bufer [lot] = "=" then compress (greater-or-equal); 11<1': if bufler [lot] = 11=11 then compress (less-or-equal)
else if buffer [lot] = 0>11 then compress (not-equal); " (`I: if buffer [lot] = " * I1 then compress ( begin-comment )
else if bufier [foe] = I'. I1 then compress (" [I'); 11*`1: if bufier [lot] = I') " then compress (end-comment);
This code is used in section 145.

148. We have to look at the preceding character to make sure this isn't part of a real constant, before trying to find an identifier starting with `e'or `E'.
( Get an identifier 148 ) G begin if ((c = "e") V (c = llE1l)) A (lot > 1) then if (bufler [lot - 21 5 11911) A (bufler [foe - 2] > "0") then c + 0; if c # 0 then begin deer (lot); id-first + lot; repeat incr (lot); d + bufer [foe]; until ((d < "0") V ((d > 11911) A (d <.llA1l)) V ((d > "Z") A (d < "a")) V (d > "z")) A (d # "~"); if lot > id-first + 1 then begin ct identifier ; id-lot +- lot ; end; end else c +-- "E"; {exponent of a real constant } end
This code is used in section 145.

$149 TANGLE

INPUTTING THE NEXT TOKEN 175

149. A string that starts and ends with double-quote mcarks is converted into an identifier that behaves like a numeric macro by means of the following piece of the program.
( Get a preprocessed string 149 ) begin double-chars t 0; id-first t Zoc - 1; repeat d e br#er[Zoc]; incr (roe); i f (d= ~tttwt) v (d = II,,,) then if bufler [roe] = d then begin incr (Zoc); d +- 0; incr (double-chars); end else begin if d = `I@" then err-print ( ' ! ,Double,@,sign,missing `) end else if Zoc > limit then begin err-print ( l !,StringUconstantUdidn"tUend'); d t """"; end; until d = IIllll~l;
id-Zoc t Zoc - 1; c +- identifier; end
This code is used in section 145.

150. After an 0 sign has been scanned, the next character tells us whether there is more work to do.
( Get control code and possible module name 150) E begin c t control-code (bufler [Zoc]); incr (Zoc); if c = ignore then goto resturt else if c = hex then scanning-hex t true else if c = module-name then ( Scan the module name and make cur-module point to it 151) else if c = control-text then begin repeat c t skip-uhead; until c # "@"; if bufler [Zoc - l] # @`>" then err-print ( `!,ImproperUOUwithinUcontrolutext'); got0 restart ;

end This code is used in section 145.

151. ( Scan the module name and rrAw cur-module point to it 151) E begin (Put module name into mod-text [l . . k] 153 ); if k > 3 then begin if (mod-text [k] = I'. `I) A (mod-text [k - l] = `I. ") A (mod-text [k - 21 = ". ") then
cur-module +- prefix-lookup (k - 3) else cur-module +- mod-lookup(k);
end

This code is used in section 150.
152. Module names are placed into the mod-text array with consecutive spaces, tabs, and carriage-returns replaced by single spaces. There will be no spaces at the beginning or the end. (We set mod-text [0] +-- 1'U" to facilit,ate this, since the mod-lookup routine uses mod-text [I] as the f!irst, character of the name) ( Set initial values 10 ) +r
mod-text [0] + "u";

178 SCANNING A NUMERIC DEFINITION

TANGLE $158

158. ( Set accumulator to the value of the right-hand side 158 ) G accumulator t 0; next-sign + 4-I; loop begin next-control +- get-next; reswitch: case next-control of digits: begin ( Set ual to value of decimal constant, and set next-control to the following token 160); add-in (ual); goto reswitch; end; octul: begin ( Set ual to value of octal constant, and set next-control to the following token 161);
add-in (ual); goto reswitch; end; hex: begin ( Set ual to value of hexadecimal constant, and set next-control to the following token 162 ); add-in (ual); goto reswitch; end;
identifier : begin q t id-lookup (normal); if iZk[q] # numeric then begin next-control +-- I'*"; goto reswitch; { leads to error } end;
add-in (equiu [q] - `100000); end;
"+": do-nothing; "-": next-sign t -next-sign; format, definition, module-name, begin-Pascal, new-module: goto done; " ; ": err-print ( `!,OmitUsemicolo~in,numericudefinition'); othercases ( Signal error, flush rest of the definition 159) endcases;
end; ilone :
This code is used in section 157.

159. ( Signal error, flush rest of the definition 159) EE begin err-print ( `!,Improperunumericudefinition,will,beuflushed'); repeat next-control t skip-ahead until end-of_definition (next-control); if next-control = module-name then begin {we want to scan the module name too } Zoc t Zoc -- 2; next-control 4- get-next ; end; accutnulutor +- 0; goto done; end
This code is uvcd in section 158.

160.. ( Set vlrl to value of dccirnal constant, (and set next-control to the following token 160) E uaz +-- 0 ; repeat ual t 10 * val + next-control - "0"; next-control t- get-next; until (next-control > "9") V (next-control < "0")
This code is used in section 158.

161. ( Set VUZ to value of octal constant, and set next-control to the following token 161) ual 4-- 0; next-control t "0"; repeat ual t 8 * vaZ + fqext-contr0Z -- "0"; next-control t get-next; until (next-control > "7") V (next-control < "0")
This codr is used in section 158.

$156 TANGLE

SCANNING A NUMERIC DEFINITION 177

156. Scanning a numeric definition. When TANGLE looks at the PASCAL text following the `='of a numeric macro definition, it calls on the precedure scan-numeric(p), where p points to the name that is to be defined. This procedure evaluates the right-hand side, which must consist entirely of integer constants and defined numeric macros connected with + and - signs (no parentheses). It also sets the global variable next-control to the control code that terminated this definition.
A definition ends with the control codes definition, format, module-name, begin_paacaZ, and new-module, all of which can be recognized by the fact that they are the largest values get-neti can return.
define end-of_definition(#) E (# 2 fotmut ) { is # a control code ending a definition? }
(Globals in the outer block 9) +r next-control: eight-bitts; {control code waiting to be acted upon }

157. The evaluation of a numeric expression makes use of two variables called the accumulator and the next-sign. At the beginning, uccumulutor is zero and next-sign is +l. When a + or - is scanned, next-sign is multiplied by the value of that sign. When a numeric value is scanned, it is multiplied by next-sign and added to the accumulator, then next-aign is reset to +l.
define add-in (#) E begin accumulator t accumulator + next-sign * (#); next-sign +- +l; end
procedure scan-numeric (p : nome-pointer); { defines numeric macros} label reawuitch, done; var accumulator : integer ; { accumulates sums } next-sign: -1 . . +l; {sign to attach to next value } q: name-pointer ; { points to identifiers being evaluated } vul: integer ; { constants being evaluated } begin ( Set accumulator to the value of the right-hand side 158 ); if uba (accumulator) > `100000 then begin err-print ( `!UValueUtooUbig:~U', uccumulutor : 1); accumulator t 0;
end; equiv [p] + accumulator + `100000; {. name p now is defined to equal accumulator } end;

176 INPUTTING THE NEXT TOKEN
153. (Put module name into mod-text [l . . k] 153) s ' kt0;
loop begin if lot > limit theli begin get-line; if input-has-ended then begin err-print ( l !,InputUended,in,sectionUname'); end; end;
d t bufler (Zoc]; (If end of name, goto done 154 > ; incr (Zoc); if k < longest-name - 1 then incr (k); if (d = ttUtl) V (d = tub-murk) then
begin d t t'u"; if mod-text [k - I] = t'ut' then deer (k); end; mod-text [k] +- d; end; done : ( Check for overlong name 155 ); if (mod-text [k] = lvut') A (k > 0) then deer (k);
This code is used in section 151.

goto done;

154. (If end of name, goto done 154) 3 if d = "@" then
begin d +- bufler [Zoc + 11; if d = ">" then
begin Zoc t lot + 2; goto done;
end; if (d = llU1') v (d = tab-murk) V (d = "*`I) then
begin err-print ( `!,SectionUnameUdidn"tUend'); goto done; end; incr (k); mod-text [k] t "@"; incr (Zoc); {now d = bu,,fer [ Zoc] again } end
This code is used in section 153.

155. ( Check for overlong name 1%) s if k > longest-name - 2 then begin print-d ( `!,SectiqnUnameUtooUlong:U'); for j t 1 to 25 do print (xchr [mod-text [j]]); print(`. . . `); murk-harmless; end
This code is used in section 153.

TANGLE $153

$162 TANGLE

SCANNING A NUMERIC DEFINITION

162. 6 vu1

( Set uul to value of hexadecimal +- 0; next-control t ItOn;

constant,

and

set

next-control

to

the

following

token

162

)

E

repeat if next-control 1 "A" then next-control + next-control + "0" + 10 - "A";

vu1 + 16 * vu1 + next-control - "0"; nezt-control t- get-nezt;

until (next-control > "F") V (nezt-control < "0") V ((next-control > "9") A (next-control < "A"))

This code is used in section 158.

179

180 SCANNING A MACRO DEFINITION

TANGLE 163.

163. Scanning a macro definition. The rules for generating the replacement texts corresponding to simple macros, parametric macros, and PASCAL texts of a module are almost identical, so a single procedure is used for all three cases. The differences are that
a) The sign # denotes a parameter only when it appears outside of strings in a parametric macro; otherwise it stands for the ASCII character #. (This is not used in standard PASCAL, but some PASCAL3 allow, for example, `/#' after a certain kind of file name.)
b) Module names are not allowed in simple macros or parametric macros; in fact, the appearance of a module name terminates such macros and denotes the name of the current module.
c) The symbols Qd and Of and Qp are not allowed after module names, while they terminate macro definitions.

164. Therefore there is a procedure scan-rep1 whose parameter t specifies either simple or purumetric or module-name. After scan-rep1 has acted, cur-repl-text will point to the replacement text just generated, and next-control will contain the control code that terminated the activity.
( Globals in the outer block 9 ) +E cur-repl-text : text-pointer ; { replacement text formed by scan-rep1 }

165. procedure scan-rep1 (t : eight-bits); { creates a replacement text }
label continue, done, found; var a: sixteen-bits; { the current token }
b: ASCII-code ; { a character from the buffer } bal: eight-bits ; { left parentheses minus right parentheses } begin bul t 0;
loop begin continue: a +- get-next; case a of 11 (`I: incr (bal); 11 1 *11. if bul = 0 then err-print ( l !"Extra,) `) else deer (bal); " "`: ( copy a string from the buffer-to tok-mem 168); I'#": if t = parametric then a t parum; ( In cases that a is a non-ASCII token (identifier, module-name, etc.), either process it and change a to a byte that should be stored, or goto continue if a should be ignored, or goto done if a signals the end of this replacement text 167 )
othercases do-nothing endcases;
upp-rep1 (a); {store a in tok-mem }
end; done: next-control t a; (Make sure the parentheses balance 166);
if text-ptr >. max-texts - zz then overflow (`text `); cur-rcpl-text t text-ptr ; tok-atart [text-ptr + zz] +-- tok-ptr [z]; incr (textqtr);
if-z = zz - 1 then z t 0 else incr (z); end:

$166 TANGLE
166. (Make sure the parentheses balance 1~) z if bal > 0 then begin if bal = 1 then ert_print('!uMissingu)') else err_print('!uMissingu', bul:l,`U)"s'); while bal > 0 do begin app-rep2 (`I> I@); deer (M); end; end
This code is used in section 165.

SCANNING A MACRO DEFINITION 181

167. (In cases that a is a non-ASCII token (identifier, module-name, etc.), either process it and change a to a byte that should be stored, or goto continue if a should be ignored, or goto done if a signals . the end of this replacement text 167 ) G
identifier: begin a t idJookup(normaf); app-repl ((u div `4OU) + `200); a + a mod `400;
end; module-name: if t # module-name then goto done
else begin app-repZ(( cur-module div `400) + `250); a + cur-module mod `400; end;
verbatim: ( Copy verbatim string from the buffer to iok-mem 109); definition, format, begin-Pascal: if t # module-name then goto done
else begin err-print ( '! &I ', schr [ bufler [lot - l]], 'uisuignoreduinuPASCALUtext'); goto continue;
end; new-module : goto done ;
This code is used in section 165.

168. ( Copy a string from the buffer to tok-mem 168 ) 3 . begin b t `1'0;
loop begin app-repl (II); if 6 = `IQ0 then if bufler [Zoc] = I'@*' then incr (lot) { store only one (8 } else err-print ( ' !UYouUshouldUdoubleU61UsignsUinUstrings'); if lot = limit then begin err-print (' !UStringudidn"tUend'); bufler (lot] +- "`I'; buJer[loc + l] + 0; end; b +- bufler [lot]; incr(foc); if 6 = II "I then begin if bufler[Zoc] # `*`I' then goto found e l s e b e g i n incr (lot); app-repZ( `I "I); end; end; end;
found: end { now n holds the final `I "' that will be stored }
This code iu used in section 165.

182 SCANNING A MACRO DEFINITION

TANGLE $169

169. ( Copy verb&m string from the buffer to tok-mem 189) z * begin app-repl( verbatim); bufler [limit + I] t "(Q";
while bufleer (lot] # "@" do '
begin app-repl (bufler [foe]); incr (Zoc ); if foe < limit then
if (bufier [roe] = "@I') A (bufier [Zoc. + l] = "Q") then begin upp-repZ("0"); Zoc + lot + 2; end;
end; if Zoc > limit then err-print ( ' ! "Verbat im,,stringudidn ' `tuend `) else if bufler [lot + l] # ">" then err-print ( `!,YouushouldudoubleuQ,signs,inuverbatim~strings'); lot + lot + 2; end {another verbatim byte will be stored, since a = verbatim }
This code is used in section 167.

170. The following procedure is used to define a simple or parametric macro, just after the `==' of its definition has been scanned.
procedure define-macro (t : eight-bits); var p: name-pointer ; { the identifier being defined } begin p +- id-lookup (t); scan-repl (t); equiu [p] + cur-repl-tezt ; texthzk [cur-repl-tezt] t 0; end;

$171 TANGLE

SCANFJING A MODULE 183

171. Scanning a module. The stun-module procedure starts when `QU' or `@*' has been sensed in the input, and it proceeds until the end of that module. It uses module-count to keep track of the current module number; with luck, WEAVE and TANGLE will both assign the same numbers to modules.
( Globals in the outer block 9 ) +Z module-count : 0 . . `27777; { the current module number }

172. The top level of scan-module is trivial.
procedure scan-module; label continue, done, exit; var p: name-pointer ; { module name for the current module } begin incr (module-count); ( Scan the definition part of the current module 173 ); ( Scan the PASCAL part of the current module 175 );
exit: end;

173. ( Scan the definition part of the current module 173 ) z nezt-control 4- 0; loop begin continue: while next-control 5 formut do begin next-control t skip-ahead; if nezt-control = module-name then begin {we want to scan the module name too}
Zoc +- Zoc - 2; next-control + get-next;
end;
end;
if next-control # definition then goto done; next-control t get-next ; { get identifier name } if next-control # identifier then
begin err-print ( `!UDefinitionUflushed,UmustUstartUwithU', `identifier,ofJengthu>ul'); got0 continue ;
end; next-control +- get-next; { get token after the identifier } if next-control = "=`I then
begin scan-numeric (id-lookup (numeric)); goto continue ; end
else if next-control = equivalence-sign then begin define-mucro (simple); goto continue ; end
else ( If the next text is `(#) s', call define-macro and goto continue 174); err-print( `!,DefinitionUflushedUsince,it~starts,badly'); end;

This code is used in section

184 SCANNING A MODULE

TANGLE

174. ( If the next text is `(#) E', call define-macro and goto continue 174 ) 3 if next-control = " (" then begin next-control t get-next; if next-control = "#" then begin next-control t get-next; if next-control = ")I' then begin next-control t- get-next; if next-control = "=" then begin err-print ( '! JJseU==Uf orumacros `) ; next-control +- equivalence-sign; end; if next-control = equivalence-sign then begin define-macro (parametric); got0 continue ; end; end; end; end;
This code is used in section 173.

175. ( Scan the PASCAL part, of the current module 175) E case next-control of begin-Pascal: p + 0; module-nnme: begin p +- cur-module; ( Check that = or z follows this module name, otherwise return 176 ); end; othercases return
endcases; ' (Insert the module number into tok-mem 177);
scan-rep1 (module-name ); { now cur-repl-text points to the replacement text } (Update the data structure so that the replacement text is accessible 178 );
This code is used in section 172.

176. (Check that = or z follows this module name, otherwise return 176) G repeat next-control t get-next; until next-control # "+"; {allow optional `+=`} if (next-control # "=`I) A (next-control # equivalence-sign) then begin err-print ( '!uPASCALctextUflushed,LJ=usign,is,,missing');
repeat next-control t skip-ahead; until next-control = new-module ; return; end
This code is used in section 175.

177. ( Insert the module number into tok-mem 177 ) E store-two-bytes( `150000 -I- module-count); { `150000 = `320 * `400 }
Thiv code is used in section 175.

9174

$178 TANGLE

SCANNING A MODULE

178. ( Update the data structure so that the replacement text is accessible 178 ) E ' if p = 0 then { unnamed module}
begin text-link [lust-unnamed] +-- cur-repl-text ; lust-unnamed + cur-repl-text ; end else if equiu [p] = 0 then equiu [p] t cur-repl-text { first module of this name }
else begin p t equiv [p]; while text-link [p] < moduZe$ug do p t text-link [p]; { find end of list }
text-link [p] t- cur-repl-text ; end; text-link [cur-repl-text] + module-flag; { mark this replacement text as a nonmacro }
This code is used in section 175.

185

188 THE MAIN PROGRAM

TANGLE $182

182. The main program. We have defined plenty of procedures, and it is time to put the last pieces `of the puzzle in place. Here is where TANGLE starts, and where it ends.
begin initialize; ( Initialize the input system 134 ); print-ln (banner); { print a "banner line" } (Phase I: Read all the user's text and compress it into tok-mem 183 ); stat for zo +- 0 to zz - 1 do maz-tok-ptr [zo] +- tok-ptr [zo]; tats (Phase II: Output the contents of the compressed tables 112 ); end-of-TANGLE: if string-ptr > 128 then ( Finish off the string pool file 184); stat (Print statistics about memory usage 180); tats {here files should be closed if the operating system requires it } (Print the job history 187); end.

183. (Phase I: Read all the user's text and compress it into tok-mem 183) f phase-one t true; module-count t 0;
repeat next-control t skip-ahead; until next-control = new-module; while Tinput-has-ended do scan-module; ( Check that all changes have been read 138 ); phase-one t false;
This code is used in section 182.

184. ( Finish off the string pool file 184 ) 3 begin print-n1 (string-ptr - 128 : 1, `,stringsUwrittenUtoUstringupoolufile.

`); write(pooZ, `*`);

for string-ptr +- 1 to 9 do begin out-buf [string-ptr] t pool-check-sum mod 10; pool-check-sum + pool-check-sum div 10;

end;

for string-ptr t 9 downto 1 do write (pool, xchr ["Of1 + out-buf [string-ptr]]);

write-Zn(pool);

end

This code is used in section 182.

185. ( Globals in the outer block 9) +S stat wo: O..ww-1; { segment of memory for which statistics are being printed }
tats

1 8 6 . ( P rints ta tis tits about memory usage 186 ) print-nZ( `MemoryLusageLstatistics: `); print-n1 (name-ptr : 1, `+ames ,U', text-ptr : 1, `,replacementUtext
for wo t 1 to ww -- 1 do print (`+ l , byte-ptr [wo] : 1);
print ('&ytes,& max-tok-ptr [0] : 1);
for zo t 1 to zz - 1 do print (`+ l , max-tok-ptr [zo] : 1);
print ( `Utokens. `);
This code is used in section 182.

s ; `); printnl (byte-ptr [0] : 1);

5181 TANGLE
181. define breakpoint = 888 {place where a breakpoint is desirable }
debug procedure debug-help; {routine to display various things } label breakpoint, exit; var k: sixteen-bits ; { index into various arrays } begin incr (debug-skipped); if debug-skipped < debug-cycle then return; debug-skipped +-- 0; loop begin write (term-out, `#`); update-terminal; { prompt }
read (term-in, ddt ); . { read a list of integers } if ddt < 0 then return else if ddt = 0 then
begin goto breakpoint; @\ { go to every label at least once } breakpoint: ddt + 0; O\
end else begin read (term-in, dd);
case ddt of 1: print-id (dd); 2: print-rep1 (dd); 3: for k t 1 to dd do print (xchr [bufer [k]]); 4: for k t 1 to dd do print (xchr [mod-text [k]]); 5: for k t 1 to out-ptr do print (xchr[out-buj [ICI]); 6: for k t 1 to dd do print (xchr [out-contrib [k]]); othercases print ( `? `) endcases; end;
exit: end;

. DEBUGGING 187

186 DEBUGGING

TANGLE 179

179. Debugging. The PASCAL debugger with which TANGLE was developed allows breakpoints to be set, and variables can be read and changed, but procedures cannot be executed. Therefore a `debug-help' procedure has been inserted in the main loops of each phase of the program; when ddt and .dd are set to appropriate values, symbolic printouts of various tables will appear.
The idea is to set a breakpoint inside the debug-help routine, at the place of `breakpoint :' below. Then when debug-help is to be activat,ed, set trouble-shooting equal to true. The debug-help routine will prompt you for values of ddt and dd, discontinuing this when ddt 5 0; thus you type 2n + 1 integers, ending with zero or a negative number. Then control either passes to the breakpoint, illlowing you to look at and/or change variables (if you typed zero), or you exit the routine (if you typed a negative value).
Another global variable, debug-cycle, can be used to skip silently past calls on debug-help. If you set debug-cycle > 1, the program stops only every debug-cycle times debug-help is called; however, any error stop will set debug-cycle to zero.
( Globals in the outer block 9 ) +Z debug trouble-shooting: boolean ; { is de bug-help wanted? }
ddt : sixteen-bits ; {operation code for the debug-help routine > dd: sixteen-bits ; { operand in procedures performed by debug-help } debug-cycle : integer ; { threshold for debug-help stopping } debug-skipped: integer ; { we have skipped this many debug-help calls } term-in: text$le ; { the user's terminal as an input file }
gubed

180. The debugging routine needs to read from the user's terminal.

( Set initial values 10 ) +debug trouble-shooting + true ; debug-cycle t 1; debug-skipped +- 0; trouble-shooting +- false; debug-cycle + 99999; { use these when it almost works } reset (term-in, `TTY : `, `/ I `); { open term-in as the terminal, don't do a get }

gubed

.

$187 TANGLE

THE MAIN PROGRAM 189

187. Some implementations may wish to pass the history value to the operating system so that it can be used to govern whether or not other programs are started. Here we simply report the history to the user.
(Print the job history 187 ) z case history of spotless : print-n1 ( '(NoUerrors,were,f ound. ) `); harmless-message : print-n1 ( l (DidUyouUsee,theUwarningumessageUabove?) *); error-message : print-d ( l (Pardon,me , UbutUIUthink,I,spottedUsomethingUwrong.)'); fatal-message : print-n1 ( '(ThatUwasUaUf atal,error , umyuf riend. ) `); end { there are no other cases }
This code is used in section 182.

190 SYSTEM-DEPENDENT CHANGES

TANGLE ..

$188

188. System-dependent changes. This module should be replaced, if necessary, by changes to the program that are necessary to make TANGLE work at a particular installation. It is usually best to design

your change file so that all changes to previous modules preserve the module numbering; then everybody's

version will be consistent with the printed program. More extensive changes, which introduce new modules,

can be inserted here; then only the index itself will get a new module number.

$189 TANGLE

. INDEX 191

189. Index. Here is a cross-reference table for the TANGLE processor. All modules in which an identifier is used are listed with that identifier, except that reserved words arc indexed only when they appear in format definitions, and the appe&nces of identifiers in module names are not indexed. Underlined entries correspond to where the identifier was declared. Error messages and a few other things like "ASCII code" are indexed here too.

@d is ignored in PASCAL text: 167'.
Qf is ignored in PASCAL text: 167. @p is ignored in PASCAL text: 167.
a : 7 4 , 8 7 , 165. abs : 103, 157.
accumulator: IS?, 158, 159. udd-in : l57, 158. Ambiguous prefix: 69. and-sign : l5, 114. aPP 1 99, 101, 102, 103, 111. app-repl: 93, 165, 166, 167, 168, 169. app-val: 99, 103, 111. ASCII code: 11, 72. ASCII-code : 11, 13, 27, 28, 38, 50, 65, 94, 95,
100, 126, 139, 141, 165.
b : 8 7 , 9 7 , 165. bad-case : lo7, 109, 110. bul: 87, 93, Ml, 142, l65, 166. banner: 1, 182. begin: 3. begin-comment: 72, 76, 121, 139, 147.
begin-Pascal: 139, 156, 158, 167, 175. boolean : 28, 29, 124, 127, 143, 179. brace-level: 82, 83, 98, 121. break: 22.
break-ptr: 94, 95, 96, 97, 98, 101, 102, 106, 107, 109. 110, 111, 122.
breakpoint: 179, m. buj-size: 23, 27, 28, 31, 50, 53, 124, 126, 127,
128, 132. b ufle 7 : 27, 28, 31, 32, 50, 53, 54, 56, 57, 58, 61,
64, 127, 129, 131, 132, 133, 134, 135, 136, 137, 138; 140, 141, 142, 145, 147, 148, 149, 150, 153, 154, 167, 168, 169, 181.
byte-field: 78, 79. byte-mem : 37, 38, 39, 40, 41, 48: 49, 53, 56, 61,
63, 66, 67. 68, G9, 75, 87, 90, 113, 116. byte-ptr : 39, 14, 42, 61, 67, 90, 91, 186. byte-aturt: 37, 38, 39, 40, 42, 49, 50, 56, 61, 63,
67, 68? 75. 78; 81, 90, 116, 143. c: 53, j%, 0. 1-L3 97 1-470 1-4 1, 1--4--5-*
Can't output ASCII code n: 113.
carriage -return : IS, 17, 28. Change file ended. . . : 130, 132, 137. Change file entry did not match: 138.
change-bufler : m, 127, 128, 131, 132, 136, 138.
change-changing: l25, 132, 134, 137.

change-file : 2, 23, 24, 32, 124, 126, 129, 130, 132, 137.
change-limit : l2& 127, 128, 131, 132, 136, 138. changing : 32, l24, 125, 126, 128, 132, 134,
135, 138. char : 12, 14. check-break: 97, 101, 102, 103, 111.
check-change: l32, 136. check-sum: 72, 76, 119, 139. check-sum-prime: @. chop-hash: 5& 52, 60, 62. chopped-id: 50, 53, 58, 63. chr: 12, 13, 17, 18. compress: &g. confusion : 35, 89. Constant too big: 119. continue : 5, 113, 128, 129, 165, 167, 172, 173, 174. control-code : l3cJ, 140, 143, 150. control-text : 139, 150. count: 69. cur-byte :- 7 8 , 79, 83, 84, 85, 87, 90, 93. cur-char: 113, 116, 117, 119, 120. cur-end: 78, 79, 83, 84, 85, 87, 90. cur-mod: 78, 79, 83, 84, 87. cur-module : 143, 151, 167, 175. cur-name : 78, 79, 83, 84, 85. cur-repl: 78, 79, 80, 83, 84, 85. cur-repl-text : Jl, 165, 170, 175, 178. cur-&cite: 7!J, 84, 85. cur-val: 8& 87, 89, 116, 119, 121. d : 145.
d d : u>, 1 8 1 .
d d t : U9, 1 8 1 . debug: 3-7 4-7 3-07 3-1-, 7-47 8-73 9-0> 9-17 1-475 179,
l&l, 181. debug-cycle : m, 180, 181. de bug-help : 30, 31, 87, 145, 179, J&l. debug-skipped: 179, 180, 181. deer : G,, 28, 85, 91, 93, 99., 116, 121, 142, 148,
153, 165, 166. define-macro: l70, 173, 174. dehnition: 139, 156, 158, 167, 173.
Definition flushed...: 173.
digits: U9, 158. do-nothing; 6, 93, 102, 113, 145, 158, 165. done: 5, 87, 93, 128, 129, 140, 145, 153, 154, 157, '
158, 159, 165, 167, 172, 173.

192 INDEX

Double Q sign missing: 149.
double-chars: 50, 64, 143, 149. double-dot : 72, 114, 147.
EWDIC: 115. eight-bits: 37, 38. 53. 82, 87, 95, 101, 113, 139,
140, 141, 145. 156, 165, 170. else: 7.
end: 3, 7. end-comment: 72, 76, 121, 139, 147.

end-field: 7J, 79. end-of-definition : 136, 159.

end-of-TANGLE: 2, 3 4 , 1 8 2 . endcases: z.
eof: 28. eoln: 28.

equal: 66, 67, 68.

equiv : 37, 38, 47, 48, 50, 60, 62, 63, 64, 67, 84,

88, 89, 90, 157, 158, 170, 178.

equivalence-sign : l5, 114, 147, 173, 174, 176.

err-print: 3l, 59, 64, 66, 69, 97, 98, 108, 113, 117,

118, 119, 120, 121, 125, 129, 130, 132, 133, 137,

138, 141, 142, 149, 150, 153, 154, 157, 158, 159,

165, 166, 167, 168, 169, 173, 174, 176.

error : 28, 3l, 34, 63, 88, 90.

error-message : 9, 187.

exit: 5, 6, 85, 107, 127, 128, 132, 141, 172, 181.

extension: 66, 68, 69.

Extra >: 165.

Extra 62): 121.

f: 28.

.

false : 28, 29, 125, 126, 127, 132, 134, 144,

146, 180, 183.

fatal-error : 34, 35, 36.

fatal-message : 9, 187.

final-limit : 28. first-text-char: 12, 18.

Jlush-b?lJer: 9 7 , 9 8 , 1 2 2 . force-line : 72, 76, 113, 139.

form-feed: .L& 28. format: 139, 156, 158, 167, 173.

jorward: 3 0 . jounil: ti, 5 3 , 55, 56, 66, 87, 89, 145, 146, 165, 168.
jrnc : loo, 101, 102, 104, 113, 120.

Fraction too long: 120.
get: 28, 180. get-jraction: l& 119, 120. get-line : 124, 135, 140, 141, 145, 153. . get-next: 143, l45, 156, 158, 159, 160, 161, 162,
165, 173, 174, 176. get-output: 86,87,94, 112, 113, 117, 118, 119, 120. greater : CXi, 68, 69. !yr~rff r or equal: l5, 114, 147.

TANGLE $189
gubed: 3.
h: 5l, a. harmless-message : 9, 187.
hash: 39, 50, 52, 55. hash-size : 8, 50, 51, 52, 53, 54, 58. hex : 72, 76, 119, 139, 150, 158. history : $2, 10, 187. Hmm... n of the preceding...: 133. i: 16, 53. id-first: 50, 53,54, 56,57, 58,61,64,143, 148, 149. id-lot : 50, 53, 54, 56, 58, 61, 64, 143, 148, 149. id-lookup : 50, 53, 143, 158, 167, 170, 173. ident: IOO, 101, 102, 105, 114, 116. identifier: @, 89,116,143,148, 149,158,167,173. Identifier conflict...: 63. ignore : l& 140, 150. ilk : 37, 38, 47, 48, 50, 57, 59, 60, 61, 64, 85,
89, .90, 158.
Improper @ within control text: 150.
Improper numeric definition...: 159. Incompatible module names: 66. incr: 6, 28, 54, 56, 58,61,63,64,67,68,69, 74, 75,
84, 87, 90, 93, 97, 99, 116, 117, 118, 120, 121, 129, 130, 132, 136, 137, 140, 141, 142, 145, 147, 148, 149, 150, 153, 154, 165, 168, 169, 172, 181. initialize : 2, 182.
Input ended in mid-comment: 141.
Input ended in section name: 153.
Input line too long: 28. input-has-ended: 124, 132, 134, 136, 140, 141,
145, 153, 183. input -In : 28, 129, 130, 132, 136, 137. integer : 14, 40, 86, 95, 99, 106, 107, 113, 124,
132, 157, 179. j: -3,1 6-6, 6-9, 1-193 1-4*5 join : 72, 101, 113, 139.
jump-out: 2, 31, 34. k: 3J., 4-9,53-, 6-6, 6-9774-787-997 -799 -1701, 113,
-1Y27-1T28->13-2..1-4.5-17821 1: 3-1> 5-37 6-67 6-9* last-sign : 95, 103, 106, 107. last-text-char: l2, 16, 18. last-unnamed: 70, 71, 178. lejt-arrow : l5, 114, 147.
l e n g t h : 3CJ, 5 5 . less: 66, 67, 68, 69. less-or-equal: l5, 114, 147. limit : 28,32,m,l27, 129,130,131,133,134,135,
136, 137, 138, 140, 141, 145, 149, 153, 168, 169. line : 32, 33, 96, 97, 121, 125, 129, 130, 132,
134, 136, 137, 138.
line-feed: J5, 28.

I.

$189 TANGLE
line-length: 8, 94, 97, 100, 101, 113, 117, 118, 120, 122.
lines-dont-match: l27, 132.
link: 37, 38, 39, 48, 50, 55, 70. llink: 4 8 , 6 6 , 6 7 , 6 9 . lot : 28, 32, 124, 129, 133, 134, 135, 137, 138,
140, 141, 142, 145, 147, 148, 149, 150, 153, 154, 159, 167, 168, 169, 173.
Long line must be truncated: 97. longest-name: t-4, 65, 66, 69, 145, 153, 155. loop: 6. mark-error: 9, 31. mark-fatal: 9, 34. mark-harmless: 9, 112, 155. max-bytes : t3, 38, 40, 49, 53, 61, 66, 67, 69,
87, 90, 113. max-id-length: 8, 116. max-names : t3, 38, 39, 61, 67, 69, 90. maxtexts: 8, 38, 43, 70, 90, 165. max-tok-ptr : 44, 91, 182, 186. max-toks : 8, 38, 44, 73, 74, 93. mist: 9J, 96, 100, 101, 102, 105, 107, 111, 113,
119, 121, 122. Missing n >: 166. mod: 94.
mod-field: 78, 79. mod-lookup: 65, 66, 151, 152. mod-text: 65, 66, 67, 68, 69, 145, 151, 152, 153,
154, 155, 181. module-count : 139, l7l, 172, 177, 183. module -flag : 70, 85, 178. module-name: 139, 143, 150, 156, 158, 159, 164,
167, 173, 175. module-number: 86, 87, 121. n: 11133, 2 .
Name does not match: 69.
name-field: 78, 79. name-pointer: 39, 40, 49, 53, 66, 69, 78, 84,
143, 157, 170, 172. name-ptr : 39, 40, 42, 49, 53, 55, 57, 59, 61, 67,
90, 91, 92, 93, 186. new-line : 20, 31, 32, 34. new-module : KN, 140, 145, 156, 158, 167, 176, 183. next-control: -1-576 158, 159, 160, 161, 162, 164,
165, 173, 174, 175, 176, 183. next-sign : l& 158. nil: 6. No output was specified: 112.
No parameter given for macro: 96.
normal: 47, 50, 53, 57, 59. 60. 61, 89, 158, 167. Not present: <section name>: 88. not-equal: l5, 114, 147.

INDEX 193
not-found: 5, 53, 63. not-sign: l5, 114. num-or-id: 95, 101, 102, 107, 111. number: 86, 89, 119. numeric : 47, 53, 64, 89, 158, 173. octal: 72, 76, 119, 139, 158. Omit semicolon in numeric def . . .: 158. open-input: 24, 134. or-sign: 15, 114. ord: 13. other-line : l24, 125, 134, 138. othercases: 7.
others: 7. out-app: 95, 102, 104, 106, 108. out-buf : 31, 33, 94, 95, 96, 97, 99, 100, 109,
110, 181, 184. out-buf-size : 8, 31, 94, 97, 99. out-contrib : m, 101, 105, 113, 114, 116, 117,
118, 119, 120, 121, 181. out-ptr : 33, 94, 95, 96, 97, 98, 99, 101, 102, 106,
107, 109, 110, 111, 122, 181. out-sign : 95, 103, 104, 107, 108. out-state: 95, 96, 101, 102, 104, 106, 107, 108,
111, 113, 117, 122.
out-val: 95, 103, 104, 106, 107, 108. output-state: 7 8 , 7 9 . overflow: 36, 61, 67, 73, 84, 90, 93, 165. p: 40, 53, @, 69, 74, 84, 157. 170, 172. pack: 61. param : 72, 76, 87, 93, 165. parametric : 47, 53, 85, 89, 164, 165, 174.
PASCAL text flushed...: 176.
pascal-file: 2, 25, 26, 97. phase-one : 29, 31, 183. pool: 2, 25, 26, 64, 184. pool-c hec k-aurn : 40, 42, 64, 119, 184. pop-level: 85, 87, 90, 91.
pre/ix: 6 6 , 6 8 . prefix-lookup: 69, 151.
Preprocessed string is too long: 64.
prcbproccsacd strings: 64, 149. prime-the-change-brlfler : 128, 134, 137. print: 20, 31, 32, 33, 34, 49, 63, 74, 75, 76, 88,
93, 97, 139, 155, 181, 186. print-id: 49, 75, 88, 90, 181. print-ln: 20, 32, 33, 182. print-nl: 20,28,63,88,90,112,155,184,186, 187.
print-repl: 74, 181.
Program ended at brace level n: 98.
push-level: 81, 88, 89, 92. (I: 53, G-6-,69-,1-5*7 r: @.

194 INDEX

read: 181. read-ln: 28.

repl-field: 78, 79.

reset: 24, 180.

restart : 5, 87, 88, 89, 90, 92, 101, 102, 104,

135, 145, 150.

reswitch: 3, 113, 117, 119, 120, 157, 158.

return: 5, 6.

rewrite : 21, 26.

rlink: $8, 66, 67, 69.

9: 53.

scan-module : 171, 172, 183.

scannumeric : 156, l57, 173.

scan-repl: 164, 165, 170, 175.

scanning-hex: 143, 144, 145, 146, 150.

Section ended in mid-comment: 142.

Section name didn't end: 154.

Section name too long: 155.

semi-ptr: 94, 96, 97, 98, 101.

send-out: 100, lOl, 112, 113, 114, 116, 117,

118, 119, 120, 121.

send-sign: 100, 106, 112, 113.

send-the-output: 112, &lJ.

send-val: 100, lo7, 112, 119, 121.

set-element-sign: 15, 114.

sign : @, 102, 106, 108.

sign-val: 95, 102, 104, 106, 107, 108.

signval-sign: 95, 102, 106, 108.

signval-val : 95, 102, 106, 108.

-

simple : 47, 53, 89, 90, 164, 173.

sixteen-bits: 37, 38, 50, 66, 69, 73, 74, 78, 87,

101, 165, 179, 181.

skip-ahead: 140, 150, 159, 173, 176, 183.

skip-comment: &I, 145.

Sorry, x capacity exceeded: 36.

spotless : 9, 10, 187.

stack: 78, 79, 84, 85.

stack-ptr: 78, 79, 83, 84, 85, 87, 90, 113, 117, 118.

stack-size: 6, 79, 84.

stat: 3.

store-two-bytes: 7J, 93, 177.

str : _ Ho, 101, 114, 117, 118, 119, 121.

String constant didn't end: 149.
String didn't end: 168. String too long: 117.
string-ptr : 39, 40, 42, 64, 182, 184. systcrn dependencies: 1, 2, 4, 7, 12, 17, 20, 21,
22, 24, 26, 28, 32, 34, 115, 116, 121, 180, 181, 182, 187, 188. t: 53->10-1>16-75 1-7--0-* tab-mark : l5, 32, 139, 142, 145, 153, 154.
T A N G L E : 2.

TANGLE $189
t a t s : 3. temp-line: I& 125. term-in: 179, 180, 181. term-out: 20, 21, 22, 181. text-char: l2, 13, 20. text-file : X2, 20, 23, 25, 28, 179. text-link: 37, 38, 43, 70, 71, 83, 85, 90, 112,
170, 178. text-pointer: 43, 44, 70, 74, 78, 164. text-ptr : 43, 44, 46, 74, 81, 90, 91, 165, 186. This can't happen: 35. This identifier has already.. .: 59.
This identifier was defined...: 59.
tok-mem : 37, 38, 43, 44, 45, 70, 73, 74, 75, 78, 79, 80, 81, 87, 90, 93, 165.
tok-ptr : 43, 44, 46, 73, 81, 90, 91, 93, 165, 182. tok-start: 37, 38, 43, 44, 46, 70, 74, 78, 83, 84,
85, 90, 91, 165. trouble-shooting: 87, 145, l79, 180. true : 6, 28, 29, 124, 125, 127, 132, 134, 136, 138,
143, 150, 179, 180, 183. Two numbers occurred.. .: 108.
unambig-length: 8, 47, 50, 53, 58, 63. unbreakable: 95, 102, 113, 117. up-to : ll6, 145. update-terminal: 22, 31, 97, 112, 139, 181. uppercase: 58, 63, 105, 110, 114, 116, 119, 120. Use == for macros: 174. v: 9J, 101, 106, 107. val: l57, 158, 160, 161, 162. Value too big: 157. verbatim: 72, 76, 113, 118, 139, 167, 169. Verbatim string didn't end: 169. Verbatim string too long: 118. w: 4-9,53-,66-,69-987-1,13-WEB file ended...: 132. web-file: 2, 23, 24, 32, 124, 126, 132, 136, 138. Where is the match. . . : 129, 133, 137. wi: 4l, 42. 200: m,186. write : 20, 64, 97, 181, 184. write -In : 20, 64, 97, 184. ww: 8, 38, 39, 40, 41, 42, 43, 49, 53, 56, 61, 63, 66,
67, 68, 69, 75, 87, 90, 91, 113, 116, 185, 186. 2: 73. xchr : l3, 14, 16, 17, 18, 32, 33, 49, 63, 64, 75,
76, 97, 155, 167, 181, 184. xclause: 6.
xord: l.J, 16, 18, 28. You should double Q signs: 168, 169.
z: 44. zi : 45, 46.

$189 TANGLE
zo: 80, 83, 84, 85, 87, 90, 93, 182, 186. zp : 74, 75. 2.2 : 8, 38, 43, 44, 45, 46, 74, 80, 83, 84, 85, 90,
91, 165, 182, 186.

INDEX 195

196 NAMES OF THE SECTIONS

TAN. GLE $189

( Append out-val to buffer 103) Used in sections 102 and 104. ( Append th e (1 ecimal value of V, with parentheses if negative 111) Used in section 107.
( Cases involving Q(: and Q) 121) Used in section 113. ( Chses like <> and := 114) Used in section 113. ( Cases related to constants, possibly leading to get-fraction or reswitch 119) Used in section 113.
( Cases related to identifiers 116) Used in section 113. ( Check for ambiguity and update secondary hash 62 ) Used in section 61. ( Cheek for overlong name 155 ) Used iu section 153. ( Check if q conflicts with p 63 ) Used in section 62.
( Check that all changes have been read 138 ) Used in section 183. ( Check that = or = follows this module name, otherwise return 176) Used in section 175. ( Compare name p with current identifier, goto found if equal 56 ) Used in section 55.
( Compiler directives 4 ) Used in section 2. ( Compress two-symbol combinations like ` : ='147 ) Used in section 145. ( Compute the hash code h 54) Used in section 53.
( Compute the name location p 55 ) Used in section 53. ( Compute the secondary hash code h and put the first characters into the auxiliary array chopped-id 58)
Used in section 57.
( Constants in the outer block 8) Used in section 2. (Contribution is * or / or DIV or MOD 105) Used in section 104.
( Copy a string from the buffer to tok-mem 168 ) Used in section 165. ( Copy the parameter into tok-mem 93 ) Used in section 90. ( Copy verbatim string from the buffer to tok-mem 169) Used in section 167. ( Define and output a new string of the pool 64 ) Used in section 61. ( Display one-byte token a 76) Used in section 74. (Display two-byte token starting with a 75 ) Used in section 74. (Do special things when c = "Q", "\", "(", ")"; return at end 142) Used in section 141. (Empty the last line from the buffer 98) Used in section 112.
(Enter a new identifier into the table at position p 61) Used in section 57. (Enter a new module name into the tree 67 ) Used in section 66. . (Error handling procedures 30, 31, 34 ) Used in section 2. (Expand macro a <and goto found, or goto restart if no output found 89) Used in section 87. ( Expand module a - `24000, goto restart 88 ) Used in section 87. ( Finish off the string pool file 184 ) Used in section 182. ( Force a line break 122 ) Used in section 113. ( Get a preprocessed string 149) IJsed in section 145..
( Get itll idcntificr 148 ) Used in section 145. ( Get control code <and possible module name 150 ) Used in section 145. ( Get the buffer ready for appending the new information 102) Used in section 101.
( Give double-definition error and change p to type t 50) Used in section 57. ( Globals in the outer block 9, 13, 20, 23, 25, 27, 29, 38, 40, 44, 50, 65, 70, 79, 80, 82, 86, 94, 95, 100, 124, 126, 143, 156,
164, 171, 179, 185 ) Used in section 2.
( Go to jound if c is a hexadecimal digit, otherwise set scanning-hex t- fulse 146 ) Used in section 145.
( Handle cases of send-val when out-state contains a sign 108 ) Used in section 107. (Lf end of name, goto done 154) Used in section 153. ( If previous output wau * or /, goto bad-case 109) Used in section 107. (If previous output was DIV or MOD, goto bad-case 110) Used in section 107. (If the current line starts with @y, report any discrepancies md return 133 ) Used in section 132. (If the next text is `(#) =`, call define-macro and goto continue 174) Used in section 173. (III cases that a is a non-ASCII token (identifier, module-name, etc.), either process it cand change a to a
byte that should IX st&cd, or goto continue if n should be ignored, or goto clone if a signals the end of this replacement t,cxt 167 ) Used in section 165.

P

$189 TANGLE

NAMES OF THE SECTIONS 197

( Initialize the input system 134 ) used in section 182.
( Initialize the output buffer 96 ) Used in section 112. (Initialize the output stacks 83 ) ' Used in section 112. ( Insert the module number into tok-mem 177 ) Used in section 175. (Local variables for initialization 16, 41, 45, 51 ) Used in section 2. ( Make sure the parentheses balance 166) Used in section 165. (Move bufler and limit to change-bufleer and change-limit 131) Used in sections 128 and 132. ( Other printable characters 115 ) used in section 113. (Phase I: Read all the user's text and compress it into tok-mem 183 ) Used in section 182. (Phase II: Output the contents of the compressed tables 112 ) Used in section 182. (Print error location based on input buffer 32 ) Used in section 31. (Print error location based on output buffer 33 ) Used in section 31. (Print statistics about memory usage 186) Used in section 182. (Print the job history 187 ) Used in section 182. (Put a parameter on the parameter stack, or goto restart if error occurs SO) Used in section 89. ( Put module name into mod-text [I . . k] 153 ) Used in section 151. (Read from change-file and maybe turn off changing 137) Used in section 135. ( Read from web-file and maybe turn on changing 136 ) Used in section 135. (Reduce sign-val-val to sign-val and goto restart 104) Used in section 102. (Remove a parameter from the parameter stack 91) Used in section 85. ( Remove p from secondary hash table 60 ) Used in section 59. ( Scan the definition part of the current module 173 ) Used in section 172. ( Scan the module name and make cur-module point to it 151) used in section 150. ( Scan the PASCAL part of the current module 175) Used in section 172. (Send a string, goto teawitch 117) Used in section 113. ( Send verbatim string 118) Used in section 113. ( Set accumulator to the value of the right-hand side 158) Used in section 157. ( Set c to the result of comparing the given name to name p 68 ) Used in sections 66 and 69. ( set initial values 10, 14, 17, 18, 21, 26, 42, 46, 48, 52, 71, 144, 152, 180 ) Used in section 2. ( Set vaZ to value of decimal constant, and set next-control to the following token 160) Used in section 158. ( Set vaZ to value of hexadecimal constant, and set next-control to the following token 162) Used in
section 158.
( Set vaZ to value of octal constant, and set next-control to the following token 161) Used in section 158. ( Signal error, flush rest of the definition 159 ) Used in section 158. ( Skip over comment hes in the change file; return if end of file 129 ) IJsed in section 128. ( Skip to the next nonblank line; return if end of file 130 ) Used in section 128. ( Special code to finish real constants 120 > Used in section 113.
( Start scanning current macrd parameter, goto restart 92) Used in section 87. ( Types in the outer block 11, 12, 37, 39, 43, 78 > Used in section 2. {Update the data structure so that the replacement text is accessible 178) Used in section 175. (Update th e tables and check for possible &rors 57 ) Used in section 53.

APPENDIX F - MACROS FOR FORMATTING

.

199

Appendix F: The webmac . tex file. This is the file that extends "plain m format in order to support the features needed by the output of WEAVE.

1 standard macros for WEB listings (in addition to PLAIN.TEX) \parskip Opt % no stretch between paragraphs \parindent lem 1 for paragraphs and for the first line of PASCAL text

\font\eightrm=cmr8 \let\sc=\eightrm \let\mainfont=\tenrm \font\titlefont=cmr7 scaled\magstep4 % title on the contents page \font\ttitlefont=cmttlO scaled\magstep2 % typewriter type in title \font\tentex=cmtexlO % TeX extended character set (used in strings)

\def\\#l(\hbox(\it#l\/\kern.O5em)) % italic type for identifiers

\def\l#l(\hboxC$#l$)) % one-letter identifiers look a bit better this way

\def\&#l(\hbox(\bf#l\/)) % boldface type for reserved words

\def\.#l(\hbox(\tentex % typewriter type for strings

\let\\=\BS % backslash in a string

\let\'=\RQ % right quote in a string \let\'=\LQ % left quote in a string

.

\let\{=\LB % left brace in a string

\let\)=\RB % right brace in a string

\let\'=\TL % tilde in a string
\let\ =\SP % space in a string \let\-=\UL % underline in a string \let\&=\AM % ampersand in a string

. #I33

\def\#(\hbox{\tt\char'\#)) % parameter sign *

\def\$(\hbox{\tt\char`\$>) % dollar sign

\def\%{\hbox(\tt\char`\%)) % percent sign

\def\^(\ifmmode\mathchar"222 \else\char'^ \fi) % pointer or hat

% circumflex accents can be obtained from \^^D instead of \'

\def\AT!(Q) % at sign for control text

\chardef\AM=`\& '/, ampersand character in a string \chardef\BS=`\\ % backslash in a string . \chardef\LB=`\( % left brace in a string \def\LQ((\tt\char'22)) % left quote in a string \chardef\RB=`\) % right brace in a string \def\RQ({\tt\char'23)) % right quote in a string \def\SP{{\tt\char`\ 3) % (visible) space in a string \chardef\TL=`\' % tilde in a string \chardef\UL='\- % underline character in a string
\newbox\bak \setbox\bak=\hbox to -1 em{) % backspace one em \newbox\bakk\setbox\bakk=\hbox to - 2em() % backspace two ems

\newcount\ind % current indentation in ems \def\l{\global\advance\ind byl\hangindent\ind em) % indent one more notch \def\2{\global\advance\ind by-l) % indent one less notch \def\3#l{\hfil\ penalty#,lO\hfilneg) % optional break within a statement \def\4(\copy\bak} % backspace one notch \def\5{\hfil\penalty-l\hfilneg\kern2.5em\copy\bakk\ignorespaces3% optional break

200 APPENDIX F - MACROS FOR FORMATTING
\def\6(\ifmmode\else\par % forced break ' \hangindent\ind em\noindent\kern\ind em\copy\bakk\ignorespaces\fi)
\def\7(\Y\6> % f arced break'and a little extra space

.

\let\yskip=\smallskip \def\to(\mathrel{.\,.}> % double dot, used only in math mode \def\note#l#2.(\Y\ noindent(\hangindent2em\baselineskipl0pt\eightrm#l #2.\par)) \def\lapstar{\rlap(*>> \def\startsection(\Q\noindentC\let\*=\lapstar\bf\modstar.\quad}~ \def\defin#l(\global\advance\ind by 2 \I\&(#1 1) % begin `define' or `format' \def\A(\note(See also)) % cross-reference for multiply defined section names \def\B(\mathopen(\.(@\{)}> % begin controlled comment \def\C#l(\'1f mmode\gdef\XX(\null$\null)\else\gdef\XX{>\fi % PASCAL comments
\XX\hfil\penalty-l\hfilneg\quad$\(\,$#l$\,\~$\XX~ \def\D(\defin(define)) % macro definition \def\E(\cdotlO^> y, exponent in floating point constant \def\F(\defin(format>> % format definition \let\G=\ge % g reater than or equal sign \def\H#l{\hbox(\rm\char"7D\tt#l)) % hexadecimal constant \let\I=\ne % unequal sign \def\J<\.(@\&)) % TANGLE's join operation \let\K=\gets % left arrow \let\L=\le % 1 ess than or equal sign \outer\def\M#l.(\MN#l.\ifon\vfil\p enalty-lOO\vfilneg % beginning of section
\vskipl2ptminus3pt\startsection\ignorespaces> \outer\def\N#l.#2.(\MN#l.\vfil\ eject % beginning of starred section
\def\rhead{\ upp ercase(\ignorespaces#2)) % define running headline \message(*\modno} % progress report \edef\next~\write\cont~\Z~#2}~\mqdno)(\the\pageno}~}\next % to contents file \ifon\startsection(\bf\ignorespaces#2.\quad~\ignorespaces~ \def\MN#l.(\par % common code for \M, \N {\xdef\modstar(#l)\let\*=\empty\xdef\modno~#l~} \ifx\modno\modstar \onmaybe \else\ontrue \fi \mark(\modno)> \def\O#l{\hbox(\rm\char'23\kern-.2em\it#l\/\kern.O5em~} % octal constant \def\P(\rightskip=Opt plus IOOpt minus IOpt % go into PASCAL mode \sfcode';=3000 \pretolerance 10000 \hyphenpenalty 10000 \exhyphenpenalty 10000 \global\ind=2 \I\ \unskip) \def\Q(\rightskip=Opt % get out of PASCAL mode \sfcode` ;=I500 \pretolerance 200 \hyphenpenalty 50 \exhyphenpenalty 50 ) \let\R=\lnot % logical not . \let\S=\equiv % equivalence sign \def\T{\mathclose(\.{@\)))) % terminate controlled comment \def\U(\note{This code is used in)) % cross-reference for uses of sections \let\V=\lor % logical or \let\W=\land % logical and \def\X#l:#2\X(\ifmmode\gdef\XXC\null$\null~\else\gdef\XX~~\fi % section name \XX$\langle\,$#2{\eightrm\kern.5em#l)$\,\rangle$\XX~ \def\Y(\par\yskip) \let\Z=\let '/, now you can \send the control sequence \Z * \def\){\hbox(\.<@\$>>> % sign for string pool check sum

APPENDIX F - MACROS FOR FORMATTING
\def\l{\hbox{\.(@\\}}} % sign for forced line break \def\=#lC\kern2pt\hbox(\vrule\vtop(\vbox<\hrule
\hbox(\strut\kern2pt\.(#l}\kern2pt}} \hrule}\vrule}\kern2pt} % verbatim string \let\'=\ignorespaces \let\*=*
\def\onmaybe(\let\ifon=\maybe} \let\maybe=\iftrue \newif\ifon \newif\iftitle \newif\ifpagesaved \def\lheader(\mainfont\the\pageno\eightrm\qquad\rhead\hfill\title\qquad
\tensy x\mainfont\topmark} % top line on left-hand pages \def\rheader(\tensy x\mainfont\topmark\eightrm\qquad\title\hfill\rhead
\qquad\mainfont\the\pageno} % top line on right-hand pages \def\page{\box255 } \def\normaloutput#l#2#3(\shipout\vbox(
\ifodd\pageno\hoffset=\pageshift\fi \vbox to\fullpageheight( \iftitle\global\titlefalse \else\hbox t o \pagewidth(\vbox tolOpt{}\ifodd\pageno'#3\else#2\fi}\fi \vfill#l}} % parameter #I is the page itself \global\advance\pageno byl}
\def\rhead{\.(WEB} OUTPUT} % this running head is reset by starred sections \def\title(} '/, an optional title can be set by the user \def\topofcontents{\centerline{\titlefont\title}
\vfill} % this material will start the table of contents page \def\botofcontents(\vfill} % this material will end the table of contents page \def\contentspagenumber{O} % default page number for table of contents \newdimen\pagewidth \pagewidth=6.5in % the width of each page \newdimen\pageheight \pageheight=8.7in % the height of each page \newdimen\fullpageheight \fullpageheight=gin % page height including headlines \newdimen\pageshift \pageshift=Oin % shift righthand pages wrt lefthand ones \def\magnify#l(\mag=#l\pagewidth=6.5truein\pageheight=8.7truein
\fullpageheight=9truein} \def\setpage(\hsize\pagewidth\vsize\pageheight} % use after changing page size \def\contentsfile(CONTENTS} % file that gets table of contents info \def\readcontents{\input CONTENTS}
\newwrite\cont \output(\setboxO=\page % the first page is garbage
\openout\cont=\contentsfile \global\output{\normaloutput\page\lheader\rheader}} \setpage \vbox to \vsize(} % the first \topmark won't be null
\def\ch(\note{The foll owing sections were changed by the change file:} \let\*=\relax}
\newbox\sbox % saved box preceding the index \newbox\lbox % lefthand column in the index \def\inx(\par\vskip6pt plus lfil % we are beginning the index
\write\cont{} '/, ensure that the contents file isn't empty \closeout\cont % the contents information has been fully gathered

201

202 APPENDIX F - MACROS FOR FORMATTING
\global\setbox\sbox=\page \global\pagesavedtrue} \pagesavedfalse \eject % eject the page-so-far and predecessors \setbox\sbox\vbox{\unvbox\sbox} x take it out of its box \vsize=\pageheight \advance\vsize by -\ht\sbox % the remaining height \hsize=.5\pagewidth \advance\hsize by -1Opt
% column width for the index (2Opt between ~01s) \parfillskip Opt plus .6\hsize '/, try to avoid almost empty lines \def\lr{L} % this tells whether the left or right column is next \output(\if L\lr\global\setbox\lbox=\page \gdef\lr(R}
\else\normaloutput(\vbox to\pageheightC\box\sbox\vss \hbox to\pagewidthC\box\lbox\hfil\page}}}\lheader\rheader
\global\vsize\pageheight\gdef\lr{L}\global\pagesavedfalse\fi} \message(Index:} \parskip Opt plus .5pt \outer\def\:##l, {\par\hangindent2em\noindent##l:\kernlem} % index entry \def\[##l]($\underline{##l}$} x underlined index item \rm \rightskipOpt plus 2.5em \tolerance IO?00 \let\*=\lapstar \hyphenpenalty 10000 \parindentOpt} \def\fin(\par\vfill\eject 1 this is done when we are ending the index \ifpagesaved\null\vfill\eject\fi % output a null index column \if L\lr\else\null\vfill\eject\fi % finish the current page \parfillskip Opt plus lfil \def\rhead{NAMES OF THE SECTIONS} \message(Section names:} \output{\normaloutput\page\lheader\rheader} '-\setpage \def\note##l##2.(\quad(\eightrm##l ##2.}} \def\U(\note{Used in}} % cross-reference for uses of sections \def\:{\par\hangindent 2em}\let\*=*} \def\con{\par\vfill\eject % finish the section names \rightskip Opt \hyphenpenalty 50 \tolerance 200 \setpage \output{\normaloutput\page\lheader\rheader} \titletrue % prepare to output the table of contents \pageno=\conten.tspagenumber \def\rhead(TABLE OF CONTENTS} \message{Table of contents:} \topofcontents \line{\hfil S ection\hbox to3em(\hss Page}} \def\Z##l##2##3(\line{\ignorespaces##l
\leaders\hbox to .5em(.\hfil}\hfil\ ##2\hbox to3em{\hss##3}}} \readcontents\relax % read the contents info . \botofcontents \end} % print the contents page(s) and terminate

APPENDIXG-NOTES ONFORMATTING

.

203

Appendix G: How to use WEB macros. The macros in webmac make it possible to produce a variety of formats without editing the output of WEAVE, and the purpose of this appendix is to explain some of the possibilities.
1. Three fonts have been declared in addition to the standard fonts of PLAIN format: You can say `(\sc stuff}' to get STUFF in small caps; and you can select the largish fonts \titlefont and \ttitlefont in the title of your document, where \ttitlefont is a typewriter style of type.
2. When you mention an identifier in `l$$ text, you normally call it ` I identifier I `. But you can also say `\\{identifier}`. The output will look the same in both cases, but the second alternative doesn't put identifier into the index, since it bypasses WEAVE's translation from PASCAL mode.
3. To get typewriter-like type, as when referring to `WEB', you can use the `\. ' macro (e.g., `\. (WEB)`). In the argument to this macro you should insert an additional backslash before the symbols listed as `special string characters'in the index to WEAVE, i.e., before backslashes and dollar signs and the like. A `\u' here will result in the visible space symbol; to get an invisible space following a control sequence you can say `C,)`.
4. The three control sequences \pagewidth, \pageheight, and \fullpageheight can be redefined in the limbo section at the beginning of your WEB file, to change the dimensions of each page. The standard settings
\pagewidth=6.5in \pageheight=8.7in
\fullpageheight=gin

were used to prepare the present report; \fullpageheight is \pageheight plus room for the additional heading and page numbers at the top of each page. lf you change any of these quantities, you should call the macro \setpage immediately after making the change.
5. The \pageshift macro defines an amolmt by which right-hand pages (i.e., odd-numbered pages) are shifted right with respect to left-hand (even-numbered) ones. By adjusting this amount you may be able to get two-sided output in which the page numbers line up on opposite sides of each sheet.
6. The \titIe macro will appear at the top of each page in small caps. For example, Appendix D was produced after saying `\def \ti t le(WEAVE}`.
7. The first page usually is number 1; if you want some other starting page, just set \pageno to the desired number. For example, the initial limbo section for Appendix D included the command `\pageno=l6'.
8. The macro \if tit le will suppress the header line if it is defined by `\titletrue'. The normcal vahc is \titlefaIse except for the table of contents; thus, the contents page is usually unnumbered. lf your program is so long that the table of contents doesn't fit on a single page, or if you want a number to appear on the contents page, you should reset \pageno when you begin the table of contents.
Two macros are provided to give flexibility to the table of contents: \topof content s is invoked just before the contents info is read, and \botof contents is invoked just after. For example, Appendix D was produced with the following definitions:

\def\topofcontents(\null\vfill \titlefalse % include headline on the contents page \def\rheader{\mainfont Appendix D\hfil 15) \centerline{\titlefont The (\ttitlefont WEAVE} processor} \vskip 15pt \centerline{(Version 2)) \vfill>
Redefining \rheader, which is the headline for right-hand pages, suffices in this case to put the desired information at the top of the page.
9. Data for the table of contents is writLen to a file that is read after the indexes have bctn wed; thcrc's one line of data for every stnrrcd module. For example, when Appendix D was being generated, a file CONTENTS. TEX containing
\Z ( Introduction)(l){lG) \Z { The character set}(ll)(lQ~

204 APPENDM. G - NOTES ON FORMATTING
and similar lines was created. The \topof content s macro could redefine \Z so that the information appears in another format.
10. Sometimes it is necessary or desirable to divide the output of WEAVE into subfiles that can be processed separately. For example, the listing of Y&X runs to more than 500 pages, and that is enough to exceed the capacity of many printing devices and/or their software. When an extremely large job isn't cut into smaller pieces, the entire process might be spoiled by a single error of some sort, making it necessary to start everything over.
Here's a safe way to break a woven 6Ie into three parts: Say the pieces are CY, /3, and 7, where each piece begins with a starred module. All macros should be defined in the opening limbo section of cr, and copies of this QX code should be placed at the beginning of p and of 7. In order to process the parts separately, we need to take care of two things: The starting page numbers of p and 7 need to be set up properly, and the table of contents data from all three runs needs to be accumulated.
The webmac macros include two control sequences \content sf ile and \readcontents that facilitate the necessary processing. We include `\def\contentsfile(CONTl>' in the limbo section of (Y, and we include `\def \contentsf ile(CONT2)' in the limbo section of /?; this causes w to write the contents data for a and 0 into CONTl . TEX and CONT2. TEX. Now in 7 we say

\def\readcontents(\input CONTl \input CONT2 \input CONTENTS);

this brings in the data from alI three pieces, in the proper order. However, we still need to solve the page-numbering problem. One way to do it is to include the following
in the limbo material for ,f3:

\message(Please t y p e t h e l a s t p a g e n u m b e r o f p a r t 1: ) \read-lto\\ \pageno=\\ \advance\pageno by 1

Then you simply beginning of 7.

provide

the necessary

data when

T@

requests

it;

a. similar

construction

is used

at

the

This method can, of course, be used to divide a woven file into any number of pieces.

11. Sometimes it is nice to include things in the index that are typeset in a special way. For example,
we might want to have an index entry for `TgjX'. WEAVE provides only two standard ways to typeset an index entry (unless the entry is an identifier or a reserved word): `Q-' gives roman type, and `0. ' gives typewriter type. But if we try to typeset `T@' in roman type by saying, e.g., `@^\TeXG>`, the backslash character gets in the way, and this entry wouldn't appear in the index with the T's.
The solution is to use the `8: ' feature, declaring a macro that simply removes a sort key as follows:

\def \9#1<>

Now you can say, e.g., `Q : TeX)(\TeX@>'in your WEB file; WEAVE puts it into the index alphabetically, based on the sort key, (and produces the macro call `\S(TeX)(\TeX>' which will ensure that the sort key isn't printed.
A similar idea can be used to insert hidden material into module names so that they are alphabetized in whatever way you might wish. Some people call these tricks "special refinements"; others call them "kludges".
12. The control sequence \modno is set to the number of the module being typeset.
13. If you want to list only the modules that have changed, together with the index, put the command `\let\maybe=\if f alse'in the limbo section before the first module of your WEB file. It's customary to make this the first change in your change file.

APPENDIXH-GETTINGSTARTED

205

Appendix H: Installing the WEB system. Suppose you want to use the WEB programs on your computer, and suppose that you can't simply borrow them from somebody else who has the same kind of machine. Here's what to do:
(1) Get a tape that contains the files WEAVE.WEB, TANGLE.WEB, TANGLE. PAS, and WEBMAC .TEX. The tape will probably also contain an example change file TANGLE. CH.
(2) Look at the sections of TANGLE that are listed under "system dependencies" in the index of Appendix E above, and figure out what changes (if any) will be ncedcd for your system.
(3) Make a change file TANGLE. CH that contains the changes of (2); d o not change your copy of TANGLE. WEB, leave it intact. (The rules for change files are explained at the end of the manual just before the appendices; you may want to look at the example change file that arrived with your copy of TANGLE. WEB. It's also a good idea to define all the "switches" like debug and gubed to be null in your first change files; then you can sure that your compiler will handle all of the code.)
(4) Make teh c hang es of (2) in your copy of TANGLE. PAS. (If these changes are extensive, you might be better off finding some computer that that already has TANGLE running, and making the new TANGLE. PAS from TANGLE. WEB and your TANGLE. CH.)
(5) Use your PASCAL compiler to convert your copy of TANGLE. PAS to a running program TANGLE. (6) Check your changes as follows: Run TANGLE on TANGLE. WEB and your TANGLE. CH, yielding TANGLE. PAS';
make a running program TANGLE' by applying PASCAL to TANGLE. PAS'; run TANGLE' on TANGLE. WEB and your TANGLE. CH, yielding TANGLE. PAS"; and check that TANGLE. PAS" is identical to TANGLE. PAS'. Once this test has been passed, you have got a working TANGLE program. (7) Make a change file WEAVE. CH analogous to (3)) but this time consider the system-dependent parts of WEAVE that are listed in the index to Appendix D. (8) Rim TANGLE on WEAVE. WEB and your WEAVE. CH, obtaining WEAVE. PAS.
(9) Use PASCAL on WEAVE.PAS to make a running WEAVE program. (10) Run WEAVE on TANGLE. WEB and TANGLE. CH to produce TANGLE. TEX. (11) Run `l'@ on TANGLE .TEX, obtaining a listing analogous to Appendix E. This listing will incorporate
your changes. (12) Run WEAVE on WEAVE. WEB and your WEAVE. CH to produce WEAVE. TEX. (13) Run Tl$ on WEAVE. TEX, obtaining a listing analogous to Appendix D that incorporates your changes.
This description assumes that you already have a working T~$82 system. But what if you don't have lm82? Then you start with a tape that also contains TEX . WEB and plain. tex, and you refer to a hardcopy listing of the T@82 program corresponding to TEX . WEB. Between steps (10) and (11) you do the following:
(10.1) Make a change file TEX. CH to fix the system dependent portions of TEX. WEB, in a manner analogous to step (2). Since `l&X is a much more complex program than WEAVE or TANGLE, there are more system-dependent features to think about, but by now you will be good at making such modifications. Do not make any changes to TEX . WEB.
(10.2) Make an almost-copy of your TEX. CH called INITEX. CH; this one will have the `init' and `tini' macros redefined in order to make the initialization version of TJ$. It also might have smaller font memory and dynamic memory areas, since INITEX doesn't nod as much memory for such things; by setting the memory smaller in INITEX, you gurtrantce that the production system will have a "cushion."
(10.3) Run TANGLE 011 TEX. WEB and INITEX. CH, obtaining INITEX . PAS and TEX . POOL.
(10.4) Run PASCAL on INITEX. PAS, obtaining INITEX. (10.5) Run INITEX on TEX. POOL, during which run you type `plain'and `\dump'. This will produce a file
plain. fmt containing the data needed to initialize m's memory. (10.6) R,un TANGLE on TEX. WEB and the TEX. CH of (10.1)) obtaining TEX. PAS.
(10.7) Run PASCAL on TEX. PAS, obtaining VIRTEX.
(10.8) lf your operating systcrn support,s programs whose core images have been saved, run VIRTEX, type `&plain', then save the core image and call its ?`J$. Othcrwisc, VIRTEX will be your qfi, and it will read `plain. fmt' (or some other fmt file) each time you run.

206 APPENDIX H - GETTING STARTED
This 21-step process may seem long, hut it is actually an oversimplification, since you also need fonts and a way to print the device-independent files that w spews out. On the other hand, the total number of steps is not quite so large when you consider that TANGLE-followed-by-PASCAL and WEAVE-followed-by-w may be regarded <as single operations.
If you have only the present report, not a tape, you will have to prepare files WEAVE. WEB and TANGLE. WEB by hand, typing them into the computer by following Appendices D and E. Then you have to simulate the behavior of TANGLE by converting TANGLE. WEB manually into TANGLE. PAS; with a good text editor this takes about six hours. Then you have to correct errors that were made in all this hand work: but still the whole project is not impossibly difficult, because in fact the entire development of WEAVE and TANGLE (including the writing of the programs and the manual) took less than two months of work.

