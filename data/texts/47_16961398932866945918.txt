Proposed Wording for Concepts (Revision 9)
Authors: Douglas Gregor, Indiana University Bjarne Stroustrup, Texas A&M University James Widman, Gimpel Software Jeremy Siek, University of Colorado at Boulder
Document number: N2773=08-0283 Revises document number: N2741=08-0251 Date: 2008-09-19 Project: Programming Language C++, Core Working Group Reply-to: Douglas Gregor <doug.gregor@gmail.com>
Introduction
This document provides proposed wording for concepts. Readers unfamiliar with concepts are encouraged to read the complete proposal [1]. It is recommended that readers "tour" this concepts wording using N2399=07-0259, which provides an examples-directed view of the major language features involved in concepts, cross-referenced with this document. This document provides wording for changes to the core language. Changes to the standard library are discussed in separate documents.
Changes from N2741
-- Clarify wording regarding the kinds of archetypes for which candidate operator functions will be built (13.6).
-- Associated template requirements can now only be satisfied by template aliases, not by class templates defined within a concept map (14.9.2.2).
-- "Implicit concepts" are now called "auto concepts" in the wording.
-- Moved the support concepts from library clause 20 into clause 14.9.4.
-- Replaced the term late-check-block with late-checked-block.
-- Removed the compiler-supported concept std::FunctionType, because it was found to be unnecessary as a compile built-in.
-- Introduced the model of archetypes as class types, and adjusted certain other types (e.g., "object type") to allow for archetypes that are meant to stand in for those types. For example, T where the requirement std::ObjectType<T> is in scope.
-- Move the text describing how to build an archetype from concept requirements into its own section (14.10.2.1).
-- Use more-refined/less-refined terminology throughout.

2
Typographical conventions Within the proposed wording, text that has been added will be presented in blue and underlined when possible. Text that has been removed will be presented in red,with strike-through when possible. Wording new to this revision will be underlined in green. Take that, angry fruit salad. Purely editorial comments will be written in a separate, shaded box.

Chapter 1 General

[intro]

1.3 Definitions

[intro.defs]

1.3.11

[defns.signature]

signature

the name and the parameter-type-list (8.3.5) of a function, as well as the class, concept, concept map, or namespace of

which it is a member. If a function or function template is a class member its signature additionally includes the cv-

qualifiers (if any) and the ref-qualifier (if any) on the function or function template itself. The signature of a constrained

member (9.2) includes its template requirements. The signature of a function template additionally includes its return

type and, its template parameter list, and its template requirements (if any). The signature of a function template spe-

cialization includes the signature of the template of which it is a specialization and its template arguments (whether

explicitly specified or deduced). [ Note:Signatures are used as a basis for name mangling and linking. -- end note ]

1.3 Definitions

General 4

4

Chapter 2 Lexical conventions

[lex]

2.11 Keywords

[key]

1 The identifiers shown in Table 3 are reserved for use as keywords (that is, they are unconditionally treated as keywords in phase 7):

asm auto axiom bool break case catch char char16_t char32_t class concept concept_map const const_cast

Table 3: keywords

continue

friend

register

default

goto

reinterpret_cast

delete

if

requires

do

inline

return

double

int

short

dynamic_cast late_check signed

else

long

sizeof

enum

mutable

static

explicit

namespace static_assert

export

new

static_cast

extern

operator struct

false

private

switch

float

protected template

for

public

this

throw true try typedef typeid typename union unsigned using virtual void volatile wchar_t while

2.11 Keywords

Lexical conventions 6

6

Chapter 3 Basic concepts

[basic]

3 An entity is a value, object, subobject, base class subobject, array element, variable, function, instance of a function, enumerator, type, class member, template, namespace, or parameter pack, concept, or concept map.

6 Some names denote types, classes, concepts, concept map namesconcept maps, enumerations, or templates. In general, it is necessary to determine whether or not a name denotes one of these entities before parsing the program that contains it. The process that determines this is called name lookup (3.4).

3.2 One definition rule

[basic.def.odr]

1 No translation unit shall contain more than one definition of any variable, function, class type, concept, concept map, enumeration type or template.

5 There can be more than one definition of a class type (clause 9), concept (14.9), concept map (14.9.2), enumeration type ([dcl.enum]), inline function with external linkage ([dcl.fct.spec]), class template (clause 14), non-static function template (14.5.6), static data member of a class template ([temp.static]), member function of a class template ([temp.mem.func]), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then

3.3 Declarative regions and scopes

[basic.scope]

3.3.1 Point of declaration

[basic.scope.pdecl]

10 The point of declaration for a concept (14.9) is immediately after the identifier in the concept-definition. The point of declaration for a concept map (14.9.2) is immediately after the concept-id in the concept-map-definition.
11 The point of declaration for a template requirement (14.10.1) is immediately after the corresponding requirement in a requires-clause or the constrained-template-parameter in a template-parameter-list. The point of declaration of an implied template requirement (14.10.1.2) is the point of declaration of the template requirement from which it was implied or immediately after the declaration of the entity from which the requirement was implied.

Add the following new sections to 3.3 [basic.scope] after [basic.scope.class]: 3.3.8 Concept scope

[basic.scope.concept]

1 The following rules describe the scope of names declared in concepts and concept maps.
1) The potential scope of a name declared in a concept or concept map consists not only of the declarative region following the name's point of declaration, but also of all associated function bodies in that concept or concept map.

3.4 Name lookup

Basic concepts 8

2) A name N used in a concept or concept map S shall refer to the same declaration in its context and when reevaluated in the completed scope of S. No diagnostic is required for a violation of this rule.
3) If reordering declarations in a concept or concept map yields an alternate valid program under (1), the program is ill-formed, no diagnostic is required.
4) A name declared within an associated function definition hides a declaration of the same name whose scope extends to or past the end of the associated function's concept or concept map.

3.3.9 Requirements scope

[basic.scope.req]

1 A template requirement has requirements scope. Its potential scope begins at its point of declarationimmediately after its concept-id and terminates at the end of the constrained template (14.10) or constrained member (9.2).

2 In a constrained context (14.10), the names of all associated functions inside the concepts named by the concept requirements in the template's requirements are visible in the scope of the template declarationdeclared in the same scope as the constrained template's template parameters. Each of these names refers to one or more members of the concept map archetypes (14.10.2) that correspond to the concept requirements. [ Note: The declaration of these names in the scope of the template parameters does not establish archetypes unless name lookup finds these declarations. -- end note ] [ Example:

concept A<class B> { void g( const B& );
}

template< class T, class U > requires A<U> void f( T & x, U & y ) {
g( y ); // binds to A<U'>'::g( const U' & ) g( x ); // error: no overload of g takes T' values. }

-- end example ]

3 [ Note: Function names can be found within the concept map archetypes ([temp.archetype]) corresponding to a template's requirements. [ Example: -- end example ] -- end note ]

3.3.10 Name hiding

[basic.scope.hiding]

1 A name can be hidden by an explicit declaration of that same name in a nested declarative region, more refined concept (14.9.3), or derived class ([class.member.lookup]).

Add the following new paragraph:

6 In an associated function definition, the declaration of a local name hides the declaration of a member of the concept or concept map with the same name; see 3.3.8.

3.4 Name lookup

[basic.lookup]

1 The name lookup rules apply uniformly to all names (including typedef-names ([dcl.typedef]), namespace-names ([ba-

8

9 Basic concepts

3.4 Name lookup

sic.namespace]), concept-names (14.9), concept-map-names (14.9.2), and class-names ([class.name]) wherever the grammar allows such names in the context discussed by a particular rule. Name lookup associates the use of a name with a declaration ([basic.def]) of that name. Name lookup shall find an unambiguous declaration for the name (see [class.member.lookup]). Name lookup may associate more than one declaration with a name if it finds the name to be a function name; the declarations are said to form a set of overloaded functions (13.1). Overload resolution (13.3) takes place after name lookup has succeeded. The access rules (clause [class.access]) are considered only once name lookup and function overload resolution (if applicable) have succeeded. Only after name lookup, function overload resolution (if applicable) and access checking have succeeded are the attributes introduced by the name's declaration used further in expression processing (clause 5).

3.4.1 Unqualified name lookup

[basic.lookup.unqual]

Add the following new paragraphs:

16 A name used in the definition of a concept or concept map X outside of an associated function body shall be declared in one of the following ways:
-- before its use in the concept or concept map X or be a member of a less refined concept of X, or
-- if X is a member of namespace N, before the definition of concept or concept map X in namespace N or in one of N's enclosing namespaces.
[ Example:
typedef int result_type; concept C<class F, class T1> {
result_type operator() (F&, T1); typename result_type; // error result_type used before declared }
-- end example ]
17 A name used in the definition of an associated function (14.9.1.1) of a concept or concept map X following the associated function's declarator-id shall be declared in one of the following ways:
-- before its use in the block in which it is used or in an enclosing block ([stmt.block]), or
-- shall be a member of concept or concept map X or be a member of a less refined concept of X, or
-- if X is a member of namespace N, before the associated function definition, in namespace N or in one of N's enclosing namespaces.

3.4.2 Argument-dependent name lookup

[basic.lookup.argdep]

2 For each argument type T in the function call[...]
-- If T is a fundamental type, its associated sets of namespaces and classes are both empty.
-- If T is a non-archetype class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes.[...]

9

3.4 Name lookup

Basic concepts 10

3.4.3 Qualified name lookup

[basic.lookup.qual]

1 The name of a class, concept map (but not a concept), or namespace member or enumerator can be referred to after the :: scope resolution operator (5.1) applied to a nested-name-specifier that nominates its class, concept map, namespace, or enumeration. During the lookup for a name preceding the :: scope resolution operator, object, function, and enumerator names are ignored. If the name found does not designate a namespace, concept map, or a class, enumeration, or dependent type, the program is ill-formed.

Add the following paragraph to Qualified name lookup [basic.lookup.qual]

6 In a constrained templatecontext (14.10), a name prefixed by a nested-name-specifier that nominates a template type parameter T is looked up as follows: for each template requirement C<args> whose template argument list references T, the name is looked up as if the nested-name-specifier referenced C<args> instead of T (3.4.3.3), except that only the names of associated types are visible during this lookup. If an associated type of at least one requirement is found, then each name found shall refer to the same type. Otherwise, if the reference to the name occurs within a constrained context, the name is looked up within the scope of the archetype associated with T (and no special restriction on name visibility is in effect for this lookup). [ Note: Otherwise, the name is a member of an unknown specialization [temp.dep.type] -- end note ] [ Example:

concept C<typename T> { typename assoc_type;
}

template<typename T, typename U> requires C<T> && C<U>

T::assoc_type

// okay: refers to C<T>::assoc_type

f();

-- end example ]

Add the following subsection to Qualified name lookup [basic.lookup.qual] 3.4.3.3 Concept map members

[concept.qual]

1 If the nested-name-specifier of a qualified-id nominates a concept instance, the name specified after the nested-name-specifier is looked up as follows:
-- If the template argument list of the concept instance references a template parameter or associated type of a requirementdepends on a template parameter, and if the name, when looked up within the scope of the concept (not the concept instance), refers to an associated type or class template, the result of name lookup is the associated type or class template as a member of the requirementa dependent type composed of the concept instance and the associated type or class template. [ Note: this implies that, given two distinct type parameters T and U, C<T>::type and C<U>::type are distinct types (although they may refer toalias the same archetype). Also, lookup of 'type' within C<T> and C<U> does not require the creation of a concept map archetype for C<T> or C<U>. -- end note ]
-- Otherwise, concept map lookup (14.10.1.1) first determines which concept map is referred to by the nested-name-specifier. Then concept member lookup (14.9.3.1) is used to find the name within the scope of the concept map. The name shall represent one or more members of that concept map or the concept maps corresponding to the concept's less refined concepts. [ Note: this lookup requires a concept map definition, so if the template argument list of the concept instance references a template parameter or associated type of a requirementis dependent on a template

10

11 Basic concepts

3.9 Types

parameter (and, therefore, the name does not refer to an associated type or class template--a case which would have been handled by the previous bullet), a concept map archetype definition is required. -- end note ]
[ Note: Outside of a constrained context, this means that one or more requirement members (14.9.2) will be found, and since those names are synonyms for sets of other names, the result of name lookup is the union of each of those sets. -- end note ] . [ Note: a concept map member can be referred to using a qualified-id at any point in its potential scope (3.3.8). [ Example:
concept C<typename F, typename T1> { typename type; type operator()(F&, T1);
}
template<typename F, typename T1> requires C<F, T1> C<F, T1>::result_type g(F& f, const T1& t1) {
return f(t1); }
-- end example ] -- end note ]
2 A concept map member name hidden by a name in a nested declarative region or by the name of a more refined concept's member can still be found if qualified by the name of its concept map followed by the :: operator.

3.9 Types

[basic.types]

1 [ Note: 3.9 and the subclauses thereof impose requirements on implementations regarding the representation of types. There are two kinds of types: fundamental types and compound types. Types describe objects ([intro.object]), references (8.3.2), or functions (8.3.5). In a constrained context (14.10), type archetypes can behave like various kinds of types, e.g., object types, scalar types, literal types, etc.are class types; however, a type archetype has a compiler-supported requirement (i.e., a type archetype T' in a context where some requirement C<T> is in scope) may be used in certain contexts where a class type is normallly not permitted or may be disallowed in certain contexts where a class type is normally permitted. Such contexts are explicitly noted in this International Standard. -- end note ]

9 Arithmetic types (3.9.1), enumeration types, pointer types, pointer to member types ([basic.compound]), and std::nullptr_t, and cv-qualified versions of these types ([basic.type.qualifier]) are collectively called scalar types. Scalar types, POD classes (clause 9), arrays of such types and cv-qualified versions of these types ([basic.type.qualifier]) are collectively called POD types. Scalar types, trivial class types (clause 9), arrays of such types and cv-qualified versions of these types ([basic.type.qualifier]) are collectively called trivial types. Scalar types, standard-layout class types (clause 9), arrays of such types and cv-qualified versions of these types ([basic.type.qualifier]) are collectively called standard-layout types.

10 An effective trivial type T is a trivial type or a (possibly cv-qualified) type archetype (14.10.2) has the requirement std::TrivialType<T>.

11 A type is a literal type if it is:

-- a scalar type; or

-- a class type (clause 9) with

11

3.9 Types

Basic concepts 12

-- a trivial copy constructor,
-- a trivial destructor,
-- at least one constexpr constructor other than the copy constructor,
-- no virtual base classes, and
-- all non-static data members and base classes of literal types; or
-- an array of literal type.
12 An effective literal type T is a non-archetype literal type or a (possibly cv-qualified) type archetype (14.10.2) has the requirement std::LiteralType<T>.
-- end note ]
8 An object type is a (possibly cv-qualified) type that is not a function type, not a reference type, and not a void type. An effective object type T is a non-archetype object type or a (possibly cv-qualified) type archetype (14.10.2) has the requirement std::ObjectType<T>.

3.9.1 Fundamental types

[basic.fundamental]

7 Types bool, char, char16_t, char32_t, wchar_t, and the signed and unsigned integer types are collectively called integral types.1) A synonym for integral type is integer type. The representations of integral types shall define values by use of a pure binary numeration system.2)

8 An effective integral type T is an integral type or a (possibly cv-qualified) type archetype (14.10.2) has the requirement std::IntegralType<T>.

1) Therefore, enumerations ([dcl.enum]) are not integral; however, enumerations can be promoted to integral types as specified in [conv.prom]. 2) A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest position. (Adapted from the American National Dictionary for Information Processing Systems.)
12

Chapter 4 Standard conversions

[conv]

4.1 Lvalue-to-rvalue conversion

[conv.lval]

1 An lvalue ([basic.lval]) of a non-function, non-array type T can be converted to an rvalue. If T is an incomplete type, a program that necessitates this conversion is ill-formed. If the object to which the lvalue refers is not an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has undefined behavior. If T is a non-class typenot an effective class type, the type of the rvalue is the cv-unqualified version of T. Otherwise, the type of the rvalue is T.

4.10 Pointer conversions

[conv.ptr]

2 An rvalue of type "pointer to cv T," where T is an effective object type can be converted to an rvalue of type "pointer to cv void". The result of converting a "pointer to cv T" to a "pointer to cv void" points to the start of the storage location where the object of type T resides, as if the object is a most derived object ([intro.object]) of type T (that is, not a base class subobject). The null pointer value is converted to the null pointer value of the destination type.

4.10 Pointer conversions

Standard conversions 14

14

Chapter 5 Expressions

[expr]

5.1 Primary expressions

[expr.prim]

7 An identifier is an id-expression provided it has been suitably declared (clause 7). [ Note: for operator-function-ids, see 13.5; for conversion-function-ids, see 12.3.2; for template-ids, see [temp.names]. A class-name prefixed by  denotes a destructor; see 12.4. Within the definition of a non-static member function, an identifier that names a non-static member is transformed to a class member access expression ([class.mfct.non-static]). -- end note ] The type of the expression is the type of the identifier. The result is the entity denoted by the identifier. The result is an lvalue if the entity is a function, variable, or data member.
qualified-id: ::opt nested-name-specifier templateopt unqualified-id :: identifier :: operator-function-id :: template-id

nested-name-specifier: type-name :: namespace-name :: nested-name-specifier identifier :: nested-name-specifier templateopt template-id :: nested-name-specifieropt concept-id ::
5.2 Postfix expressions

[expr.post]

5.2.1 Subscripting

[expr.sub]

1 A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type "pointer to T" and the other shall have enumeration or integral type. The result is an lvalue of type "T." The type "T" shall be a completely-defined effective object type.

5.2.2 Function call

[expr.call]

3 The type of the function call expression is the return type of the statically chosen function (i.e., ignoring the virtual keyword), even if the type of the function actually called is different. This type shall be a complete effective object type, a reference type or the type void.

4 [...]When a function is called, the parameters that have effective object type shall have completely-defined object type.[...]

5.2 Postfix expressions

Expressions 16

7 [..]After these conversions, if the argument does not have arithmetic, enumeration, pointer, pointer to member, or effective class type, the program is ill-formed.[...]

5.2.3 Explicit type conversion (functional notation)

[expr.type.conv]

2 The expression T(), where T is a simple-type-specifier ([dcl.type.simple]) for a non-array complete effective object type or the (possibly cv-qualified) void type, creates an rvalue of the specified type, which is value-initialized ([dcl.init]; no initialization is done for the void() case).

5.2.6 Increment and decrement

[expr.post.incr]

1 The value of a postfix ++ expression is the value of its operand. [ Note: the value obtained is a copy of the original value -- end note ] The operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to a complete effective object type.[...]

5.2.7 Dynamic cast

[expr.dynamic.cast]

1 The result of the expression dynamic_cast<T>(v) is the result of converting the expression v to type T. T shall be a pointer or reference to a complete effective class type, or "pointer to cv void." Types shall not be defined in a dynamic_cast. The dynamic_cast operator shall not cast away constness (5.2.9).

2 If T is a pointer type, v shall be an rvalue of a pointer to complete effective class type, and the result is an rvalue of type T. If T is an lvalue reference type, v shall be an lvalue of a complete effective class type, and the result is an lvalue of the type referred to by T. If T is an rvalue reference type, v shall be an expression having a complete effective class type, and the result is an rvalue of the type referred to by T.

5.2.8 Reinterpret cast

[expr.reinterpret.cast]

7 A pointer to an effective object can be explicitly converted to a pointer to an object of different type. Except that converting an rvalue of type "pointer to T1" to the type "pointer to T2" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified.

10 An rvalue of type "pointer to member of X of type T1" can be explicitly converted to an rvalue of type "pointer to member of Y of type T2" if T1 and T2 are both function types or both effective object types.

5.2.9 Const cast

[expr.const.cast]

3 For two pointer types T1 and T2 where
T1 is cv1,0 pointer to cv1,1 pointer to    cv1,n-1 pointer to cv1,n T
and
T2 is cv2,0 pointer to cv2,1 pointer to    cv2,n-1 pointer to cv2,n T
where T is any effective object type or the void type and where cv1,k and cv2,k may be different cv-qualifications, an rvalue of type T1 may be explicitly converted to the type T2 using a const_cast. The result of a pointer const_cast refers to the original object.

4 An lvalue of type T1 can be explicitly converted to an lvalue of type T2 using the cast const_cast<T2&> (where T1 and T2 are effective object types) if a pointer to T1 can be explicitly converted to the type "pointer to T2" using a const_cast. Similarly, for two effective object types T1 and T2, an expression of type T1 can be explicitly converted to an

16

17 Expressions

5.3 Unary expressions

rvalue of type T2 using the cast const_cast<T2&&> if a pointer to T1 can be explicitly converted to the type "pointer to T2" using a const_cast. The result of a reference const_cast refers to the original object.

5.3 Unary expressions

[expr.unary]

5.3.1 Unary operators

[expr.unary.op]

1 The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an effective object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is "pointer to T," the type of the result is "T." [ Note: a pointer to an incomplete type (other than cv void) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to an rvalue, see 4.1. -- end note ]

2 The result of the unary & operator is a pointer to its operand. The operand shall be an lvalue or a qualified-id. In the first case, if the type of the expression is "T," the type of the result is "pointer to T." In particular, the address of an object of type "cv T" is "pointer to cv T," with the same cv-qualifiers. For a qualified-id, if the member is a static member of type "T", the type of the result is plain "pointer to T." If the member is a non-static member of class C of type T, the type of the result is "pointer to member of class C of type T." The address of a member of a concept map (14.9.2) shall not be taken, either implicitly or explicitly, nor shall a member of a concept map be bound to a reference. [ Example:

struct A { int i; }; struct B : A { }; ... &B::i ...

// has type int A::*

-- end example ] [ Note: a pointer to member formed from a mutable non-static data member ([dcl.stc]) does not reflect the mutable specifier associated with the non-static data member. -- end note ]

5.3.2 Increment and decrement

[expr.pre.incr]

1 The operand of prefix ++ is modified by adding 1, or set to true if it is bool (this use is deprecated). The operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to a completely-defined effective object type. The result is the updated operand; it is an lvalue, and it is a bit-field if the operand is a bit-field. If x is not of type bool, the expression ++x is equivalent to x+=1.

5.3.6 Alignof

[expr.alignof]

An alignof expression yields the alignment requirement of its operand type. The operand shall be a type-id representing a complete effective object type.

5.5 Pointer-to-member operators

[expr.mptr.oper]

2 The binary operator .* binds its second operand, which shall be of type "pointer to member of T" (where T is a completely-defined effective class type) to its first operand, which shall be of class T or of a class of which T is an unambiguous and accessible base class. The result is an object or a function of the type specified by the second operand.

3 The binary operator ->* binds its second operand, which shall be of type "pointer to member of T" (where T is a completely-defined effective class type) to its first operand, which shall be of type "pointer to T" or "pointer to a class of which T is an unambiguous and accessible base class." The result is an object or a function of the type specified by

17

5.7 Additive operators

Expressions 18

the second operand.

5.7 Additive operators

[expr.add]

1 [...]For addition, either both operands shall have arithmetic or enumeration type, or one operand shall be a pointer to a completely defined effective object type and the other shall have integral or enumeration type.

2 For subtraction, one of the following shall hold:

-- both operands have arithmetic or enumeration type; or

-- both operands are pointers to cv-qualified or cv-unqualified versions of the same completely defined effective object type; or

-- the left operand is a pointer to a completely defined effective object type and the right operand has integral or enumeration type.

5.17 Assignment and compound assignment operators

[expr.ass]

7 The behavior of an expression of the form E1 op = E2 is equivalent to E1 = E1 op E2 except that E1 is evaluated only once. In += and -=, E1 shall either have arithmetic type or be a pointer to a possibly cv-qualified completely defined effective object type. In all other cases, E1 shall have arithmetic type.

5.19 Constant expressions

[expr.const]

2 A conditional-expression is a constant expression unless it involves one of the following as a potentially evaluated subexpression (3.2), but subexpressions of logical AND ([expr.log.and]), logical OR ([expr.log.or]), and conditional ([expr.cond]) operations that are not evaluated are not considered [ Note:an overloaded operator invokes a function -- end note ]:

-- an lvalue-to-rvalue conversion (4.1) unless it is applied to

-- an lvalue of effective integral type that refers to a non-volatile const variable or static data member initialized with constant expressions, or

-- an lvalue of effective literal type that refers to a non-volatile object defined with constexpr, or that refers to a sub-object of such an object;

-- a class member access ([expr.ref]) unless its postfix-expression is of effective trivial or effective literal type or of pointer to effective trivial or effective literal type;

3 A constant expression is an integral constant expression if it is of integral or enumeration type, or if it is an archetype has the concept requirement std::IntegralConstantExpressionType<T> (14.9.4). [ Note: such expressions may be used as array bounds (8.3.4, 5.3.4), as case expressions (6.4.2), as bit-field lengths (9.6), as enumerator initializers (7.2), as static member initializers (9.4.2), and as integral or enumeration non-type template arguments (14.3). -- end note ]

4 If an expression of effective literal class type is used in a context where an integral constant expression is required, then that class type shall have a single non-explicit conversion function to an integral or enumeration type and that conversion function shall be constexpr.

18

Chapter 6 Statements

[stmt.stmt]

1 Except as indicated, statements are executed in sequence.
statement: labeled-statement expression-statement compound-statement selection-statement iteration-statement jump-statement declaration-statement try-block late-checked-block
6.7 Declaration statement

[stmt.dcl]

3 It is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A program that jumps3) from a point where a local variable with automatic storage duration is not in scope to a point where it is in scope
is ill-formed unless the variable has effective trivial type (3.9) and is declared without an initializer ([dcl.init]).

6.9 Late-checked block

[stmt.late]

1 In a constrained context (14.10), a late-checked block treats the enclosed statements as if they were in an unconstrained context. Outside of a constrained context, the late-checked block has no effect. [ Note: in a late-checked block, template parameters do not behave as if they were replaced with their corresponding archetypes. Thus, template parameters imply the existence of dependent types, type-dependent expressions, and dependent names as in an unconstrained template. Furthermore, names at requirements scope (3.3.9) are not visible. -- end note ]
late-checked-block: late_check compound-statement
2 [ Example:

concept Semigroup<typename T> { T::T(const T&); T operator+(T, T);
}

concept_map Semigroup<int> { int operator+(int x, int y) { return x * y; }
}
3)The transfer from the condition of a switch statement to a case label is considered a jump in this respect.

6.9 Late-checked block

Statements 20

template<Semigroup T> T add(T x, T y) {
T r = x + y; // uses Semigroup<T>::operator+ late_check {
r = x + y; // uses operator+ found at instantiation time (not considering Semigroup<T>::operator+) } return r; }
-- end example ]
3 [ Note: within a late-checked block, users should prefer to avoid using operations which, if written outside of the latechecked block and in the nearest enclosing unconstrained context, would bind to a member of a concept map archetype. If said avoidance is not practical, those operations should be clearly documented. For example, the author of add(T,T) should warn other users against satisfying Semigroup<T>::operator+ with anything other than the operator+ that would normally be selected for a given type T. -- end note ]
4 [ Note: a late-checked block should be used only when certain suitably constrained versions of templates are not yet available for use from within the body of a constrained template definition and the only viable alternative is the use of an unconstrained template. late_check is regarded as an evolutionary tool, to mitigate the cost of migrating a template library to use concepts when the library is based on unconstrained templates that cannot be constrained at that time. The use of late_check involves a loss of type-checking and can circumvent the syntax adaptation capabilities provided by concept maps, leading to instantiations that will silently invoke different operations than expected, as in the use of + in the add example above. For these reasons, the use of late_check should be avoided whenever possible. -- end note ]

20

Chapter 7 Declarations

[dcl.dcl]

1 Declarations specify how names are to be interpreted. Declarations have the form
declaration-seq: declaration declaration-seq declaration
declaration: block-declaration function-definition template-declaration explicit-instantiation explicit-specialization linkage-specification namespace-definition concept-definition concept-map-definition
block-declaration: simple-declaration asm-definition namespace-alias-definition using-declaration using-directive static_assert-declaration alias-declaration
alias-declaration: using identifier = type-id
simple-declaration: decl-specifier-seqopt init-declarator-listopt ;
static_assert-declaration: static_assert ( constant-expression , string-literal ) ;
[ Note: asm-definitions are described in [dcl.asm], and linkage-specifications are described in [dcl.link]. Functiondefinitions are described in [dcl.fct.def] and template-declarations are described in clause 14. Namespace-definitions are described in [namespace.def], concept-definitions are described in 14.9.1, concept-map-definitions are described in 14.9.2, using-declarations are described in 7.3.3 and using-directives are described in [namespace.udir]. -- end note ] The simple-declaration
decl-specifier-seqopt init-declarator-listopt ;

Declarations 22

is divided into two parts: decl-specifiers, the components of a decl-specifier-seq, are described in [dcl.spec] and declarators, the components of an init-declarator-list, are described in clause 8.

2 A declaration occurs in a scope (3.3); the scope rules are summarized in 3.4. A declaration that declares a function or defines a class, concept, concept map, namespace, template, or function also has one or more scopes nested within it. These nested scopes, in turn, can have declarations nested within them. Unless otherwise stated, utterances in clause 7 about components in, of, or contained by a declaration or subcomponent thereof refer only to those components of the declaration that are not nested within scopes nested within the declaration.

7.1.5 The constexpr specifier

[dcl.constexpr]

1 The constexpr specifier shall be applied only to the definition of an object, function, or function template, or to the declaration of a static data member of an effective literal type (3.9).

3 The definition of a constexpr function shall satisfy the following constraints:

-- its return type shall be an effective literal type

-- each of its parameter types shall be an effective literal type

-- its function-body shall be a compound-statement of the form

{ return expression ; }

where expression is a potential constant expression (5.19)
-- every implicit conversion used in converting expression to the function return type ([dcl.init]) shall be one of those allowed in a constant expression (5.19).

7.3.3 The using declaration

[namespace.udecl]

1 A using-declaration introduces a name into the declarative region in which the using-declaration appears. That name is a synonym for the name of some entity declared elsewhere.
using-declaration: using typenameopt::opt nested-name-specifier unqualified-id ; using :: unqualified-id ; using ::opt nested-name-specifieropt concept_map ::opt nested-name-specifieropt concept-id ; using ::opt nested-name-specifieropt concept_map ::opt nested-name-specifieropt concept-nameopt ; using ::opt nested-name-specifieropt concept-name ;
21 A using-declaration for a concept map is an alias to the concept map determined by concept map lookup (14.10.1.1) of the concept-id from the specified namespace. [ Example:

namespace N1 { concept C<typename T> { }
} namespace N2 {
concept_map N1::C<int> { } // A template<typename T> concept_map N1::C<T*> { } // B } namespace N3 { using N2::concept_map N1::C<int>; // aliases A

22

23 Declarations
using N2::concept_map N1::C<int*>; // aliases B, instantiated with T=int }
-- end example ]
22 A using-declaration for a concept map that specifies a concept-name (and not a concept-id) brings all of the concept maps and concept map templates from the specified namespace for the given concept into the scope in which the using-declaration appears. [ Example:
namespace N1 { concept C<typename T> { } template<C T> void f(T) { }
} namespace N2 {
concept_map N1::C<int> { } // A template<typename T> concept_map N1::C<T*> { } // B } namespace N3 { using N2::concept_map N1::C; // aliases A and B void g() {
f(1); // uses concept map N1::C<int> from A f(new int); // uses concept map N1::C<int*> instantiated from B with T=int } }
-- end example ]
23 If no concept is specified in the concept map using declaration, the following rule applies. Let X be the namespace specified in the nested-name-specifier of the using-declaration. Let S be the set of all names of concept maps and concept map templates in X and in the transitive closure of all namespaces nominated by using-directives in X and its used namespaces, except that using-directives that nominate non-inline namespaces ([namespace.memdef]) are ignored in any namespace, including X, directly containing one or more names of a concept map or concept map template. No namespace is considered more than once to see if it contains a concept map or concept map template. If S is the empty set, the program is ill-formed. For each element in S, a name is introduced into the declarative region in which the using-declaration appears. The name is a synonym for the referent concept map or concept map template. [ Example:
namespace N1 { concept C<typename T> { } template<C T> void f(T) { }
} namespace N2 {
concept D<typename T> { } } namespace N3 {
concept_map N1::C<int> { } // A template<typename T> concept_map N1::C<T*> { } // B concept_map N2::D<int> { } // C } namespace N4 { using N3::concept_map; // aliases A, B, and C
23

Declarations 24
} -- end example ] 24 If the second nested-name-specifier is specified but no concept is specified, then all concept maps in the namespace specified by the first nested-name-specifier for all concepts in the namespace specified by the second nested-name-specifier are brought into scope. 25 [ Note: a using-directive for a namespace brings the concept maps of that namespace into scope, just like other entities. -- end note ] [ Example:
namespace N1 { concept C<typename T> { }
} namespace N2 {
concept_map N1::C<int> { } } namespace N3 {
using namespace N2; template<N1::C T> void foo(T) { }; void bar() {
foo(17); // ok, finds the concept map from N2 } } -- end example ]
24

Chapter 8 Declarators

[dcl.decl]

8.3 Meaning of declarators

[dcl.meaning]

7 In a constrained context (14.10), a type archetype cv T shall only be used as the type of a variable if the template has a concept requirement VariableType<T>.

8.3.1 Pointers

[dcl.ptr]

5 In a constrained context (14.10), a type archetype cv T shall only be used to form a type "pointer to cv T" if the template has a concept requirement PointeeType<T>.

8.3.2 References

[dcl.ref]

6 In a constrained context (14.10), a type archetype cv T shall only be used to form a type "reference to cv T" if the template has a concept requirement ReferentType<T>.

8.3.3 Pointers to members

[dcl.mptr]

3 A pointer to member shall not point to a static member of a class ([class.static]), a member with reference type, or "cv void." In a constrained context (14.10), a pointer to member shall only point to a type archetype cv T if the template has a concept requirement MemberPointeeType<T>. [ Note: see also 5.3 and 5.5. The type "pointer to member" is distinct from the type "pointer", that is, a pointer to member is declared only by the pointer to member declarator syntax, and never by the pointer declarator syntax. There is no "reference-to-member" type in C++. -- end note ]

8.3.4 Arrays

[dcl.array]

1 [...] If the constant expression is omitted, the type of the identifier of D is "derived-declarator-type-list array of unknown bound of T," an incomplete effective object type.

2 An array can be constructed from one of the fundamental types (except void), from a pointer, from a pointer to member, from a class, from an enumeration type, or from another array. In a constrained context (14.10), an array shall only be constructed from a type archetype cv T if the template has a concept requirement ObjectType<T>ValueType<T>.

8.3.5 Functions

[dcl.fct]

6 If the type of a parameter includes a type of the form "pointer to array of unknown bound of T" or "reference to array of unknown bound of T," the program is ill-formed.4) Functions shall not have a return type of type array or function,
although they may have a return type of type pointer or reference to such things. There shall be no arrays of functions,
although there can be arrays of pointers to functions. In a constrained context (14.10), a type archetype cv T shall only

4) This excludes parameters of type "ptr-arr-seq T2" where T2 is "pointer to array of unknown bound of T" and where ptr-arr-seq means any sequence of "pointer to" and "array of" derived declarator types. This exclusion applies to the parameters of the function, and if a parameter is a pointer to function or pointer to member function then to its parameters also, etc.

8.3 Meaning of declarators

Declarators 26

be used as the return type of a function type if the template has a concept requirement Returnable<T>. Types shall not be defined in return or parameter types. The type of a parameter or the return type for a function definition shall not be an incomplete class type (possibly cv-qualified) unless the function definition is nested within the member-specification for that class (including definitions in nested classes defined within the class).

26

Chapter 9 Classes

[class]

4 A union is a class defined with the class-key union; it holds only one data member at a time ([class.union]). [ Note:aggregates of class type are described in [dcl.init.aggr]. -- end note ]

5 An effective class T is a non-archetype class or a type archetype (14.10.2) has the requirement std::ClassType<T>.

9.2 Class members

[class.mem]

member-specification: member-declaration member-specificationopt access-specifier : member-specificationopt
member-declaration: member-requirementopt decl-specifier-seqopt member-declarator-listopt ; member-requirementopt function-definition ;opt ::opt nested-name-specifier templateopt unqualified-id ; using-declaration static_assert-declaration template-declaration

member-requirement: requires-clause
member-declarator-list: member-declarator member-declarator-list , member-declarator
member-declarator: declarator pure-specifieropt declarator constant-initializeropt identifieropt : constant-expression
pure-specifier: =0
constant-initializer: = constant-expression
Insert the following in 9.2 [class.mem] p2 2 A non-archetype class is considered a completely-defined object type (3.9) (or complete type) at the closing } of the
class-specifier. [ Note: Each type archetype 14.10.2 is considered to be a unique generated class type and is considered to be defined when it is established. -- end note ] Within the class member-specification, the class is regarded as complete within function bodies, default arguments, exception-specifications (including such things in nested classes). Otherwise it is regarded as incomplete within its own class member-specification.

9.2 Class members

Classes 28

Add the following new paragraphs to 9.2 [class.mem] 19 A non-template member-declaration that has a member-requirement (14.10.1) is a constrained member and shall only
occur in a class template (14.5.1) or nested class thereof. The member-declaration for a constrained member shall declare a member function. A constrained member is treated as a constrained template (14.10) whose template requirements include the requirements specified in its member-requirement clause and the requirements of each enclosing constrained template.

9.4.2 Static data members

[class.static.data]

3 If a static data member is of const effective literal type, its declaration in the class definition can specify a constantinitializer. A static data member of effective literal type can be declared in the class definition with the constexpr specifier; if so, its declaration shall specify a constant-initializer. In both these cases, the member may appear in integral constant expressions. The member shall still be defined in a namespace scope if it is used in the program and the namespace scope definition shall not contain an initializer.

28

Chapter 12 Special member functions [special]

12.1 Constructors

[class.ctor]

5 A default constructor for a class X is a constructor of class X that can be called without an argument. If there is no user-declared constructor for class X, a constructor having no parameters is implicitly declared. An implicitly-declared default constructor is an inline public member of its class. For a union-like class that has a variant member with a non-trivial default constructor, an implicitly-declared default constructor is defined as deleted ([dcl.fct.def]). A default constructor is trivial if it is implicitly-declared and if:

-- its class has no virtual functions ([class.virtual]) and no virtual base classes ([class.mi]), and

-- all the direct base classes of its class have trivial default constructors, and

-- for all the non-static data members of its class that are of class type (or array thereof), each such class has a trivial default constructor.

An implicitly-declared default constructor for class X is deleted if:

-- X is a union-like class that has a variant member with a non-trivial default constructor,

-- any non-static data member is of reference type,

-- any non-static data member of const-qualified type (or array thereof) does not have a user-provided default constructor, or

-- any non-static data member or direct or virtual base class has class type M (or array thereof) and M has no default constructor, or if overload resolution (13.3) as applied to M's default constructor, results in an ambiguity or a function that is deleted or inaccessible from the implicitly-declared default constructor.

7 A non-user-provided default constructor for a class is implicitly defined when it is used (3.2) to create an object of its class type ([intro.object]). The implicitly-defined or explicitly-defaulted default constructor performs the set of initializations of the class that would be performed by a user-written default constructor for that class with an empty mem-initializerlist ([class.base.init]) and an empty function body. If the implicitly-defined copy constructor is explicitly defaulted, but the corresponding implicit declaration would have been deleted, the program is ill-formed. If that user-written default constructor would satisfy the requirements of a constexpr constructor ([decl.constexpr]), the implicitly-defined default constructor is constexpr. Before the non-user-provided default constructor for a class is implicitly defined, all the nonuser-provided default constructors for its base classes and its non-static data members shall have been implicitly defined. [ Note: an implicitly-declared default constructor has an exception-specification ([except.spec]). An explicitly-defaulted definition has no implicit exception-specification. -- end note ]

12.3 Conversions

Special member functions 30

12.3 Conversions

[class.conv]

12.3.2 Conversion functions

[class.conv.fct]

1 A member function of a class X having no parameters or an associated function of a concept whose sole parameter is of type X, and with a name of the form
conversion-function-id: operator conversion-type-id
conversion-type-id: type-specifier-seq conversion-declaratoropt
conversion-declarator: ptr-operator conversion-declaratoropt
specifies a conversion from X to the type specified by the conversion-type-id. Such member functions are called conversion functions. Classes, enumerations, and typedef-names shall not be declared in the type-specifier-seq. Neither parameter types norNo return type can be specified. The type of a conversion function (8.3.5) is "function taking no parameter (if the conversion function is a member function) or a parameter of type X (if the conversion function is an associated function) returning conversion-type-id." A conversion function is never used to convert a (possibly cvqualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), or to (possibly cv-qualified) void.5)

[ Example:

class X { // ...
public: operator int();
};

void f(X a) {
int i = int(a); i = (int)a; i = a; }

In all three cases the value assigned will be converted by X::operator int(). -- end example ]

12.4 Destructors

[class.dtor]

3 If a class has no user-declared destructor, a destructor is declared implicitly. An implicitly-declared destructor is an inline public member of its class. If the class is a union-like class that has a variant member with a non-trivial destructor, an implicitly-declared destructor is defined as delected ([dcl.fct.def]). A destructor is trivial if it is implicitlydeclared and if:

-- all of the direct base classes of its class have trivial destructors and
5) Even though never directly called to perform a conversion, such conversion functions can be declared and can potentially be reached through a call to a virtual conversion function in a base class

30

31 Special member functions

12.8 Copying class objects

-- for all of the non-static data members of its class that are of class type (or array thereof), each such class has a trivial destructor.
An implicitly-declared destructor for a class X is deleted if:
-- X is a union-like class that has a variant member with a non-trivial destructor,
-- any of the non-static data members has class type M (or array thereof) and M has an deleted destructor or a destructor that is inaccessible from the implicitly-declared destructor, or
-- any direct or virtual base class has a deleted destructor or a destructor that is inaccessible from the implicitlydeclared destructor.
5 An implicitly-declared destructor is implicitly defined when it is used to destroy an object of its class type ([basic.stc]). A program is ill-formed if the class for which a destructor is implicitly defined has:if the implicitly-defined destructor is explicitly defaulted, but the corresponding implicit declaration would have been deleted.
-- a non-static data member of class type (or array thereof) with an inaccessible destructor, or
-- a base class with an inaccessible destructor.
Before the implicitly-declared destructor for a class is implicitly defined, all the implicitly-declared destructors for its base classes and its non-static data members shall have been implicitly defined. [ Note: an implicitly-declared destructor has an exception-specification ([except.spec]). -- end note ]

12.8 Copying class objects

[class.copy]

4 If the class definition does not explicitly declare a copy constructor, one is declared implicitly. If the class is a union-like class that has a variant member with a non-trivial copy constructor, an implicitly-declared copy constructor is defined as deleted ([dcl.fct.def]). Thus, for the class definition

struct X { X(const X&, int);
};

a copy constructor is implicitly-declared. If the user-declared constructor is later defined as X::X(const X& x, int i =0) { / ... / }

then any use of X's copy constructor is ill-formed because of the ambiguity; no diagnostic is required. 5 The implicitly-declared copy constructor for a class X will have the form
X::X(const X&)

if
-- each direct or virtual base class B of X has a copy constructor whose first parameter is of type const B& or const volatile B&, and
-- for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a copy constructor whose first parameter is of type const M& or const volatile M&.6)
6) This implies that the reference parameter of the implicitly-declared copy constructor cannot bind to a volatile lvalue; see [diff.special].

31

12.8 Copying class objects

Special member functions 32

Otherwise, the implicitly declared copy constructor will have the form
X::X(X&)
An implicitly-declared copy constructor is an inline public member of its class. An implicitly-declared copy constructor for a class X is deleted if X has:
-- a variant member with a non-trivial copy constructor and X is a union-like class,
-- a non-static data member of class type M (or array thereof) that cannot be copied because overload resolution (13.3), as applied to M's copy constructor, results in an ambiguity or a function that is deleted or inaccessible from the implicitly-declared copy constructor, or
-- a direct or virtual base class B that cannot be copied because overload resolution (13.3), as applied to B's copy constructor, results in an ambiguity or a function that is deleted or inaccessible from the implicitly-declared copy constructor.
7 A non-user-provided copy constructor is implicitly defined if it is used to initialize an object of its class type from a copy of an object of its class type or of a class type derived from its class type7). [ Note: the copy constructor is implicitly defined even if the implementation elided its use ([class.temporary]). -- end note ] A program is ill-formed if the class for which a copy constructor is implicitly defined or explicitly defaulted has:if the implicitly-defined copy constructor is explicitly defaulted, but the corresponding implicit declaration would have been deleted.
-- a non-static data member of class type (or array thereof) with an inaccessible or ambiguous copy constructor, or
-- a base class with an inaccessible or ambiguous copy constructor.
Before the non-user-provided copy constructor for a class is implicitly defined, all non-user-provided copy constructors for its direct and virtual base classes and its non-static data members shall have been implicitly defined. [ Note: an implicitly-declared copy constructor has an exception-specification ([except.spec]). An explicitly-defaulted definitions has no implicit exception-specifion. -- end note ]
10 If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. If the class is a union-like class that has a variant member with a non-trivial copy assignment operator, an implicitly-declared copy assignment operator is defined as deleted ([dcl.fct.def]). The implicitly-declared copy assignment operator for a class X will have the form
X& X::operator=(const X&)
if
-- each direct base class B of X has a copy assignment operator whose parameter is of type const B&, const volatile B& or B, and
-- for all the non-static data members of X that are of a class type M (or array thereof), each such class type has a copy assignment operator whose parameter is of type const M&, const volatile M& or M.8)
Otherwise, the implicitly declared copy assignment operator will have the form
X& X::operator=(X&)
7) See [dcl.init] for more details on direct and copy initialization. 8) This implies that the reference parameter of the implicitly-declared copy assignment operator cannot bind to a volatile lvalue; see [diff.special].

32

33 Special member functions

12.9 Inheriting Constructors

The implicitly-declared copy assignment operator for class X has the return type X&; it returns the object for which the assignment operator is invoked, that is, the object assigned to. An implicitly-declared copy assignment operator is an inline public member of its class. An implicitly-declared copy assignment operator for class X is deleted if X has:
-- a variant member with a non-trivial copy assignment operator and X is a union-like class,
-- a non-static data member of const non-class type (or array thereof), or
-- a non-static data member of reference type, or
-- a non-static data member of class type M (or array thereof) that cannot be copied because overload resolution (13.3), as applied to M's copy assignment operator, results in an ambiguity or a function that is deleted or inaccessible from the implicitly-declared copy assignment operator, or
-- a direct or virtual base class B that cannot be copied because overload resolution (13.3), as applied to B's copy assignment operator, results in an ambiguity or a function that is deleted or inaccessible from the implicitlydeclared copy assignment operator.
Because a copy assignment operator is implicitly declared for a class if not declared by the user, a base class copy assignment operator is always hidden by the copy assignment operator of a derived class ([over.ass]). A using-declaration (7.3.3) that brings in from a base class an assignment operator with a parameter type that could be that of a copyassignment operator for the derived class is not considered an explicit declaration of a copy-assignment operator and does not suppress the implicit declaration of the derived class copy-assignment operator; the operator introduced by the using-declaration is hidden by the implicitly-declared copy-assignment operator in the derived class.
12 A non-user-provided copy assignment operator is implicitly defined when an object of its class type is assigned a value of its class type or a value of a class type derived from its class type. A program is ill-formed if the class for which a copy assignment operator is implicitly defined has:if the implicitly-defined copy assignment operator is explicitly defaulted, but the corresponding implicit declaration would have been deleted.
-- a non-static data member of const type, or
-- a non-static data member of reference type, or
-- a non-static data member of class type (or array thereof) with an inaccessible copy assignment operator, or
-- a base class with an inaccessible copy assignment operator.
Before the non-user-provided copy assignment operator for a class is implicitly defined, all non-user-provided copy assignment operators for its direct base classes and its non-static data members shall have been implicitly defined. [ Note: an implicitly-declared copy assignment operator has an exception-specification ([except.spec]). An explicitlydefaulted definition has no implicit exception-specification. -- end note ]

12.9 Inheriting Constructors 2 The constructor characteristics of a constructor or constructor template are
-- the template parameter list (14.1), if any, -- the template requirements (14.10.1), if any, -- the parameter-type-list ([decl.fct]),

[class.inhctor]

33

12.9 Inheriting Constructors
-- the exception-specification ([except.spec]), -- absence or presence of explicit ([class.conv.ctor]), and -- absence or presence of constexpr (7.1.5).

Special member functions 34

34

Chapter 13 Overloading

[over]

13.1 Overloadable declarations

[over.load]

2 Certain function declarations cannot be overloaded:

-- Function declarations that differ only in the return type cannot be overloaded.

-- Member function declarations with the same name and, the same parameter-type-list and the same template requirements (if any), cannot be overloaded if any of them is a static member function declaration ([class.static]). Likewise, member function template declarations with the same name, the same parameter-type-list, and the same template parameter lists, and the same template requirements (if any) cannot be overloaded if any of them is a static member function template declaration. The types of the implicit object parameters constructed for the member functions for the purpose of overload resolution (13.3.1) are not considered when comparing parametertype-lists for enforcement of this rule. In contrast, if there is no static member function declaration among a set of member function declarations with the same name and the same parameter-type-list, then these member function declarations can be overloaded if they differ in the type of their implicit object parameter. [ Example: the following illustrates this distinction:

class X { static void f(); void f(); void f() const; void f() const volatile; void g(); void g() const; void g() const volatile;
};

// ill-formed // ill-formed // ill-formed
// OK: no static g // OK: no static g

-- end example ]
-- Member function declarations with the same name and the same parameter-type-list as well as member function template declarations with the same name, the same parameter-type-list, and the same template parameter lists, and the same template requirements, cannot be overloaded if any of them, but not all, have a ref-qualifier (8.3.5). [ Example:
class Y { void h() &; void h() const &; // OK void h() &&; // OK, all declarations have a ref-qualifier void i() &; void i() const; // ill-formed, prior declaration of i

13.3 Overload resolution

Overloading 36

}; -- end example ]

// has a ref-qualifier

13.3 Overload resolution

[over.match]

13.3.1 Candidate functions and argument lists

[over.match.funcs]

1 The subclauses of 13.3.1 describe the set of candidate functions and the argument list submitted to overload resolution in each of the seven contexts in which overload resolution is used. [ Note: With concepts (14.9) and constrained templates, the set of candidate functions can be determined by an associated function candidate set or a retained candidate set (14.10.3). -- end note ] The source transformations and constructions defined in these subclauses are only for the purpose of describing the overload resolution process. An implementation is not required to use such transformations and constructions.

13.5 Overloaded operators

[over.oper]

13.5.4 Function call

[over.call]

1 If declared in a class type, operator() shall be a non-static member function with an arbitrary number of parameters. It can have default arguments. It implements the function call syntax

postfix-expression ( expression-listopt )
where the postfix-expression evaluates to a class object and the possibly empty expression-list matches the parameter list of an operator() member function of the class. Thus, a call x(arg1,...) is interpreted as x.operator()(arg1, ...) for a class object x of type T if T::operator()(T1, T2, T3) exists and if the operator is selected as the best match function by the overload resolution mechanism ([over.match.best]).

2 If declared in a concept or concept map, operator() shall be a non-member associated function with one or more parameters. It implements the function call syntax

postfix-expression ( expression-listopt )
where the postfix-expression evaluates to an object and the possibly empty expression-list matches the parameter list of the operator() associated function after the first parameter of the parameter list has been removed. Thus, a call x(arg1,...) is interpreted as operator()(x, arg1, ...) for an object x of type T if operator()(T, T1, T2, T3) exists and if the operator is selected as the best match function by the overload resolution mechanism ([over.match.best]).

13.5.5 Subscripting

[over.sub]

1 If declared in a class type, operator[] shall be a non-static member function with exactly one parameter. It implements the subscripting syntax

postfix-expression [ expression ]

Thus, a subscripting expression x[y] is interpreted as x.operator[](y) for a class object x of type T if T::operator[](T1) exists and if the operator is selected as the best match function by the overload resolution mechanism ([over.match.best]).

36

37 Overloading

13.6 Built-in operators

2 If declared in a concept or concept map, operator[] shall be a non-member associated function with exactly two parameters. It implements the subscripting syntax

postfix-expression [ expression ]

Thus, a subscripting expression x[y] is interpreted as operator[](x, y) for an object x of type T if operator[](T, T1) exists and if the operator is selected as the best match function by the overload resolution mechanism ([over.match.best]).

13.5.6 Class member access

[over.ref]

1 If declared in a class type, operator-> shall be a non-static member function taking no parameters. It implements class member access using ->

postfix-expression -> id-expression

An expression x->m is interpreted as (x.operator->())->m for a class object x of type T if T::operator->() exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3).

2 If declared in a concept or concept map, operator-> shall be a non member associated function taking exactly one parameter. It implements class member access using ->

postfix-expression -> id-expression

An expression x->m is interpreted as (operator->(x))->m for an object x of type T if operator->(T) exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3).

13.6 Built-in operators

[over.built]

1 The candidate operator functions that represent the built-in operators defined in clause 5 are specified in this subclause. These candidate functions participate in the operator overload resolution process as described in [over.match.oper] and are used for no other purpose. Built-in operators are not defined for archetypes (14.10.2), except as noted, even though template requirements naming compiler-supported concepts (14.9.4) can classify archetypes as non-class types. [ Note: because built-in operators take only operands with non-class type, and operator overload resolution occurs only when an operand expression originally has class or enumeration type, operator overload resolution can resolve to a built-in operator only when an operand has a class type that has a user-defined conversion to a non-class type appropriate for the operator, or when an operand has an enumeration type that can be converted to a type appropriate for the operator. Also note that some of the candidate operator functions given in this subclause are more permissive than the built-in operators themselves. As described in [over.match.oper], after a built-in operator is selected by overload resolution the expression is subject to the requirements for the built-in operator given in clause 5, and therefore to any additional semantic constraints given there. If there is a user-written candidate with the same name and parameter types as a built-in candidate operator function, the built-in operator function is hidden and is not included in the set of candidate functions. -- end note ]

5 For every cv-qualified or cv-unqualified effective object type T, there exist candidate operator functions of the form

T & operator*(T *);

7 For every type T, including archetypes for which the template requirements contain std::PointeeType<T>, there exist candidate operator functions of the form
T * operator+(T *);

37

13.6 Built-in operators

Overloading 38

11 For every quintuple (C1, C2, T, CV1, CV2), where C2 is a class type, C1 is the same type as C2 or is a derived class of C2, T is an effective object type or a function type, and CV1 and CV2 are cv-qualifier-seqs, there exist candidate operator functions of the form
CV12 T & operator->*(CV1 C1 *, CV2 T C2 ::*);

where CV12 is the union of CV1 and CV2.
13 For every cv-qualified or cv-unqualified effective object type T, there exist candidate operator functions of the form
T * operator+(T *, std::ptrdiff_t); T & operator[](T *, std::ptrdiff_t); T * operator-(T *, std::ptrdiff_t); T * operator+(std::ptrdiff_t, T *); T & operator[](std::ptrdiff_t, T *);

14 For every T, where T is a pointer to effective object type, there exist candidate operator functions of the form std::ptrdiff_t operator-(T *, T *);

15 For every pointer to effective object type or enumeration type T, there exist candidate operator functions of the form

bool bool bool bool bool bool

operator<(T , T ); operator>(T , T ); operator<=(T , T ); operator>=(T , T ); operator==(T , T ); operator!=(T , T );

16 For every pointer to member type T, including pointer to member types involving archetypes, there exist candidate operator functions of the form

bool bool

operator==(T , T ); operator!=(T , T );

19 For every pair (T, VQ), where T is any type, including archetypes for which the template requirements contain std::PointeeType<T>, and VQ is either volatile or empty, there exist candidate operator functions of the form
T *VQ & operator=(T *VQ &, T *);

20 For every pair (T, VQ), where T is an enumeration or pointer to member type, including pointer to member types that involve archetypes, and VQ is either volatile or empty, there exist candidate operator functions of the form
VQ T & operator=(VQ T &, T );

21 For every pair (T, VQ), where T is a cv-qualified or cv-unqualified effective object type and VQ is either volatile or empty, there exist candidate operator functions of the form
T *VQ & operator+=(T *VQ &, std::ptrdiff_t); T *VQ & operator-=(T *VQ &, std::ptrdiff_t);

38

39 Overloading

13.6 Built-in operators

25 For every type T, where T is a pointer or pointer-to-member type, including pointer and pointer-to-member types that involve archetypes, there exist candidate operator functions of the form
T operator?(bool, T , T );

39

13.6 Built-in operators

Overloading 40

40

Chapter 14 Templates

[temp]

1 A template defines a family of classesor functions, functions, or concept maps, or an alias for a family of types.
template-declaration: exportopt template < template-parameter-list > requires-clauseopt declaration
template-parameter-list: template-parameter template-parameter-list , template-parameter
The declaration in a template-declaration shall
-- declare or define a function or a class, or
-- define a member function, a member class or a static data member of a class template or of a class nested within a class template, or
-- define a member template of a class or class template, or
-- be an alias-declaration., or
-- define a concept map.
A template-declaration is a declaration. A template-declaration is also a definition if its declaration defines a function, a class, a concept map, or a static data member.
5 A class template shall not have the same name as any other template, class, concept, function, object, enumeration, enumerator, namespace, or type in the same scope (3.3), except as specified in (14.5.5). Except that a function template can be overloaded either by (non-template) functions with the same name or by other function templates with the same name ([temp.over]), a template name declared in namespace scope or in class scope shall be unique in that scope.
Add the following new paragraphs to [temp]: 12 A template-declaration with a requires keyword is a constrained template (14.10). The requires-clause specifies
template requirements (14.10.1).

14.1 Template parameters
1 The syntax for template-parameters is:
template-parameter: type-parameter parameter-declaration constrained-template-parameter

[temp.param]

14.1 Template parameters

Templates 42

type-parameter: class ...opt identifieropt class identifieropt = type-id typename ...opt identifieropt typename identifieropt = type-id template < template-parameter-list > class ...opt identifieropt template < template-parameter-list > class identifieropt = id-expression
constrained-template-parameter: ::opt nested-name-specifieropt concept-name ...opt identifieropt ::opt nested-name-specifieropt concept-name identifieropt constrained-default-argumentopt ::opt nested-name-specifieropt concept-name < simple-requirement-argument-list > ...opt identifier ::opt nested-name-specifieropt concept-name < simple-requirement-argument-list > identifier constraineddefault-argumentopt
constrained-default-argument: = type-id = assignment-expression = id-expression
simple-requirement-argument-list: auto auto , template-argument-list
4 A non-type template-parameter shall have one of the following (optionally cv-qualified) types:
-- integral or enumeration type,
-- pointer to object or pointer to function,
-- reference to object or reference to function,
-- pointer to member., or
-- in a constrained template (14.10), a type archetype T for which the concept requirement NonTypeTemplateParameterType<T> (14.9.4) is part of the template's requirements.
Add the following new paragraph to 14.1 [temp.param] 18 A template-parameter declared with a concept-name is a template type, non-type or template parameter or parameter
pack that specifies a template requirement (14.10.1) using the simple form of template requirements. The kind (type, nontype or template) of the parameter is that of the first template parameter of the concept named in the constrained-template-parameter. For a non-type parameter, the type is that of the first template parameter of the concept named in the constrained-template-parameter. For a template parameter, the template parameter list is that of the first template parameter of the concept named in the constrained-template-parameter. A template parameter or parameter pack written ::opt nested-name-specifieropt C ...opt T, where C is a concept-name, is equivalent to a template parameter or parameter pack T declared as a type-parameter or parameter-declaration with the template requirement or pack expansion ::opt nested-name-specifieropt C<T> ...opt added to the template requirements. A template parameter or parameter pack written ::opt nested-name-specifieropt C<auto, T2, T3, ..., TN>.. is equivalent to a template parameter or parameter pack T declared as a type-parameter or parameter-declaration with the template requirement ::opt nested-name-specifieropt} C<T, T2, T3, ..., TN>...opt added to the template requirements.

concept C<typename T> { ... }

42

43 Templates

14.4 Type equivalence

concept D<typename T, typename U> { ... } concept E<typename T, typename U, typename V = U> { ... }
template<C T, D<auto, T> P> void f(T, P); // equivalent to template<class T, class P> requires C<T> && D<P, T> void f(T, P);
template<C T, E<auto, T> P> void f(T, P); // equivalent to template<class T, class P> requires C<T> && E<P, T, T> void f(T, P);
-- end example ] When the type-parameter is a template type parameter pack, the equivalent requirement is a pack expansion (14.5.3). [ Example:
concept C<typename T> { }
template<C... Args> void g(Args const&...); // equivalent to template<typename... Args> requires C<Args>... void g(Args const&...);
-- end example ]

14.4 Type equivalence

[temp.type]

Add the following new paragraph to 14.4 [temp.type] 2 In a constrained context (14.10), two types are the same type if some same-type requirement (14.10.1) makes them
equivalent (14.10.1).

14.5 Template declarations

[temp.decls]

14.5.1 Class templates

[temp.class]

Add the following new paragraph to 14.5.1 [temp.class] 5 A constrained member (9.2) in a class template is declared only in class template specializations in which its template
requirements (14.10.1) are satisfied (14.10.1.1). If there exist multiple overloads of the constrained member with identical signatures, ignoring the template requirements, and identical return types, only the most specialized overload, as determined by partial ordering of the template requirements (14.5.6.2), is declared in the instantiation. If partial ordering results in an ambiguity, a deleted function with the given signature (without any template requirements) is declared in the instantiation. [ Example:

auto concept C<typename T> { bool operator<(T, T);
}

concept D<typename T> : C<T> { / ... / }

template<typename T> struct A {

43

14.5 Template declarations

Templates 44

requires C<T> void g(); // #1 requires D<T> void g(); // #2 };

struct X { }; concept_map D<int> { / ... / }

void f(A<float> lf, A<int> li, A<X> lX) {
lf.g(); // okay: C<float> implicitly defined, calls #1 li.g(); // okay: calls #2, which is more specialized than #1 lX.g(); // error: no 'g' member in A<X> }

-- end example ]

14.5.2 Member templates

[temp.mem]

10 A member template of a constrained class template is itself a constrained template (14.10). The template requirements of the member template are the template requirements of each of its enclosing constrained templates and any requirements specified or implied by the member template itself. [ Example:

concept C<typename T> { void f(const T&); } concept D<typename T> { void g(const T&); }

template<C T> class A { requires D<T> void h(const T& x) { f(x); // okay: C<T>::f g(x); // okay: D<T>::g }
};

-- end example ]

14.5.3 Variadic templates

[temp.variadic]

1 A template parameter pack is a template parameter that accepts zero or more template arguments. [ Example:

template<class ... Types> struct Tuple { };

Tuple<> t0; Tuple<int> t1; Tuple<int, float> t2; Tuple<0> eror;

// Types contains no arguments // Types contains one argument: int // Types contains two arguments: int and float // error: 0 is not a type

-- end example ]
[ Note: a template parameter pack can also occur in a concept's template parameter list (14.9.1). [ Example:
auto concept C<typename F, typename... Args> { typename result_type; result_type operator()(F&, Args...);

44

45 Templates

14.5 Template declarations

}
-- end example ] -- end note ]
4 A pack expansion is a sequence of tokens that names one or more parameter packs, followed by an ellipsis. The sequence of tokens is called the pattern of the expansion; its syntax depends on the context in which the expansion occurs. Pack expansions can occur in the following contexts:
-- In an expression-list (5.2); the pattern is an assignment-expression.
-- In an initializer-list ([dcl.init]); the pattern is an initializer-clause.
-- In a base-specifier-list ([class.derived]); the pattern is a base-specifier.
-- In a mem-initializer-list ([class.base.init]); the pattern is a mem-initializer.
-- In a template-argument-list ([temp.arg]); the pattern is a template-argument.
-- In an exception-specification ([except.spec]); the pattern is a type-id.
-- In a requirement-list (14.10.1); the pattern is a requirement.
6 The instantiation of an expansion produces a comma-separated list E1, E2, ..., EN, where N is the number of elements in the pack expansion parameters and  is the syntactically-appropriate separator for the list. Each Ei is generated by instantiating the pattern and replacing each pack expansion parameter with its ith element. All of the Ei become elements in the enclosing list. [ Note: The variety of list varies with the context: expression-list, base-specifier-list, template-argument-list, requirement-list, etc. -- end note ]

14.5.5 Class template partial specializations

[temp.class.spec]

9 Within the argument list of a class template partial specialization, the following restrictions apply:

-- A partially specialized non-type argument expression shall not involve a template parameter of the partial specialization except when the argument expression is a simple identifier. [ Example:

template <int I, int J> struct A {}; template <int I> struct A<I+5, I*2> {}; // error

template <int I, int J> struct B {}; template <int I> struct B<I, I> {};

// OK

-- end example ]

-- The type of a template parameter corresponding to a specialized non-type argument shall not be dependent on a parameter of the specialization. [ Example:

template <class T, T t> struct C {}; template <class T> struct C<T, 1>;

// error

template< int X, int (*array_ptr)[X] > class A {};

int array[5];

template< int X > class A<X,&array> { };

// error

45

14.5 Template declarations

Templates 46

-- end example ]
-- The argument list of the specialization shall not be identical to the implicit argument list of the primary template, unless the specialization contains template requirements that are more specific (14.5.6.2) than the primary template's requirements. [ Example:
concept C<typename T> { int F(T); }
template<typename T> class X { / ... / }; // #6 template<typename T> requires C<T> class X<T> { / ... / }; //#7, okay
-- end example ] The template parameter list of a specialization shall not contain default template argument values.9)
-- An argument shall not contain an unexpanded parameter pack. If an argument is a pack expansion (14.5.3), it shall be the last argument in the template argument list.
10 The template requirements of a primary class template are implied (14.10.1.2) in its class template partial specializations that are constrained templates. [ Example:
concept C<typename T> { / ... / } concept D<typename T> { / ... / }
template<typename T> requires C<T> class Y { / ... / }; template<typename T>
requires D<T> // same as requires C<T> && D<T> class Y<T> { / ... / };
-- end example ]

14.5.5.1 Matching of class template partial specializations

[temp.class.spec.match]

2 A partial specialization matches a given actual template argument list if the template arguments of the partial specialization can be deduced from the actual template argument list (14.8.2) and the deduced template arguments satisfy the partial specialization's template requirements (if any). [ Example:

A<int, int, 1> a1; A<int, int*, 1> a2; A<int, char*, 5> a3; A<int, char*, 1> a4; A<int*, int*, 2> a5;

// uses #1 // uses #2, T is int, I is 1 // uses #4, T is char // uses #5, T1 is int, T2 is char, I is 1 // ambiguous: matches #3 and #5

concept_map D<int> { / ... / } struct Y { };

X<int> x1; X<Y> x2;

// uses #7 // uses #6

9) There is no way in which they could be used.

46

47 Templates

14.5 Template declarations

-- end example ]

4 In a type name that refers to a class template specialization, (e.g., A<int, int, 1>) the argument list must match the template parameter list of the primary template. If the primary template has template requirements, the arguments shall satisfy those requirements. The template arguments of a specialization are deduced from the arguments of the primary template.

14.5.5.2 Partial ordering of class template specializations

[temp.class.order]

2 [ Example:

concept Con1<typename T> { }

concept Con2<typename T> : Con1<T> { }

template<int I, int J, class T> class X { };

template<int I, int J>

class X<I, J, int> { }; // #1

template<int I>

class X<I, I, int> { }; // #2

template<int I, int J, class T> requires Con1<T> class X<I, J, T> { }; // #3

template<int I, int J, class T> requires Con2<T> class X<I, J, T> { }; // #4

template<int I, int J> void f(X<I, J, int>);

// #A

template<int I>

void f(X<I, I, int>);

// #B

template<int I, int J, class T> requires Con1<T> void f(X<I, J, T>); // C

template<int I, int J, class T> requires Con2<T> void f(X<I, J, T>); // D

The partial specialization #2 is more specialized than the partial specialization #1 because the function template #B is more specialized than the function template #A according to the ordering rules for function templates. The partial specialization #4 is more specialized than the partial specialization #3 because the function template D is more specialized than the function template C according to the partial ordering rules for function templates. -- end example ]

14.5.6 Function templates

[temp.fct]

14.5.6.1 Function template overloading

[temp.over.link]

6 Two function templates are equivalent if they are declared in the same scope, have the same name, have identical template parameter lists, have identical template requirements (if any), and have return types and parameter lists that are equivalent using the rules described above to compare expressions involving template parameters. Two function templates are functionally equivalent if they are equivalent except that one or more expressions that involve template parameters in the return types, and parameter lists, and template requirements (if any) are functionally equivalent using the rules described above to compare expressions involving template parameters. If a program contains declarations of function templates that are functionally equivalent but not equivalent, the program is ill-formed; no diagnostic is required.

14.5.6.2 Partial ordering of function templates

[temp.func.order]

2 Partial ordering selects which of two function templates is more specialized than the other by transforming each template in turn (see next paragraph) and performing template argument deduction using the function parameter types, or in the case of a conversion function the return type. [ Note: if template argument deduction succeeds, the deduced arguments were used to determine if the requirements of the template are satisfied.then the template requirements (if any) have all been satisfied (14.10.1.1) by the deducted template arguments. -- end note ] The deduction process determines whether one of the templates is more specialized than the other. If so, the more specialized template is the one chosen by the partial ordering process.

47

14.5 Template declarations

Templates 48

3 To produce the transformed template, for each type, non-type, or template template parameter (including template parameter packs thereof) synthesize a unique type, value, or class template respectively and substitute it for each occurrence of that parameter in the function type of the template. When the template is a constrained template, the unique type is an archetype and concept map archetypes for each of the requirements stated in or implied by its template requirements are also synthesized; see 14.10. [ Note: because the unique types are archetypes, two template type parameters may share the same archetype due to same-type constraints. -- end note ]
4 Using the transformed function template's function parameter list, or in the case of a conversion function its transformed return type, perform type deduction against the function parameter list (or return type) of the other function. The mechanism for performing these deductions is given in [temp.deduct.partial].
[ Example:
template<class T> struct A { A(); };

template<class T> void f(T); template<class T> void f(T*); template<class T> void f(const T*);

template<class T> void g(T); template<class T> void g(T&);

template<class T> void h(const T&);

template<class T> void h(A<T>&);

void m() {

int *p;

f(p);

// f(const T*) is more specialized than f(T) or f(T*)

float x;

g(x);

// Ambiguous: g(T) or g(T&)

A<int> z;

h(z);

// overload resolution selects h(A<T>&)

const A<int> z2;

h(z2);

// h(const T&) is called because h(A<T>&) is not callable

}

-- end example ]
[ Note: when two constrained templates have identical signatures (ignoring template requirements), the partial ordering is based on those template requirements. Similarly, a constrained template is more specialized than an unconstrained template because it has more stringent requirements. -- end note ] [ Example:
auto concept CopyConstructible<typename T> { T::T(const T&);
}
template<CopyConstructible T> struct A { A(); };
concept C<typename T> { } concept D<typename T> : C<T> { } concept_map C<int*> { } concept_map D<float> { }

48

49 Templates

14.5 Template declarations

template<typename T> concept_map D<A<T>> { }

template<class T> requires C<T> void f(T&) { } // #1 template<class T> requires D<T> void f(T&) { } // #2 template<class T> requires C<A<T>> void f(A<T>&) { } // #3 template<class T> void f(T&); // #4

void m() { int *p; f(p); float x; f(x); A<int> z; f(z);
}

// calls #1: template argument deductions fails #2 and #3, and #1 is more specialized than #4 // #2 is called because #3 is not callable and #2 is more specialized than #1 and #4 // ambiguous: no partial ordering between #2 and #3

-- end example ] Add the following new subsection to Template declarations [temp.decls]

14.5.8 Concept map templates

[temp.concept.map]

1 A concept map template defines an unbounded set of concept maps with a common set of associated function, associated type, and associated class template definitions. [ Example:

concept F<typename T> { typename type; type f(T);
}

template<typename T> concept_map F<T*> {
typedef T& type; T& f(T*); }

-- end example ]
2 A concept map template is a constrained template (14.10) [ Note: a concept map template is a constrained template even if it does not have template requirements. -- end note ]
3 Within the template-argument-list of the concept-id in a concept map template (including nested template argument lists), the following restrictions apply:
-- A non-type argument expression shall not involve a template parameter of the concept map except when the argument expression is a simple identifier.
-- The type of a template parameter corresponding to a non-type argument shall not be dependent on a parameter of the concept map.

49

14.5 Template declarations

Templates 50

-- The template parameter list of a concept map template shall not contain default template argument values.10)
4 During concept map lookup (14.10.1.1), concept map matching determines whether a particular concept map template can be used. Concept map matching matches the template arguments in the concept instance to the template arguments in the concept map template, using matching of class template partial specializations (14.5.5.1).
5 For two concept map templates, the first is at least as specialized as the second if, given the following rewrite to two class template partial specializations of an invented class template X, the first class template partial specialization is at least as specialized as the second according to the rules for partial ordering of class template partial specializations (14.5.5.2). The primary class template X has the same template parameters as the concept of the concept map templates. The class template partial specializations are constrained templates, even if the corresponding concept map templates have no requirements specified.
-- the first class template partial specialization has the same template parameters and template arguments as the first concept map template, and
-- the second class template has the same template parameters and template arguments as the second concept map template.
[ Example:
concept C<typename T> { } concept Ptr<typename T> { } template<typename T> concept_map Ptr<T*> { / ... / }
template<typename T> requires Ptr<T*> concept_map C<T*> { / ... / } // #1 template<typename T> requires Ptr<T> concept_map C<T> { / ... / } // #2
template<typename T> class X; template<typename T> requires Ptr<T*> class X<T*>; // A template<typename T> requires Ptr<T> class X<T>; // B
The concept map template #1 is more specialized than the concept map template #2 because the class template partial specialization A is more specialized than the class template partial specialization B according to the ordering rules for class template partial specializations. -- end example ]
6 A concept map template shall satisfy the requirements of its corresponding concept (14.9.2) at the time of definition of the concept map template. [ Example:
concept C<typename T> { }
concept F<typename T> { void f(T);
}
template<C T> struct X;
template<F T> void f(X<T>); // #1
template<typename T>
10) There is no way in which they could be used.
50

51 Templates

14.5 Template declarations

concept_map F<X<T>> { } // error: requirement for f(X<T>) not satisfied
template<F T> concept_map F<X<T>> { } // okay: uses #1 to satisfy requirement for f(X<T>)
-- end example ]
7 If the definition of a concept map template uses an instantiated archetype (14.10.2), and instantiation of the concept map template results in a different specialization of that class template with an incompatible definition, the program is ill-formed. The specialization is considered to have an incompatible definition if the specialization's definition causes a different definition of any associated type or associated class template in the concept map, if its definition causes any of the associated function definitions to be ill-formed, or if the resulting concept map fails to satisfy the axioms of the corresponding concept. [ Example:
concept Stack<typename X> { typename value_type; value_type& top(X&); // ...
}
template<typename T> struct dynarray { T& top();
};
template<> struct dynarray<bool> { bool top();
};
template<typename T> concept_map Stack<dynarray<T>> {
typedef T value_type; T& top(dynarray<T>& x) { return x.top(); } }
template<Stack X> void f(X& x) {
X::value_type& t = top(x); }
void g(dynarray<int>& x1, dynarray<bool>& x2) { f(x1); // okay f(x2); // error: Stack<dynarray<bool> > uses the dynarray<bool> class specialization // rather than the dynarray primary class template, and the two // have incompatible signatures for top()
}
-- end example ]
8 A concept map template shall be declared before the first use of a concept map that would make use of the concept map template as the result of an instantiation in every translation unit in which such a use occurs; no diagnostic is required.
51

14.6 Name resolution

Templates 52

14.6 Name resolution

[temp.res]

3 When a qualified-id is intended to refer to a type that is not a member of the current instantiation (14.6.2.1) and its nested-name-specifier is not a concept instance (14.9) and depends on a template-parameter (14.6.2), it shall be prefixed by the keyword typename, forming a typename-specifier. If the qualified-id in a typename-specifier does not denote a type, the program is ill-formed. When the nested-name-specifier refers to a concept instance, name lookup into the corresponding concept determines whether the qualified-id refers to a type or a value.

14.6.2 Dependent names

[temp.dep]

14.6.2.2 Type-dependent expressions

[temp.dep.expr]

3 An id-expression is type-dependent if it contains: -- an identifier that was declared with a dependent type,

-- a template-id that is dependent,

-- a conversion-function-id that specifies a dependent type,

-- a nested-name-specifier or a qualified-id that names a member of an unknown specialization., or

-- an identifier, nested-name-specifier, or a qualified-id that names a member of the current instantiation that is a constrained member (9.2).

14.6.2.3 Value-dependent expressions

[temp.dep.constexpr]

1 Except as described below, a constant expression is value-dependent if any subexpression is value-dependent.

2 An identifier is value-dependent if it is:

-- a name declared with a dependent type,

-- the name of a non-type template parameter,

-- a constant with effective literal type and is initialized with an expression that is value-dependent.

14.6.3 Non-dependent names

[temp.nondep]

Add the following new paragraph to Non-dependent names [temp.nondep] 2 [ Note: if a template contains template requirements, name lookup of non-dependent names in its constrained contexts
(14.10) can find the names of associated functions in the requirements scope (3.3.9). -- end note ]

14.7 Template instantiation and specialization

[temp.spec]

1 The act of instantiating a function, a class, a concept map, a member of a class template or a member template is referred to as template instantiation.
2 A function instantiated from a function template is called an instantiated function. A class instantiated from a class template is called an instantiated class. A concept map instantiated from a concept map template is called an instantiated concept map. A member function, a member class, or a static data member of a class template instantiated from the member definition of the class template is called, respectively, an instantiated member function, member class or static

52

53 Templates

14.7 Template instantiation and specialization

data member. A member function instantiated from a member function template is called an instantiated member function. A member class instantiated from a member class template is called an instantiated member class.

14.7.1 Implicit instantiation

[temp.inst]

5 If the overload resolution process can determine the correct function to call without instantiating a class template definition or concept map template definition, it is unspecified whether that instantiation actually takes place. [ Example:

template <class T> struct S { operator int();
};

void f(int); void f(S<int>&); void f(S<float>);

void g(S<int>& sr) {

f(sr);

// instantiation of S<int> allowed but not required

// instantiation of S<float> allowed but not required

};

-- end example ]
9 An implementation shall not implicitly instantiate a function template, a member template, a non-virtual member function, concept map template, a member class or a static data member of a class template that does not require instantiation. It is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated. The use of a template specialization in a default argument shall not cause the template to be implicitly instantiated except that a class template may be instantiated where its complete type is needed to determine the correctness of the default argument. The use of a default argument in a function call causes specializations in the default argument to be implicitly instantiated.
10 Implicitly instantiated class, concept map, and function template specializations are placed in the namespace where the template is defined. Implicitly instantiated specializations for members of a class template are placed in the namespace where the enclosing class template is defined. Implicitly instantiated member templates are placed in the namespace where the enclosing class or class template is defined. [ Example:
namespace N { template<class T> class List { public: T* get(); // ... };
}

template<class K, class V> class Map { N::List<V> lt; V get(K); // ...
};

void g(Map<char*,int>& m)

53

14.8 Function template specializations

Templates 54

{ int i = m.get("Nicholas"); // ...
}

a call of lt.get() from Map<char*,int>::get() would place List<int>::get() in the namespace N rather than in the global namespace. -- end example ]

Add the following new paragraph to [temp.inst] 15 If no concept map exists for a given concept instance, and there exists a concept map template that matches the concept
instance, the concept map is implicitly instantiated when the concept map is referenced in a context that requires the concept map definition, either to satisfy a concept requirement (14.10.1) or when the nested-name-specifier of a qualified-id references a concept instance (3.4.3.3).

14.7.2 Explicit specialization

[temp.expl.spec]

Add the following new paragraph to [temp.expl.spec]:
23 [ Note: The template arguments provided for an explicit specialization shall satisfy the template requirements of the primary template (14.5.5.1). [ Example:

concept C<typename T> { } concept_map C<float> { }

template<typename T> requires C<T> void f(T);

template<> void f<float>(float); // okay: concept_map C<float> satisfies requirement template<> void f<int>(int); // ill-formed: no concept map satisfies the requirement for C<int>

-- end example ] -- end note ]

14.8 Function template specializations

[temp.fct.spec]

14.8.2 Template argument deduction

[temp.deduct]

2 If the reference to the template occurs within a constrained context (14.10) and the template is an unconstrained template, type deduction fails.

3 When an explicit template argument list is specified, the template arguments must be compatible with the template parameter list and must result in a valid function type as described below; otherwise type deduction fails. Specifically, the following steps are performed when evaluating an explicitly specified template argument list with respect to a given function template:

-- The specified template arguments must match the template parameters in kind (i.e., type, non-type, template). There must not be more arguments than there are parameters, unless at least one parameter is a template parameter pack, and there shall be an argument for each non-pack parameter. Otherwise type deduction fails.

-- Non-type arguments must match the types of the corresponding non-type template parameters, or must be convertible to the types of the corresponding non-type parameters as specified in [temp.arg.nontype], otherwise type deduction fails.

54

55 Templates

14.8 Function template specializations

-- All references in the function type and template requirements of the function template to the corresponding template parameters are replaced by the specified template argument values. If a substitution in a template parameter, the template requirements (if any), or in the function type of the function template results in an invalid type, type deduction fails. [Note: The equivalent substitution in exception specifications is done only when the function is instantiated, at which point a program is ill-formed if the substitution results in an invalid type.] Type deduction may fail for the following reasons:

-- Attempting to instantiate a pack expansion containing multiple parameter packs of differing lengths.

-- Attempting to create an array with an element type that is void, a function type, a reference type, or an abstract class type, or attempting to create an array with a size that is zero or negative. [ Example:

template <class T> int f(T[5]);

int I = f<int>(0);

int j = f<void>(0);

// invalid array

-- end example ]
-- Attempting to use a type that is not a class type in a qualified name. [ Example:
template <class T> int f(typename T::B*); int i = f<int>(0);

-- end example ]
-- Attempting to use a type in a nested-name-specifier of a qualified-id when that type does not contain the specified member, or
-- the specified member is not a type where a type is required, or
-- the specified member is not a template where a template is required, or
-- the specified member is not a non-type where a non-type is required.
[ Example:
template <int I> struct X { }; template <template <class T> class> struct Z { }; template <class T> void f(typename T::Y*){} template <class T> void g(X<T::N>*){} template <class T> void h(Z<T::template TT>*){} struct A {}; struct B { int Y; }; struct C {
typedef int N; }; struct D {
typedef int TT; };

int main() {
// Deduction fails in each of these cases:

55

14.8 Function template specializations

Templates 56

f<A>(0); // A does not contain a member Y f<B>(0); // The Y member of B is not a type g<C>(0); // The N member of C is not a non-type h<D>(0); // The TT member of D is not a template }
-- end example ] -- Attempting to create a pointer to reference type. -- Attempting to create a reference to void. -- Attempting to create "pointer to member of T" when T is not a class type. [ Example:
template <class T> int f(int T::*); int i = f<int>(0);
-- end example ] -- Attempting to give an invalid type to a non-type template parameter. [ Example:
template <class T, T> struct S {}; template <class T> int f(S<T, T()>*); struct X {}; int i0 = f<X>(0);
-- end example ] -- Attempting to perform an invalid conversion in either a template argument expression, or an expression used
in the function declaration. [ Example: template <class T, T*> int f(int);int i2 = f<int,1>(0); // can't conv 1 to int*
-- end example ] -- Attempting to create a function type in which a parameter has a type of void. -- Attempting to use a type in a nested-name-specifier of a qualified-id that refers to a member in a concept
instance, for which concept map lookup (14.10.1.1) does not find a concept map corresponding to that concept instance. -- Attempting to use a class or function template with template arguments that do not satisfy that template's requirements. [ Example:
concept C<typename T> { / ... / }
template<typename T> requires C<T> class X { / ... / };
template<typename T> int f(X<T>*); // #1 template<typename> int f(...); // #2 int i0 = f<int>(0); // okay: calls #2
-- end example ]
56

57 Templates

14.9 Concepts

6 When all template arguments have each template argument has been explicitly specified, deduced or obtained from default template arguments, all uses of template parameters in non-deduced contexts are each use of a template parameter in the function type and in each template requirement is replaced with the corresponding deduced or default argument values. If the substitution results in an invalid type, as described above, type deduction fails. If a substituted requirement cannot be satisfied (14.10.1.1), type deduction fails.
Add the following new sections to 14 [temp]:

14.9 Concepts

[concept]

1 Concepts describe an abstract interface that can be used to constrain templates (14.10). Concepts state certain syntactic and semantic requirements (14.9.1) on a set of template type, non-type, and template template parameters.
concept-id: concept-name < template-argument-listopt >

concept-name: identifier
2 A concept-id names a specific use of a concept by its concept-name and a set of template arguments. The concept and its template arguments, together, are referred to as a concept instance. [ Example: CopyConstructible<int> is a concept-id if name lookup (3.4) determines that the identifier CopyConstructible refers to a concept-name; then, CopyConstructible<int> is a concept instance that refers to the CopyConstructible concept used with the type int. -- end example ]
3 A concept C is treated as a constrained template (14.10) X for the purpose of making the concept's definition a constrained context. The template requirements for the conceptX consist of a concept requirement for the concept's concept instance (14.10.1)C<T1, T2, ..., TN>, where T1, T2, ..., TN are the template parameters of C, and the template requirements implied by that concept requirement (14.10.1.2). [ Example:

concept C<typename T> { }

concept D<typename T> { requires C<T>; // D is treated as a constrained template whose template requirements are D<T> && C<T>
}

-- end example ] 14.9.1 Concept definitions
1 The grammar for a concept-definition is: concept-definition: autoopt concept identifier < template-parameter-list > refinement-clauseopt concept-body ;opt

[concept.def]

2 Concept-definitions are used to declare concept-names. A concept-name is inserted into the scope in which it is declared immediately after the concept-name is seen. A concept is considered defined after the closing brace of its concept-body. A full concept name is an identifier that is treated as if it were composed of the concept name and the sequence of its enclosing namespaces.

57

14.9 Concepts

Templates 58

3 Concepts shall only be defined at namespace scope.
4 A concept-definition that starts with auto defines an auto concept, otherwise it defines an explicit concept.
5 The template-parameter-list of a concept-definition shall not contain any requirements specified in the simple form (14.10.1).
6 concept-body: { concept-member-specificationopt }

concept-member-specification: concept-member-specifier concept-member-specificationopt

concept-member-specifier: associated-function type-parameter ; associated-requirements axiom-definition

The body of a concept contains associated functions (14.9.1.1), associated types (14.9.1.2), associated class templates, associated requirements (14.9.1.3), and axioms (14.9.1.3). A name x declared in the body of a concept shall refer to only one of: an associated type, an associated class template, an axiom, or one or more associated functions that have been overloaded (clause 13).

14.9.1.1 Associated functions

[concept.fct]

1 Associated functions describe functions, member functions, or operators (including templates thereof) that specify the functional behavior of the concept's template arguments and associated types and class templates (14.9.1.2). A concept map (14.9.2) for a given concept must satisfy each associated function in the concept (14.9.2.1).
associated-function: simple-declaration function-definition template-declaration
2 An associated-function shall declare a function or function template. If the declarator-id of the declaration is a qualified-id, its nested-name-specifier shall name a template parameter of the enclosing concept; the declaration declares a member function or member function template. An associated function shall not be extern, inline or virtual ([dcl.fct.spec]), explicitly-defaulted or deleted ([dcl.fct.def]), or a friend function ([class.friend]). An associated function shall not contain an exception-specification ([except.spec]).
3 Associated functions may specify requirements for non-member functions and operators. [ Example:

concept Monoid<typename T> { T operator+(T, T); T identity();
}

-- end example ]

58

59 Templates

14.9 Concepts

4 With the exception of the assignment operator ([over.ass]) and operators new, new[], delete, and delete[], associated functions shall specify requirements for operators as non-member functions. [ Note: This restriction applies even to the operators (), [], and ->, which can otherwise only be declared as non-static member functions (13.5): [ Example:
concept Convertible<typename T, typename U> { operator U(T); // okay: conversion from T to U T::operator U*() const; // error: cannot specify requirement for member operator
}
-- end example ] -- end note ]
5 Associated functions may specify requirements for static or non-static member functions, constructors, and destructors. [ Example:
concept Container<typename X> { X::X(int n); X::~X(); bool X::empty() const; static size_t X::max_size();
}
-- end example ]
6 Associated functions may specify requirements for new and delete. [ Example:
concept HeapAllocatable<typename T> { void* T::operator new(std::size_t); void* T::operator new[](std::size_t); void T::operator delete(void*); void T::operator delete[](void*);
}
-- end example ]
7 Associated functions may specify requirements for function templates and member function templates. [ Example:
concept Sequence<typename X> { typename value_type;
template<InputIterator Iter> requires Convertible<InputIterator<Iter>::value_type, Sequence<X>::value_type> X::X(Iter first, Iter last);
}
-- end example ]
8 Concepts may contain overloaded associated functions (clause 13). [ Example:
concept C<typename X> { void f(X); void f(X, X); // okay int f(X, X); // error: differs only by return type
}
59

14.9 Concepts

Templates 60

-- end example ]
9 Associated member functions with the same name and the same parameter-type-list, as well as associated member function templates with the same name, the same parameter-type-list, the same template parameter lists, and the same template requirements (if any), cannot be overloaded if any of them, but not all, have a ref-qualifier (8.3.5).
10 Associated functions may have a default implementation. This implementation is instantiated whenif used. A default implementation of an associated function is a constrained template (14.10) whose template requirements include concept requirements for the enclosing concept, its less refined concepts, along withand its associated requirements. [ Example:
concept EqualityComparable<typename T> { bool operator==(T, T); bool operator!=(T x, T y) { return !(x == y); }
}

class X {}; bool operator==(const X&, const X&);

concept_map EqualityComparable<X> { } // okay, operator!= uses default

-- end example ]

14.9.1.2 Associated types and class templates

[concept.assoc]

1 Associated types and associated class templates are types and class templates, respectively, defined in the concept body and used in the description of the concept.

2 An associated type specifies a type in a concept body. Associated types are typically used to express the parameter and return types of associated functions. [ Example:

concept Callable1<typename F, typename T1> { typename result_type; result_type operator()(F&&, T1);
}

-- end example ]
3 An associated class template specifies a class template in a concept. [ Example:
concept C<typename T> { template<ObjectType U> class X;
}

-- end example ]
4 Associated types and class templates may be provided with a default value. The default value is used to satisfy the associated type or class template requirement when no corresponding definition is provided in a concept map (14.9.2.2). [ Example:
concept Iterator<typename Iter> { typename difference_type = int;
}

60

61 Templates

14.9 Concepts

concept_map Iterator<int*> { } // okay, difference_type is int

-- end example ]
5 Associated types and class templates may use the simple form to specify requirements (14.10.1) on the associated type or class template. The simple form is equivalent to a declaration of the associated type or class template followed by an associated requirement (14.9.1.3) stated using the general form (14.10.1). [ Example:
concept InputIterator<typename Iter> { / ... / }

concept Container<typename X> { InputIterator iterator; // same as typename iterator; requires InputIterator<iterator>;
}

-- end example ]

14.9.1.3 Associated requirements

[concept.req]

1 Associated requirements place additional requirements on the concept's template parameters, associated types, and associated class templates. Associated requirements have the same form and behavior as template requirements in a constrained template (14.10).
associated-requirements: requires-clause ;
[ Example:

concept Iterator<typename Iter> { typename difference_type; requires SignedIntegral<difference_type>;
}

-- end example ] 14.9.1.4 Axioms

[concept.axiom]

1 Axioms allow the expression of the semantic properties of concepts.
axiom-definition: requires-clauseopt axiom identifier ( parameter-declaration-clause ) axiom-body

axiom-body: { axiom-seqopt }

axiom-seq: axiom axiom-seqopt

axiom: expression-statement if ( expression ) expression-statement
An axiom-definition defines a new semantic axiom whose name is specified by its identifier. [ Example:

61

14.9 Concepts

Templates 62

concept Semigroup<typename Op, typename T> : CopyConstructible<T> { T operator()(Op, T, T);
axiom Associativity(Op op, T x, T y, T z) { op(x, op(y, z)) == op(op(x, y), z);
} }
concept Monoid<typename Op, typename T> : Semigroup<Op, T> { T identity_element(Op);
axiom Identity(Op op, T x) { op(x, identity_element(op)) == x; op(identity_element(op), x) == x;
} }
-- end example ]
2 Within the body of an axiom-definition, equality (==) and inequality (!=) operators are available for each concept type parameter and associated type T. These implicitly-defined operators have the form:
bool operator==(const T&, const T&); bool operator!=(const T&, const T&);
[ Example:
concept CopyConstructible<typename T> { T::T(const T&);
axiom CopyEquivalence(T x) { T(x) == x; // okay, uses implicit ==
} }
-- end example ]
3 Name lookup within an axiom will only find the implicitly-declared == and != operators if the corresponding operation is not declared as an associated function (14.9.1.1) in the concept, one of it's less refined concepts (14.9.3), or in an associated requirement (14.9.1.3). [ Example:
concept EqualityComparable<typename T> { bool operator==(T, T); bool operator!=(T, T);
axiom Reflexivity(T x) { x == x; // refers to EqualityComparable<T>::operator==
} }
-- end example ]
62

63 Templates

14.9 Concepts

4 Where axioms state the equality of two expressions, implementations are permitted to replace one expression with the other. [ Example:
template<typename Op, typename T> requires Monoid<Op, T> T identity(const Op& op, const T& t) { return op(t, identity_element(op)); // equivalent to "return t;" }

-- end example ]
5 Axioms can state conditional semantics using if statements. The expression is contextually converted to bool (clause 4). When the condition can be proven true, and the expression-statement states the equality of two expressions, implementations are permitted to replace one expression with the other. [ Example:
concept TotalOrder<typename Op, typename T> { bool operator()(Op, T, T);

axiom Antisymmetry(Op op, T x, T y) { if (op(x, y) && op(y, x)) x == y; } axiom Transitivity(Op op, T x, T y, T z) { if (op(x, y) && op(y, z)) op(x, z) == true; } axiom Totality(Op op, T x, T y) { (op(x, y) || op(y, x)) == true; } }

-- end example ]
6 An axiom containing a requires-clause only applies when the specified template requirements are satisfied.In a concept map where the requires clause of an axiom-definition is not satisfied, an implementation shall behave as if the axiom weere not defined. [ Example:
concept EqualityComparable2<typename T, typename U = T> { bool operator==(T, U); bool operator!=(T, U);

requires std::SameType<T, U> axiom Reflexivity(T x) { x == x; // okay: T and U have the same type
} }

-- end example ]

7 Whether an implementation replaces any expression according to an axiom is implementation-defined. With the exception of such substitutions, the presence of an axiom shall have no effect on the observable behavior of the program. [ Note: the intent of axioms is to provide a mechanism to express the semantics of concepts. Such semantic information can be used for optimization, software verification, software testing, and other program analyses and transformations, all of which are outside the scope of this International Standard. -- end note ]

14.9.2 Concept maps

[concept.map]

1 The grammar for a concept-map-definition is:

63

14.9 Concepts

Templates 64

concept-map-definition: concept_map ::opt nested-name-specifieropt concept-id { concept-map-member-specificationopt } ;opt
concept-map-member-specification: concept-map-member concept-map-member-specificationopt
concept-map-member: simple-declaration function-definition template-declaration
2 Concept maps describe how a set of template arguments satisfy the requirements stated in the body of a concept definition (14.9.1). For template argument deduction ([temp.deduct.type]) against a constrained template to succeed, each of the template's requirements shall be satisfied (14.10.1.1). The concept map's name (which is the full concept name of its concept) is inserted into the scope in which the concept map or concept map template (14.5.8) is defined immediately after the concept-id is seen. The name of the concept map is the full concept name of the concept in the corresponding concept instance. [ Example:
class student_record { public:
std::string id; std::string name; std::string address; };
namespace N { concept EqualityComparable<typename T> { bool operator==(T, T); }
}
namespace M { concept_map N::EqualityComparable<student_record> { // the concept map's name is ::N::EqualityComparable bool operator==(const student_record& a, const student_record& b) { return a.id == b.id; } }
}
template<typename T> requires EqualityComparable<T> void f(T);
f(student_record()); // okay, have concept_map EqualityComparable<student_record>
-- end example ]
3 A concept map may contain two kinds of members: requirement members and members that satisfy requirement members. The latter may be explicitly declared within the concept map, explicitly declared within a refinementconcept map for a more refined concept, or generated implicitly from a default implementation from the concept or refinement of the conceptone of its more refined concepts.
4 A requirement member represents a requirement to satisfy (as described below)Each requirement member represents
64

65 Templates

14.9 Concepts

an entity (a single associated function (14.9.1.1), associated type or associated class template (14.9.1.2) fromin the corresponding concept that must be satisfied as described below. The set of requirement members is the set of associated functions, associated types and associated class templates from the concept after substitution of the concept's template parameters with the corresponding template arguments. [ Note: There is no way to explicitly declare a requirement member. -- end note ]
5 After a requirement is satisfied, the requirement member serves as a synonym for the set of entities that satisfies the requirement (14.9.2.1, 14.9.2.2). That entityset of entities is said to be the satisfier of the requirement member. Each requirement member is visible during qualified name lookup (3.4.3.3). [ Note: A satisfier need not be a member of a concept map. -- end note ]
6 A concept map member that satisfies a requirement member cannot be found by any form of name lookup (3.4).
7 A concept map archetype (14.10.2) is considered to have satisfiers (generated from the concept) for each of its requirement members.
8 Concept maps shall satisfy every associated function (14.9.1.1), associated type and associated class template requirement (14.9.1.2) of its concept instance and all of the requirements inherited from its less refined concept instances (14.9.3). [ Example:
concept C<typename T, typename U> { T f(T); U f(U); }
concept_map C<int, int> { int f(int); // okay: matches requirement for f in concept instance C<int, int>
}
-- end example ]
9 Concept maps shall not contain declarations that do not satisfy any requirement in their corresponding concept or its less refined concepts. [ Example:
concept C<typename T> { }
concept_map C<int> { int f(int); // error: no requirement for function f
}
-- end example ]
10 At the point of definition of a concept map, all associated requirements (14.9.1.3) of the corresponding concept and its less refined concepts (14.9.3) shall be satisfied (14.10.1.1). [ Example:
concept C<typename T> { / ... / }
concept D<typename Iter> { typename type; requires C<type>;
}
concept_map C<ptrdiff_t> { }
concept_map D<int*> {
65

14.9 Concepts

Templates 66

typedef ptrdiff_t type; } // okay: there exists a concept_map C<ptrdiff_t>
class X { ... };
concept_map D<X> { typedef long type;
} // error: no concept_map C<long> if ptrdiff_t is not long
-- end example ]
11 A concept map for an auto concept is implicitly defined (14.9.1) when it is needed by concept map lookup (14.10.1.1). If any requirement of the concept or its less refined concepts is notwould not be satisfied by the implicitly-defined concept map, the concept map is not implicitly defined. The implicitly-defined concept map is defined in the namespace of the concept. [ Example:
auto concept C<typename T> { T::T(const T&); T operator+(T, T);
}
template<typename T> requires C<T> T add(T x, T y) {
return x + y; }
int f(int x, int y) { return add(x, y); // okay: concept map C<int> implicitly defined
}
-- end example ]
12 [ Note: Failure to implicitly define a concept map does not necessarily imply that the program is ill-formed (14.8.2). -- end note ] [ Example:
auto concept F<typename T> { void f(T);
}
auto concept G<typename T> { void g(T);
}
template<typename T> requires F<T> void h(T); // #1 template<typename T> requires G<T> void h(T); // #2
struct X { }; void g(X);
void func(X x) {
66

67 Templates

14.9 Concepts

h(x); // okay: implicit concept map F<X> fails, causing template argument deduction to fail for #1; calls #2 }

-- end example ]

13 A concept map or concept map template shall be defined before the first use of a concept instance that would make use of the concept map or concept map template in every translation unit in which such a use occurs; no diagnostic is required. If the introduction of a concept map or concept map template changes a previous result (e.g., in template argument deduction (14.8.2)), the program is ill-formed, no diagnostic required. Concept map templates must be instantiated if doing so would affect the semantics of the program. A concept map for a particular concept instance shall not be defined both implicitly and explicitly in the same namespace in a programtranslation unit. If one translation unit of a program contains an explicitly-defined concept map for that concept instance, and a different translation contains an implicitly-defined concept map for that concept instance, then the program is ill-formed, no diagnostic required.

14 The implicit or explicit definition of a concept map asserts that the axioms (14.9.1.4) stated in its corresponding concept (and the concepts that it refines) hold, permitting an implementation to perform the transformations described in 14.9.1.4. If an axiom is violated, the behavior of the program is undefined.

14.9.2.1 Associated function definitions

[concept.map.fct]

1 Function definitions in the concept map can be used to adapt the syntax of the concept's template arguments to the syntax expected by the concept. [ Example:

concept Stack<typename S> { typename value_type; bool empty(S const&); void push(S&, value_type); void pop(S&); value_type& top(S&);
}

// Make a vector behave like a stack template<Regular T> concept_map Stack<std::vector<T> > {
typedef T value_type; bool empty(std::vector<T> const& vec) { return vec.empty(); } void push(std::vector<T>& vec, value_type const& value) {
vec.push_back(value); } void pop(std::vector<T>& vec) { vec.pop_back(); } value_type& top(std::vector<T>& vec) { return vec.back(); } }

-- end example ]
2 A function or function template defined in a concept map is inline.
3 An associated function (or function template) requirement is satisfied as follows. Given an associated function (call it f), let R be the return type of f, after substitution of the concept's template arguments for their corresponding concept parameters. Construct an expression E (as defined below) in the scope of the concept map. Then, the associated function requirement is satisfied:

67

14.9 Concepts

Templates 68

-- if R is cv void and the expression E is well-formed,
-- otherwise, if R is not cv void and the expression "E implicitly converted to R" is well-formed, or
-- otherwise, if f has a default implementation.
4 The expression E is defined differently depending on the associated function and the concept map definition. Let parm1, parm2, ..., parmN be the parameters of f (after substitution of the concept map arguments) and parm1 , parm2 , ..., parmN be expressions, where each parmi is an id-expression naming parmi. If the declared type of parmi is an lvalue reference type, then parmi is treated as an lvalue, otherwise, parmi is treated as an rvalue.
For an associated member function (or member function template) in a type X (after substitution of the concept map arguments into the associated member function or member function template), let x be an object of type cv X, where cv are the cv-qualifiers on the associated member function (or member function template). If the requirement has no ref-qualifier or if its ref-qualifier is &, x is an lvalue; otherwise, x is an rvalue.
The expression E is defined as follows:
-- If f is an associated non-member function or function template and the concept map contains one or more function or function template definitions with the same name as f, E is f(parm1 , parm2 , ..., parmN ), and the overload set of entities f consists of the definitions of f in the concept map. [ Note: Unqualified lookup 3.4.1 and argument dependent lookup 3.4.2 are suppressed. -- end note ].
-- Otherwise, if f is a non-static associated member function and the concept map contains one or more member function or member function template definitions in the type X and with the same name as f, E is x.f(parm1 , parm2 , ..., parmN ), where name lookup of x.f refers to the definitions of X::f in the concept map.
-- Otherwise, if f is a static associated member function and the concept map contains one or more member function or member function template definitions in the type X and with the same name as f, E is X::f(parm1 , parm2 , ..., parmN ), where name lookup of X::f refers to the static definitions of X::f in the concept map.
-- If the associated function or function template is a prefix unary operator Op, E is Op parm1 .
-- If the associated function or function template is a postfix unary operator Op, E is parm1 Op.
-- If the associated function or function template is a binary operator Op, E is parm1 Op parm2 .
-- If the associated function or function template is the function call operator, E is parm1 (parm2 , parm3 , ..., parmN ).
-- If the associated function is a conversion operator, E is parm1 if the conversion operator requirement is not explicit and (R)parm1 if the conversion operator requirement is explicit, where R is the return type of the conversion operator.
-- If the associated function or function template is a non-member function or function template, E is an unqualified call f(parm1 , parm2 , ..., parmN ).
-- If the associated function or function template is a static member function or function template in the type X, E is a call X::f(parm1 , parm2 , ..., parmN ).
-- If the associated function is a constructor or constructor template that is explicit or has N = 1 parameters, E is X(parm1 , parm2 , ..., parmN ). [ Example:

68

69 Templates

14.9 Concepts

concept TwoIntConstructible<typename T> { T::T(int, int);
}
struct X { X(long, int); }; concept_map TwoIntConstructible<X> { } // okay: X has a constructor that can accept two ints
// (the first is converted to a long)
-- end example ] -- If the associated function is a constructor or constructor template that has one parameter (and is not explicit),
E is "parm1 implicitly converted to X". [ Example:
concept IC<typename T> { T::T(int);
}
concept EC<typename T> { explicit T::T(int);
}
struct X { X(int);
};
struct Y { explicit Y(int);
};
concept_map IC<X> { } // okay concept_map EC<X> { } // okay concept_map IC<Y> { } // error: cannot copy-initialize Y from an int concept_map EC<Y> { } // okay
-- end example ] -- If the associated function is a destructor, E is x.X().[ Example:
concept D<typename T> { T::~T();
}
concept_map D<int> { } // okay: int is not a class type
struct X { }; concept_map D<X> { } // okay: X has implicitly-declared, public destructor
struct Y { private: ~Y(); }; concept_map D<Y> { } // error: Y's destructor is inaccessible
-- end example ]
69

14.9 Concepts

Templates 70

-- If the associated member function requirement is a requirement for an operator new or new[], E is operator new(parm1 , parm2 , ..., parmN ) or operator new[](parm1 , parm2 , ..., parmN ), respectively. Name lookup for the allocation function occurs in the scope of X; if this lookup fails to find the name, the allocation function's name is looked up in the global scope.If X is a class type, the allocation function's name is looked up in the scope of X. If this lookup fails to find the name, or if X is not a class type, the allocation function's name is looked up in the global scope.
-- If the associated member function requirement is a requirement for an operator delete or delete[], E is operator delete(parm1 , parm2 , ..., parmN ) or operator delete[](parm1 , parm2 , ..., parmN ), respectively. Name lookup for the deallocation function occurs in the scope of X; if this lookup fails to find the name, the deallocation function's name is looked up in the global scope.If X is a class type, the deallocation function's name is looked up in the scope of X. If this lookup fails to find the name, or if X is not a class type, the deallocation function's name is looked up in the global scope.
-- Otherwise, the associated function is a member function requirement, and E is x.f(parm1 , parm2 , ..., parmN ).
5 Each satisfied associated function (or function template) requirement has a corresponding associated function candidate set. An associated function candidate set is a candidate set (14.10.3) representing the functions or operations used to satisfy the requirement. The seed of the associated function candidate set is determined based on the expression E used to determine that the requirement was satisfied.
-- If the evaluation of E involves overload resolution at the top level, the seed is the function (13.3.1) selected by the outermost application of overload resolution (clause 13).
-- Otherwise, if E is a pseudo destructor call ([expr.pseudo]), the seed is a pseudo-destructor-name.
-- Otherwise, the seed is the initialization of an object.

14.9.2.2 Associated type and template definitions

[concept.map.assoc]

1 Definitions in the concept map provide types and templates that satisfy requirements for associated types and templates (14.9.1.2), respectively.

2 Associated type parameter requirements are satisfied by type definitions in the body of a concept map. [ Example:

concept ForwardIterator<typename Iter> { typename difference_type;
}

concept_map ForwardIterator<int*> { typedef ptrdiff_t difference_type;
}

-- end example ]
3 Associated class template requirements are satisfied by class template definitions or template aliases ([temp.alias]) in the body of the concept map. [ Example:
concept Allocator<typename Alloc> { template<class T> class rebind;
}

70

71 Templates

14.9 Concepts

template<typename T> class my_allocator {
template<typename U> class rebind; };
template<typename T> concept_map Allocator<my_allocator<T>> {
template<class U> using rebind = my_allocator<T>::rebind; }
-- end example ]
4 A concept map member that satisfies an associated type or class template requirement can be implicitly defined using template argument deduction (14.8.2) with one or more associated function requirements (14.9.2.1), if the associated type or class template requirement does not have a default value. The definition of the associated type or class template is determined using the rules of template argument deduction from a type ([temp.deduct.type]).
-- Let P be the return type of an associated function after substitution of the concept's template parameters specified by the concept map with their template arguments, and where each undefined associated type and associated class template has been replaced with a newly invented type or template template parameter, respectively.
-- Let A be the return type of the seed in the associated function candidate set corresponding to the associated function.
If the deduction fails, no concept map members are implicitly defined by that associated function. If the results of deduction produced by different associated functions yield more than one possible value, that associated type or class template is not implicitly defined. [ Example:
auto concept Dereferenceable<typename T> { typename value_type; value_type& operator*(T&);
}
template<typename T> requires Dereferenceable<T> void f(T&);
void g(int* x) { f(x); // okay: Dereferenceable<int*> implicitly defined // implicitly-defined Dereferenceable<int*>::operator* calls built-in * for integer pointers // implicitly-defined Dereferenceable<int*>::value_type is int
}
-- end example ]
5 If an associated type or class template (14.9.1.2) has a default value, a concept map member satisfying the associated type or class template requirement shall be implicitly defined by substituting the concept map arguments into the default value. If this substitution does not produce a valid type or template (14.8.2), the concept map member is not implicitly defined. [ Note:If substitution fails, the associated type or class template can still be deduced, as described below. -- end note ] [ Example:
auto concept A<typename T> {
71

14.9 Concepts

Templates 72

typename result_type = typename T::result_type; }
auto concept B<typename T> { T::T(const T&);
}
template<typename T> requires A<T> void f(const T&); // #1 template<typename T> requires B<T> void f(const T&); // #2
struct X {}; void g(X x) {
f(x); // okay: A<X> cannot satisfy result_type requirement, and is not implicitly defined, calls #2 }
-- end example ]

14.9.3 Concept refinement
1 The grammar for a refinement-clause is: refinement-clause: : refinement-specifier-list

[concept.refine]

refinement-specifier-list: refinement-specifier , refinement-specifier-list refinement-specifier

refinement-specifier: ::opt nested-name-specifieropt concept-id
2 Refinements specify an inheritance relationship among concepts. A concept B named in a refinement-specifier of concept D is a less refined concept of D and D is a more refined concept of B. A concept refinement inherits all requirements in the body of a concept (14.9.1), such that the requirements of the more refined concept are a superset of the requirements of the less refined concept. [ Note: when a concept D refines a concept B, every set of template arguments that satisfies the requirements of D also satisfies the requirements of B. The refinement relationship is transitive. -- end note ] [ Example: In the following example, EquilateralPolygon refines Polygon. Thus, every EquilateralPolygon is a Polygon, and constrained templates (14.10) that are well-formed with a Polygon constraint are well-formed when given an EquilateralPolygon.
concept Polygon<typename P> { / ... / }

concept EquilateralPolygon<typename P> : Polygon<P> { / ... / }

-- end example ] 3 A refinement-specifier shall refer to a previously defined concept. [ Example:
concept C<typename T> : C<vector<T>> {/ ... / } // error: concept C is not defined

72

73 Templates

14.9 Concepts

-- end example ]
4 The template-argument-list of a refinement-specifier's concept-id shall refer to at least one of the template parameters, and no template parameter shall be used in a way that establishes an archetype (14.10.2). [ Example:
concept C<typename T> { T f(); }
concept D<typename T> : C<int> // error: C<int> uses no template parameters
{ // ...
}
concept E<typename T> : C<T>, D<decltype(f())> // error: establishes archetype T'
{ // ...
}

-- end example ]

5 Within the definition of a concept, a concept map archetype is synthesized for each refinement-specifier in the concept's refinement-clause (if any).

14.9.3.1 Concept member lookup

[concept.member.lookup]

1 Concept member lookup determines the meaning of a name in concept scope (3.3.8). The following steps define the result of name lookup for a member name f in concept scope C. CR is the set of concept scopes corresponding to the concepts refined by the concept whose scope is C.

2 If the name f is declared in concept scope C, and f refers to an associated type or class template (14.9.1.2), then the result of name lookup is the associated type or class template.

3 If the name f is declared in concept scope C, and f refers to one or more associated functions (14.9.1.1), then the result of name lookup is the set consisting of the associated functions in C in addition to the associated functions in each concept scope in CR for which name lookup of f results in a set of associated functions. [ Example:

concept C1<typename T> : CopyConstructible<T> { T f(T); // #1
}

concept C2<typename T> { typename f;
}

concept D<typename T> : C1<T>, C2<T> { T f(T, T); // #2
}

template<typename T> requires D<T> void f(T x)

73

14.9 Concepts

Templates 74

{ D<T>::f(x); // name lookup finds #1 and #2, overload resolution selects #1
}
-- end example ]
4 If the name f is not declared in C, name lookup searches for f in the scopes of each of the less refined concepts (CR). If name lookup of f is ambiguous in any concept scope CR, name lookup of f in C is ambiguous. Otherwise, the set of concept scopes CR is a subset of CR containing only those concept scopes for which name lookup finds f. The result of name lookup for f in C is defined by:
-- If CR is empty, name lookup of f in C returns no result. -- Otherwise, if CR contains only a single concept scope, name lookup for f in C is the result of name lookup for f
in that concept scope.
-- Otherwise, if f refers to one or more functions in all of the concept scopes in CR , then f refers to the set consisting of all associated functions from all of the concept scopes in CR .
-- Otherwise, if f refers to an associated type or class template in all concept scopes in CR , and all of the associated types or class templates are equivalent (14.10.1), the result is the associated type or class template f.
-- Otherwise, name lookup of f in C is ambiguous.
[ Example:
concept A<typename T> { typename t; }
concept B<typename T> { typename t; }
concept C<typename T> : A<T>, B<T> { f(t); // error: ambiguous, the two t's are not equivalent f(A<T>::t); // okay
}
-- end example ]
5 When name lookup in a concept scope C results in a set of associated functions, duplicate associated functions are removed from the set. [ Example:
concept A<typename T> { T f(T); // #1a
}
concept B<typename T> { T f(T); // #1b T g(T); // #2a
}
concept C<typename T> : A<T>, B<T> { T g(T); // #2b
}

74

75 Templates

14.9 Concepts

template<typename T> requires C<T> void h(T x) {
C<T>::f(x); // overload set contains #1a; #1b was removed as a duplicate C<T>::g(x); // overload set contains #2b; #2a was removed as a duplicate }
-- end example ]

14.9.3.2 Implicit concept maps for refined concepts

[concept.refine.maps]

1 When a concept map or concept map template is defined for a concept C that has a refinement clause, concept maps or concept map templates for each of the concept instances in the refinement clause of C shall be defined, implicitly or explicitly, in the namespace of which the more refined concept map or concept map template is a member. [ Example:

concept A<typename T> { } concept B<typename T> : A<T> { }

concept_map B<int> { } // implicitly defines concept map A<int>

-- end example ]
2 A concept map or concept map template for a refinement (called a less refined concept map or concept map template) has been defined if concept map lookup (14.10.1.1) finds a concept map for the concept instance I in the namespace of which the more refined concept map or concept map template is a member, where I is determined by substituting the template arguments of the more refined concept map or concept map template into the refinement-specifier corresponding to the refinement. If concept map lookup fails, if it finds an implicitly generated concept map for an auto concept, or if it finds a concept map from a different namespace, a suitable concept map shall beis defined implicitly, as described below. [ Example:
concept C<typename T> { } concept D<typename T> : C<T> { }

template<typename T> concept_map C<T*> { } // #1

template<typename T> concept_map D<T*> { } // okay: #1 defines the concept map corresponding to the refinement-specifier C<T*>

-- end example ]
3 Concept map templates (14.5.8) can only be implicitly defined for certain refinementsless refined concepts from the concept map templates of more refined concepts. A less refined concept map template corresponding to a particular refinement-specifier can be defined if all of the template parameters of the more refined concept map template are deduciblecan be deduced. Let R be the refinement-specifier after substitution of the more refined concept map's template arguments for the corresponding template parameters. A template parameter T of the more refined concept map template is deduciblecan be deduced if for any template argument P in R's template-argument-list there exists a type, template, or value A such that template argument deduction (14.8.2) performed with that P/A pair would determine a value for T. If any template parameter of the more refined concept map template is not deduciblecan not be deduced, the program

75

14.9 Concepts

Templates 76

is ill-formed. Otherwise, a less refined concept map template is implicitly defined in the namespace of the more refined concept map template; its template-parameter-list and template requirements are the same as the more refined concept map template, and its concept-id is R. [ Example:
concept C<typename T> { } concept D<typename T, typename U> : C<T> { }
template<typename T> struct A { };
template<typename T> concept_map D<A<T>, T> { } // implicitly defines: template<typename T> concept_map C<A<T>> { }
template<typename T, typename U> concept_map D<T, A<U>> { } // ill-formed: cannot deduce template parameter U from C<T> // and there is no concept map template C<T>
-- end example ]
4 When a less refined concept map or concept map template is implicitly defined, definitions in the more refined concept map or concept map template can be used to satisfy the requirements of the less refined concept (14.9.2). [ Note: a single function definition in a concept map can be used to satisfy multiple requirements. -- end note ] [ Example: in this example, the concept map D<int> implicitly defines the concept map C<int>.
concept C<typename T> { T f(T); void g(T);
}
concept D<typename T> : C<T> { void g(T);
}
concept_map D<int> { int f(int x) { return -x; } // satisfies requirement for C<int>::f void g(int x) { } // satisfies requirement for C<int>::g and D<int>::g
}
-- end example ]
5 Each concept map or concept map template shall have satisfiers that are compatible with the satisfiers of its less refined concept maps or concept map templates. A satisfier of the more refined concept map or concept map template is compatible with its corresponding satisfier of the less refined concept map or concept map template if
-- the satisfiers correspond to an associated function requirement (14.9.1.1) and their associated function candidate sets have the same seed or
-- the satisfiers satisfy an associated type or class template requirement (14.9.1.2) and both satisfiers name the same type or template, respectively.
If a program contains satisfiers of a concept map or concept map template that are not compatible with their corresponding satisfiers of a less refined concept map or concept map template, the program is ill-formed. If the concept maps or concept
76

77 Templates

14.9 Concepts

map templates with satisfiers that are not compatible occur in different translation units, no diagnostic is required. [ Example:
concept C<typename T> { typename assoc; assoc f(T);
}
concept D<typename T> : C<T> { int g(T);
}
concept E<typename T> : D<T> { }
concept_map C<int> { typedef int assoc; int f(int x) { return x; }
}
concept_map D<int> { typedef int assoc; // okay: same type as C<int>::assoc // okay: f is not defined in D<int> int g(int x) { return -x; } // okay: satisfies D<int>::g
}
concept_map E<int> { typedef float assoc; // error: E<int>::assoc and D<int>::assoc are not the same type // okay: f is not defined in D<int> int g(int x) { return x; } // error: D<int>::g already defined in concept map D<int>
}
-- end example ]

14.9.4 Support concepts

[concept.support]

1 The concepts in [concept.support] provide the ability to state template requirements for C++ type classifications (3.9) and type relationships that cannot be expressed directly with concepts. Concept maps for these concepts are implicitly defined. A program shall not provide a concept map or concept map template for any concept in [concept.support] nor shall it provide a definition for any of these concepts.

2 The following concepts are implicitly defined at the beginning of each translation unit. [ Note:This implies that the namespace std is always visible at global scope. -- end note ]

namespace std { concept Returnable<typename T> { } concept PointeeType<typename T> { } concept MemberPointeeType<typename T> { } concept ReferentType<typename T> { } concept VariableType<typename T> { } concept ObjectType<typename T> see below ;

77

14.9 Concepts

Templates 78

concept ValueType<typename T> see below ; concept ClassType<typename T> see below ; concept Class<typename T> see below ; concept PolymorphicClass<typename T> see below ; concept Union<typename T> see below ; concept TrivialType<typename T> see below ; concept StandardLayoutType<typename T> see below ; concept LiteralType<typename T> see below ; concept ScalarType<typename T> see below ; concept ArithmeticType<typename T> see below ; concept NonTypeTemplateParameterType<typename T> see below ; concept IntegralConstantExpressionType<typename T> see below ; concept IntegralType<typename T> see below ; concept EnumerationType<typename T> see below ; concept FloatingPointType<typename T> see below ; concept SameType<typename T, typename U> { } concept DerivedFrom<typename Derived, typename Base> { } }
concept Returnable<typename T> { }
3 Note: Describes types that can be used as the return type of a function.
4 Requires: for every non-array type T that is cv void or that provides a copy operation suitable for use in a return statement ([stmt.return]) and is not an abstract class, the concept map Returnable<T> is implicitly defined in namespace std.
concept PointeeType<typename T> { }
5 Note: describes types to which a pointer can be created.
6 Requires: for every type T that is an object type, a function type that does not have cv-qualifiers, or cv void, a concept map PointeeType<T> is implicitly defined in namespace std.
concept MemberPointeeType<typename T> { }
7 Note: describes types to which a pointer-to-member can be created.
8 Requires: for every type T that is an object type or function type, a concept map MemberPointeeType<T> is implicitly defined in namespace std.
concept ReferentType<typename T> { }
9 Note: describes types to which a reference can be created, including reference types (since references to references can be formed during substitution of template arguments).
10 Requires: for every type T that is an object type, a function type that does not have cv-qualifiers, or a reference type, a concept map ReferentType<T> is implicitly defined in namespace std.
concept VariableType<typename T> : ReferentType<T> { }
11 Note: describes types that can be used to declare a variable.

78

79 Templates

14.9 Concepts

12 Requires: for every type T that is an object type or reference type, but not an abstract class, a concept map VariableType<T> is implicitly defined in namespace std.
concept ObjectType<typename T> : ReferentType<T>, PointeeType<T> { } 13 Note: describes object types (3.9), for which storage can be allocated. 14 Requires: for every type T that is an object type, a concept map ObjectType<T> is implicitly defined in namespace
std.
concept ValueType<typename T> : ObjectType<T>, VariableType<T>, MemberPointeeType<T> { } 15 Note: describes value types, for which objects, variables, references, pointers, and pointers-to-members can be
created. 16 Requires: for every type T that is an object type but not an abstract class, a concept map ValueType<T> is
implicitly defined in namespace std.
concept ClassType<typename T> : ObjectType<T> { } 17 Note: describes class types (i.e., unions, classes, and structs). 18 Requires: for every type T that is a class type (Clause 9), a concept map ClassType<T> is implicitly defined in
namespace std.
concept Class<typename T> : ClassType<T> { } 19 Note: describes non-union classes (Clause 9). 20 Requires: for every non-union class T, a concept map Class<T> is implicitly defined in namespace std.
concept PolymorphicClass<typename T> : Class<T> { } 21 Note: describes polymorphic class types ([class.virtual]). 22 Requires: for every type T that is a polymorphic class, a concept map PolymorphicClass<T> is implicitly defined
in namespace std.
concept Union<typename T> : ClassType<T>, ValueType<T> { } 23 Note: describes union types ([class.union]). 24 Requires: for every type T that is a union, a concept map Union<T> is implicitly defined in namespace std.
concept TrivialType<typename T> : ValueType<T> { } 25 Note: describes trivial types (3.9). 26 Requires: for every type T that is a trivial type, a concept map TrivialType<T> is implicitly defined in namespace
std.
concept StandardLayoutType<typename T> : ValueType<T> { } 27 Note: describes standard-layout types (3.9).

79

14.9 Concepts

Templates 80

28 Requires: for every type T that is a standard-layout type, a concept map StandardLayoutType<T> is implicitly defined in namespace std.
concept LiteralType<typename T> : ValueType<T> { } 29 Note: describes literal types (3.9). 30 Requires: for every type T that is a literal type, a concept map LiteralType<T> is implicitly defined in namespace
std.
concept ScalarType<typename T> : TrivialType<T>, LiteralType<T>, StandardLayoutType<T> { }
31 Note: describes scalar types (3.9). 32 Requires: for every type T that is a scalar type, a concept map ScalarType<T> is implicitly defined in namespace
std.
concept ArithmeticType<typename T> : ScalarType<T> { } 33 Note: describes arithmetic types (3.9.1). 34 Requires: for every type T that is an arithmetic type, a concept map ArithmeticType<T> is implicitly defined in
namespace std.
concept NonTypeTemplateParameterType<typename T> : VariableType<T> { } 35 Note: describes type that can be used as the type of a non-type template parameter (14.1). 36 Requires: for every type T that can be the type of a non-type template-parameter (14.1), a concept map
NonTypeTemplateParameterType<T> is implicitly defined in namespace std.
concept IntegralConstantExpressionType<typename T> : ScalarType<T>, NonTypeTemplateParameterType<T> { }
37 Note: describes types that can be the type of an integral constant expression (5.19). 38 Requires: for every type T that is an integral type or enumeration type, a concept map
IntegralConstantExpressionType<T> is implicitly defined in namespace std.
concept IntegralType<typename T> : IntegralConstantExpressionType<T>, ArithmeticType<T> { }
39 Note: describes integral types (3.9.1). 40 Requires: for every type T that is an integral type, a concept map IntegralType<T> is implicitly defined in
namespace std.
concept EnumerationType<typename T> : IntegralConstantExpressionType<T> { IntegralType underlying_type;
} 41 Note: describes enumeration types ([dcl.enum]). underlying_type is the underlying type of the enumeration
type.

80

81 Templates

14.10 Constrained templates

42 Requires: for every type T that is an enumeration type, a concept map EnumerationType<T> is implicitly defined in namespace std.
concept FloatingPointType<typename T> : ArithmeticType<T> { } 43 Note: describes floating point types (3.9.1). 44 Requires: for every type T that is a floating point type, a concept map FloatingPointType<T> is implicitly
defined in namespace std.
concept SameType<typename T, typename U> { } 45 Note: describes a same-type requirement (14.10.1).
concept DerivedFrom<typename Derived, typename Base> { } 46 Requires: for every pair of class types (T, U), such that T is either the same as or publicly and unambiguously
derived from U, a concept map DerivedFrom<T, U> is implicitly defined in namespace std.

14.10 Constrained templates

[temp.constrained]

1 A template that has a requires-clause (or declares any template type parameters using the simple form of requirements (14.1)) is a constrained template. A constrained template can only be instantiated with template arguments that satisfy its template requirements. The template definitions of constrained templates are similarly constrained, requiring names to be found through name lookup at template definition time (3.4). [ Note: Names can be found in the template requirements of a constrained template (3.3.9). The practical effect of constrained templates is that they provide improved diagnostics at template definition time, such that any use of the constrained template that satisfies the template's requirements is likely to result in a well-formed instantiation. -- end note ]

2 A template that is not a constrained template is an unconstrained template.

3 A constrained context is a part of a constrained template in which all name lookup is resolved at template definition time. Names that would be dependent outside of a constrained context shall be found in the current scope, which includes the template requirements of the constrained template (3.3.9). [ Note: Within a constrained context, template parameters behave as if aliased to their corresponding archetypes (14.10.2) so there are no dependent types ([temp.dep.type]), and no type-dependent values (14.6.2.2) or dependent names (14.6.2). Instantiation in constrained contexts (14.10.4) still substitutes types, templates and values for template parameters. -- end note ] A constrained context is any part of a constrained template that is not an unconstrained context (described below).

4 Any context that is not a constrained context is an unconstrained context. Within a constrained context, several constructs provide unconstrained contexts:

-- a late-checked block (6.9),

-- a default argument in a template-parameter, and

-- a default function argument (8.3.5).

5 Within a constrained context, a program shall not refer to an unconstrained templaterequire a template specialization of an unconstrained template for which the template arguments of the specialization depend on a template parameter.

81

14.10 Constrained templates

Templates 82

14.10.1 Template requirements

[temp.req]

1 A template has template requirements if it contains a requires-clause or any of its template parameters is specified using the simple form of requirements (14.1). Template requirements state the conditions under which the template can be used.
requires-clause: requires requirement-list requires ( requirement-list )

requirement-list: requirement ...opt && requirement-list requirement ...opt
requirement: ::opt nested-name-specifieropt concept-id ! ::opt nested-name-specifieropt concept-id
2 A requires-clause contains a list of requirements, all of which must be satisfied by the template arguments for the template. [ Note: Requirement satisfaction is described in 14.10.1.1. -- end note ] A requirement not containing a ! is a concept requirement. A requirement containing a ! is a negative requirement.
3 A concept requirement that refers to the std::SameType concept (14.9.4) is a same-type requirement. A same-type requirement is satisfied when its two template arguments refer to the same type (including the same cv qualifiers). In a constrained template (14.10), a same-type requirement std::SameType<T1, T2> makes the types T1 and T2 equivalent. [ Note: type equivalence is a congruence relation, thus
-- std::SameType<T1, T2> implies std::SameType<T2, T1>,
-- std::SameType<T1, T2> and std::SameType<T2, T3> implies std::SameType<T1, T3>,
-- std::SameType<T1, T1> is trivially true,
-- std::SameType<T1*, T2*> implies std::SameType<T1, T2> and std::SameType<T1**, T2**>, etc.
-- end note ] [ Example:
concept C<typename T> { typename assoc; assoc a(T);
}

concept D<typename T> { T::T(const T&); T operator+(T, T);
}

template<typename T, typename U> requires C<T> && C<U> && std::SameType<C<T>::assoc, C<U>::assoc> && D<C<T>::assoc> C<T>::assoc f(T t, U u) {
return a(t) + a(u); // okay: C<T>::assoc and C<U>::assoc are the same type }

82

83 Templates

14.10 Constrained templates

-- end example ]
4 A requirement followed by an ellipsis is a pack expansion (14.5.3). Requirement pack expansions place requirements on all of the arguments in one or more template parameter packs. [ Example:
auto concept OutputStreamable<typename T> { std::ostream& operator<<(std::ostream&, const T&);
}
template<typename T, typename... Rest> requires OutputStreamable<T> && OutputStreamable<Rest>... void print(const T& t, const Rest&... rest) {
std::cout << t; print(rest...); }
template<typename T> requires OutputStreamable<T> void print(const T& t) {
std::cout << t; }
void f(int x, float y) { print(17, ", ", 3.14159); // okay: implicitly-generated OutputStreamable<int>, OutputStreamable<const char[3]>, // and OutputStreamable<double> print(17, " ", std::cout); // error: no concept map OutputStreamable<std::ostream>
}
-- end example ]
5 If the requirements of a template are inconsistent, such that no set of template arguments can satisfy all of the requirements, the program is ill-formed, no diagnostic required. [ Example:
concept C<typename T> { }
template<typename T> requires C<T> && !C<T> void f(const T&); // error: no type can satisfy both C<T> && !C<T>, no diagnostic required
-- end example ]

14.10.1.1 Requirement satisfaction

[temp.req.sat]

1 During template argument deduction (14.8.2) against a constrained template, it is necessary to determine whether each of the requirements of the constrained template can be satisfied by the template arguments.

2 A concept requirement is satisfied if concept map lookup (described below) finds a unique concept map with the same full concept name as the concept named by the concept requirement and whose template argument list is the same as the template argument list of the concept requirement, after substitution of the constrained template's template arguments

83

14.10 Constrained templates

Templates 84

into the concept requirement's template argument list. Concept maps used to satisfy a concept requirement can be defined explicitly (14.9.2), instantiated from a concept map template (14.5.8), or defined implicitly (14.9.2). [ Example:
concept A<typename T> { } auto concept B<typename T> { T operator+(T, T); } concept C<typename T> { } concept D<typename T> { }
concept_map A<float> { } concept_map B<float> { } template<typename T> concept_map C<T*> { } template<typename T> requires B<T> concept_map D<T> { }
template<typename T> requires A<T> void f(T); template<typename T> requires B<T> void g(T); template<typename T> requires C<T> void h(T); template<typename T> requires D<T> void i(T);
struct X { }; void h(float x, int y, int X::* p, int *q) {
f(x); // okay: uses concept map A<float> f(y); // error: no concept map A<int>; requirement not satisfied g(x); // okay: uses concept map B<float> g(y); // okay: implicitly defines and uses concept map B<int> g(p); // error: no implicit definition of concept map B<int X::*>; requirement not satisfied h(q); // okay: instantiates concept map C<T*> with T=int to satisfy requirement C<T> i(p); // error: i can't get no satisfaction; the concept map template D<T> does not apply because B<int X::*> is not satisfied }
-- end example ]
3 A negative requirement is satisfied if concept map lookup fails to find a concept map that would satisfy the corresponding concept requirement. [ Note: If concept map lookup results in an ambiguity, concept map lookup halts and the negative requirement is not satisfied. -- end note ] [ Example:
concept A<typename T> { } auto concept B<typename T> { T operator+(T, T); }
concept_map A<float> { } concept_map B<float> { }
template<typename T> requires !A<T> void f(T); template<typename T> requires !B<T> void g(T);
struct X { }; void h(float x, int y, int X::* p) {
f(x); // error: concept map A<float> has been defined f(y); // okay: no concept map A<int> g(x); // error: concept map B<float> has been defined g(y); // error: implicitly defines concept map B<int>, requirement not satisfied g(p); // okay: concept map B<int X::*> cannot be implicitly defined
84

85 Templates

14.10 Constrained templates

}

-- end example ]
4 Concept map lookup is a mechanism that attempts to find a concept map that corresponds to the concept instance (call it I) formed from the concept of a requirement and its template argument list after substitution of template arguments for their corresponding template parameters. There is an associated full concept name (14.9.1) of I; call it N. Concept map lookup searches an ordered sequence Q (defined below) where each element is a set of concept maps called S. For each element in Q (progressing from the lowest to the highest-numbered element of Q), concept map lookup attempts to find within S
-- exactly one matching non-template concept map or, if one does not exist,
-- exactly one most-specific matching concept map template according to concept map matching rules (14.5.8).
If no matching concept map is found within a set S in Q, concept map lookup proceeds to the next set in Q. If partial ordering of concept map templates results in an ambiguity, concept map lookup returns no result.
5 When concept map lookup is performed during template argument deduction during partial ordering ([temp.deduct.partial]), Q is defined as containing only one element S, where S is the set of concept map archetypes synthesized from the requirements of the argument template (14.5.6.2,[temp.deduct.partial]).
6 When concept map lookup is performed during the instantiation of a constrained template (14.10.4), Q is defined as the following ordered sequence:
1. S is the set of concept maps, each with name N, that have replaced the concept map archetypes used in the constrained template.
2. S is the set of concept maps and concept map templates found by searching for N in the namespaces of which a subset of the concept maps in (1) (described below) are members and in the associated namespaces of those namespaces ([namespace.def]); using-directives in those namespaces are not followed during this search. Only those concept maps in (1) that were explicitly defined or were instantiated from concept map templates areConcept maps in (1) that were implicitly generated from an auto concept are not considered when determining which namespaces to search.
3. If a concept map for I can be implicitly defined from an auto concept (14.9.2), S contains the concept map generated from the auto concept. Otherwise, S is empty.
[ Example:
concept C<typename T> { } concept D<typename T> { }

namespace N1 { concept_map C<int> { } concept_map D<int> { }
} namespace N2 {
template<C T> void f(T); template<C T> requires D<T> void f(T); template<C T> void g(T x) {
f(x);

// #1 // #2

85

14.10 Constrained templates

Templates 86

} using N1::concept_map C<int>; void h() {
g(1); // inside g's call to f, concept map lookup for D<int> finds N1::D<int>; calls #2 } }
-- end example ]
7 In all other cases (excluding during the instantiation of a constrained template and template argument deduction during partial ordering), Q is defined as the ordered sequence:
1. S is formed by performing unqualified name lookup (3.4.1) for N.
2. S is the set of concept maps and concept map templates found by searching for N in the namespace of which the concept of I is a member and its associated namespaces ([namespace.def]); using-directives in these namespaces are not followed during this search and all names found by way of using-declarations are ignored.
3. If a concept map for I can be implicitly defined (14.9.2), S contains the implicitly-defined concept map for I. Otherwise, S is empty.
8 [ Note: When concept map lookup is performed within a constrained context (14.10), concept map archetypes, whose names are placed at the same scope as template parameters, can be found by unqualified lookup. Concept map lookup does not require the definition of a concept map archetype that it finds. -- end note ]
9 If concept map lookup finds a matching concept map in a set S within Q, concept map lookup succeeds and the remaining elements of Q are ignored. [ Note: The ordering of name-finding methods in Q can effect a kind of "concept map hiding" behavior. [ Example:
namespace N1 { concept C<typename T> { } concept_map C<int> { } // #1
template<C T> void f(T x); } namespace N2 {
concept_map N1::C<int> { } // #2
namespace N3 { concept_map N1::C<int> { } // #3
void g() { N1::f(1); // uses #3 to satisfy concept requirement N1::C<int>
} } }
-- end example ] -- end note ]
10 [ Note: Concept maps declared in the namespace of the concept itself will be found last by concept map lookup. [ Example:

86

87 Templates

14.10 Constrained templates

namespace N1 { concept C<typename T> { } concept_map C<int> { }
} template<N1::C T> void f(T x); void g() {
f(1); // Ok, finds N1::concept_map C<int> because it is in the same namespace as concept N1::C. }
-- end example ] -- end note ]
11 If a concept requirement appears (directly or indirectly) multiple times in the requirements of the template, and if the concept maps (14.9.2) used to satisfy the multiple occurrences of the concept requirement are not the same concept map or are different from the concept map that would be determined by concept map lookup (14.10.1.1), then the template arguments do not satisfy the requirements of the template. [ Note:This does not necessarily imply that the program is ill-formed. -- end note ] [ Example:
concept A<typename T> { } concept B<typename T> {
typename X; requires A<X>; } concept C<typename T> { typename X; requires A<X>; } namespace N1 { concept_map A<int> { } // #1 concept_map B<int> { } // uses #1 to satisfy the requirement for A<int> } namespace N2 { concept_map A<int> { } // #2 concept_map C<int> { } // uses #2 to satisfy the requirement for A<int> } template<typename T> requires B<T> && C<T> struct S { }; using N1::concept_map B<int>; using N2::concept_map C<int>; S<int> s; // ill-formed, two different concept maps for A<int>, #1 and #2
-- end example ]

14.10.1.2 Requirement implication

[temp.req.impl]

1 The declaration of a constrained template implies additional template requirements that are available within the body of the template. A requirement is implied if the absence of that requirement would render the constrained template declaration ill-formed. Template requirements are implied from:

-- the type of a constrained function template,

87

14.10 Constrained templates

Templates 88

-- the template arguments of a constrained class template partial specialization,
-- the template arguments of a concept map template,
-- the template parameters of a constrained template,
-- the requirements of a constrained template (including implied requirements),
-- the associated requirements and refinements of a concept, and
-- the type of an associated function requirement.
2 A requirement is only implied if that requirement is not already present in the template requirements.
3 For every concept requirement in a template's requirements (including implied requirements), requirements for the refinements and associated requirements of the concept named by the concept instance (14.9.3, 14.9.1.3) are implied.
4 The formation of types within certain parts of the declaration of a constrained template (described above) implies the template requirements needed to ensure that the types themselves are well-formed within any instantiation. The following type constructions imply template requirements:
-- For every template-id X<A1, A2, ..., AN>, where X is a constrained template, the requirements of X (after substitution of the arguments A1, A2, ..., AN) are implied. [ Example:
template<LessThanComparable T> class set { / ... / };
template<CopyConstructible T> void maybe_add_to_set(std::set<T>& s, const T& value); // use of std::set<T> implicitly adds requirement LessThanComparable<T>
-- end example ]
-- For every type cv T that is used as the type of a variable, where T aliases an archetype, the concept requirement VariableType<T> is implied.
-- For every type "pointer to cv T", where T aliases a type archetype, the concept requirement PointeeType<T> is implied.
-- For every type "reference to cv T", where T aliases a type archetype, the concept requirement ReferentType<T> is implied.
-- For every type "pointer to member of X of type cv T":
-- If X aliases a type archetype, the concept requirement ClassType<X> is implied.
-- If T aliases a type archetype, the concept requirement MemberPointeeType<T> is implied.
-- For every type "array of unknown bound of T" or "array of N T" where T aliases a type archetype, the concept requirement ValueType<T> is implied.
-- For every type cv T that occurs as the return type of a function, where T aliases an archetype, the concept requirement Returnable<T> is implied.
-- For every type T that is used as the type of a non-type template parameter, where T aliases an archetype, the concept requirement NonTypeTemplateParameterType<T> is implied.

88

89 Templates

14.10 Constrained templates

-- For every type T that is a parameter type or return type of a constexpr function, where T aliases an archetype, the concept requirement LiteralType<T> is implied.
-- If the formation of a type containing an archetype T would be ill-formed due to a missing requirement C<T>, where C is a compiler-supported concept (14.9.4), the requirement C<T> is implied.
-- For every qualified-id that names an associated type or class template, a concept requirement for the concept instance containing that associated type or class template is implied. [ Example:
concept Addable<typename T, typename U> { CopyConstructible result_type; result_type operator+(T, U);
}
template<CopyConstructible T, CopyConstructible U> Addable<T, U>::result_type // implies Addable<T, U> add(T t, U u) {
return t + u; }
-- end example ]
[ Example:
concept C<typename T> { typename assoc; }
template<typename T> requires C<T> C<T>::assoc // implies Returnable<C<T>::assoc> f(T*, T&); // implies PointeeType<T> and ReferentType<T>
-- end example ]
5 In the definition of a constrained class template partial specialization, the requirements of its primary class template (14.5.5), after substitution of the template arguments of the class template partial specialization, are implied. If this substitution results in a requirement that does not depend on any template parameter, then the requirement must be satisfied (14.10.1); otherwise, the program is ill-formed. [ Example:
template<typename T> requires EqualityComparable<T> class simple_set { };
template<std::ObjectType T> class simple_set<T*> // implies EqualityComparable<T*> { };
-- end example ]
6 The template requirements for two templates are identical if they contain the same concept, negative, and same-type requirements in arbitrary order. Two requirements are the same if they have the same kind, name the same concept, and have the same template argument lists.
89

14.10 Constrained templates

Templates 90

14.10.2 Archetypes

[temp.archetype]

1 An archetype is a non-dependent type, template, or value whose behavior is defined by the template requirements (14.10.1) of its constrained template. Within a constrained context (14.10), a type, value, or template that has an established archetype (described below) behaves as if it were its archetype. [ Note: this substitution of archetypes (which are not dependent) for their corresponding types, templates, or values (which would be dependent in an unconstrained template) effectively treats all types and, templates, and values (and therefore both expressions and names) in a constrained context as "non-dependent". -- end note ]

2 The archetype of a type is a type, the archetype of a template is a class template, and the archetype of a value is a value.

3 A type in a constrained context aliases an archetype if it is:

-- a template type parameter (14.1),

-- an associated type (14.9.1.2), or

-- a class template specialization involving one or more archetypes.

4 A template in a constrained context aliases an archetype if it is:

-- a template template parameter (14.1) or

-- an associated class template (14.9.1.2).

5 A value in a constrained context aliases an archetype if it is a constant-expression (5.19) whose value depends on a template parameter. Two values that alias archetypes are the same if their expressions are equivalent (14.5.6.1). If the translation of the program requires comparison of two values that alias archetypes and are functionally equivalent but not equivalent, the program is ill-formed, no diagnostic required.

6 If two types, T1 and T2, both alias archetypes and are the same (e.g., due to one or more same-type requirements (14.10.1)), then T1 and T2 alias the same archetype T . [ Note: there is no mechanism to specify the relationships between different value archetypes, because such a mechanism would introduce the need for equational reasoning within the translation process. -- end note ]

7 An archetype does not exist until it is established. An archetype becomes established under the following circumstances:

-- a type that aliases the archetype has been usedwhen it is used in the template argument list of a class template specialization or concept instance whose definition is required,

-- a type that aliases the archetype is provided as an argument to a sizeof or alignof expression ([expr.sizeof], 5.3.6),

-- at the end of the function declarator in a function declaration in which one or more parameters use a type that aliases the archetype, or

-- the archetype has been committed (described below)the archetype is used in a context where a complete type is required.

8 If a same-type requirement attempts to make two types equivalent that both alias established archetypes but do not alias the same archetype, the program is ill-formed.

9 A type archetype that has been committed has been defined as described below. Once an archetype has been committed, its definition can no longer be changed by the introduction of additional concept requirements. A program that specifies

90

91 Templates

14.10 Constrained templates

or implies concept requirements that use a committed archetype is ill-formed. An archetype is committed when:
-- the definition of the archetype is required,
-- the completeness of a type archetype might affect the semantics of the program, or
-- name lookup finds an associated function with a parameter that uses a type that aliases the archetype.
10 In the declaration of a constrained member, member template, or nested class, archetypes are established and committed as if itthe member were the only member of its class. [ Note: This means that members that come before the constrained member, member template, or nested class cannot prevent the expression of additional requirements on template parameters from enclosing scopes. -- end note ] [ Example: Given:
concept C1<typename T> { } concept C2<typename T> { } concept C3<typename T> { }
template <C1 T> class X { requires C2<T> void g(T) {} class B { void g(T) {} requires C3<T> void f(T) {} };
};
X::g is evaluated as if in the context:
template <C1 T> class X { requires C2<T> void g(T) {}
};
and X::B::g is evaluated as if in the context:
template <C1 T> class X { class B { requires C3<T> void f(T) {} };
};
-- end example ]
11 An archetype T has the requirement of a given concept instance if T appears in the template argument list of the concept instance when that concept instance appears in a requirement whose potential scope encloses a region where the archetype T is used. [ Example:
concept C<typename T> {} template <C T> void f( T ) {}

Beginning at the declaration of T until the closing curly brace of the definition of f(T) above, we say that T " has the requirement C<T>". -- end example ]

91

14.10 Constrained templates

Templates 92

12 An archetype is synthesized from the template requirements of the constrained template in which it is defined; see 14.10.2.1.
13 If two associated member function or member function template requirements that name a constructor or destructor for a type T have the same signature, the duplicate signature is ignored.
14 If a class template specialization is an archetype that does not appear as a template argument of any explicitly-specified requirement in the template requirements and whose template is not itself an archetype, then the archetype is an instantiated archetype. An instantiated archetype is an archetype whose definition is provided by the instantiation of its template with its template arguments (which involve archetypes). The template shall not be an unconstrained template. [ Note: Partial ordering of class template partial specializations (14.5.5.2) depends on the properties of the archetypes, as defined by the requirements of the constrained template. When the constrained template is instantiated (14.10.4), partial ordering of class template partial specializations occurs a second time based on the actual template arguments. -- end note ] [ Example:
template<EqualityComparable T> struct simple_multiset {
bool includes(const T&); void insert(const T&); // ... };
template<LessThanComparable T> struct simple_multiset<T> { // A
bool includes(const T&); void insert(const T&); // ... };
template<LessThanComparable T> bool first_access(const T& x) {
static simple_multiset<T> set; // instantiates simple_multiset<T >, where T is the archetype of T , // from the partial specialization of simple_multiset marked 'A'
return set.includes(x)? false : (set.insert(x), true); }
-- end example ]
[ Note: Class template specializations for which template requirements are specified behave as normal archetypes. -- end note ] [ Example:
auto concept CopyConstructible<typename T> { T::T(const T&);
}
template<CopyConstructible T> struct vector;
auto concept VectorLike<typename X> { typename value_type = typename X::value_type; X::X(); void X::push_back(const value_type&); value_type& X::front();
92

93 Templates

14.10 Constrained templates

}
template<CopyConstructible T> requires VectorLike<vector<T>> // vector<T> is an archetype (but not an instantiated archetype) void f(const T& value) {
vector<T> x; // okay: default constructor in VectorLike<vector<T> > x.push_back(value); // okay: push_back in VectorLike<vector<T> > VectorLike<vector<T>>::value_type& val = x.front(); // okay: front in VectorLike<vector<T }
-- end example ]
15 [ Note: Constrained class templates involving recursive definitions are ill-formed if the recursive class template specialization is an instantiated archetype. Constrained class templates involving recursive definitions can be specified by adding template requirements on the recursive class template specializations, making them archetypes that are not instantiated archetypes. [ Example:
template<CopyConstructible... T> class tuple;
template<CopyConstructible Head, CopyConstructible... Tail> class tuple<Head, Tail...> : tuple<Tail...> // ill-formed: tuple<Tail...> is an instantiated archetype,
// but it is an incomplete type {
Head head; // ... };
template<> class tuple<> { / ... / };
-- end example ] -- end note ]
16 In a constrained context, for each concept requirement that is stated in or implied by the corresponding requirements, a concept map archetype for that requirement is synthesized by substituting the archetype of T for each occurrence of T within the template arguments of the requirement. The concept map archetype acts as a concept map, and its definition is used to resolve name lookup into requirements scope (3.3.9) and satisfy the requirements of templates used inside the constrained context. When the definition of a concept map archetype is required, it is synthesized from the definition of its corresponding concept (14.9.2). An implementation shall not define a concept map archetype unless the definition of that concept map archetype is required. [ Example:
concept SignedIntegral<typename T> { T::T(const T&); T operator-(T);
} concept RandomAccessIterator<typename T> {
SignedIntegral difference_type; difference_type operator-(T, T); } template<SignedIntegral T> T negate(const T& t) { return -t; }
template<RandomAccessIterator Iter>
93

14.10 Constrained templates

Templates 94

RandomAccessIterator<Iter>::difference_type distance(Iter f, Iter l) { typedef RandomAccessIterator<Iter>::difference_type D; D dist = f - l; // okay: - operator resolves to synthesized operator- in // the concept map archetype RandomAccessIterator<Iter >, // where Iter is the archetype of Iter return negate(dist); // okay, concept map archetype RandomAccessIterator<Iter > // implies the concept map archetype SignedIntegral<D >, // where D is the archetype of D
-- end example ]

14.10.2.1 Assembling archetypes

[temp.archetype.assemble]

1 An archetype T for a type T is all of the following that apply:

-- an object type ([intro.object]), if the template contains the requirement std::ObjectType<T>,

-- a function type (8.3.5), if the template contains the requirement std::FunctionType<T>,

-- a class type (clause 9), if the template contains the requirement std::ClassType<T>,

-- a class (clause 9), if the template contains the requirement std::Class<T>,

-- a union ([class.union]), if the template contains the requirement std::Union<T>,

-- a trivial type (3.9), if the template contains the requirement std::TrivialType<T>,

-- a standard layout type (3.9), if the template contains the requirement std::StandardLayoutType<T>,

-- a literal type (3.9), if the template contains the requirement std::LiteralType<T>,

-- a scalar type (3.9), if the template contains the requirement std::ScalarType<T>,

-- an arithmetic type (3.9.1), if the template contains the requirement std::ArithmeticType<T>,

-- an integral type (3.9.1), if the template contains the requirement std::IntegralType<T>,

-- a floating point type (3.9.1), if the template contains the requirement std::FloatingPointType<T>, and

-- an enumeration type ([dcl.enum]), if the template contains the requirement std::EnumerationType<T>.

2 A type archetype is a unique generated class type whose special member functions are each either user-provided or deleted (depending on template requirements) and whose other members are given entirely by its template requirements. A type archetype is considered to be completely defined when it is established (although it may later acquire additional members as a result of additional requirements).

3 The archetype T of T contains a public member function or member function template corresponding to each member function or member function template of each concept map archetype corresponding to a concept requirement that names T (14.10.1). [ Example:

concept CopyConstructible<typename T> { T::T(const T&);
}

94

95 Templates

14.10 Constrained templates

concept MemSwappable<typename T> { void T::swap(T&);
}
template<typename T> requires CopyConstructible<T> && MemSwappable<T> void foo(T& x) {
// archetype T of T contains a copy constructor T ::T (const T &) from CopyConstructible<T> // and a member function void swap(T &) from MemSwappable<T> T y(x); y.swap(x); }
-- end example ]
4 If no requirement specifies a copy constructor for a type T, a copy constructor is implicitly declared (12.8) in the archetype of T with the following signature:
T(const T&) = delete;
[ Example:
concept DefaultConstructible<typename T> { T::T();
}
concept MoveConstructible<typename T> { T::T(T&&);
}
template<typename T> requires DefaultConstructible<T> && MoveConstructible<T> void f(T x) {
T y = T(); // okay: move-constructs y from default-constructed T T z(x); // error: overload resolution selects implicitly-declared
// copy constructor, which is deleted }
-- end example ]
5 If no requirement specifies a copy assignment operator for a type T, a copy assignment operator is implicitly declared (12.8) in the archetype of T with the following signature:
T& T::operator=(const T&) = delete;
6 If no requirement specifies a destructor for a type T, a destructor is implicitly declared (12.4) in the archetype of T with the following signature:
~T() = delete;
7 If no requirement specifies a unary & operator for a type T, a unary member operator & is implicitly declared in the archetype of T for each cv that is a valid cv-qualifier-seq:
95

14.10 Constrained templates

Templates 96

cv T* operator&() cv = delete;
8 For each of the allocation functions new, new[], delete, and delete[] ([class.free]), if no requirement specifies the corresponding operator with a signature below, that allocation function is implicitly declared as a member function in the archetype T of T with the corresponding signature from the following list:
static void* T ::operator new(std::size_t) = delete; static void* T ::operator new(std::size_t, void*) = delete; static void* T ::operator new(std::size_t, const std::nothrow_t&) throw() = delete; static void* T ::operator new[](std::size_t) = delete; static void* T ::operator new[](std::size_t, void*) = delete; static void* T ::operator new[](std::size_t, const std::nothrow_t&) throw() = delete; static void T ::operator delete(void*) = delete; static void T ::operator delete(void*, void*) = delete; static void T ::operator delete(void*, const std::nothrow_t&) throw() = delete; static void T ::operator delete[](void*) = delete; static void T ::operator delete[](void*, void*) = delete; static void T ::operator delete[](void*, const std::nothrow_t&) throw() = delete;
9 If the template requirements contain a requirement std::DerivedFrom<T, Base>, then the archetype of T is publicly derived from the archetype of Base. If the same std::DerivedFrom<T, Base> requirement occurs more than once within the template requirements, the repeated std::DerivedFrom<T, Base> requirements are ignored.

14.10.3 Candidate sets

[temp.constrained.set]

1 A candidate set is a set containing functions and function templates that is determined by a seed (defined below). A candidate set is defined in a constrained context (a retained candidate set, 14.10.4) or as the result of satisfying an associated function requirement in a concept map (an associated function candidate set, 14.9.2.1). Candidate sets are used to capture a set of candidate functions that are used in the instantiation of a constrained template (14.10.4) or when referring to members in a concept map (14.9.2). [ Note: For the purposes of this section, candidate operator functions (13.6) are considered functions. -- end note ]

2 Each candidate set has a seed, which provides the basis for the candidate set itself. All functions and function templates that are consistent with the seed are contained in the candidate set. The seed is determined as part of the definition of the candidate set, and will be one of:

-- a function,

-- the initialization of an object ([dcl.init]), or

-- a pseudo-destructor-name ([expr.pseudo]).

3 A function is consistent with the seed if all of the following apply:

-- it has the same name as the seed,

-- its enclosing namespace is the same as the enclosing namespace of the seed,

-- the seed has a return type of cv void or the function has the same return type as the seed, after the reference (if any) and then top-level cv-qualifiers (if any) have been removed from the return types of the seed and the function, and

96

97 Templates

14.10 Constrained templates

-- it has the same parameter-type-list as the seed, after making the following adjustments to both parameter-type-lists:
-- for a non-static member function, add the implicit object parameter (13.3.1) as the first parameter in the parameter-type-list,
-- for each parameter type, remove the top-level reference (if any) and then top-level cv-qualifiers (if any), -- if the function has M parameters, the seed has N parameters, and M > N, remove each of the last M - N
parameters that has a default argument from the parameter-type-list, and
-- remove the ellipsis, if any.
[ Note:No function or function template is consistent with a non-function seed. A seed that is a function is consistent with itself. -- end note ]
4 A function template is consistent with the seed if all of the following apply:
-- it has the same name as the seed,
-- its enclosing namespace is the same as the enclosing namespace of the seed, and
-- if the candidate set containing the seed is a retained candidate set, the function template is a constrained function template.
5 A candidate set is a set of overloaded functions. Overload resolution (13.3) for a candidate set is subject to the following additional conditions:
-- the set of candidate functions for overload resolution is the set of functions in the candidate set, and
-- if template argument deduction on a candidate function produces a function template specialization that is not consistent with the seed of the candidate set, the function template specialization is not a viable function ([over.match.viable]).

14.10.4 Instantiation of constrained templates

[temp.constrained.inst]

1 Instantiation of a constrained template replaces each template parameter within the definition of the template with its corresponding template argument, using the same process as for unconstrained templates (14.7).

2 Instantiation of a constrained template also replaces each concept map archetype with the concept map that satisfied the corresponding template requirement. [ Note: A concept member that had resolved to a member of a concept map archetype now refers to a member of the corresponding concept map. -- end note ]

3 In the instantiation of a constrained template, a call to a function that resolves to an associated function in a concept map archetype (14.10.2) is instantiated using the associated function candidate set (14.10.3) that satisfies the corresponding associated function requirement in the concept map that replaces the concept map archetype. The instantiated form depends on the seed of the associated function candidate set and the syntactic form that resulted in the call in the constrained template:

-- If the seed is a function, the instantiated form is a call to the associated function candidate set. [ Example:

concept F<typename T> { T::T(); void f(T const&);
}

97

14.10 Constrained templates

Templates 98

template<typename T> requires F<T> void g(T const& x) {
f(x); // calls F<T>::f. When instantiated with T=X, calls #1 f(T()); // calls F<T>::f. When instantiated with T=X, calls #2 }
struct X {}; void f(X const&); // #1 void f(X&&); // #2
concept_map F<X> { } // associated function candidate set for f(X const&) contains #1 and #2, seed is #1
void h(X const& x) { g(x);
}
-- end example ]
-- Otherwise, if the seed is a pseudo-destructor-name, the instantiated form is a pseudo destructor call ([expr.pseudo]).
-- Otherwise, if the seed is the initialization of an object, the instantiated form is the appropriate kind of initialization (zero-initialization, default-initialization, value-initialization, or no initialization) based on the syntactic form in the constrained template. [ Example:
auto concept DefaultConstructible<typename T> { T::T();
}
template<DefaultConstructible T> void f() {
T t1; // type-checks as a call to DefaultConstructible<T>'s T::T() T t2{}; // type-checks as a call to DefaultConstructible<T>'s T::T() }
template void f<int>(); // t1 is not initialized, t2 is value-initialized
-- end example ]
4 A use of a function template specialization in a constrained template instantiates to a reference to that function template specialization's retained candidate set. The retained candidate set is a candidate set (14.10.3) whose seed is the function template specialization. [ Example:
concept InputIterator<typename Iter> { typename difference_type;
} concept BidirectionalIterator<typename Iter> : InputIterator<Iter> { } concept RandomAccessIterator<typename Iter> : BidirectionalIterator<Iter> { }
template<InputIterator Iter> void advance(Iter& i, Iter::difference_type n); // #1 template<BidirectionalIterator Iter> void advance(Iter& i, Iter::difference_type n); // #2

98

99 Templates

14.10 Constrained templates

template<BidirectionalIterator Iter> void f(Iter i) { advance(i, 1); // seed function is #2
}
concept_map RandomAccessIterator<int*> { typedef std::ptrdiff_t difference_type;
}
template<RandomAccessIterator Iter> void advance(Iter& i, Iter::difference_type n); // #3
void g(int* i) { f(i); // in the call to advance(), #2 is the seed of the retained candidate set, the retained candidate set contains #1, #2, // and #3, and partial ordering of function templates selects #3.
}
-- end example ] -- end note ]
5 When a function call in the instantiation of a constrained template is instantiated as a call to a candidate set (14.10.3), the user-defined conversions applied to the function call arguments in the call to the seed are applied in the call to the candidate set in the instantiation. When such a user-defined conversion is applied to an instantiated function call argument, it acts as the user-defined conversion sequence ([over.ics.user]) for that argument. [ Note: the user-defined conversion sequence may still be preceded and followed by a standard conversion sequence. -- end note ] [ Example:
concept C<typename T> { operator int(const T&);
};
class A { };
concept_map C<A> { operator int(const A&) { return 0; }
}
void f(int);
template<C T> void f(const T& x) { f(x); // okay: implicit, user-defined conversion from T to int
}
template void f<A>(const A&); // okay: call f(x) applies the implicit, user-defined // conversion from the template definition using C<A>::operator int.
-- end example ]
6 In the instantiation of a constrained template, a template specialization whose template arguments involve the constrained template's template parameters (14.10.2) is replaced by the template specialization that results from substituting the constrained template's template arguments for their corresponding template parameters. [ Note: If the template specialization is a template alias ([temp.alias]), the substitution occurs in the type-id of the template alias. -- end note ] The resulting type (call it A) shall be compatible with the type involving the template parameters (call it A ) that it replaced, otherwise the program is ill-formed. The template specializations are compatible if all of the following conditions hold:
99

14.10 Constrained templates

Templates 100

-- for each function, function template, or data member m of A referenced by the constrained template, there exists a member named m in A that is accessible from the constrained template and whose type, storage specifiers, template parameters (if any), and template requirements (if any) are the same as the those of A ::m after substituting the constrained template's template arguments for the corresponding template parameters,
-- for each member type t of A referenced by the constrained template, there exists a member type t in A that is accessible from the constrained template and is compatible with the member type A ::t as specified herein, and
-- for each base class B of A referenced by a derived-to-base conversion (4.10) in the constrained template, there exists an unambiguous base class B of A that is accessible from the constrained template, where B is the type produced by substituting the constrained template's template parameters with the corresponding template arguments in B .
[ Example:
auto concept CopyConstructible<typename T> { T::T(const T&);
}
template<CopyConstructible T> struct vector { // A
vector(int, T const &); T& front(); };
template<typename T> struct vector<T*> { // B
vector(int, T* const &); T*& front(); };
template<> struct vector<bool> { // C
vector(int, bool); bool front(); };
template<CopyConstructible T> void f(const T& x) {
vector<T> vec(1, x); T& ref = vec.front(); }
void g(int i, int* ip, bool b) { f(i); // okay: instantiation of f<int> uses vector<int>, instantiated from A f(ip); // okay: instantiation of f<int*> uses vector<int*>, instantiated from B f(b); // ill-formed, detected in the instantiation of f<bool>, which uses the vector<bool> specialization C: // vector<bool>::front is not compatible with vector<T>::front (where T=bool)
}
-- end example ]
100

Appendix B (informative) Implementation quantities

[implimits]

Add the following bullet to paragraph 2 -- Recursively nested implicit concept map definitions [1024]

:

Acknowledgments
The effort to introduce concepts into C++ has been shaped by many. The authors of the "Indiana" and "Texas" concepts proposals have had the most direct impact on concepts: Gabriel Dos Reis, Ronald Garcia, Jaakko Jrvi, Andrew Lumsdaine, Jeremy Siek, and Jeremiah Willcock. Other major contributors to the introduction of concepts in C++ include David Abrahams, Matthew Austern, Mat Marcus, David Musser, Sean Parent, Sibylle Schupp, Alexander Stepanov, and Marcin Zalewski. Howard Hinnant helped introduce support for rvalue references. Stephen Adamczyk, Daniel Krgler, Jens Maurer, John Spicer, and James Widman provided extremely detailed feedback on various drafts and prior revisions of this wording, and the wording itself has benefited greatly from their efforts and the efforts of the C++ committee's Core Working Group.

Bibliography
[1] D. Gregor and B. Stroustrup. Concepts (revision 1). Technical Report N2081=06-0151, ISO/IEC JTC 1, Information Technology, Subcommittee SC 22, Programming Language C++, October 2006.

