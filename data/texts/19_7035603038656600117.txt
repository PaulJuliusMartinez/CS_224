Bezier and B-spline Technology

Fredrik Andersson

fmu@home.se

Supervisor:

Berit Kvernes
beritk@cs.umu.se

June 11, 2003

2

Abstract

Graphical curves and surfaces are hot topics in many di(cid:11)erent areas of re-
search and application, not least due to the rapid progression of computer
aided design (CAD) and gaming technology. Two of the most popular rep-
resentations for this (cid:12)eld are the Bezier and B-spline curves and surfaces.

This thesis will describe the theory behind these topics from a program-
mers viewpoint, together with the developed software which is a rather intu-
itive application to model di(cid:11)erent types of Bezier and B-spline curves and
surfaces in real-time.

The mathematics behind these elements can be quite intimidating to
the normal user at (cid:12)rst, hence this thesis is dedicated to students with
some background in elementary linear algebra and variable calculus but not
necessarily in computer graphics.

There are an abundance of interesting aspects to this topic of curves
and surfaces, and this thesis will primarily focus on the di(cid:11)erent ways to
use, implement and e(cid:14)ciently evaluate them. Thus, this report will serve as
excellent material for students entering the (cid:12)eld of polynomial curves and
surfaces in computer graphics.

3

Acknowledgements

I would like to thank my supervisor Berit Kvernes for the great support,
both morally and technically. Also, love goes to my parents which have
assisted with (cid:12)nance, corrective reading and moral support.

Francois Rimasson, 3D-artist, and Andreas Johansson, fellow student,
supplied me with superb visual material for the presentation of my work.
This was very appreciated and I thank both of you.

4

Contents

1 Introduction

1.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Objective . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Structure of the thesis . . . . . . . . . . . . . . . . . . . . . .
1.4 Prerequisites
. . . . . . . . . . . . . . . . . . . . . . . . . . .
1.5 Software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.6 Notation and Typesetting . . . . . . . . . . . . . . . . . . . .

2 Bezier curves and surfaces

2.1 Basis function . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Curve de(cid:12)nition . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Curve segments . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Bezier subdivision . . . . . . . . . . . . . . . . . . . . . . . .
2.5 Rational Bezier curves . . . . . . . . . . . . . . . . . . . . . .
2.6 Bezier surfaces
. . . . . . . . . . . . . . . . . . . . . . . . . .
2.7 The de Casteljau algorithm . . . . . . . . . . . . . . . . . . .
2.8 Real-time aspects . . . . . . . . . . . . . . . . . . . . . . . . .
2.8.1 Computation . . . . . . . . . . . . . . . . . . . . . . .
2.8.2
Sculpting . . . . . . . . . . . . . . . . . . . . . . . . .
2.9 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 B-spline curves and surfaces

. . . . . . . . . . . . . . . . . .
3.1 Comparison to Bezier curves
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Knots
3.3 B-spline basis functions
. . . . . . . . . . . . . . . . . . . . .
3.4 B-spline formulation . . . . . . . . . . . . . . . . . . . . . . .
3.4.1 NURBS . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 NURBS surfaces
. . . . . . . . . . . . . . . . . . . . . . . . .
3.6 The de Boor algorithm . . . . . . . . . . . . . . . . . . . . . .
3.7 Real-time aspects . . . . . . . . . . . . . . . . . . . . . . . . .
3.7.1 Computation . . . . . . . . . . . . . . . . . . . . . . .
3.7.2
Sculpting . . . . . . . . . . . . . . . . . . . . . . . . .
3.8 Knot insertion and deletion . . . . . . . . . . . . . . . . . . .

9
9
10
10
11
11
11

13
13
15
16
17
18
18
19
20
20
21
21

23
23
24
26
27
27
30
30
31
31
32
33

5

3.9 Concatenation . . . . . . . . . . . . . . . . . . . . . . . . . .
3.10 Other spline forms . . . . . . . . . . . . . . . . . . . . . . . .
3.10.1 Natural spline . . . . . . . . . . . . . . . . . . . . . . .
3.10.2 Hermite curves . . . . . . . . . . . . . . . . . . . . . .
3.10.3 Catmull-Rom splines . . . . . . . . . . . . . . . . . . .
3.10.4 Uniformly shaped (cid:12)-spline . . . . . . . . . . . . . . . .
3.11 B-spline summary . . . . . . . . . . . . . . . . . . . . . . . .

4 Applications

4.1 Camera movement . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Topologies . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Character movement . . . . . . . . . . . . . . . . . . . . . . .
4.4 Collision detection . . . . . . . . . . . . . . . . . . . . . . . .
4.5 Soft objects . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.6 Automatic LOD . . . . . . . . . . . . . . . . . . . . . . . . .
4.7 Object modeling . . . . . . . . . . . . . . . . . . . . . . . . .

5 Implementation

5.1 Simple evaluation . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Forward di(cid:11)erence . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Recursive subdivision . . . . . . . . . . . . . . . . . . . . . .
5.4 Look-up tables
. . . . . . . . . . . . . . . . . . . . . . . . . .
5.5 Portability . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Implementation comparison . . . . . . . . . . . . . . . . . . .
5.6

6 Closing remarks

6.1 Personal comments . . . . . . . . . . . . . . . . . . . . . . . .
6.2 Future work . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.3 Using the software . . . . . . . . . . . . . . . . . . . . . . . .

34
34
35
35
35
36
36

37
37
38
39
39
42
43
43

45
45
45
46
47
47
48

53
53
54
54

6

List of Figures

2.1 Basis functions of degree one
. . . . . . . . . . . . . . . . . .
2.2 Basis functions of degree two . . . . . . . . . . . . . . . . . .
2.3 Basis functions of degree three
. . . . . . . . . . . . . . . . .
2.4 Curve and control polygon . . . . . . . . . . . . . . . . . . . .
2.5 Continuity constraint . . . . . . . . . . . . . . . . . . . . . . .
2.6 Bezier surface . . . . . . . . . . . . . . . . . . . . . . . . . . .
Illustration of de Casteljau’s algorithm . . . . . . . . . . . . .
2.7

3.1 Uniform B-spline curve . . . . . . . . . . . . . . . . . . . . . .
3.2 Knots and segments
. . . . . . . . . . . . . . . . . . . . . . .
3.3 Non-uniform B-spline curve with clamped endpoints . . . . .
3.4 Cubic with clamped end points, Cox de Boor . . . . . . . . .
3.5 NURBS curve, wi = 1:0 for all i . . . . . . . . . . . . . . . . .
3.6 NURBS curves, w7 = 1:0, w7 = 15:0 respectively . . . . . . .
3.7 NURBS surface, 6x4 control points . . . . . . . . . . . . . . .
3.8 de Boor algorithm, cubic curve . . . . . . . . . . . . . . . . .
3.9 Before and after knot insertion . . . . . . . . . . . . . . . . .
3.10 Cubic Hermite basis functions . . . . . . . . . . . . . . . . . .

4.1 Key rotations on a spline
. . . . . . . . . . . . . . . . . . . .
4.2 Game level side-view . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
4.3 Di(cid:11)erent resolutions
. . . . . . . . . . . . . . . . . . . . . . . .
4.4 Bounding volumes
4.5 Bezier surface with springs
. . . . . . . . . . . . . . . . . . .
4.6 Bezier patch, di(cid:11)erent LOD . . . . . . . . . . . . . . . . . . .

5.1 Bezier class diagram . . . . . . . . . . . . . . . . . . . . . . .
5.2 Simple evaluation vs. Forward di(cid:11)erence . . . . . . . . . . . .
5.3 Bernstein polynomials vs. de Casteljau . . . . . . . . . . . . .
5.4 de Boor vs. Cox de Boor . . . . . . . . . . . . . . . . . . . . .
5.5 B-spline vs. Bezier . . . . . . . . . . . . . . . . . . . . . . . .

14
14
15
16
17
19
20

24
24
25
26
27
28
29
31
33
35

37
38
40
41
42
43

48
49
50
51
52

7

8

Chapter 1

Introduction

Over the last two decades the scene of computer graphics has literally ex-
ploded with progress in all directions; the arrival of dedicated 3D hardware,
computer generated animation and faster computers to name a few key
events.

One of these directions focus on displaying smooth curves and surfaces,
suitable for modeling landscapes, faces and other topologies of interest. Here
arise the need for Bezier and, in particular, B-spline curves, two concepts
with roots in the late 1950’s.

These two types of curves are made up of an arbitrary amount of control
points which provide a guideline for the evaluated curve to approximate.
The approximation can be modi(cid:12)ed to suit its needs in a number of di(cid:11)erent
ways; weighted control points, knot vectors, varying the degree of the curve,
and so forth. All will be expanded on and explained later.

One might ask why parametric representations of curves and surfaces
are to prefer over the polygonal representation. A few good reasons are
tiny size, automatic detail resolution and scalability1. The advantages are
numerous and will be thoroughly investigated.

1.1 Background

Before the 1950’s, designing smooth shapes was a very tedious e(cid:11)ort. Envi-
ronment dependent aluminum strips, clumsy full scale moulding forms and
a timetable that would havoc most modern companies.

In 1959, an employee at the Citroen automobile company named Paul
de Faget de Casteljau came up with the simple idea of iterating a(cid:14)ne com-
binations of polygon meshes to obtain smooth surfaces suitable for modeling
car chassis. Almost simultaneously, Peugeot employee Pierre Bezier worked
on the intersection of partial cylinders to achieve the same goals. Both ver-
sions, which produced equal curves, are today known as the Bezier curve

1The ability to transfer between small and large systems

9

since Pierre Bezier was the (cid:12)rst to write a public paper on the subject. Paul
de Faget de Casteljau was however not forgotten, as his named is etched in
the Casteljau algorithm, one of the most common ways to evaluate Bezier
curves. Both of these methods, and their extensions to other curves, are
explained in later sections.

The Bezier curve was formally presented in [9] and has since then been
a very common way to display smooth curves, both in computer graphics
and mathematics.

The B-spline curve is an extended version of the Bezier curve that con-
sists of segments, each of which can be viewed as an individual Bezier curve
with some additions that will be covered in chapter 3.

1.2 Objective

The purpose of this thesis is to thoroughly investigate and explain the con-
cept, use and implementation of Bezier and B-spline curves and surfaces to
readers with little experience in the (cid:12)eld. This is accomplished primarily
with the report, but also practically aided from the developed software.

There are a number of issues that perplexes the use of parametric curves

or surfaces in computer graphics. With no priorities, to name a few:

(cid:15) Creating and sculpting in an intuitive manner
(cid:15) Evaluation for e(cid:11)ective real-time2 use
(cid:15) Collision detection
(cid:15) Intimidating mathematics
(cid:15) Approximation errors

Since computer graphics and gaming technology are appreciated topics with
most computer science students (and hence, readers of this thesis), these
areas will serve as a guideline for the report.

1.3 Structure of the thesis

Mathematics are fundamental to parametric curves and surfaces, so the re-
port begins with a very thorough explanation of the Bezier and B-spline
curve concepts and the related topics of interest (Hermite curves, for in-
stance). Figures are used extensively to demonstrate and simplify the the-
ories, with some references to the developed thesis application.

Further on, sections on the actual use of curves and surfaces in the real
world followed by some discussion of advantages and disadvantages with the
contemporary representations.

2Around 25 frames per second or above, loosely speaking

10

The vast (cid:12)eld of implementation options are covered at the end of the
thesis, together with some discussions about e(cid:14)ciency, collision detection
and related topics.

1.4 Prerequisites

It is assumed that the reader of this thesis has studied elementary linear
algebra, some multivariate calculus and maybe a dash of computer graphics.
The two latter are not really necessary, but improves the understanding of
the underlying mathematics and theories.

1.5 Software

The software developed for this thesis is a portable OpenGL3 application
that has a graphical user interface written with GLUI4. Supplied with the
thesis are three packages:

(cid:15) Compiled Linux x86 version
(cid:15) Compiled Windows 2000/XP version
(cid:15) Source code tarball5
The software has been tested on Mandrake 8.0, Mandrake 9.0, Windows
2000 and Windows XP. Since both OpenGL and GLUI exist for nearly all
platforms, compiling on other systems should not be a problem. Make sure
to edit the Make(cid:12)le to match your system libraries.

The software itself does not have a very steep learning curve. Click and
drag the control points, toggle di(cid:11)erent display information and curve modes
from the graphical user interface.

1.6 Notation and Typesetting

This report uses standard LATEX. Also, the concept of C x and Gx continuity
levels are used extensively, and should be familiar to the reader as I have
observed no other formats for describing continuity in the realms of computer
graphics.

3Portable graphics library for developing 2D- and 3D applications
4Portable GUI library, built completely on OpenGL
5Common compression format for Unix/Linux, *.tar.gz

11

12

Chapter 2

Bezier curves and surfaces

As mentioned in section 1.1, the Bezier curve was developed in the late
1950’s. We will focus on the cubic polynomial curve since this is the most
used in computer graphics and it is quite easy to extend this case to poly-
nomials of higher degree later on.

We will begin by looking at the Bernstein polynomial evaluation which
provide a so called basis function for Bezier curves. A later section covers
the geometrical equivalent by the de Casteljau algorithm.

2.1 Basis function

A cubic Bezier curve consists of four control points used to position and
modify the curve, P0 through P3. The two intermediate points P1 and P2
are used to specify the endpoint tangent vectors, hence the curve interpo-
lates (passes through) P0 and P3 while approximating the other two control
points. To accomplish this we need some sort of weighting function which
tells us the in(cid:13)uence of the control points at a given point on the curve. One
can use an arbitrary function to suit the requirements but in most cases we
de(cid:12)ne the Bernstein polynomials [1][2]

Bi;n(u) = n

i!ui(1 (cid:0) u)n(cid:0)i

n!

i!(n (cid:0) i)!

(2.1)

(2.2)

or similarly

Bi;n(u) =

ui(1 (cid:0) u)n(cid:0)i

where i is the control point to be weighted and n is the degree of the curve,
to be the basis function. As we can see in (cid:12)gure 2.1-2.3 these polynomials are
symmetric and sum to unity. The resulting Bezier curve is also symmetric,
as can be seen in (cid:12)gure 2.4, hence the evaluation direction does not matter.
Since the understanding of the basis function is crucial to grasp this

report, we will now expand on the topic.

13

The parameter u 2 (0; 1) can be viewed as a particle trying to interpolate
the control points in discrete steps. As it moves along the trajectory, it is
drawn towards control point i by an amount determined by Bi;3(u), in the
cubic case. Without thinking too much about equation 2.1 consider the
following image which illustrates the Bernstein polynomials at degree 1 (the
curve is just a straight line between the control points).

influence

1

0

u

1

Figure 2.1: Basis functions of degree one

At u = 0 the second control point (the dashed line) has zero in(cid:13)uence, but
as we move along 0 (cid:20) u (cid:20) 1 the (cid:12)rst control point looses in(cid:13)uence while the
second gains. The result of this is obviously a straight line between the two
control points. The basis functions used in this (cid:12)gure are B0;1 and B1;1.

influence

1

0

u

1

Figure 2.2: Basis functions of degree two

Figure 2.2 illustrates the case of n = 2, a quadratic polynomial basis func-
tion. The two previous control points get a steeper loss and gain, but never
lose in(cid:13)uence except at the end points. As we shall see later, this enables the
actual Bezier curve to be concave or convex (just as regular second degree

14

polynomials look). The basis functions used in this (cid:12)gure are B0;2, B1;2 and
B2;2.

It is perhaps suitable to mention that there is no local control this far.

Moving one control points a(cid:11)ects the entire curve.

influence

1

0

u

1

Figure 2.3: Basis functions of degree three

Above we see the case of n = 3, a cubic polynomial basis function. This
implies that the curve can behave like any cubic curve and can be both
concave and convex. This is the most comfortable degree, at least according
to regular users, to work with.
If we have n < 3 we do not have much
freedom to work with, and if we have n > 3 the curve becomes hard to
handle since it tends to \take o(cid:11)" where we do not want it to.

It is also important to note that the basis functions always sum to unity.
Anywhere on the (cid:12)gures above, the di(cid:11)erent values of the curves sum up to
one, regardless of curve degree.

2.2 Curve de(cid:12)nition

Now that we are familiar with the Bezier basis functions, here is the de(cid:12)ni-
tion of a Bezier curve of degree n

C(u) =

PiBi;n(u)

(2.3)

nXi=0

To evaluate the curve at u 2 (0; 1) we simply iterate the n+1 control points
and compute the corresponding in(cid:13)uence. This can also be expressed in
matrix form for those more familiar with linear algebra.

(2.4)
where U is a vector of [un; un(cid:0)1; : : : ; u; 1], MB the Bezier basis matrix and
GB is a vector with the n+1 control points. The (cid:12)rst, more analytical

C(u) = U MBGB

15

description, will be used throughout this thesis since it is more suitable
from an implementor’s point of view.

In (cid:12)gure 2.4 we see how the symmetry of the Bernstein polynomials is
re(cid:13)ected in the actual curve. This is also true if we are using the de Casteljau
algorithm (see section 2.7).

From equation 2.3 we discover that no matter the degree of the curve,
there is no local control property. All control points a(cid:11)ect the curve, and
this can be a disadvantage when designing smooth shapes with the Bezier
curve. To remedy this (cid:13)aw we introduce curves made up of several Bezier
segments which is covered in the next section.

Figure 2.4: Curve and control polygon

To sum up this section, above we see a Bezier curve of degree three with
four control points and an outlined control polygon. Notice how the P 0P 1
and P 2P 3 tangents specify the direction at the endpoints. The convex hull
can be illustrated by enclosing a rubber band around the control points,
and this is a fundamental property of the Bezier curve. No matter how we
manipulate the control points, we can always rely on the curve to lie within
the convex hull. This is a useful property that we take advantage of in
collision detection, see section 4.4.

2.3 Curve segments

By concatenating several Bezier curves we can obtain local control. This is
done by sharing the (cid:12)rst and last control point with the surrounding curves.
Obviously, the (cid:12)rst and last segment only share one of these.

16

This will however introduce some discontinuities at the shared control
point. A Bezier curve has C 1 continuity to its de(cid:12)ned interval, but at the
shared vertices we get C 0. Hence, we do not obtain a smooth transition
between segments if we do not create these manually, which can be good or
bad, depending on the application.

For instance, a simple square cannot be created with concatenated C 1
continuous curves unless we introduce a discontinuity at the corners of it,
just as a circle requires smooth transitions and greater continuity.

Figure 2.5: Continuity constraint

Assume we have curves P = P0; P1; : : : ; Pn+1 and Q = Pn+1; Q1; : : : ; Qm+1
of degree n and m respectively. To force continuity between these two curves
we must have tangential continuity between Pn, Pn+1 and Q1. In (cid:12)gure 2.5
we have Pn and Q1 marked with squares while Pn+1 is a circle, which is the
join point of these two curves. The disadvantage with this constraint is that
we loose one degree of freedom in each curve since they become \locked" to
provide the smooth transition.

2.4 Bezier subdivision

If a Bezier curve is not (cid:13)exible enough, we can break the curve at a given
point u0 and create two new Bezier curves that join on u0. An algorithm
for this task was presented by de Casteljau [8], and it uses a geometric
construction technique.

More formally, this involves (cid:12)nding points L0; L1; L2; L3 and R0; R1; R2; R3
so that the Bezier curve formed by L exactly matches 0 (cid:20) u < 0:5 of the
original curve, and R matches 0:5 (cid:20) u (cid:20) 1:0. Since L and R are separate
curves, they are both evaluated locally with 0:0 (cid:20) u (cid:20) 1:0.
Assume that our original Bezier curve consists of P0; P1; P2; P3. We then
construct a point H that divides P0P1, P1P2 and P2P3 in a ratio of (1(cid:0) u0).
This creates a hull with points L0L1L2L3 and R0R1R2R3, and we have two
sets of control points that lie in the hull of the original control points since
L and R are weighted sums of P .

This basically is the de Casteljau algorithm which is covered in section

2.7.

17

2.5 Rational Bezier curves

Rational curves imply that each of the control points are extended with one
coordinate which represents the weight or amount of in(cid:13)uence. A heavy
vertex will draw the curve towards it, and a light vertex (can be negative as
well) will push the curve away.

This is of great importance when designing curves on the computer
Instead of dragging the control point

screen, which has a limited area.
far away, perhaps outside the canvas, we can simply increase the weight.

The extension does not require much calculation and we now have:

C(u) = Pn
Pn

i=0 wiPiBi;n(u)
i=0 wiBi;n(u)

(2.5)

where wi is the weight of Pi. Both sums can be calculated within the same
iteration of the control points, so for very little processing time we obtain a
curve which is far more useful.

2.6 Bezier surfaces

The Bezier surface is simply an extension of the Bezier curve in two para-
metric directions, a tensor product of two curves. It is evaluated through

C(u; v) =

nXi=0

mXj=0

Pi;jBi;n(u)Bj;m(v)

(2.6)

where the parametric directions have degree n and m respectively, though
it is often the case that n = m. This yields (n + 1) (cid:3) (m + 1) control points.
Equation 2.6 suggests that the control points are stored in a matrix, but
this must not necessarily be true since the order of which they are evaluated
is irrelevant to the result.

C(u; v) = Pn
i=0Pm
Pn
i=0Pm

j=0 wi;jPi;jBi;n(u)Bj;m(u)

j=0 wi;jBi;n(u)Bj;m(u)

(2.7)

Equation 2.7 looks intimidating, but is simply the evaluation of a rational
surface, which is totally analogous to the case of one parametric direction.
Regarding surface concatenation, we often apply the same constraints as

discussed in section 2.3, but this time in two parametric directions.

Figure 2.6 shows a tessellated1 view of a cubic Bezier surface.

1After polygons have been constructed

18

Figure 2.6: Bezier surface

2.7 The de Casteljau algorithm

As mentioned in earlier parts of the report, de Casteljau came up with a
geometrical algorithm (or rather, an algorithm that we can interpret geo-
metrically) which solves for any point on a Bezier curve of any degree.
In (cid:12)gure 2.7 we see how the algorithm solves for u = 0:5 in a cubic Bezier
curve by subdividing the control points by a ratio of 1(cid:0) u. That is, we draw
a hull between lines P0P1 (cid:3) 0:5, P1P2 (cid:3) 0:5 and P2P3 (cid:3) 0:5 and continue in
the same manner with the new \control points’. Since the curve is of degree
3 we stop here and we have found our curve value. The same procedure
applies to any degree but with di(cid:11)erent recursion depth, and is of course
extendable to any u 2 (0; 1).

This algorithm can also be represented as a triangular scheme, starting

with four control points and eventually reducing them to a single point.

P0
P1
P2
P3

B0
B1
B2

C0
C1

D0

The math behind this scheme is obvious if we have the geometrical interpre-
tation (see (cid:12)gure 2.7) Another common representation is to de(cid:12)ne a recur-
rence relation for the de Casteljau algorithm. This also yields a triangular
scheme, but we express it as an equation.

19

Figure 2.7: Illustration of de Casteljau’s algorithm

Let P0;j be Pj for j = 0; 1; : : : ; n where n is the degree of the curve,

i = 1; 2; : : : ; n and j = 0; 1; : : : ; n (cid:0) i. Point Pi;j is then computed as

Pi;j = (1 (cid:0) u)Pi(cid:0)1;j + uPi(cid:0)1;j+1

(2.8)

2.8 Real-time aspects

2.8.1 Computation

The Bezier curve is very cheap to evaluate even with a very small (cid:1)u2. The
(cid:1)u need not be uniform, but can be increased on (cid:13)at intervals with criteria
from the control polygon.

The most common way to enhance a surface is to render it with di(cid:11)erent
types of illumination or even ray-tracing, and these operations require a lot
of processing time compared to the actual evaluation of surface coordinates
and polygon tessellation. This huge topic is covered in many other reports
and books [3][4], and does not get much room in this report.

2The di(cid:11)erence between one point of evaluation and the next

20

2.8.2 Sculpting

A decent editor for Bezier curves and surfaces should allow options of de-
gree and weight together with automatic C 1 continuous concatenation when
adding new segments. In the case of surfaces we also need facilities for in-
tuitive rotation and, as already mentioned, options for di(cid:11)erent types of
tessellation, shading and other visual attributes.

In some modes of the thesis application, only the control polygon is
drawn in real-time while manipulating the control points, since it requires
too much computation to update the rendered surface continuously. This
provides a rough sketch of the resulting object which is rendered once the
updating stops. Another way to reduce the workload is to only render the
object in its mesh form3.

One can argue that a slow rendering frequency does not a(cid:11)ect the actual
curve or surface, which in fact it does not, but that is a topic of discussion
elsewhere.

Another interesting aspect is that the computer screen is two-dimensional
which complicates the editing of surfaces (or three-dimensional curves). We
(cid:12)rst have to project the curve or surface to screen space (two-dimensional),
where we manipulate the control points with the mouse. Once done, we
project the control points back to computation space (three-dimensional).

Of course, the surface can be rotated and hence manipulated implicitly
in three dimensions, but this still poses a problem since it is very hard to
determine the depth value without good visual depth cues4.

2.9 Summary

To sum up this chapter, here are a few key properties of the Bezier curve
that are good to remember in the chapters to come.

(cid:15) Polynomial curve
(cid:15) Evaluation by Bernstein polynomials, de Casteljau
(cid:15) Number of control points and degree are dependent
(cid:15) Convex hull property
(cid:15) Interpolation of (cid:12)rst and last control point
(cid:15) Geometric operations on control points apply to the entire curve.

3No coloring or processing of polygons after tessellation
4Familiar object reference, shading, focus, blocking and so forth.

21

22

Chapter 3

B-spline curves and surfaces

In the last section we discovered some serious drawbacks with Bezier curves
and surfaces

(cid:15) No real local control
(cid:15) Strict relation between curve degree and number of control points

These (cid:13)aws are overcome with the B-spline curve and its bi-parametric ex-
tension, which this section will try to explain.

3.1 Comparison to Bezier curves

A B-spline curve of degree m with n control points consist of n (cid:0) m Bezier
curve segments. These segments all have C 2 continuity at the join points.
For instance, a cubic curve (degree 3) with 10 control points has 7 segments.

Any Bezier curve of arbitrary degree can be converted in to a B-spline
(see section 3.4 on the basis function similarity) and any B-spline can be
converted in to one or more Bezier curves.

In its unwound form, B-splines do not interpolate any of its control
points, while the Bezier curve automatically clamps its endpoints. However,
B-splines can be forced to interpolate any of its n control points without
repeating it, which is not possible with the Bezier curve.

In general it can be stated that the B-spline curve requires more com-
putation, but is far more (cid:13)exible and pleasing to work with, which is the
reason why it has become part of almost every serious graphics development
environment.

The only real drawback compared to the Bezier curve is that the under-

lying mathematics can be quite troublesome and intimidating at (cid:12)rst.

23

3.2 Knots

As explained in the previous section, a B-spline curve consists of segments.
The join point between these segments are called knots, and play a funda-
mental role in the understanding of this kind of curve. In the cubic case
we have n + 4 knot values and in the general case n + m + 1, which are
commonly stored in a knot vector. This relationship will become clear over
the next couple of sections.

The knot vector is used to specify values in the evaluation interval where
the curve changes segment. By spacing the n + m + 1 intervals with equal
distance we obtain a uniform B-spline curve, while an uneven spacing yields
a non-uniform B-spline curve.

Figure 3.1: Uniform B-spline curve

Figure 3.1 shows a uniform B-spline curve of degree 3 and with 10 control
points, hence we have 7 segments which are joined with C 2 continuity. The
uniform part of this curve is that the distance between a knot value and the
next is equal.

Q3

Q7

Q8

Q4

Q6

Q5

Q9

Figure 3.2: Knots and segments

24

Segment
3
4
5
6
7
8
9

Control points
0 1 2 3
1 2 3 4
2 3 4 5
3 4 5 6
4 5 6 7
5 6 7 8
6 7 8 9

In the table above we can see how the local control property is obtained with
B-spline curves. The uniform knot vector for this curve is [0; 1
14 ; 1].
The reason why the segment numbering begins at 3 will become clear once
we look at the basis functions and their evaluation in the next section.

14 ; : : : ; 13

14 ; 2

By changing the values of the knot vector we make parametric segments
shorter or longer, and this is one of the biggest advantages of the B-spline
curve (see (cid:12)gure 3.2).

The easiest way to demonstrate this technique is to \clamp" the end-
points by changing the knot vector to [0; 0; 0; 0; 4
14 ; 1; 1; 1; 1]. This
transforms the (cid:12)rst and last segments to single points which forces the curve
to interpolate the endpoints ((cid:12)gure 3.3)

14 ; : : : ; 10

14 ; 5

Figure 3.3: Non-uniform B-spline curve with clamped endpoints

This is the most common way to manipulate the knot vector, but of course
we can clamp any point p 2 (0; 1). By doing this, we create a discontinuity
at that particular point.
In this example, a double knot reduces the continuity to C 1 and a triple
knot to C 0. The number of repeated knot values are often referred to as the

25

multiplicity of the knot.

Here we encounter another clever feature of the B-spline curve; several
disjoint segments can be made from one knot vector and a set of control
points by introducing discontinuities.

3.3 B-spline basis functions

When constructing a uniform B-spline curve the basis functions are trans-
lates of each other, yielding a very simple basis function. To complicate
things we have to consider the non-uniform case, where the knot values are
not equally distant from one another and this is not a very simple task.

Below we (cid:12)nd the Cox de Boor algorithm, which can recursively com-
pute the basis functions to any uniform or non-uniform B-spline curve of
degree n. The knot values with corresponding index is denoted ti and i is
the control point to evaluate.

Bi;1(t) = 1:0 if ti (cid:20) t (cid:20) ti+1, else 0.0
Bi;2(t) = t(cid:0)ti
ti+1(cid:0)ti
Bi;n(t) = t(cid:0)ti

Bi;1(t) + ti+2(cid:0)t
ti+2(cid:0)ti+1

ti+n(cid:0)1(cid:0)ti

Bi+1;1(t)

Bi;n(cid:0)1(t) + ti+n(cid:0)t
ti+n(cid:0)ti+1

Bi+1;n(cid:0)1(t)

This algorithm is similar to the de Casteljau algorithm covered in chapter
1 but is more general since we can keep the abstraction level on the entire
curve instead of individual segments. Here we also see the need for having
n + m + 1 control points.

influence

1

0

u

1

Figure 3.4: Cubic with clamped end points, Cox de Boor

By clamping the knot vector on a curve with degree 3 we obtain the same
graph of in(cid:13)uence as we did with the cubic Bezier basis function. If we have

26

greater multiplicity on some knot elsewhere, the graph will peak there.

3.4 B-spline formulation

There are a couple of di(cid:11)erent ways to describe a B-spline curve. In its most
basic form it looks just like the Bezier formulation.

W m(u) =

nXi=0

PiBi;m(u)

(3.1)

where P is the control point vector, B the basis function, n the number
of control points and m the degree of the curve. Equation 3.1 is simple to
understand, and uses the fact the B will automatically return 0 if the control
point being evaluated is \out of reach" of u.

This is however not very e(cid:14)cient since we for every u must evaluate the
basis function for every Pi. In the cubic case we only need to know m+1 = 4
relevant control points since an arbitrary point u is never a(cid:11)ected by more
than so many. This topic will be expanded on in coming sections of the
report.

3.4.1 NURBS

The term NURBS stands for Non-Uniform Rational B-Spline and is the
most common way to model curves and surfaces in computer graphics [5],
hence it deserves a topic by itself in this report.

Figure 3.5: NURBS curve, wi = 1:0 for all i

27

Just as with Bezier curves, a rational curve means that we extend the
control points by one coordinate that will represent the weight, or attrac-
tion/repellation, of that particular control point.
In (cid:12)gure 3.5 we see a
NURBS curve where all control points are assigned weight 1.0, which is the
default \weight-less" value.

This can be seen by inspection of the NURBS formulation (equation 3.2)

as wi = 1:0 does not modify any calculations or results.

Figure 3.6: NURBS curves, w7 = 1:0, w7 = 15:0 respectively

In (cid:12)gure 3.6 we see what happens when we increase or decrease the weight.
If we increase the weight enough, the curve will interpolate and eventually
pass through P7.

It should also be noted that an increase or decrease in wi does not a(cid:11)ect
the C 2 continuity, though it may introduce some sharp corners when viewed

28

with poor detail or a large (cid:1)u.

This type of rational extension can cause the curve to violate the convex
hull property1, which may be of computational interest in collision detection,
for instance. This is computationally handled so that the weight can only
span, say, (0:8; 20:0)

Another interesting fact is that around wi = 20:0 the curve interpolates
Pi, which is perhaps more intuitive than to modify the knot vector for inter-
polation. The interested reader should observe Phantom vertices, discussed
in [11], which is another method of forcing vertex interpolation.

W m(u) = Pn
Pn

i=0 wiPiBi;m(u)
i=0 wiBi;m(u)

The rational mathematic extension is analogous to that of Bezier curves
and produces no computational di(cid:14)culties, and in equation 3.2 we see the
famous NURBS formulation which probably is the most popular curve in
computer graphics to this date.

(3.2)

Figure 3.7: NURBS surface, 6x4 control points

1The curve should lie within the area enclosed by all control points

29

3.5 NURBS surfaces

If we extend equation 3.2 in two parametric directions we obtain a surface
with the same properties as the NURBS curve. This equation is not pleasant
to the eye in its mathematical form, but in its rendered.

i=0Pt
W m(u; v) = Pn
Pn
i=0Pt

j=0 wiPiBi;m(u)Bj;m(v)
j=0 wiBi;m(u)Bj;m(v)

(3.3)

The surface does not have to be of equal degree in both directions, but
to keep things more understandable we settle for this now. Observe the
surface in its rendered form in (cid:12)gure 3.7 where we clearly see the local
control property.

By evaluating this equation we obtain a surface with local control, one
knot vector in each parametric direction and with rational properties; vir-
tually anything one could wish for when modeling a surface.

It goes without saying that Bi;m(u) uses the knot vector u and Bj;m(v)

the knot vector v.

3.6 The de Boor algorithm

For the B-spline curve we also have a geometrical way to display the calcu-
lations, which is an extension of the de Casteljau algorithm covered in the
previous chapter for Bezier curves. It is called the de Boor algorithm, and
should not be confused with the Cox de Boor algorithm described earlier.

The only di(cid:11)erence is that we for a point u must determine which m + 1
control points that a(cid:11)ect it, and there after apply the de Casteljau algorithm
to that segment. See (cid:12)gure 2.7 for the geometrical interpretation.

This is not a hard operation since we have a co-relation between the knot

and control point vectors.

In (cid:12)gure 3.8 we see how the de Boor algorithm would evaluate u = 0:4.
Assume we have a knot vector [0; 0; 0; 0; 0:25; 0:5; 0:75; 1; 1; 1; 1] and seven
control points. In the (cid:12)gure we see the control polygon of these.

The point u = 0:4 lies in [0:25; 0:5] and hence the control points a(cid:11)ected
are P 1; P 2; P 3; P 4. We remind ourselves that the curve formed by these
points is a Bezier segment and apply the de Casteljau algorithm to calculate
the point.

30

Figure 3.8: de Boor algorithm, cubic curve

Since the de Boor algorithm is very similar to the de Casteljau algorithm,

we can in analogy with equation 2.8 also express it as follows:

For every segment S, let P0;j be Pj for j = 0; 1; : : : ; n where n is the
degree of the curve (and hence, the degree of an individual segment), i =
1; 2; : : : ; n and j = 0; 1; : : : ; n(cid:0) i. Point Pi;j on segment S is then computed
as

Pi;j = (1 (cid:0) u)Pi(cid:0)1;j + uPi(cid:0)1;j+1

(3.4)

3.7 Real-time aspects

3.7.1 Computation

As mentioned before, a B-spline curve or surface can be quite expensive
to calculate, especially in the non-uniform case. One method that provides
faster calculations is if we force the knot values to ui(cid:0)ui+1 = 1 or ui(cid:0)ui+1 =
0. This way the Cox de Boor algorithm can be computed o(cid:15)ine 2 and stored
in matrices for fast evaluation, hence it must not be evaluated for every curve
segment unless we change the knot vector.

2Before visual execution

31

In section 3.4 we brie(cid:13)y discussed the fact that each segment only re-
quires input from m + 1 control points, four in the case of a cubic curve. By
evaluating the curve through segments we can avoid to include every control
point in the calculations.

Say we have knot vector t and wish to evaluate a cubic B-spline with
a control point vector P . We denote the basis function B with arguments
degree, control point and parameter value, in that order.

for i:=3 to sizeof(P):

for u:=t[i] to t[i+1]:

result := 0
result += P[i-3] * B(3,i-3,u)
result += P[i-2] * B(3,i-2,u)
result += P[i-1] * B(3,i-1,u)
result += P[i-0] * B(3,i-0,u)
plot result

end for

end for

This is pseudo-code of the main loop of a B-spline curve evaluation, and it
shows how we can avoid unnecessary computation.

Since the B-spline curve can be represented in matrix form, it can also
be wise to take advantage of fast matrix multiplication algorithms, or use
software like Matlab or Maple as modules for the multiplications.

As mentioned in the previous chapter we can vary (cid:1)u with B-splines as
well, by inspecting the slope of Pi and Pi+1. A (cid:13)at section of the curve does
not need the same resolution as a heavily curved one.

3.7.2 Sculpting

Most properties from Bezier sculpting carry over to the B-spline. The new
thing that we have to consider is the editing of the knot vector(s).

If the GUI (Graphical User Interface) supports input of vectors or strings,
it is quite common to display an editable strip of text where the knot values
can be edited with the keyboard.

A more re(cid:12)ned method is to project the knot values to a line or plane
that lies below the curve or surface, where the user can manipulate the
values by dragging the projected icons in the (cid:12)xed parametric directions,
which is perhaps the most intuitive way to modify the knot vectors.

Knot multiplicity is also a detail to consider, as the software must allow

insertions of several knots at the same coordinate

32

3.8 Knot insertion and deletion

If the B-spline curve is not (cid:13)exible enough we resolve to a technique known
as knot insertion. Since the size of knot vector t and control point vector P
is related, the idea behind this concept is to add one or more control points
without modifying the shape of the curve, thereby obtaining a knot vector of
greater size and (cid:13)exibility. The reason for this is the fundamental property
that m = n + p + 1, where m and n are the sizes of the control point vector
and knot vector respectively, and p is the degree. As mentioned earlier, a
cubic curve with 7 control points has 3+7+1 = 11 knot values, for instance.
Assume for the following knot insertion that we have our original control
points P0; P1; : : : ; Pn and wish to (cid:12)nd Q0; Q1; : : : ; Qn; Qn+1 which produces
the same curve of degree p.

Figure 3.9: Before and after knot insertion

33

To the knot vector T we wish to insert a knot at u, where the value of u is
in the knot vector interval [Tk; Tk+1]. Since only a part of the curve is a(cid:11)ected
by this operation, we only need to consider control points Pk; Pk(cid:0)1; : : : ; Pk(cid:0)p
which are the ones that are involved in the calculation of [Tk; Tk+1].

Now that we have the necessary facts we can calculate point Qi which

is in between original control points Pi(cid:0)1 and Pi by

Qi = (1 (cid:0) ai)Pi(cid:0)1 + aiPi , where
ai = u(cid:0)ui
ui+p(cid:0)ui

for k (cid:0) p + 1 (cid:20) i (cid:20) k

which indeed is a very simple and fast calculation. Notice the similar-
ities to the de Casteljau and de Boor algorithms. Geometrically speak-
ing, the control polygon is una(cid:11)ected over the entire curve except between
Pk; Pk(cid:0)1; : : : ; Pk(cid:0)p. This method naturally works for inserting knots at ex-
isting values with any multiplicity, but this is more e(cid:14)ciently done with the
Oslo algorithm [6] which can insert several knots in one operation.

The reverse operation, the deletion of a knot, requires deletion of a con-
trol point and hence it does not preserve the shape of the curve. See [7] for
further reading.

In (cid:12)gure 3.9 we see how the exact same curve can be represented by a
di(cid:11)erent amount of control points. Here we have inserted a knot at u = 0:8,
on the right half of the curve. This will provide us with greater local control,
and can be repeated if necessary.

3.9 Concatenation

There are algorithms for merging both B-spline curves and patches. The
simplest way to a accomplish a concatenation is to simply create a new
larger curve or patch which contain all the control points, but since we in
most cases work with clamped end points we can apply the same technique
as shown for Bezier curves in the previous chapter. That is, to introduce
a continuity constraint between the last and (cid:12)rst couple of points on each
curve.

3.10 Other spline forms

So far we have covered a few of the most common types of curves and
surfaces. In this section we look at some other useful types that aid us in
common computer graphics tasks.

34

3.10.1 Natural spline

A natural spline is the real-life model of the spline curves used in computer
graphics. They are strips of (cid:13)exible metal (aluminum, for instance) that are
C 2 continuous, but they do not posses local control. Moving one control
point a(cid:11)ects the entire curve.

3.10.2 Hermite curves

The Hermite curve, named after Charles Hermite, is similar to the Bezier
curve where we specify two endpoints and two other points to determine
the tangents and these endpoints. However, it uses a di(cid:11)erent set of basis
functions and behaves di(cid:11)erently, see (cid:12)gure 3.10. It also interpolates all of
its control points, but does not have a convex hull property.

Influence

1

1

Figure 3.10: Cubic Hermite basis functions

3.10.3 Catmull-Rom splines

The Catmull-Rom splines [12], also called Overhauser splines [13], is a set
of splines that interpolate all or most of their control points, hence this
is a very common type of parametric curve that we use to model exact
representations.

The downside to this type of parametric curve is that it does not posses
the convex hull property, which complicates some applications (collision de-
tection, for instance).

35

3.10.4 Uniformly shaped (cid:12)-spline

This type of curve works like a B-spline curve but with two new variables in
the calculations called bias and tension. In addition to the rational exten-
sion, we now have two further \weights" to modify our curve which provide
a higher degree of (cid:13)exibility. It should be noted that these two parameters
are not exclusive to each control points, but are de(cid:12)ned globally. The curve
was presented by Barsky and Bartel [10][11].

The only problem with this spline is that it is only C 0 continuous at
the segment join points (knots). This complicates some of the applications
involving movement discussed in the next chapter. As with the Catmull-
Rom spline, the (cid:12)-spline does not have a convex hull property, neither does
it have local control.

3.11 B-spline summary

Presented below are a few key terms to remember regarding B-spline curves
and their use.

(cid:15) Local control
(cid:15) No relation between degree and number of control points
(cid:15) Knot insertion and the knot vector
(cid:15) Uniformity and non-uniformity
(cid:15) de Boor algorithm
(cid:15) Cox de Boor algorithm
(cid:15) NURBS

36

Chapter 4

Applications

The need for curves and surfaces is very obvious, and here we will cover at
least some areas of application where they are used extensively.

4.1 Camera movement

One of the (cid:12)rst areas in 3D computer graphics to be exploited by polynomial
curves was the non-linear movement of a camera or object through a virtual
environment.
If we create a linear path between some key positions the
camera will be jerky in its movements. By interpolating the path with a
spline curve we obtain a smooth curve which (cid:12)ts the task perfectly.

Within the spline data-type we can also store rotation, acceleration and
other properties at certain key points, still with very small storage require-
ments.

Figure 4.1: Key rotations on a spline

Above we have a spline with certain key positions that contain a vector of
direction. In an o(cid:11)-line operation we interpolate between these key rotations
by, for instance, spherical interpolation, and simply store the results along

37

the curve. In these key positions it is also common to store an increase or
decrease in acceleration, camera zoom, lens properties and so forth.

Put shortly, the spline curve is a necessary tool for creating nice camera

movements without having to do frame-by-frame animation.

4.2 Topologies

In visualization software we often need to model topologies of di(cid:11)erent types.
In computer games we crave natural-looking bodies, faces and level surfaces
for our characters to travel on. This is not seldom done by using NURBS
surfaces, which provide excellent control both for smooth and sharp surfaces.
Here we can bene(cid:12)t from the non-discrete property that allows for dif-
ferent resolutions depending on the application. We can compute a polygon
mesh of rough size for the physics while computing a (cid:12)ner resolution for the
visual output by using the same set of control points.

Figure 4.2: Game level side-view

Figure 4.2 shows how we can create a simple jump in a racing game by using
disjoint segments in one spline (done through the knot vector) or by using
several splines.

This method of level creation is extremely useful when modeling a virtual
version of a real scenario. Prior to implementation we can measure the
topology of the real racing track (or whatever it is we model), scale these
points to the virtual world and use them as control points to a NURBS
surface.

Another common method for building tracks is to use a NURBS curve

and to specify tilt, yaw and pitch1 at the key points (see (cid:12)gure 4.1).

Both of the explained methods provide very intuitive sculpting, both
for developers and end users wanting to create their own levels. Thus it is

1Common descriptors for specifying rotation and orientation

38

not hard to realize why the NURBS curve have become so popular in game
design over the last couple of decades.

Speaking of surface (cid:12)tting, this is also a much used model for creating
virtual versions of real characters. We scan the topology of the human face
and adapt the results as control points in a NURBS surface, but often this
needs \tweaking" since the surface does not interpolate all of its control
points.

4.3 Character movement

If we gaze back at the amusement applications developed during the early
1980’s we often see that characters move in straight lines, or even in (cid:12)xed
directions (up, down left, right). As soon as the processing power of com-
puters started to elevate, developers began to use curve interpolation and
approximation to get smooth movements.

If we combine key points on NURBS curves, good-looking rotational
interpolation (spherical interpolation, for instance), inverse kinematics2 and
random movements (behavioral noise) we basically have today’s concept for
creating decent character translocation.

Specifying paths of movement through splines have several advantages.
If the spline passes through an obstacle we modify the curve to obtain a
smooth motion around it, a very fast operation which can be done in real-
time. For instance, if we want an object to move between point A and B
we (cid:12)rst create a straight line (spline) and try it for intersection with other
objects in the scene, which is a cheap operation (see chapter 4.4).
If it
collides with anything we manipulate the curve.

In racing games we perhaps have the last 3-4 recorded locations of an
adversary player. Once we receive a new location (control point) we create
a spline path with these points and obtain a smooth non-linear motion.

4.4 Collision detection

The basic problem behind the topic collision detection is to determine when
objects collide, with as little processing power as possible, while maintaining
a solid behavior.

This is a huge topic by itself and we will concentrate on the advantages
of using parametric representations for curves and surfaces and how to use
them in an interactive application.

To start things o(cid:11), we have a couple of primitives that are used exten-
sively in collision detection. These consist of planes, spheres, lines and so
forth. The idea is to encapsulate or compose an object with these primitives

2Popular way to animate movement through bone structure

39

so that an intersection between two primitives can be determined quickly.
There are rapid algorithms for most combinations such as sphere-line, box-
plane and plane-line which we will use to make a bounding primitive collision
detection between objects.

Figure 4.3: Di(cid:11)erent resolutions

In an o(cid:11)-line process we read the control points and create two versions of the
surface, one with the visual output resolution and one with resolution suited
for the collision detection engine. In (cid:12)gure 4.3 the control points remain in
the same position but we tessellate the surface at di(cid:11)erent resolution.

This tactic is often combined with a tree structure. In this tree we break

40

the surface in to several hierarchic bounding volumes where every vertex
except root and leafs have volumes as parent and children. See picture 4.4
below.

Figure 4.4: Bounding volumes

This is a classical technique for eliminating the need for unnecessary calcula-
tions. First we try the collision with the top volume. If it does not intersect,
we can abort with only a few calculations \wasted". If it does, we traverse
down the tree and repeat the process.

This tree can be computed o(cid:11)-line and the only di(cid:14)culty is to anticipate
the depth of the tree, which is very dependent on the application. If this
surface is a (cid:13)ag that we drive by at high speed, we may only need the two
top levels. One the other hand, it could be part of something that is closely

41

inspected by the user, say a piece of paper with clues in an adventure game.
In the latter case we usually want to make the volumes such that grouped
polygons lie approximately in the same plane or box, so that we can use
documented intersection algorithms that solve very quickly.

One should observe the discussion in earlier topics about using adap-
tive subdivision, but now applied to the low-resolution surface. By using
this technique wisely and checking for (cid:13)atness criteria we can save tremen-
dous amounts of processing power for other important tasks. Since half of
the game developer’s work consists of clever tricks and cheats for greater
performance, we often trade a little bit of accuracy for fewer collision com-
putations, in a case like this.

This tree-structure technique is of course also applicable to curves where

we create bounding boxes to snare smaller and smaller parts of the curve.

4.5 Soft objects

A very tricky subject in the realms of physics and computer graphics is to
model good-looking cloth, blankets and other soft deformable objects. Often
we get a good result by suspending a surface with a number of springs that
we use to calculate the resulting forces. These forces can then be applied to
the surface control points. In (cid:12)gure 4.5 a spring is attached to every control
point.

Figure 4.5: Bezier surface with springs

42

4.6 Automatic LOD

LOD (Level Of Detail) determines how detailed a particular object is. An
oft-used trick that developers use is to render several versions of an object
o(cid:11)-line. This object can be a picture, model, surface or anything with
a polygonal representation. As the camera moves closer to the object, we
switch between di(cid:11)erent levels of LOD. A close-up of the object may contain,
say, 500 polygons while a very distant view only contains (cid:12)ve.

This is very similar to the technique described in section 4.4, see (cid:12)gure

4.6 below.

Figure 4.6: Bezier patch, di(cid:11)erent LOD

There are several topics to expand on regarding LOD computations, and
these concern how the transition between di(cid:11)erent resolutions is made. The
important aspect here is that we acknowledge the power of a parametric
representation.

However, if we do not have a parametric representation available, there
are other techniques generally known as imploding, where we reduce the
number of polygons by some set of rules involving the distance to the viewer.

4.7 Object modeling

One last topic that should be mentioned is the ability to create in-game
objects, which is a very common application. This is often done in 3D
modeling software but can be done within the executing applications as
well.

Consider the look of a curved door passage in an ordinary computer
game. There is a large possibility that the frame of this door is done by a U-
shaped spline that is tessellated with a certain thickness and then textured.
Another great example are vines, which must be the most suited thing
to model with a spline or Bezier curve, since they by de(cid:12)nition respond very
similar to their real aliases.

43

A very famous example of the power of parametric surfaces is the \Utah
teapot" which is, like the name implies, a virtual model of a teapot and
was one of the (cid:12)rst real objects to be replicated with surface patches. By
using a few Bezier- or even fewer B-spline surfaces we can construct a very
realistic teapot. Consider the polygonal mesh version that requires at least
a couple of hundred de(cid:12)nition points while the parametric version does the
same job with considerably fewer points (say, 40-50). Add to that the non-
discrete property that allows us to change the resolution just by changing
the evaluation interval.

44

Chapter 5

Implementation

This chapter will deal with topics that emerged while developing the thesis
application and some interesting areas of research that are connected to the
actual implementation.

5.1 Simple evaluation

So far we have described the evaluation of curves and surfaces as a \brute
force" task where we set an interval (cid:1)u and evaluate the curve accordingly.
This is common but not very e(cid:14)cient since the shape varies over the pa-
rameter interval.
It may be completely (cid:13)at, only to make a short peak
somewhere, and that is a waste of processor time.

5.2 Forward di(cid:11)erence

Most computer scientists and mathematicians have encountered the evalua-
tion method forward di(cid:11)erence, which is one way to adapt (cid:1)u according to
some given criteria, in this case (cid:13)atness of the curve.

The forward di(cid:11)erence (cid:1)f (t) of the function f (t) is given by

This we can write as

(cid:1)f (t) = f (t + (cid:14)) (cid:0) f (t)

fn+1 = fn + (cid:1)fn

(5.1)

(5.2)

where f is evaluated a uniform interval with size (cid:14). For a cubic polyno-
mial, which is the most common degree for parametric curves and surfaces,
we have

f (t) = at3 + bt2 + ct + d

(5.3)

so the forward di(cid:11)erence becomes

45

(cid:1)f (t) = a(t + (cid:14))3 + b(t + (cid:14))2 + c(t + (cid:14)) + d (cid:0) (at3 + bt2 + ct + d)
To further ease the computation we can now apply the same technique

(5.4)

to (cid:1)f (t). Equation 5.2 and 5.4 now gives us

This yields

or similarly

(cid:1)2f (t) = (cid:1)f (t + (cid:14)) (cid:0) (cid:1)f (t)
(cid:1)2f (t) = 6a(cid:14)2t + 6a(cid:14)3 + sb(cid:14)2

(cid:1)2fn = (cid:1)fn+1 (cid:0) (cid:1)fn

(cid:1)fn = (cid:1)fn(cid:0)1 + (cid:1)2fn(cid:0)1

(5.5)

(5.6)

(5.7)

(5.8)

Since we in this example are working with cubic polynomials the last
and third forward di(cid:11)erence will be a constant, and we calculate it just as
shown above. In summary we know have

fn+1 = fn + (cid:1)fn

(cid:1)fn = (cid:1)fnn (cid:0) 1 + (cid:1)2fn(cid:0)1

(cid:1)2fn(cid:0)1 = (cid:1)2fn(cid:0)2 + 6a(cid:14)3

This may seem a bit much just for calculating a line segment, but we
have now reduced the calculations per 3D point from ten additions and
nine multiplications to just nine additions, if we use the Bezier curve as an
example. Though, we have to calculate the initial conditions when using
forward di(cid:11)erence, but this only has to be done once.

5.3 Recursive subdivision

Another method for improved e(cid:14)ciency is to use a recursive subdivision
technique as suggested in earlier chapters of the report. This is best ex-
plained in pseudo-code.

Draw(CURVE c, ERROR e)

if(Straight(c,e))

then DrawLine(curve)

else

46

SubdivideCurve(c, leftCurve, rightCurve)
draw(leftCurve,e)
draw(rightCurve,e)

end if

end draw

This Divide-and-Conquer algorithm is simple to implement and halts
when the divided curve segment (if any) is (cid:13)at enough to be drawn as a
straight line. This test can be, for instance, the quadratic area enclosed
by the curve end points, the area beneath it or the angle between the end
points.

5.4 Look-up tables

Look-up tables are often used when we know the evaluation resolution of a
function. In games we most often create them for trigonometric functions,
but we can use them for parametric curves and surfaces as well. For each
control point, we build a table that holds indices to the basis function return
value at each interval. When we show or manipulate the surface in real-time,
we never have to access the cumbersome weighting functions.

As the tables can be come quite large, the trade-o(cid:11) associated with
this trick is storage size. Usually, processor time is of more value than the
memory usage, so it is very common that we implement this feature.

5.5 Portability

As claimed earlier in the report, portability is one of the strongest features
of parametric curves and the algorithms that deal with them. If we combine
this fact with an object-oriented approach we get a class that can be very
general. Consider the class diagram1 (cid:12)gure below which is based on the
Fly3D graphical engine.

1Common way for displaying class hierarchy and content

47

Figure 5.1: Bezier class diagram

This is a basic class that holds all the algorithms and functions needed for
a Bezier curve evaluation. All functions are platform independent, with a
minor exception for the load bez function because (cid:12)le reading can di(cid:11)er on
some platforms. What each function does and what each variable holds
should be of no di(cid:14)culty to understand.

Similar classes are easily done for B-spline curves and surfaces, with ad-
dition of the knot vector operations and algorithms. The only thing needed
to display (if that is our goal) the curve is a plotting function, which often
varies over di(cid:11)erent platforms.

5.6 Implementation comparison

In this section we shall look at a few comparisons between di(cid:11)erent imple-
mentations and how well they scale. The test involves the calculation of
a typical curve with di(cid:11)erent resolutions, and the time is measured with a
system pro(cid:12)ling tool.

It should be noted that the tests use a system-wide clock, which is not
devoted to one process only. The values are averages of three separate
sessions.

Following each chart is a short text that discusses the di(cid:11)erences ob-

tained and why they occurred.

48

s
d
n
o
c
e
S

 10

 9

 8

 7

 6

 5

 4

 3

 2

 8

Bezier evaluation: Simple vs. Forward Difference, 1000 iterations

Simple
Fw. diff

 10

 12

 14

 16

 18

 20

Resolution x 1000

Figure 5.2: Simple evaluation vs. Forward di(cid:11)erence

As explained earlier in the report, the forward di(cid:11)erence method reduces
the amount of calculations needed per 3D point from ten additions and nine
multiplications to just nine additions. This can be clearly seen in (cid:12)gure 5.2.

49

s
d
n
o
c
e
S

 24

 22

 20

 18

 16

 14

 12

 10

 8

 6

 4

 10

Bezier: Bernstein vs. de Casteljau evaluation, 1000 iterations

Bernstein
de Casteljau

 15

 20

 25

 30

 35

 40

 45

 50

Resolution x 1000

Figure 5.3: Bernstein polynomials vs. de Casteljau

The only di(cid:11)erence between these two is the theoretical view; the de Castel-
jau algorithm is interpreted geometrically while the Bernstein polynomials
are handled analytically. They contain the same number of multiplications,
compute the same points, but as mentioned in the introduction their his-
tory is quite di(cid:11)erent. In the end, it comes down to which is more easy to
implement. The small local di(cid:11)erences are visible in (cid:12)gure 5.3.

50

NURBS: de Boor vs. Cox de Boor, 1000 iterations

de Boor
Cox de Boor

 35

 30

 25

 20

 15

 10

 5

s
d
n
o
c
e
S

 0

 10

 20

 30

 40

 60
 50
Resolution x 100

 70

 80

 90

 100

Figure 5.4: de Boor vs. Cox de Boor

As mentioned in chapter 3, the Cox de Boor algorithm is not optimized
\by default". We have to extend it so that it does not include unnecessary
control points, and also it helps to force successive knot values to zero or one.
That enables us to store a small number of matrices that are computed o(cid:11)-
line for fast on-line evaluation. Figure 5.4 shows two common methods for
evaluating B-spline curves. It was included to demonstrate the importance
of clever algorithms. The actual modi(cid:12)cations to the Cox de Boor algorithm
are not very hard to implement.

The Cox de Boor graph was only tested up to a resolution of 3000, where

it simply took to long to evaluate any further.

51

s
d
n
o
c
e
S

 12

 10

 8

 6

 4

 2

 0

 10

Bezier (Bernstein) vs. B-spline (de Boor)

Bernstein
de Boor

 20

 30

 40

 50

 60

 70

Resolution x 100

Figure 5.5: B-spline vs. Bezier

Lastly, in (cid:12)gure 5.5 we see why we often trade (cid:13)exibility for performace in
time-critical applications. It shows a comparison between a Bezier and a
B-spline curve, both of degree three and four control points.

In most applications where high (cid:13)exibility is not required, we use the

Bezier curve due to its rapid evaluation and sculpting simplicity.

52

Chapter 6

Closing remarks

This thesis was intended to be a solid material for beginners in the (cid:12)eld
of parametric curves, o(cid:11)ering a simple and intuitive sculpting tool and a
walk-through of the theory behind them.

Only a fraction of the applications have been covered here, mostly as-
pects applicable to computer games and multimedia. The CAD section
would be a thesis of its own, with volumetric sweeps, constructive solid ge-
ometry and so forth. Hopefully the reader has gained some understanding
and interest to explore this popular (cid:12)eld in computer graphics.

6.1 Personal comments

During earlier experiences with parametric curves, terms like NURBS and
rational curves were intimidating, not least on the mathematical side. Many
students feel the same way, so my e(cid:11)ort has been to explain the common
concepts in the easiest way possible. Hopefully this is something that com-
puter graphics classes can take advantage of and hand this material to their
students.

Since mathematics has never been my strong side, it was a good exer-
cise to implement the software and hopefully provide a good explanation for
other students. Some of the implementation may not be entirely correct, but
at least the sculpting software works like intended and will serve as excellent
hands-on experience with the curves and surfaces.

(cid:15) Fun
(cid:15) Fast
(cid:15) File I/O
(cid:15) Intuitive
(cid:15) Portable code
These were the goals of the software, and I feel quite satis(cid:12)ed with the re-

53

sults. Of course, software like this can be expanded on forever and upgraded
with new functionality.

6.2 Future work

(cid:15) More types of curves and surfaces
(cid:15) Surface subdivision
(cid:15) Stabilize algorithms
(cid:15) Output graph of basis functions
(cid:15) Change GUI platform
(cid:15) Rotational sweeps
(cid:15) Advanced rendering options
(cid:15) ...

Since surface subdivision is a huge topic and a good alternative for cre-
ating polygon meshes and solid objects, this is also a high priority if the
software is continued.

The choice of GUI can also be discussed, since the GLUI package is
rather basic. For instance, it would be convenient to have sliders in the
parametric direction(s) for the knot insertion. This is a very common way
to modify the knot vector, and would be easier to implement if another GUI
package was used (GTK or Qt, for instance).

Regular shading or \(cid:13)at shading" implies that we specify one normal per
polygon. This means that the polygon will be rendered with equal intensity
across its span, hence it requires a large amount of polygons to get a smooth
appearance.

There are two major techniques to create interpolated shading, Phong-
and Gourad shading. In the case of Phong, the polygon is illuminated pixel-
per-pixel by interpolating the vertex normals. In its basic form it is very
slow and not suitable for real-time. There are some clever versions which
approximate the Phong model, and these are also considered to be of high
priority since they enhance the visual experience tremendously.

In Gourad shading, we instead interpolate the color of each vertex across
the polygon. This also yields a very pleasing result, but as with Phong
shading it requires some clever tricks while rendering the parametric surface.
We need to have some kind of list at each vertex that holds pointers to the
surrounding polygons or vertices, and this is not very trivial if it is to be
done in real-time.

6.3 Using the software

The thesis software has been developed on Linux Mandrake 9.1 with OpenGL
1.4, Glut 3.7 and GLUI 2.1. It should compile on any platform which sup-

54

ports the three latter (Windows, GNU/Linux, Solaris, among others).

Using the software is painless and self-explanatory. To the right, a strip
of options are available which enables the user to switch between di(cid:11)erent
types of curves and surfaces, load and save (cid:12)les and so forth.

Knot insertion is done by scrolling to the appropriate parametric value
and pressing \Insert". The results of the insertion can be viewed by the
\Show knots" option which renders the knot vector values on the canvas.

The (cid:12)eld \Area" is used to specify a maximum area of the rendered tri-
angles. If any are too large, they are subdivided to several smaller triangles.
This option does not have to be used. We can also specify the uniform
evaluation resolution by the \Resolution" scroller. Note that most of these
values (resolution, rotation speed) are integers, but are internally handled
as (cid:13)oats (1/integer).

The \Load" and \Save" buttons are used to store curves and surfaces
on (cid:12)le. Just type a (cid:12)lename and hit the button. The (cid:12)le formats are easy
to understand and can be manipulated with any text editor.

The \Weight" (cid:12)eld applies to any rational curve or surface and changes

the weight of the currently selected control point.

Rotation of the surfaces are done by pressing the X, Y or Z keys. This
will start a rotation with a velocity given in the (cid:12)eld \Rot.Speed", and halts
when another rotation is speci(cid:12)ed.

55

56

References

1. Bernstein, S. "Dmonstration du thorme de Weierstrass fonde sur le calcul
des probabilities." Comm. Soc. Math. Kharkov 13, 1-2, 1912.

2. Lorents, G. "Bernstein polynomials". Toronto Press, 1953.

3. Foley, J D. van Dam, A. Feiner S K. Hughes J F. "Computer Graphics
principles and practice". Addison/Wesley, 1997.

4. Watt, A. Policarpo, F. "3D games Real-time rendering and Software
technology", Addison/Wesley, 2001.

5. Farin, G E. "NURBS from Projective Geometry to Practical Use". A K
Peters, 1999.

6. Lyche, T., K. Moerken and K. Stroem,Conversion between B-spline bases,
in "Knot Insertion and Deletion Algorithms for B-spline Curves and Sur-
faces", R. N. Goldman and T. Lyche (eds.), SIAM, Phil, 1993, 135{153.

7. Lyche, T., \Knot removal for spline curves and surfaces", in "Approxima-
tion Theory VII", E. W. Cheney, C. K. Chui, and L. L. Schumaker, (eds.),
Academic Press, Boston, 1993, 207{227.

8. de Casteljau, \F. Outillage Methodes Calcul", Anre Citroen Automobiles
SA, Paris 1959.

9. Bezier, P. \Emploi des Machines a Commande Numerique", Masson et
Cie, Paris 1970.

10. Barsky, B. "Computer Graphics and Geometric Modeling Using Beta-
splines", Springer-verlag, New York 1988.

11. Bartels, R., J. Beatty, and B.Barsky, "An introduction to Splines for
Use in Computer Graphics and Geometric Modeling, Morgan Kaufmann,
Los Altos, CA, 1987.

12. Catmull, E., and R.Rom. "A Class of Local Interpolating Splines" in
Barnhill. R., and R. Riesenfeld, eds., Computer Aided Geometric Design,
Academic Press, San Francisco, 1974, 317-326.

13. Brewer, H., and D. Andersson, "Visual Interaction with Overhauser
Curves and Surfaces", SIGGRAPH 77, 132-137.

57

Non-referenced but useful resources

Ching-Kuang Shene, \Ching-Kuang Shene’s Homepage", [Online], Accessed
23 May 2003. Available from World Wide Web: http://www.cs.mtu.edu/(cid:24)
shene

Information Literacy Group, \Numeric style referencing", [Online], Accessed
23 May 2003. Available from World Wide Web:
http://www.leeds.ac.uk/library/training/referencing/numeric.htm

Paul Rademacher, \GLUI User Interface Library", [Online], Accessed 23
May 2003. Avalible from World Wide Web:
http://www.cs.unc.edu/(cid:24)rademach/glui/
Mark Kilgaard. Nate Robbins, \Glut, OpenGL Utility Toolkit", [Online],
Accessed 23 May 2003. Avalible from World Wide Web:
http://www.xmission.com/(cid:24)nate/glut.html

58

