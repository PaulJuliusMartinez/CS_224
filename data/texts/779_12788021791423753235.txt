(! 1J
TOWARD A MATHEMATICAL
 SEMANTICS FOR

COMPUTER LANGUAGES

by
 Dana Scott

- and
 Christopher Strachey

Oxford University Computing Laboratory Programming Research Group-Library 8-11 Keble Road Oxford OX, 3QD Oxford (0865) 54141
Oxford University Computing Laboratory
 Programming Research Group


ctIr. · "';' """, ":.\ '

OXFORD UNIVERSITY COMPUTING LABORATORY

PROGRAMMING RESEARCH GROUP

4S BANBURY ROAD

~ ..
~In

OXFORD

(UY'Y L

~

\LJ
4 OCT 1971

TOWARD A ~ATHEMATICAL SEMANTICS FOR
COMPUTER LANGUAGES

by
Dana Scott Princeton University
and
Christopher Strachey Oxford University

Technical Monograph PRG-6
August 1971
Oxford University Computing Laboratory.
 Programming Research Group,
 45 Banbury Road,
 Oxford.


~ 1971 Dana Scott and Christopher Strachey

Department of Philosophy, 1879 lIall, Princeton University, Princeton. New Jersey 08540.

Oxford University Computing Laboratory.

Programming Research Group.
 45 Banbury Road.
 Oxford OX2 6PE.


This pape r is also to appear in Fl'(.'ceedinBs 0;- the .';y-,;;;o:illT:: on ComputeT's and AutoJ7'ata. lo-licroloo'ave Research Institute Symposia Series Volume 21. Polytechnic Institute of Brooklyn. and appears as a Technical Monograph by special aJ"rangement ...·ith the publishers.
RefeJ"~nces in the Ii terature should be:- made to the _"!'OL·,-,',~;r:gs, as the texts are identical and the Symposia Sl?ries is gcaerally available in libraries.

ABSTRACT
Compilers for high-level languages aTe generally constructed to give the complete translation of the programs into machme language. As machines merely juggle bit patterns, the concepts of the original language may be lost or at least obscured during this passage. The purpose of a mathematical semantics is to give a correct and meaningful correspondence between programs and mathematical entities in a way that is entirely independent of an implementation. This plan is illustrated in a very elementary way in the introduction. The first section connects the general method wi th the usual idea of state transformations. The next section shows why the mathematics of functions has to be modified to accommodate recursive commands. Section 3 explains the modifi cation. Section 4 introduces the environments for handling variables and identifiers and shows how the semantical equations define equivalence of programs. Section 5 gives an exposition of the new type of mathematical function spaces that are required fOl the semantics of procedures when these are allowed in assignment state ments. The conclusion traces some of the background of the project and points the way to future work.

CONTENTS

O. Introduction L States and Commands 2. Recursion 3. Lattices and Fixed Points 4. Identifiers and Environments S. Procedures 6. Conclusion References

Page 1
 7

lS 20
 26

30
 39
 42


TOWARD A MATHEMATICAL SEMANTICS FOR
COMPUTER LANGUAGES

O. INTRODUCTION. The idea of a mathematical. semantics fOT a

language is perfectly well illustrated by the contrast between

numerals on the one hand and nu.mber8 on the other. The nwnerals

are expressions in a certain familiar language; while the numbers

are mathematical objects (abstract objects) which provide the

intended interpretations of the expressions. We need the ex·

pressions to be able to communicate the results of OUT theOTizings

about the numbers, but the symbols themselves should not be con

fused with the concepts they denote. For one thing, there are

many differen t languages adequate for conveying the same concepts

(e.g. binary, octal, or decimal numerals). For another. even in

the same language many different expressions can denote the same

concepts (e.g. 2+2, ~. 1+(1+(1+1)). etc.),

The problem of ex~

plaining these equiva!enr!es of expressions (whether in the same

or different languages) is one of the tasks of semantics and is

much too important to be left to syntax alone. Besides, the

mathematical concepts are required for the proof that the "arious

equivalences have been correctly described.

z

In more detail .. e may consider the follo\f>'lng explicit syntax for binary numerals:

NUMERALS


\J ::== Olllvolvl


Here we have used the Greek letter v as a metavG"t'iable over the syntactical category of numerals, and the category itself is being given a l'e!oursive definition in the usual way. Thus, a numeral is either one of the digi ts 0 or 1 or is the Tcsul t of suffixing one of these digits to a previously obtained numeral. Let the set of all numerals be called Nml for short.

Semantically speaking each of the numerals is meant to denote a unique number. Let N be the set of numbers. (The elements of Nml are expressions; while the elements of N are mathematical objects conceived in austraction independently of not<ltion.) The obvious principle of interpretation provides a
function, the evaluation mapping, which we might call \J', and
which has the functional character:

1i Nml -+ N.

Thus for each v E Nml, the function value
"'! vI
7;6 the number denoted by v.

How is the evaluation function "determined'? Inasmuch as it is to be defined on a recursively defined set Nml. it is reason
able that '\J should itself be g-iven a recursive definition. Indeed
by following exactly the four clauses of the recursive definition Nml,
we are motivated by our understanding of numerals to write:

'tJ, 0 i o

"111
'tJlvo I
1JIV11

2'V"lvl 2'1ilvi+l

Here on the left-hand side of the equations, t.t is heing applied
to expressions; while on the ri~ht-hand side the values arc given. To borro\f>' the relevant termlnolo~y flam logic, the numerical ex

3
pressions belong to the obJect ~angu.age; whereas the definition
of 1J is given in the metalaTlguage. To be able to write down ex
plicitly the definition of \.1", some metalinguistic symbolization
is of course required. The metalinguistic expressions must at all cost be distinguished from those in the object language. (We have put the object language 0 and 1 in Roman type-face and the metalanguage 0.1,2 1n italics. Logicians often take further pre cautions by enclosing the object language expressions in quotes; the quotation- express ions can then be regarded as part of the metalanguage. and thus the languages are "insulated" from one another. In this paper, however, our object languages are simple enough making the use of such devices less critical. The separation needs to be observed nevertheless, and in the semantic equations we have enclosed the object language expressions in the special brackets ( I merely as an aid to the eye.)
Granted that there is a distinction between symbol and object, it may still seem that the above equations for l1"are circular or nearly vacuous in content. Such a conclusion is wrong, however, because there is an easily appreciated point to the definition: namely, the explication of the positional '7otation. In our metalanguage we need never have heard of decimals or binaries. We do require, though, the concept of 'lumber, the concepts of J3el'O and one, the concepts of addit'io'l and multiplication. (By defin ition 2=1+1, say, and if we want, the whole theory of numbers could be conveyed in the metalanguage with the help of Roman 'lumerals augmented wi th a few tricks from algebra such as the use of operation symbols and variables.) These concepts, fundamental as they are, cannot be strictly said to -impl)j the positional notation. In fact, the clever use of 0 to help form strings of digits was a discovery L"l language. This discovery in no way changed the abstract nature of number, but it was a tremendous help in popularizing the use of arithmetic ideas ~ and there seems to be a perfectly good parallel here with computer languages many of which contain in their syntactical structures quite as clever discoveries of language.

4
One point that encourages confusion in thinking about numbers is the possibility of having a complete and canonical naming system for them. ]n the illustrative syntax fOT binary numerals we have been considering,such strings as 001101 were allowed. As everyone knows the initial run of o's is unnecessary for we can show that
"gOOllOl] ='\)(11011 = Xill.
This type of straight-forward deletion gives us the only possible equivalences in this very simple language. The Nduced numerals (Le"numerals of the forms 0 and 1\.1, where \.I E Nml is arbitrary) are then in a one-one correspondence wi th the numbe rs. We can then ~ork exclusively with these normal forms. and it is so easy to think of these expressions as being the numbers - especially if one is familiar with only one notational system. The attitude is wrong-headed, however. But for many activi ties there may be no real harm, since the confused mind will give the same answers as the clear-headed person. The notationally bound thinker may often be distinguished by the way he feels that he has to specify all his operations by algorithmic symbol manipulations (as in digitwise addition of numerals). Again there may be no real harm in this - if the algorithms are correctly given. And in the case of numbers the two approaches can be brought together (the symbolic and the conceptual), for our system of reduced numerals can, by a slight amount of good will, be regarded as a model for number theory. Since we know that all such models are isomorphic, there is not much mathematical advantage in using one model over another. This is a sense in which numbers can be consistently con fused with numerals. But the confusion does not really do us any good either.
The reasons why the number/numeral confusion should be avoided are many. For one reason, we may turn the isomorphism argument the other way round: If all models of number theory are isomorphic, you may not want to single out a pu:-ticular one at all. Because the semantical ideas will equally well apply to all of them. you may want to leave open the possibility of shiFting from one to another. This is somewhat analogous in computer language sewant ics

5
to allo~ing different representations to be used in different machines to implement the same language (in hopefully isomorphic ... ays). In the case of numbers not much advantage is bought by this freedom. but any attitude of restricting generality is a bad habi t which can be misleading in analogous but mOTe complicated situations.
A mOTe important reason fOT not getting into this hahi t comes to the fOre when one realizes that fOT some systems of mathematical concepts no fully adequate notational system is possible: the real numbers are the prime example. Of coune it will be objected that this realm of mathematics is much too abstract, much too infinitary. much too distant from real-life computation. This objection cannot stand careful conceptual investigation, but a full answer would take us too far from the topic of this papeL A quite adequate answer concerns not the mathematically very pure structures such as the real numbers, but rather our theories of classes of similar but different structures. That is to say. for the semantic investigation of certain language features it may not be appropriate to single out one (isomorphism type of) structure, but for many reasons - generali ty, lack of knowledge, for the sake of experiment - we may want the same semantica] equations to be employed OVer the whole class of structures. Since the structures need no longer be isomorphic, different structures may lead to quite different normal forms for expressions. (The mathe_matical theory of groups. for instance. could provide us innumerable such examples.) Hence. no one system of "numerals" would any longer suffice. Even if the separate structures could somehow each be symbolically constructed, the effort would be beside the point: what we are trying to get at are the C'o~mon features of the structures. The various ad hoc details would only detract from this higher purpose.
To bring this introductory sermon to a close: the point of OUT approach is to allow a proper balance between rigorous formul ation. generality of application, and conceptual simplicity. One essential achievement of the method we shall wish to claim is that

6
by insisting on a suitable level of abstraction and by emphasizing the right details we are going to hit squarely what can be called the mathematical meaning of a language. In the trivial example of the binary numerals discussed above everyone will agree that
the evaluation function 1J is indeed correctly defined. That much
is obvious. Note, however, that having accepted this fact, it is then possible to prove that certain numerical algori thms are correct (digitwise addition, say). and before we had the definition this question did not even make sense. (Specifically, digitwise addi tion is an operation \)0 Q;I VI defined on numerals vo. \), . What one needs to prove is that
'ttl \)0 Q;I vd Vl I= \)0 + Vl vii
wi th symbolic addi tion on the left and conceptual addition on the right. It is not difficult to do this, but one needs an indnctive argument.) These are simple p-oirrts. but it is easy to lose sight of them when the languages get involved.

7

1. STATES AND COMMANDS

We begin by postulating that the inter

pretation of the language depends on the states of "the system".

That is to say. computer oriented languages differ from their math·

ematical counterparts by virtue of their dynamic character. An

expression doeS not generally possess one uniquely determined value

of the expected sort, but rather the value depends upon the state

of the system at the time of initialization of evaluation. What

increases the dynamic character of the evaluation process is the

fact that the act of evaluation may very well alter the initial

state. Thus the working out of a compound expression can require

several changes of state. and the treatment of a 5ubexpression

generally has to wait for the moment at which the state can be

provided appropriate to its evaluation. Therefore the "algebra"

of equivalences of such expressions need not be as "beautiful"

as the well-known mathematical examples. This does not mean that

the semantics of such languages will be Zess mathematical, only

an order more complex.

Part of our assumption is that the states of the system form a set 5. and the dynamic character of the language wil1 require us to consider tl'ansformations of this 5 into itself: the state transformations. For the moment let us write (in our metalanguage)

[5 ->- 5]

for the set of aZZ state transformations (this set may require restriction later). Bya tl'ansfol'mation f E [5 ->- 5] we understand the ordinary concept of a mathematical function defined on S with values in 5. Functions in the mathematical sense are abstract objects - they can be defined in various linguistic forms, but after the definition is interpreted all that is left is the bare correspondenae between arguments a E 5 and values fro) E 5. In particular two functions which assume the same values for the same arguments are mathematically identical - even though they might have been defined in some object language in quite different ways.

The simplest way to regard the state transformations from a to f(oJ is that they give the results of executing a com~lnd. No explicit values are required; one is merely being asked to "move along". Of course certain "values" may be implici t in a.

8

and they may be changed in passing to [(0) (e.g. ones position). The command, however, is concerned more with the overall change; other hnds of expressions can be used to extract from a state dES any relevant values. But one syntactic category in our language will be that of commands; let us call the set of these expressions Cmd, Given Y E Cmd, no matter how camp lex, the mathematical meaning of this expression is an associ ated state transformationtlYI E [5 -+ SJ, That is, the semantics of commands is to provide us with a mapping:

t Cmd -+ [5 -+ SJ.

just as the semantics of numerals gave us:
tJ': Nml -+ N.

What is vague here is that we have no idea what commands are, whereas numerals were standard. - That we have at this stage no idea what states 0 E S are is far less serious. because that is the part of the interpretation we are on purpose leaving open.

It is not difficult to be more explicit about the syntax of cOITlJllands. however. because there are several qui te natural ways of combining them. An initial syntax might look as follows:

COMMANDS

y"~ (yll.ldummyl
E: -+ Yo ,1'1 11'0 ;1'.

Here the Greek letter y is a metavariable over the category (Cmd)

which is being given a recursive definition. On the right-hand

.y,side of the definition the y.yo

can be regarded as pre-lJiously

obtained commands. where the subscripts are required in a binary

composition to allow for different commands to be chosen. If in

one clause of the definition the same "'( appeared twice. we would

intend that the same previously obtained expression be used in

both positions. There is no implied connection between the y's

in the separate clauses. The letters ¢ and E: are meant to refer

to other syntactic categories yet to be explained. The expression

dummy i-s a COTl8tant command (an "atomic" command expression).

As anyone can see (assuming that the categories of ¢ and E

9
are simple) the set Cmd is going to be a context-free language. Also obvious is the fact that the language is ambiguous - thus yo ;)'1 ;y~ can be parsed in two different ways at least. Machines generally prefer their languages unambiguou.s; while humans enjoy a little uncertainty, or at least they find ways to overlook ambigui ties by giving each other the benefit of the doubt. Some times ambiguities make no difference (as in Yo ;"(, ;)'1). but at other times they are quite tiresome (as in e: ->- )'0,"(1;"(2). \lie shall deal with this problem presently, but in the meantime note the clause (Y) in the definition. This clause allows us to form (e: -+ Yo ,)'1) ;Y~ or (: .... Yo ,(Y j ;)'2) which are similar to the ambiguous expression but which have one chance less of being ambiguom. With a sufficient nesting of parentheses all ambiguity can be eliminated; or, speaking more precisely, there is a completely unambiguous sublanguage of Cmd. The only trouble with us humans is that the majority find writing in this sublanguagc a terrific bore; hence the tendency to the more dangerous syntax.
Before we can be more precise about Cmd and the inter
e.pretation we have to discuss the £. For the time being E E Exp,
the class of BooZean ezpr'essions (we shall allow other types of expressions later). As a starter at a syntax we can write:
EXPRESSIONS
£ ::= (£)jlTltruelfalsel£o .... £1,£2
The same remarks about ambiguity apply. The 11" are certain atomic expressi ons which we shall not stop to detail now. The Boolean expressions true and false are constants,and Eo .... £1 ,£2 is the well-known conditional expression (short for: if £0 then £1 else £2, which some rr:ay prefer).
What of interpretation? In the first place we postUlate the set T of truth values which contains the elements true and false corresponding to true and false. But the meaning &[E] is not going to be simply an element of T, for in general values must depend on states. Besides this evaluation may cause a change of state. Thus the correct functional character of & is:

10

& Exp"" [5 .... [T x SJJ.
This means that given £: E Exp and 0 E S. then
&[£!(o) <t,O')
where t E T is the value of E given 0, and 0' is the resultant state after the evaluation and may differ from a as it may have been changed by the evaluation. (Here T x S is the usual cartesian product of sets and <, ," > is the pairing function.)
Before giving the clauses that define r: and S, it is useful
to introduce several mathematical operations on functions. If f : B ->- C and 9 : A .... B, then as usual we write feg : A + C fOT the composition. where

(["9)(0.) '" [(grel»

for all cr. EA. We have further

p A - [B + [A x BJJ
M. A x B .... A, and
M, A x B .... B.

where

P(a)(e) = <0..13>,
Ma «cr.,B» = cr., and M1 «0.,13» = B
for all E(J, A, S E B. Finally, if p : A' ->- [8 + CJ and q : A .... A' x B. then p *q : A ->- C. where

(p"q) (a) p(Mo(q(a)))(MI (q(a»)

for all a Ii: A. On all of these operations and special functions we ought to write some kind of ABC subscripts, because strictly speaking they depend on the choice of the various sets; we have omitted these subscripts as they can easily be deduced from the context. The same goes for the identity function

where

I A -+ A, I(a) = C1

forallaEA.

11

Turning now to the mapping ~ we have clause by clause: 8.1:(£)] &id

because parentheses add nothing to meaning.

S,[nB = (some given S ->- IT X SJ).

because each atomic expression 11 must"have a given meaning. (Which meaning this is. need not concern us here, since at the moment all ...·e consider is the fopm of the semantic definition.)

Sf true] = PC true), and qfalse) = P(falsel,

blO'cause true and false are constants which can be evaluated "instan taneously" wi thou! change of state. This means that fOT all o.

&H true] (rJ) = < t1'l.I.e ,0> and
&ifalse~(o) = <falae,a>,

8.[£0 -+ [I,Ed = Cond(&[Ed.&IE,))*&[Eo],

where the function

eond: [5 .... T x S] x [S .... T x SJ -+ [l -;.- [S .... T )( S JJ

is such that

CandCe, ,e2) (t)

t .... 8. ,e2

so that

Cond(el.e~)(t)(cr) = {

,,(0) if t eda) itt

true I false,

for all el ,el .t,o in appropriate sets.

oft; ,

It is now possible to give the clauses of the definition
t: I (Y)I ~ <:[Yi.

elrjlJ = (some given 5 .... $),
 ~[dummy) '" I . 
 t::1£ .... Yo ,rd = CondCC[YoLQ:yd)*&IEL

eei Yll ; YI I = hi ~ ot'[Yo] ·


12
These functional equations can all be read in words: t"[ (y)] is of course the same as t'~yl. Nextt'iH is a given state .trans formation, since ¢I is taken for the moment as a primitive (or atomic) command. (Later we could introduce some syntax for the category of iP if 'We wished, and this would requi re further semantic equations of a similar sort.) The dummy·comman.d is next being interpreted as the "do nothing" transformation. The conditional- command on the other hand requi res a cond it ional operator similar to the one used for expressions, except that the domain of definition is altered to make it appropriate to commands. Specifically we have:
Cond [S ~ SJ x [S + 5] + [T + [S + SJ].
Some subscripts ought to be introduced to indicate the difference between the t",o kinds of Cond-functions, but "'e are relying on the context to make this clear. Finally Yo ;Y, is be ing interpreted as the sequencing operation on commands, "'hich in terms of state transformations is simply the composition of functions. Note, however, the order of application. The "positional notation" of the command language conventionally places the first command to be executed on the left and the follo'Wing one on the right. The convention "'ith mathematical composition of functions is just the opposite. (The reason being the common use of f{x) rather than xf for the function-value notation.)
In format these equations forl:'and8. are not much different from those for 11 as app lied to the numerals. Ir. all cases there is a syntactical defini tioo in several clauses. The semantical definition is "syntax-directed" in that it follows the same order of clauses and transforms each language construct into the in tended operation on the meanings of the parts. In the case of numerals the meanings were familiar mathematical objects on which many familiar operations (addition, mUltiplication, etc.) were already defined. In the case of commands and Boolean expressions, the values ",ere not so well known, nor were the operations (such as Cond) very common. Nevertheless. the domains [S ... SJ and [S ... T )( S] are quite appropriate to the ideas that are being

13
explained, and the various operations (Q,*,P,M·· M,) are natural ones for these domains.
That it is necessary to construct meanings out of fuwtions ([5'" S]) may seem bothersome, but it should not be deplored. After all the idea of function is one of the greatest of OUT mathematical discoveries. The Calculus would be impossible with out functions. and the development of the subject would be un thinkable without the use of various operators (derivative, in tegral, etc.) and consideration of the equations involving them. Though formal languages are not generally made explicit, still there is constant translation from intuitive ideas to mathematical concepts (veloC!ity means derivative, area means integral, super position means addition of functions. and so on). In the case of computer languages we cannot say yet that we have introduced con cepts anywhere near as important as those of the Calculus, but the spirit of mathematizing ideas can and ought to be carriM over. That the project is a useful activity remains to be demonstrated, but the treatment of r'eeul'sion in the next section ought to indicate some of the advantages of the mathematical approach.
Before turning to more important concepts. the question of ambiguity must be faced again. We have allowed our grammars to be ambiguous, and so strictly speaking the semantical mappings t: and 6. are not well defined. (,,"on Nml was well defined because that graIllJnar was not a-mbi-guous.) Is there a mistake here? We_ think not. Our attitude is that the meaning of an expression depends on the way it is parsed. From this point of view the
emappings and 6. are defined not on expressions simpLieite-r but
rather on the annotated deduetion trees for expressions based on rules of the grammar. (If one wishes a linear notation, a fUlly bracketed language could be introduced in the usual way, alld then the expressions we have written above would result by deletion of the brackets and subscripts.) As emphasized above these brackets (or trees) are intolerable to wri te; hence. as long as we keep our semantic equations "in step" with the syntactical defini

14

tions and warn the reader of the oYeTsimplification~ it will be

clear Io'hat is intended without the burden of any more notation.

(In the terminology of Knuth {2. 3]

we are still using only

synthesized attributes in assigning meanings to expressions.

Whether the inhel'ited-attr-ibute approach is convenient is some

thing we must consider further, and there is no doubt that Knuth's

way of introducing both bottom-up and top-down dependencies between

semantic equations is an interesting notion. Be that as it may.

the point of OUT paper is the study of liIhat it is that semantic

equations assign to expressions. The path by which the assignment

is made is at the moment a secondary issue.)

15

2. RECURSION. The language of commands and expressions as intro duced in the last section is at best of illustrative value. It was useful to see in not too horrible detail the connections between the syntactical and semantical equations. But the actual language used was of very limited expressive power. The command structure ,,"as of a very direct sort: the execution of such a cOl'lmand would procede along a "branch" of a tl'ee, the commands being composed in sequence and the choice of path at a branch paint being decided by evaluation of a conditional expression. In Scott [6] the expressive power of such a language was exprrnded by the introduction of a certain kind of ilifiY!ite tree, I:!ut the mathematics of this approach loIould take us too far afield here. And in any case. it is rather fully explained in that paper. Our interest here lies in more conventional language features; in particular those that can be written down in finite space. This doe$ not mean that thinking of finite expressions as being "unrolled" into infinite trees might not be mathematically illuminating, rather we do not have the time to discuss it in this paper.

The question that leads to infinite trees is of COurse that of recursive ly defirted commands. By loIay of example suppose that exit is a primitive command. as is fudge. Moreover, suppose that test is a primitive Boolean expression. One would wish then to introduce a command loop by the equation:

loop ~ (test ~ fudge; loop. exit)

In other words. to loop means to alternate testing and fudging until a negative test is produced. At that moment a hasty exit is then required without further fudging. This is one of the simplest and most familiar examples. More generally it ""ill be desired to introduce a whole sequertce of interrelated cOTMands ~OI~l""'~n-l by a system of eqnations:

~o = Yo' ~1 Y1 ····· ~rt-l = Yrt-l '
where we may think of ~o as the principal command to be executed

and the remaining ~i as auxiliary commands introduced to aid the

definition.

Now the Y . command exprE'ssions loIill involve reference J

16

to the ~i commands, just as in the loop example. Sometimes it is possible to eliminate the auxiliary commands at the expense of perspicuity by substitution of one equation in another. But at other times the elimination is not possible or not at all obvious. In any case it is a language feature of well-known convenience to allow simultaneous equations. All of this is very familiar ground.

Syntactically, to accommodate this recursive style of conunand definition. we must expand the language to allow for (temp orary) identifiers which will refer to these auxiliary commands, the precise reference being controlled by a scheme of dli.~Z.al'ation. The exact style of identifiers need not concern us here: all we require is a syntactical category Id of expressions distinct from the other kinds of expressions mentioned so far. Besides this Id should be infinite to allow for as many auxiliaries as we please.
We use the Greek r, to range ;ver Id.

Having provided identifiers, we then need to combine them wi th other command express ions. Of course an iden t i fier standing alone will be allowed in the expanded Cmd. In this way identifiers can be included in the interiors of commands. Further the system of equations indicated above can be recorded in the following declaration scheme:

§ l';o·t 1 '···'';n-1 : YOJY1····'Yn~1 where we have Slightly torn apart the equations.

The initial list

of identifiers tells uS to "watch out" because some auxiliaries are

being introduced - in the order given. The following sequence of

sicommands tells us how to use these auxiliaries with

= Yi intended

- in the order as written. Recursion is permitted because the

various ';i may occur wi thin the YJ' Having gone to the trouble

of writing 1';0 first, we may not only regard this expression as a

scheme of declaration but also as an instruction to carry out So

first, thereby activating the other I';i as necessary under the

control of the YJ .

t(The pretty brackets § and are not strictly

necessary. since we could regard: as the declaration operation and

employ the colourless ( and) to block ambigui ty - but one can carry

17

linguistic stinginess too faL)
This expansion of expression now requires a revisioTl of the synta~ for conunands whereby the principal syntactical equation (for y) is accompanied by some auxiliary equations for sequences (namely ~I'l and yl'l):

rOMMAN OS

y ::= (y)I~ldummyl(1
E -> Yo ,1'111'0 ;y,
tE;/'l ~y"

E;n ::= !;o.f.: 1 ····· F.: n _ 1 (n>o. the f.{ distinct)
yn ::= YC.-y1 ......y n-1 (n>o. the y';i arbitrary)
II word of explanation is in order here. Greek E; is a metavariable over identif:iers, while I;;n by definition is a metavariable over n-tuples of di~tinct identifiers. (We keep n>O, so the tl-tuples are nonempty.) The metavariable yn ranges over n-tuples cf commands (again, n>O). In the last clause of the definition fOT y note that the E,n and yn have the same n. Our language therefOre is no longer context-free. But, if we may say so, who caTes? Context-free languages have limited usefulness. Note, too, that we have not tried to torture ourselves wi th too rigorous a style of BNF syntactical defini tion. h'e deny that our syntax is un rigorous or even unaesthetic. On the other hand if someone has a really neat language definition system that is as easy to com prehend at th is level- ot discussion, we shall be- glad to consider it. The last thing we want to be is dogmatic about langullge: it is in the TJl(\thel'latization of concepts that we have a certain amount of dogma to sell.

For the time being we introduce no revision in the definition of Boolean expressions E. Note that the command construction
r;TI yn t

is, logically speaking, a var·iable-binding operator. The iden tifiers ~n are the bound variables (and, since a matching with the yn is intended, they lI'.ust be kept distinct); whereas other identifiers which occur may occur as fr·ee variabl.es becau5e the con strnction can be iterated. A certain semantical device "'ill have

18

to be introduced to handle this problem of scope of identifiers.

There arc other problems, however. and the loop-example
 will suffice for illustration. In the official notation there
 are no equations for commands as such; rather OUT example above
 becomes


§ loop (test .... fudge; loop. exit) ·

\oo'hich is a command with tbe understanJing that loop E Id. What

is the exact meaning of this command?

Whatever it is our dogma

says it must be a state transformation in [5 .. SJ. Let the command

be called 1. for short. We are asking whattU).] should be. In

tuitively we want

CIAI

~~test .... fudge; A. exit] "0>: d (tfi ). 1: ot'~ fu dge I 1 t:I ex it] ) .&1[ tes tl

To simplify our thinking here Ie t:

£=t'[AD, f = t'~ fudge) · Ii< = t::'[ex;t!. and t=l;[ll.est.,

where

,~.f',e E rS -~ SJ

and

t E [ S ·.. TxSJ.

Of these r,.;;, and t are known, ....·hi le i is t~ ~known w.e seek.
The functional equation for i reads:

i Cond(lof,e)*t.

Some solution or other to this equation - if any exists - has
the right to be called C[ ),J, the meaning mf th.e loO[p- co~and as
a state transformation.

!\ow comes the rub. So far we haYe not anal yz.ed the

nature of the set S at all, because \;'e opted for extreme generality.

r,e.If we ~tick to this generality and allow the functions

and

t to be Ql'bi tJOal'y functions, then it is easy to construct an

example where no solution for Jl. exists in the above equation at all.
The reason is simple: f ,.;;, and t are total functions so interrelated

that any attempt to define ~, as required sets up an infinite loop:

so that 710 choice of values can be made to satisfy the equation

19

as a functional equation between total functions.

The solution to this problem is easy enough and is .'.ell

knmm: ... e modify our idea about the function space [S -+ SJ, We

no longer demand that functions be total but understand the

functions in [S ... 5] to be partial functions. Thus for certain

cr E S and certain g E [S -+ 5] we allow g(o) to be undefined. With

this convention it can then be shown that the E'quation for i, does

indeed have a solution in the partial function sense. and in fact

it has a leas t solution. (By least we mean that the "graph"

of the function is included in every other solution.) This

approach is that of Park [4] and many others. (See reInenees

in Engeler [1].)

Sui table as it is for man)' purposes .and

simple as it is, it is not quite the method Wf> wish to ado~t.

OUT method is Telated, but it is made a little mOTe sophisticated

in oTdeT to supply a closeT analysis of the nature of the elements

of 5 which is TequiTed faT the explanation of otheT languaEe featuTes.

20

3. LATTICES AND FIXED POINTS. In the lelst section we found it necessary to expand [5 ~ SJ to allow for partial functions. The set of all partial functions is partially ol'dered by the relations:.ip of one function's being ~noluded in the other. Under this partial ordering the set [5 ... S] takes on a structure which has quite pleasant properties. These properties can be formulated in an ~stract way. so that the proof of the existence of solutions to fixed-point equations can easily be given. In order to regular ize and generalize this argument, it turns out to be natural to derive the structure on [5 ... 5] from structure on S. This is accompli.shed by expanding 5 until it becomes a partially ordered set itself - in fact, S will be made into a complete lattice. Just how this construction of an expanded 5 is to be done requires a closer examination of the kind of elements 5 should have. We will have to return to this question in more detail in §S. For the time being suppose that the expansion has been made.

Speaking a bit more generally for the moment, the structure of a complete lattice on a particular domain (set) D requires first a partial ordering which we wri te as

x I; y

for x,!I E D. This relationship is reflexive, transitive, and

x.santi-8!/mmetric. Next. if

0 is a subset of 0, we assume the

existence of an element of 0, called the least upper' bound (Zub)

of the subset X, which we write as:

Ux.

We have for ally E 0
Ux ~ y iff x ~ y. for all x E X' and this condition uniquely characterizes Ux E D. A complete
lattice is a partially ordered set in which lub's always exist.

Among the lub's in a complete lattice there are two extreme ones: . the lub of nothing and the lub of everything. That is to say, the empty subset ~ and the full subset D will both have lub's to which we give special names:

21
.1 = U¢ and T = UD.
Note that for all zED it is the case that
.li;~l;T.
We can think o£ .1 as the weakest element and T as the strongest element of D. The ordinary elements are somewhere in between, and.l and T should be considered rather extraordinary. (We can call them bottom and top.)
An intuitive way of reading the relationship :.r ~ y is to say that x approx-imates y. Thus x is worse and y is better. But take care, the sense of approximation being used here is a qualitative one of what we might style diroect appro:zi.mation. The statement x ~ if does not mean that x is very neal' y. but rather that x is a poor>el' version of Y. that x is only partially specified and that it can be improved to if without changing any of the definite features of z. For example in the case of partial functions. ~ means inclusion of graphs (the graph of a function is just the set of ordered pairs of arguments and function values); hence. impz'ovement means adding new ordered pairs. The smaller set of ordered pai rs can indeed be s aid to be an apprOXimation to the larger one. (In the case of partial functions treated by graphs in the ordinary way. the structure becomes a lattice only when T is added in a somewhat artificial way as a top element which is not represented as a set of ordered pairs. We shall discuss partial functions in a slightly different way below.) Additional examples of approx imations treated in this way can be found in Scott [5] and [6].
If we take the notion of approximation seriously, then we have to rethink what we mean by function. Thus if
f 0 ... 0
and
x ~ Y.
then f should not juggle x and y around in too arbitrary a fashion.
Indeed it ough t to follow that
f(;c) ~ fey);

22
became 1:f we improve :r to y, then in "calculating" fry) the cal
culatlOn should be just an improvement over that fOT f'(x). Mathenatically speaking the reasonable functions ought to be monotonic (i.e ·· ~ preserving).
Besides the intuitive motivation for monotonic functions, we have the well-known mathematical fact that monoton-ie functions on c(}·r;p~ete ~attice6 alway'J have fixed pOJ:nts. They even have least fixed points. This makes their use most convenient fOT OUT ?urposes.'" Actually the functions we use - and which are appropriate to computation theory - have an even stronger property; they are cont-inuous. (See the discussion in Scot t [5] anJ [6].) We shall assume this stronger property but shall not go into the technical details in this paper. The reader should only be assured that normal functions are automatically continuous.
What does all this theorY have -to do wi th the subject of semantics'? Step hy step the relevance .is this: Commands (programs) are naturally thought of as defining state transformations. Re cursive commands require partial functions. Solving for these partial functions is just finding (minimal) fixed points in certain functional equations. In general the existence of fixed points is justified by a lattice-theoretic argument. Therefore, if we can ~ee the connection between lattices and partial functions, the relevance of the theory will be estahlished.
Returning to 5. we promised to expand it to a lattice. This can be done in many ways, but for simplicity suppose that the initial version of S was just an abstract set, 50, say. In 50 we assume no particular connection~ between the elements for the sake of argument. The expanded 5 results merely by the adjunction of the two, new "ficticious" elements 1 and T. The partial ordering ~
", The argument for fixed points is as follows. Le t [ : [I -+ D
.s.be monotonic. Let y D be the subset of all y E D such that
b'~ a whenever [(a)!; a ED. Let x == UY. To show that x ~ [(x),
note first that x E Y; because if f(a) ~ 2, then y ~ a for all y E y. so x!; 2. Next note that f(x) E Y; because if fez) !; z, then x~ a, and so [(xl!; f(2) i; a by monotonicity. Therefore
{x)!; Uy == x. But then f(f(x])!; [(r), again by monotonicity,
S~ oX!; f(x) because x E Y. Thus x = [(x).

23

aside from satisfying the usual axioms, provides in addition only the relationshi.ps:

1. ~_ .:r ~ T.

(For pictures of these and other partial orderings consult Scott

[5] and [6J.)

This expanded S becomes a complete lattice

in a rather trivial way, and the construction should not be taken

as being typical.

The function space (5 .... SJ is now regarded as being the
set of all mono~onic functions from S into S. (In more interest
ing lattices we shall restrlct our function spaces to the continuous functions; in this example the restriction makes no difference.) For a E Sand g E [5 + S] when we formerly wrote that

g(O) is undefined

we shall now wri te simply

g(o) = 1..
The new element 1. can be regarded as an "embodiment" of the un defined. (The companion equation g-(o) = T could be read "g(rJ) is overde[ined" ~ but the utility of this concept is not as obvious.) Now if [,g E [5 ~ 5] are any two functions. we can write

[ !; g

to mean that

S-[(~)

g(~)

for all 0 E 5. This definition at once structures [5 ~ 5] as a partially ordered set and indeed as a complete lattice. This is
a natural definition for g's being an improvement over f. if one
reads it in words, and it corresponds to our previous ideas about funct:ions. Thus if [(0) = 1 (is undefined). then g(Oj is un_ refrtJ'ic:ted and can be any element of 5. If [(0) is better defined (say, [(0) = a' E 5 ), then g(o) can only be 0' or T if the relation ship [ ~ g is going to hold. Hence [~ g means just about what we intended when we said that the ordinary graph of f is included in that of g.

Z4

Note that by the embodiment of L. what used to be partial functions are now total functions in the expanded sense. because g(eJ) = .L is an allowed "value". This may seem like a silly thing to do, but the main mathematical point is that the lattice structure on [S -+ S] is now del'ilJed, by means of a simple definition, from the lattice structure on S. And by the very same regular process we can provide lattice structure on [$ -+ 5] -+ [5 -+ 5]. and in general on any [0 -+ 0'] - always remembering to use the set of continuous functions for this construction.

We can now make more precise that we mean by T as a lattice; namely T = (.l,faZse.true,T}, where .L I; t ~ T holds for
qt E TJ but false true and true [ false. We have used T in the
context T x S. and in general any 0 x 0' can he construed as a
lattice if 0 and 0' are. One has only to define:

<;x,;x'> ~ <y.y'> iff;x l; y and;x' l; y'.

for all ;x,y E 0 and x'.y' ED'. In this way all of the domains [T ... [S ... T x SJJ. etc. can be regarded as lattices. and by the general method fixed points can be obtained when necessary. In particular in the equation
~ = Co~J(tof.e)*t
f,e,t were certain oon8ta~ts in their intended domains. and Cond, "," were certain functions (operators) on these domains. Under the present interpretation all these domains are lattices, and it can be checked that all these functions are indeed continuous. Therefore, the function

where

F [S ~ SJ ... [S ... S]. F(t) = CondCi.,0f.e)*t

is itself a continuous functionj and we know that such functions have fixed points. The price of generality is high, but eventually there are some returns on your investment.

Another kind of pay-off was discussed in some detail in

Scott [6].

In that paper the syntaaticaZ domains were taken

to be lattices also, and it was found that the mapping

t:::Cmd-"[S-+SJ

was not only continuous but its exi6tence could be proved by the very same lattice-theoretical argument via fixed points. That is a rather fundamental point and unifies the theory considerably.

The whole process of forming fixed points can be given a functional formulation. Let 0 be any complete lattice and l~t [0 -+ [lJ be the lattice of continuous functions. Then there is a
mapping

y
such that for each f E ro
fixed point o£ f. Hence

[D -.. DJ -+ I) DJ the element YCf) E D i6 the least

[(y(fJ) = Y(fJ

will be satisfied. What is remark~ble and particularly useful is that .Y itself is (!ontinuous. Thus if we employ Y in various equations along with other continuous functions we can rest assured that the compound functions obtained are also continuous. This makes the theory very smooth, if the reader will forgive the pun.

In mak ing up the-se lattices it is sometimes useful to join two lattices together into one. We write D + D' to mean the result of taking a copy of D and a disjoint copy of D' and forming the union. To make this union a lattice we identij'y the 1 E 0 with the l' E 0' and similarly for TEO and T' E I)' (.1 = l ' and T = T'.) Thus, for "ordinary" elements of I) + I)' we can say. roughly, that either they are elements of 0 or of 0' but not both. The!; relations are carried over directly with no connections imposed between the elements of the disjoint parts. We shall in § 5 discuss considerahly more complex constructions of lattices of a "recursive" nature, but first it is necessary to explain the semantical treatment of identifiers.

26

4. IDENTIFIERS AND ENVIRONMENTS. In §Z we introduced into our syntax for commands the identifiers (t; E Id). An identifier :=;tanding alone is an "unknolo'n" having no predetermined meaning of its own - in contrast to tile constants. The way one wishes to use identifiers, ho,,"'ever, is to give them te1';po:r'ary meanings which can be altered within the differing scopes of different operators. The way to indicate a temporary assignment of meanings is by a function
p rd ... rs .... SJ

which we call (the current) environment of the identifiers. We use lS + SJ here because in the elementary command language the values of the variables are to be command values. In other languages with other types of variables other types of values would have to be used.

Let us write for short:


Env'" [Id + [5 + SJJ.


Now 1t will no 10I'.ger be true that a command has a "fixed" value,

bec~se our syntax allows y E Cmd to contain variables.
ehave to do is to redefine so that

What we

~: Cmd + [Env + [S + 5)).

e[That is to say, given y E Cmd, we do not evaluate at once yn

but rather have to provide the current 0 E Env to finde~y~ (p) as

a state transformation.

eThe details of this redefinition of

will require alt~

erations of the environments. Our notation for this is the
following. Suppose r. E ld, 8 E [5 + 5J. and 0 E Env. Then

p[8/0 E Env

is that environment p' which is just like p except for the one i dentifier ~ where we define

p 'Hf = e
(Thus p' '" PI:8/0 is the modl~f{cation of the function 0 just at the argument r, to have the prescribed value 8.) Generalizing this idea we can also .;rite
p[8 n /r,n J

27

where en E [5 -+ SJ". the set of n-tuples of sta.te transformations. IleTe E;:n is a group of n distinct identifiers and the alteration changes all the ~I values of the original P. (These defInitions require just a bit more rigor when Id is taken as a lattice in the more abstract version of syntax of Scott [6J.)

We can now state the revised clauses of the semantical
definition for t'. (The function Eo retains its former definition, because in this simple language Boolean expressions contain no
identifiers. )
t'!(y)](p) ~tlYncp), t:~¢>~(P) -'= (some given S + S).
tldummyD(p) = I,
e"n (p) ~ pHI,
t i E · Yo .YI)lp) -'= CondCCIYo](p),efYI l(p»·&[£I,
t:'[Yo ;YI](P) = eiYI~(p)o~iyo](p). l:'1§E;:n:ynUIPJ: M~(Jo.en.~[ynl(p[8'I!I;;TI]»).

These clauses are quite similar to the previous ones. except that the environment is dragged along into the interpretation of each compound command. It is invoked whenever an identifier stands in the place of a command (giving p[f.;) in the fourth claust!). It is altered whenever identifiers are bound as formal parameters. This last clause requires a gloss.

First off if pr E Env, then
t:rRynHp'l :_-<egYll-l(DI}-J"'~Yn_li(p'»

where yn = YO'Y1'" "Yn-l is an n~tuple of commands. the metaexpre ssion

Therefore

t'nyn] (p[tJn(f.;n J )

can be regarded as a funotion of the n-tuple en E [5 + S]n whose values are also in [5 + 5]n. The ),,-expression

)"sn.tlyn) (p[Sn(/;;TI J )

is just the name of that function in the domain [S + 5J n + [5 + 5]n.

The i-operator used in the equation above is then to have the

28

logical type

[[5 ~ 5]n ~ [S ~ SJnJ + [S

s )n.

(Cf. t~e end of the last section taking 0 '" ["5 .... SJn.J The value
of this Y-operator is an n-tuple, and /.fno is the selector function
such that
M~«eo.e~,...· en_~» = 8 0 ,
What we are doing here, then, is finding the least solution to the equation (really: a system of n equations)
<eoJe~ ···· ,en_1> '" t[ynj(p[Sn/.;n))

and setting

t tI ~ F,n : .. (,~ p) = eo'

Our mathematical equations describe this process rather succinctly with the aid of the vari~us functfonal-op-erators. At first- 5-ight these operators seem horrendous. but actually they are not hard to read. Furthermore they hide just the right things leaving the structure and sequencing of the operations quite apparent. It would also seem to be an advantage to condense the various clauses to one or two lines: if one can actually write equations in detail, he may have a chance of proving a theorem. And his chances are improved if the equations are not too long. It remains to be seen, admittedly. whether the method is going to be really practical for more complex languages.

In the introduction we spoke of models for a theory, and it will be useful now to return to this discussion in the present context. The concepts of our language are separated into two kinds: the pI'imitive notions and the logical cons tructs which are built on these. In the simple command language the primitive notions are the set of states S and the objects denoted by the '!T'S and ~'s. Let us introduce explicitly syntactical categories for these:

w E Pred and ¢ E Op

for the atomic predicates and operations. All the other concepts like the Boolean values, the conditional expressions, the sequencing and looping of commands are treated as logical notions with fixed

29 meanings. The only chance fOT variation then lies in the primitive concepts. The interpretation of them would be established by gi ving mappings
IP : Pre d -+ [S -+ T x 5 ]

and ~ Op -+ [5 -+ 5]

once 5 has been determined. line models aTe given as:

We could then say that in broad out

JM. = (5 ,'J\O>

because once these features aTe specified the meanings of all ex pressions in the language aTe fixed. Of course all we have explained here is the log7:cal types of tp and 1:'. but that is all one needs to give the semantical definitions for

'eJ1,: Cmd -+ [5 ... 5)

and
~I\: Exp -+ [5 ... T x SJ.
e(That is. in the semantical defini tions we should replace by C..
and 8, by ~b1 and modify the atomic clauses to read:
StUD (~) o~O'H>] and &J1.ITTU ='lPUnD.
By the way. in Scott [6] the 0' and the 1> were treated as para meters and it was noted that with S fixed both ~and~are continuous in these paTameters.)

With this point of view we can specialize and vary.t1 in restricted classes that actually are models for some reasonable concept of computational structure ~ as we contemplated for various models of the theory of integers. Besides this we can compare two models. Thus if Yo and Yl are two commands, we say that they are equivalent. in 11 iff
~(yo I = ~[Yd.
It may very well be that '(g and '(I are equivalent in 1M but not in ti'. That may be an interesting fact. Whether it is or not. we can at least say what we mean with the aid of our semantical definitions.

30

5. PROCEDURES. The language features discussed up to this point

have been of the most elementary sort and were kept simple just fOT

the sake of illustration. Even so the mathematical entities

associated with the commands and expressions ,",'erc involved enough.

Fortunately the level of complication that we have reached is a

plateau on which a variety of other features can be accommodated

without too much additional effort. Among the features pressing

for recognition is of course the assignment 8tatement. No pro grarruning language c~n be called practical if it does not include

the assignment statement in some form. The issues surrounding

the proper interpretation of the assignment statement, however,

require a rather full treatment of their own, and this will have

to be reserved for another publication (Strachey [ll]J.

In

this section we select only one concept ~ that of a procedure

to discuss in any detailj IIt8inly because it .fits in well with our

previous discussion of identifiers and function spaces. Even with

this addition the language remains fragmentary. (In the syntax we

shall make provision for an assignment statement. but the semantics

of it and some other related ideas will only be briefly sketched.

These inclusions are made so that the reader can grasp something

of the style of the languages we are considering.)

In order to be able to include other concepts in our langlJage a substantial extension of the repertoire of expressions bey(){ld the Boolean level will be necessary. In some languages this is done through the introduction of a host of syntactical categories. This may be a practical idea to aid automatic syntax checking and error detection, but for understanding the language as a whole it is sometimes a formidable hurdle. For the sake of ex position we pretend that all the type checking is going to be done at :run time. Thus all the expressions that have values will be massed together into one category. Before we start to define the category we should stop to consider what the values are going to be.

We always need BooZean vaZues (TJ. and we may as we 11 throw

in at this point (integerJ al'ithmetio values (N).

If we will

31

be getting into assignments, then some expressions will have Locations (addresses) for values (L). Tn this paper we will not say too much about them. but we want to leave room for them. Next we bring up the suggestion that at some point one may \oIan t to store - or maybe pass as a parameter - a command. Hence we are going to allow elements of C = [S -+ 5] as values of express ions also. Finally we come to procedures (P).

A procedure is very much like a mathematical function.
Now some functions have restricted domains, while others are more widely defined. We do not ",·ish to consider here typed fUl1ctions.
,iso we shall attempt to permit OUT funcbollS free range of
arguments and values. The different sorts of values were just described in the last paragraph. Let \..IS put them together into one space. the va~ue srace~
v ~ T + N + L + C + P.

Again for simplicity we restrict attention to one_parameter pro cedures; that is, the domain of a function will be V itseH. The values will also turn up in V but the path cannot be so direct. Remember that every evaluation has to depend on the state of the system. and that any action generally has to effect a change of state. It will be just the same for procedures: evaluating a procedure at an argument may produce along with a value a change of state. This argument suggests that

p = [V -> [5_-> V x 5J].

Thus if r E P and x E V. then we cannot find a value from p(x) until
we look at 0 E 5. Then we get

p(.T:)(O) ,., <y.o'>

where y is the value and 0' is the (possibly) altered state. seems just fine.

That

Or does it? Suppose the state space were a one-dement space which could be dropped from consideration. Suppose that we are in a dropping mood and that we forget about N.L, and C as well. Then the equation for V comes down to:

32

V=T+P,

which after substitution reads:
v = T + [V -0- V].

In words we can say that under the reduction every element of V is eithu' a Boolean value Or' a function. It still sounds good, but there is trouble: in ordinary set theory there are no such spaces! Why? Because there is a cardinality question. V must have at least two elements; but if so, then by Cantor's Theorem the space of a;~ functions [V .... VJ always has more elements than V. Hence, the equation is impossible.

Here is the place where the lattice-theoretic pay-off is

especially generous. By restricting [V + VJ to continu.ous functions

the cardinality of the function space is considerably reduced. That

is a help. but it is oot- enou-gh-just to have V and T + EV .. VJ in

anyone-one correspondence. The correspondence must be continuous;

then everything is fine, because we can rest assured that all our

functional equations involve only continuous functions. (Remember.

to be able to use a function as an argument of other operators, we

must keep it -inside the proper spaces.) The way to achieve a con

tinllous isomorphism is not quite obvious and demands 8n inductive con

struction. Some rem8rks are given in Scott [S]

and further hints

arc found in Scott [6].

The full details will be presented in

papers under preparation (see references in the bibliography). In

any case the outcome is that the construction of such self-referential

spaces is not only possible, but they can be made to suit a variety

of purposes - as long as one can be happy "ith continuous fur,ctions.

Since we can argue that computability theory is happy with continuous

functions, all is well, and the existence of the big value space V

can be taken for granted.

All right. what then is the (a) language that might go along "ita V? {The authors have the peculiar idea that the domains of our concepts can be quite rigorously laid out before we make final the choice of the language in which we are going to describe these concepts. And it may turn out that the same domain is suitable for several languages. This is not to deny tha t there may be some vague ideas

33

of language which influence our choice of domains. What we suggest is that, in order to sort out your ideas, you put your domains out on the table first. Then we can all start talking about them.) A possible format of the language would retain the distinction in category between Cmd and Exp. (This is a point one might liish to debate - but we do not have the space to do it here.) It is Exp that will undergo the major expansion over the earlier language, 50 we give Cmd first:

COMMANDS

y'~ (y)I.ldummy!,1
(; -... "Yo. Y1 I Yo ; Y. § ~1J:yntl
i£.! £0 : =; E I

This looks almost the same as before except for the last two clauses. Since we will convert commands into expressions. the E! is needed for the reverse process. rhe Eo :=£1 is the assignment statement taken as a cornman d to make the required assignment.

Turning now to expressions we must take note of the five parts of V:

EXPRESSIONS

.. ~ (,) I" I, I
cTltrue!false]Eo+EI.El!Eo=CII
E:NlvIEoWEI
E:lltEI+EI
"C I ,y I
E:pIACEIEoEII "y resultis E

Note that identifiers occur in both Cmd and Exp. Some may wish to avoid the overlap, but it actually does not cause any difficulty, because we will separate values in a moment.

Before trying to understand the features of this language. it will be well to state the exact logical types of the sernantical functions. An identifier will be assigned an element either from C 01" from V depending on how it is to be used. This means that nOl.' we shall have to set:

34
Env [Id + C + II].

Strictly speaking C. II and C + II are all different domains even though the first two are matched with parts of C + V. We shall requin a more precise notation to indicate this matching. A completely precise symbolism would be cumbersome, so ...'e write

(8 in [C + II]) and (,6 in [C + II])

where 5 E C and .B E II to indi cate the eorr'e8ponding clements of C + II. For is E C + V we wTi te
ale and ~IV

to indicate the "projection" from C + V onto its two parts. (In case ~ corresponds to an element of C, then 61 II = .L; and if 8 comes from V. then 0 I C =.L. The lack of precision becomes clear for spaces such as C + C where one would havE' to distinguish between left- and right-hand paTts-.)

The logical types of the functions e' and fr. now will be these;
E': Cmd + [Env .... [S ... SJJ

and

& Exp + [Env .... (S ... V x SJJ

We shall not state all the semantical equations, since either they have already been discussed enough for thE' ~impler languagE', or thE'y require too much additional development. But a few can be shown.

For the case of identifiers, we use:
l:[(l(p) ~ plU Ie

and

&[f.;i(p)

Au.<pH~ IV,D>,

which keep the types straight. Note that in the latter equation we had to make the right hand side a function of IT E S with values in V x S. The point is that if we ask for the value of ~ as an expnsslon relative to the environment and the state of the system,
then the answer is to be just P(E.;) I V without any change of state.

Wi th the two new kinds of commands, we have in the first instance:

tnc!Dtp) = Do_&[e:!(p).
where Do is a special operator defined as follows. Do V ->- [5 -+ 5 J ,

35

and

Do(6)(0') = (S!C)(rJ').

By this we mean to indicate that C IJ. Thus i f

[S -+ SJ is itself a part of

&[e:E(p)(I1) = <13.0'>,
then we project B into siC and apply that to 0' obtaining
0" = (eIC)(o').

That is the resultant Change of state in executing e:! so that t'nc!)ep)(a) = 0"

In the second instance, the assignment command, the sequence of events is more complicated.

In this paper we shall not try to wri te the equation for

eKEo :=£11 (p)(a),
but we can say in words more or less what happens. evaluate

We first

and project t3 to a.

&[£o](p)(O) = <13,0'>.
SIL. aJDcation. Next we evaluate:

&(cdCp)(a') = <13'.0">.

Now comes the scuffle, If t3' is not in the part of V which comes

from l, we set 13" = 13'

However, if 13 ' does correspond to a

location, then we consider (I' '" S'lL. At this point we reveal that

these mysterious "states of the system" are the internal states of

our hypothetical machine. That is to say, 0" represents (among other things) the current st~te of the memory of the machine - a

memory which provides contents for locations. Thus there is a

function to be applied to extract the desired contents. and we can

wri te:

36

err = Contents(o.')(a").

e"In any case we have

E V. Finally there is one last transformation

e"to be made: we have a location (l and a value

and the current 5 tate

e"Oil All that remains is to assign to 0. in air obtaining:

0'" =As8ign(a,6")(o").

We then assert that the equation:

eh:o ;=E1 ll(p)(a) = 0'"

makes the interpretation of the command what is usually intended.

Well, that is reasonably precise, but it only becomes completely

rigorous when we give an explicit oonstrL<otion of S as a domain of

internal states along with the concomitant functions Conte'lts and

Assign. [ 11],

The exposition of these ideas is the task of Strachey

Shifting now to the semantics of expressions, the compounds of the sort E:D are meant as Boolean valued predicates which dis
tingu~h between the various parts of V; namely, 0 = T,N,l,e or P
Take note of the fact that T has been made a part of V so that after a Boolean value t E T has been found. it will havE' to be injected into V. For example. to find the value of

r.crI:O=I:I~(P)(O)
we have to evaluate Eo. then E., then see if they belong to the samE' part of V. If they do and the part is T ,N, or l, then a test for equality is meaningful. We carry the test out, get a truth value. and then wrap it up into V. Remember too that the state of the systel'l will have been changing.

We need not discuss here the evaluation of numerals (v) or ari thllJetic operations (w). The mysterious operators t and + are for J',>fel'en~ing and deroeferoencing - operations involving locations. Thus to evaluate:

&HE](p)(o),

we have to find first:

fo[ E I ( p) (0 )

<6,0';' .

Then we have to find a new (unused) location a in a and take

a" = Assigrda,6)(LT'),

making

8ItE](p)(O)=<Ci,O">.

In other .... ords tE gives a reference to the value of c. Obviously we want +E to be the opposite: E is evaluated as having a value in L and then the conter.t-s of the current state of the system pro vide the value for +£.

In the case of commands as expressions we take

&[:y](p){O) = <C:lyE(p) i!'1 V,o>.

Note especially that no change of state has taken place and that tnI') (p) has not been activated. The command has been "read", so to speak, but it has not been executed. Why do we do this? Because one may .... ish to store a command or to pass it as a parameter without executing it. In that way it can be set up and then set aside fnr later use.
Before we finish our survey of the semantics with a look at procedures, the res.ult;s-construct can be given a quick explanation:

&Ry resultis eJ(p) = &[E:](p)oE'[yB(p)

That is to say, do I' first, then evaluate c. This combination is very similar to Yo ;y. but is of a different syntactical category.

Finally, we come to procedures where the notation llsed in the languagE:' is just that of the functional abstraction/functional application sort. Abstraction is easy:

&[)"CE:j(p)(O) = <f in V,o>,

where f E Pis de fined by

f = A6.&ld\p[B in C+V/O).

Here 13 E V an d

f : V ~ [S + V x SJ
comes out correctly by reference to the logical type of &.

Note

38

that tile evaluation of a functional abstraction requires no change of statr, This is reasonable because none of the state trans formations that may be lurking in £: can come out in the open until we knO'!.. the value of ('j. This cannot be known at the time the function is defined; we have to wait until it is applied to an argument.

Application can be interpreted in at least two ways. We take a more di reet path - which might not be the most flexible. Thus to evaluate:

&;Jl Eo Ed (p) (0).

first find

and set f

61 P.

&[EU] (p)(a) Then find

0( 8,0') ,

and set

&KEI] (p)(o')

0( S' ,0 ">,

&[£oEd(p)(o) = 1(6')(0").
(The "indirect" route ""Quld test S to see if it were an L, if so all it would require is to look up the contents of thnt location and try to use that value. If B were not in the L part of V, then ",c would proceed as above.)

By the time we got around to the procedures there was not so very much to say. The point is of course that

ACE

is but one clause of a highly recursive definition. The £: can be any compound expres~ion. Thus the value of Ai;.. E is a complicatE'd function. The construction of our value space allows us to treat this function (a m~thcmatical object) just like any other value. It can be used as an nrgument of another function. it can be stored, it can be thought about in a nlathematical way.

39
6. CONCLUSION There are many features l"issinF fTOI!' the lan~u£ige at the last section; to name a few: lists, structured values, initiali2.ation of parameters, mOTC flexible parameter passing, recursive procedure definitions. This last is very iJllportant. Even though the space
[v-..[s .... v"SJJ
contains all the values of procedures · ...:c gave no notation faT re cursively defined procedures the way we did for recursively defined commands. The reason for passing oyer that topic is the difficulty in keeping track of the state transformations involved in such definitions. This will have to be a topic faT another essay.
Despite the shortcomings of the present exposition, we do feel, however, that we have demonstrated the possibility of a math ematical semantics for sophisticated languapes. And we hope by now the reader understands what we mean by "mathematical semantics". In this approach the semantical functions give mathematical values to expressions values related to some given model. The values of expressions are determined in such a way that the value of a whole expression depends functionally on the values of its parts the exact connection being found throup,h the clauses of the syn tactical definition of the language. In this way the syntax is kept to a minimum so one can concentrate on the semantical inter pretation.
The advantages of the method arc many. In the first place we feel that it gets at the essence of meaning: without having to formalize any bookkeeping, symbol tahles, identifier lists, road maps or what have you - as is necessary in some lang:uage definitions. Furthermore, the method is conceptual and is not just a formal trans lation from one language into another. Sometimes the translation scheme is useful, but usually a full translation, say into the lang:uage of an "abstract" machine, makes it hard to discuss the features of the o"riginal language in isolation. As we have shown above we can move through the lanpuage one clause at a time, stopping to get a clear understanding o-f each construct by itself.

"

The present paper is on~ of a series that is the outcome of a collaboration which the authors started in the fall of 1969; further papers are mentioned in the references. As it no~ stands this t~eory falls into two rather distinct parts: th~ development of tht appropriate mathematical apparatus, and its application to the application of programming languages. From a logical point of view the development of the mathematical foundations should obviously precede their application, but as often happens it is difficult'to kna ... exactly what mathematical apparatus is needed until some applications have been attempted.
The genesis of this approach is a paper given at a Working Conference on Formal Language Description Languages sponsored by ]FIP in September 1964 (Strachey [10]). Although that paper contained the beginnings of the semantical ideas described here'. it was quite unsatisfactory "from a- mathematical point of vie....'. Not only lias there no attempt at mathematical rigor, but the very existence of some of the objects used was not certain. For example, referring again to the domain mentioned in §5 which is quite naturally associated with interpretations of reasonable languages;
v ~ T + N + L + [S · S] + [V. [S · V x 5]],
it is particularly important to note that such a domain cannot be constructed by ordinary set-theoretical means. Hence, the need for some such mathematical apparatus as we have presented here was forc~d on us. The present paper co\'ers much the same ground as Strachey {lOLbut this time the mathematical foundations are secure. It is also intended to act as a bridge between the formal mathematical foundations and their applications to programming languages by explaining in Some detail the notation and techniques we have found to be most useful.
Very much work remains to be done. An essential topic will be the discussion of the relation between tlle mathematical semantics for a language and the implementation of the language. What we claim the mathematics will have provided is the standard against which to judge an implementation. Thus if >'CE is a function definition, then our semantics tells us which function - as a math

41
ematical object - ""as inter,,~ed. Any implementation must provide us with answers that are in complete harmony with this function in the same way we expect even the simplest desk calculator to be able to add. An interesting question here is ""hether the function defined by '\/;.(: is calculable at all - in any sense. All of these questions are basic and do not even make sense without the proper mathematical foundation, which is just what we think our theory provides.

42 REFERENCES

[1] [2] [3] [4] [S]
[6J [7] [8J [9] [10]
[11]

Erwin Engeler, ed .· Semantics of Algorithmi c Languages, Springer Lecture Notes in Mathematics, vol. 188 (1971).
Donald E. Knuth. Semantio~ of Context-FJ'ee Language8. Mathematical Systems Theory. vol. 2 (1968). pp. 127-145.
· examp~eB of Formal. Semantics, in [1). pp. 212-235.
David Park, Fixpoint Induction and Pl'oofs of Program Propel'ties. in Machine Intelligence 5 (1969). pp. 59-78.
Dana Scott, Outl.ine of a Mathematioal. Theo:roy of Computation, in Proc. of the Fourth Annual Princeton Conference on Information 5cieflces and Systems (1970), pp. 169-176.
The Lattice of Fl.ow Diagrams, in [1]. pp. 311-366.
Continuous Lattices, in Proc. Dalhousie Conference. Springer Lecture Notes, in press.
, Lattl-ce-tlleoretic Models for Various Type-free Calculi, in preparation.
· Data Types a8 Lattices, in preparation.
Christopher Strachey, Towards a Formal Semantics, in
Formal Lan9uage Description Languages, r. B. Steel, ed.,
North Holland (1966), pp. 198-220.
, An Abstract Model for Storage, in preparation.

Programming Research Group Technical ~Ionographs

This is a series of technical monographs on topics in the field of computation. Further copies may be obtained from the Programming Research Group, 45 Banbury Road, Oxford, England, or, generally, direct from the author.

PRG-l

Henry

r. Ledgard
Production Sy8tem8: A FOT'mali8m for Specifying
:he S1:lr1ta.x and Translation of ComputeT' Lang1J.1ges. (£1.00, $2.50)

PRG-2

Dana Scott Old b:ne of a Mathematical Theol'y of Computation (£0.50. $1.25)

PRG-3

Dana Scott The Lattice of Flo~ Diagrams ('1.00. $2.50)

PRG-4

Chris tophc r St rachel' An Abstract Model for Storage (in preparation)

PRG-5

Dana Scott and Christopher Strachel'
Data Types as Lattices (in preparation)

PRG-6

Dana Scott and Christopher Strachey

Toward a Mathematical Semantic8 fo'!' Computer

Languages.

(£1.00, $2.50)

.PRG-7

Dana Scott Continuous Lattices

(£l.00. $2.50)

