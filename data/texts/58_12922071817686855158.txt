DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS

23

CATEGORICAL PROGRAMMING

WITH

INDUCTIVE AND COINDUCTIVE

TYPES

VARMO VENE

TARTU 2000

DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS

23

DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS

23

CATEGORICAL PROGRAMMING

WITH

INDUCTIVE AND COINDUCTIVE

TYPES

VARMO VENE

TARTU 2000

Faculty of Mathematics, University of Tartu, Estonia

Dissertation accepted for public defense of the degree of Doctor of Philosophy
(PhD) on May 26, 2000 by the Council of the Faculty of Mathematics, University
of Tartu.

Opponent:

PhD, University Lecturer

Jeremy Gibbons
Oxford University Computing Laboratory
Oxford, England

The public defense will take place on Sept. 3, 2000.

The publication of this dissertation was ﬁnanced by Institute of Computer Science,
University of Tartu.

c(cid:13) Varmo Vene, 2000

Tartu ¨Ulikooli Kirjastuse tr¨ukikoda
Tiigi 78, 50410 Tartu
Tellimus nr. 365

CONTENTS

1

2

Introduction
1.1 Motivation .
1.2 Overview of the thesis
1.3 Notation .

.

.

.

.

.

.

.

.

. . . . . . . . . . . . . . . . . . .

. .

. .

. . . . . . . . . . . . . . . .

. .

. .

. .

.

. . . . . . . . . . . . . . . . . . .

Initial algebras and catamorphisms . . . . . . . . . . .
. . . . . . . .

Inductive and coinductive types
2.1
2.2 Terminal coalgebras and anamorphisms
2.3
2.4 Related work .

. . . . . . . . . . . . . . . . . . .

Implementation in Haskell

. . . . . . . . . . . . . .

.

.

. .

. .

. .

3 Primitive (co)recursion

. .
. . . . . . . . . . . . . . . . . . .

3.1 Primitive recursion via tupling . . . . . . . . . . .
3.2 Paramorphisms .
3.3 Apomorphisms
.
3.4 Para- and apomorphisms in Haskell
3.5 Related work .

.
. . . . . . . . . . . . . . . . . . .
. . . . . . . . .

. . . . . . . . . . . . . . . . . . .

.

.

. .
. .

. .
. .

. .
. .

. .

. .

. .
. .

. .
. .

. .

. .

. .
. .

. .
. .

. .

. .

. .
. .

. .
. .

. .

9
9
. 12
. . 14

15
. . 15
. . 22
. 26
. . 31

33
. . 33
. . 35
. 40
. 43
. . 45

47
. . 47
. . 50
. 55
. 58
. . 61

4 Course-of-value (co)iteration

. .
4.1 Course-of-value iteration via memoization . . . . .
. . . . . . . . . . . . . . . . . . .
4.2 Histomorphisms .
4.3 Futumorphisms .
. . . . . . . . . . . . . . . . . .
4.4 Histo- and futumorphisms in Haskell . . . . . . . . .
4.5 Related work .

. . . . . . . . . . . . . . . . . . .

.
.

.

.

. .
. .

. .
. .

. .
. .

. .

. .

5 Mendler-style inductive types

5.1 Mendler-style inductive types: covariant case . . . .
. .
5.2 Conventional inductive types reduced to Mendler-style inductive

. .

. .

63
. 63

types .

.

.

.

. .

. .

. . . . . . . . . . . . . . . . . . . . . . .

5.3 Mendler-style inductive types: mixed variant case . .
5.4 Restricted existential types . . . . . . . . . . . . . .

. .
. .

. .
. .

5

. . 66
. 69
. 72

. .
. .

5.5 Mendler-styles inductive types reduced to conventional inductive

types .

.

.

.

. .

. .

. . . . . . . . . . . . . . . . . . . . . . .

5.6 Mendler-style inductive types in Haskell . . . . . . .
5.7 Related work .

. . . . . . . . . . . . . . . . . . .

.

.

. .

. .

. .

. .

. .

. . 75
. 78
. . 82

83
. 84
. 85
. . 89
. . 94
. . 97

6 Mendler-style recursion schemes

.

6.1 Simple iteration .
. . . . . . . . . . . . . . . . . .
6.2 Primitive recursion . . . . . . . . . . . . . . . . . .
6.3 Course-of-value iteration . . . . . . . . . . . . . .
. .
6.4 Mendler-style recursion operators in Haskell . . . . . .
6.5 Related work .
. . . . . . . . . . . . . . . . . . .

.

.

. .
. .

. .
. .

. .
. .

. .
. .
. .

. .
. .
. .

7 Conclusions

7.1 Summary . .
7.2 Future work .

. .
.
.

References

Kokkuv˜ote

Acknowledgements

. . . . . . . . . . . . . . . . . . .
.

. . . . . . . . . . . . . . . . . . .

. .

. .

. .

. .

. .

99
. 99
. . 100

102

109

111

6

LIST OF ORIGINAL PUBLICATIONS

1. Varmo Vene and Tarmo Uustalu. Functional programming with apomor-
phisms (corecursion). Proceedings Estonian Academy of Sciences: Phys.,
Maths., 47(3):147–161. Sept. 1998.

2. Tarmo Uustalu and Varmo Vene. Primitive (co)recursion and course-of-
value (co)iteration, categorically. INFORMATICA, 10(1):5–26, March 1999.

3. Tarmo Uustalu and Varmo Vene. Mendler-style inductive types, categori-

cally. Nordic Journal of Computing, 6(3):343–361. Autumn 1999.

4. Tarmo Uustalu and Varmo Vene. Coding recursion a la Mendler (extended
abstract). In J. Jeuring, ed., Proceedings 2nd Workshop on Generic Pro-
gramming, WGP’2000, Ponte de Lima, Portugal, 6 July 2000, Tech. Report
UU-CS-2000-19, Dept. of Computer Science, Utrecht Univ., pp. 69–85.
June 2000.

7

8

CHAPTER 1

INTRODUCTION

1.1 Motivation

Data types are one of the key components of every program. They allow to or-
ganize values according to their purpose and properties. Already the very ﬁrst
programming languages had some concept of data types, containing at least a
ﬁxed collection of base types, like integers, reals, characters, but also means to
form compound data types like records, arrays or lists. Soon it was realized (e.g.
by Hoare [Hoa72]) that the structure of a program is intimately related with to the
data structures it uses. Hence the ability to express and manipulate complex data
structures in a ﬂexible and intuitive way is an important measure of the usability
and expressiveness of a programming language. Especially notable in this respect
are modern functional languages like Haskell [PJH99] and ML [MTHM97] which
possess rich type systems supporting algebraic data types, polymorphism, static
type checking, etc.

In this thesis we explore two particular kinds of data types, inductive and
coinductive types, and several programming constructs related to them. The char-
acteristic property of inductive types (like natural numbers or lists) is that they
provide very simple means for construction of data structures, but in order to use
these values one often needs recursion. Coinductive types (like streams, possibly
inﬁnite lists) are dual to inductive ones. They come together with basic operations
to destruct the values, however, their construction often involves recursion. Gen-
eral recursion can be quite difﬁcult to reason about, and it is sometimes called the
goto of functional programming.

In this thesis we use a categorical theory of initial algebras and terminal coal-
gebras as the abstract framework for inductive and coinductive types. This ap-
proach is attractive, as it equips (co)inductive types with generic (co)iteration op-
erations. As these operations capture a very simple form of recursion, namely
the structural (co)recursion, they are very easy to reason about. While the class

9

of functions expressible easily in terms of (co)iteration is quite large, not all
useful functions fall under it. The main objective of this thesis is to ﬁnd new
(co)recursive operations which capture some useful programming constructs, but
still possess nice reasoning properties.

Algebraic data types in Haskell

Algebraic data types as provided by Haskell are intuitive yet powerful way to de-
scribe data structures. Essentially, new data types are deﬁned by listing all possi-
ble canonical ways to construct its values. For instance, the following declaration
in Haskell deﬁnes a new data type Shape together with two data constructors:

data Shape = Circle Float | Rectangle Float Float

Functions can manipulate such data types using pattern matching to “destruct”
the data structure into its components:

perimeter :: Shape -> Float
perimeter (Circle r)
perimeter (Rectangle h w) = 2 * (h + w)

= 2 * pi * r

Data deﬁnitions can be recursive allowing to describe data structures of varying
size. For instance, below are deﬁned natural numbers and (polymorphic) lists as
recursive data types:

data Nat
data List a = Nil | Cons a (List a)

= Zero | Succ Nat

Functions which operate on recursive data types are often recursive too. For in-
stance, below is deﬁned a function which ﬁnds the sum of the elements in the
argument list (here we use the standard notation for lists in Haskell, where []
denotes the empty list, i.e. the Nil constructor above, and (:) corresponds to
the Cons constructor):

:: [Int] -> Int

sum
sum []
sum (x:xs) = x + sum xs

= 0

The deﬁnition can be read as follows: the sum of the empty list is 0; in the case of
non-empty list, the sum of the whole list is obtained by adding the head of the list
to the sum of the tail of the list.

10

Folds

The same recursion pattern, occurs so often when deﬁning list processing func-
tions, that Haskell provides a standard higher-order function which captures its
essence:

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f b []
foldr f b (x:xs) = f x (foldr f b xs)

= b

For instance, the sum function can be deﬁned using foldr as follows:

sum = foldr (+) 0

Below are some other useful functions deﬁned as instances of foldr:

= foldr (\x n -> 1+n) 0

length
xs ++ ys = foldr (:) ys xs
map f

= foldr (\x xs -> f x : xs) []

The ﬁrst function computes the the length of the argument list, the second concate-
nates two lists, and ﬁnally, the third maps the given function to the every element
of the argument list.

The function foldr has a very nice algebraic reading: it “replaces” the binary
list constructor (:) by a binary function f, and the empty list [] by a constant
b; i.e. foldr f b is a homomorphism between the algebras formed by list con-
structors and by f and b. This observation leads naturally to the generalization
of foldr to other algebraic data types, and forms the basis of the categorical
treatment of the inductive data types. For instance, the function which “replaces”
constructors of natural numbers can be deﬁned as follows:

foldNat :: (a -> a) -> a -> Nat -> a
foldNat f b Zero
foldNat f b (Succ n) = f (foldNat f b n)

= b

Calculating with folds

The function foldr satisﬁes two important laws. The ﬁrst law, known as identity
law, is rather obvious. It states that “replacing” the constructor functions with
themselves gives the identity function:

foldr (:) [ ] = id

The second law, known as fusion law, gives conditions under which intermediate
values produced by folding can be eliminated:

h (f a b) = g a (h b) ⇒ h ◦ foldr f b = foldr g (h b)

11

To illustrate the use of these laws (and also the structured calculational proof
style [Gru96] we use throughout the thesis) we give a proof of the fact, that map
is a functor. First, the proof that map preserves identities:

=

=

=

map id
foldr(λx xs → id x : xs) [ ]

– deﬁnition of map –

– deﬁnition of id –

foldr(:) [ ]

– identity law –

id

Next, we use fusion to show that map preserves compositions:





=

=

=



=

=

=

map f ◦ map g
map f ◦ foldr(λx xs → g x : xs) [ ]

– deﬁnition of map –

– fusion law –

– deﬁnition of map –

map f (g a : [ ])
foldr(λx xs → f x : xs) [ ] (g a : [ ])
f(g a) : foldr(λx xs → f x : xs) [ ] [ ]

– deﬁnition of foldr –

f(g a) : map f [ ]

– deﬁnition of map –
foldr(λx xs → f(g x) : xs) [ ]
map (f ◦ g)

– deﬁnition of map –

The identity and fusion law for foldr can be proved by induction over lists.
However, in categorical treatment of the inductive data types as initial algebras,
these laws are simple corollaries of the initiality. Hence they are not speciﬁc to
foldr and folds for any inductive data type satisfy similar laws.

1.2 Overview of the thesis

In this thesis we develop new recursion combinators that capture more complex
recursion patterns than simple (co)iteration but still possess nice reasoning prop-
erties.
In particular, we consider combinators for primitive (co)recursion and
course-of-value (co)iteration.

It is well known that the primitive recursion can be simulated by a simple it-
eration which computes a value paired together with the argument, and that this

12

construction leads to the notion of paramorphism which captures the primitive re-
cursion directly. We will show, that the obvious dualization of this construction
leads to notion of apomorphism which captures the recursion pattern known as
primitive corecursion. More importantly, we will also show that a more involved
generic simulation of memoization by iteration leads to the notion of histomor-
phism, a direct formalization of course-of-value iteration, and describe the dual
notion of futumorphism, a formalization of course-of-value coiteration.

Inspired by type-theoretic work by N. P. Mendler [Men87, Men91], we will
introduce the concepts of Mendler-style algebra and homomorphism and treat in-
ductive types as initial Mendler-style algebras. From that basis, we will introduce
Mendler-style analogs for the cata, para and histo combinators. From the theory
developed, it appears that Mender-style recursion combinators are just as well-
suited for program calculation as the conventional ones, but support a program-
ming style more close to customary (general-)recursive programming.

The remainder of the thesis is organized as follows: Chapter 2 reviews the
conventional treatment of inductive and coinductive types as initial algebras and
terminal coalgebras of a functor. The calculational properties of basic iteration
and coiteration are studied.

Chapter 3 studies the properties of operators corresponding to primitive recur-
sion and corecursion. This is the ﬁrst chapter which contains our original contri-
bution. Namely, we formalize primitive corecursive functions as apomorphisms,
and show their utility on several simple examples (the “standard” example being
the concatenation of two colists).

The next three chapters contain our main contribution to the theory of cate-

gorical data types.

Chapter 4 is devoted to course-of-value iteration and coiteration. They are
formalized respectively as histo- and futumorphisms, the latter being functions
which generate several elements of codata type at once.

Chapter 5 presents an alternative treatment of inductive types as initial Mend-
ler-style algebras. It shows that, in the case of covariant functor, the conventional
treatment coincides with the Mendler-style one. However, Mendler-style induc-
tive types can be deﬁned also for mixed variant base functor. In this case, it is
shown, that if certain restricted existential types are available, then Mendler-style
inductive types are equivalent with the conventional ones, but for a different (co-
variant) functor.

Chapter 6 uses Mendler-style algebras to deﬁne recursion operators which
operate on conventional inductive types. Mendler-style versions of cata-, para-
and histomorphisms are formalized and their properties are studied.

The concluding chapter 7 outlines possible future work.

13

1.3 Notation

Throughout the thesis C is the default category, in which we shall assume the
existence of ﬁnite products (×, 1) and coproducts (+, 0), as well as the distribu-
tivity of products over coproducts (i.e. C is distributive). The typical example of a
distributive category is Set — the category of sets and total functions.
We make use of the following quite standard notation. Given two objects A,
B, we write fst : A × B → A and snd : A × B → B to denote the left and
right projections for the product A × B. For f : C → A and g : C → B,
pairing (we also use name fork) is the unique arrow (cid:104) f, g (cid:105) : C → A × B, such
that fst◦(cid:104) f, g (cid:105) = f and snd◦(cid:104) f, g (cid:105) = g. The left and right injections for the
coproduct A + B are inl : A → A + B and inr : B → A + B. For f : A → C
and g : B → C, case analysis (we also use name join) is the unique morphism
[ f, g ] : A + B → C, such that [ f, g ] ◦ inl = f and [ f, g ] ◦ inr = g. Besides,
given an object C, we have the unique morphism !C : C → 1. The inverse of the
canonical map [ inl× id, inr× id ] : (A×C)+(B×C) → (A+B)×C is denoted
by distr : (A+ B)× C → (A× C)+(B× C). Finally, given a predicate p : A →
1 + 1, the guard p? : A → A + A is deﬁned as (snd + snd) ◦ distr◦(cid:104) p, idA (cid:105).

14

CHAPTER 2

INDUCTIVE AND COINDUCTIVE

TYPES

In this chapter we review the traditional treatment of inductive and coinductive
types as initial algebras and terminal coalgebras of a functor.

2.1

Initial algebras and catamorphisms

Deﬁnition 2.1 (algebra)
Let F : C → C be an endofunctor on category C. An F-algebra is a pair (C, ϕ),
where C is an object and ϕ : FC → C an arrow in the category C. The object C
is the carrier and the functor F is the signature of the algebra.

Deﬁnition 2.2 (algebra homomorphism)
Let (C, ϕ) and (D, ψ) be two F-algebras. A homomorphism from (C, ϕ) to
(D, ψ) is an arrow f : C → D in the category C, such that

f ◦ ϕ = ψ ◦ F f

i.e. makes the following diagram to commute:

C

f

D

F C

F f

F D

ϕ

ψ

15

/
/




/
/
For any F-algebra, the identity arrow on its carrier is a homomorphism from
it to itself and also the composition of two homomorphisms is always a homo-
morphism, so we can deﬁne a category where objects are F-algebras and arrows
are homomorphisms between them. However we have to be a little careful, as the
same arrow from the base category can be homomorphism between more than one
pair of F-algebras. For instance, the identity arrow idC is a homomorphism from
any F-algebra with carrier C to itself.

Deﬁnition 2.3 (category of algebras)
The category of F-algebras over C — Alg(F) — is deﬁned by:

• Objects: F-algebras; i.e. arrows ϕ of C such that dom ϕ = F(cod ϕ).
• Arrows:

triples (f, ϕ, ψ) : ϕ → ψ where ϕ and ψ are F-algebras and

f : cod ϕ → cod ψ is a homomorphism from ϕ to ψ.
• Identity: idϕ = (idcod ϕ, ϕ, ϕ).
• Composition: (f, ϕ2, ϕ3) ◦ (g, ϕ1, ϕ2) = (f ◦ g, ϕ1, ϕ3).

Deﬁnition 2.4 (initial algebra)
A F-algebra (µF, in) is the initial F-algebra if for any F-algebra (C, ϕ) there exists

a unique arrow(cid:76) ϕ(cid:77) : µF → C making the following diagram commute:

F µF

F(cid:76) ϕ(cid:77)

F C

in

ϕ

µF

(cid:76) ϕ(cid:77)

C

i.e. satisfying the universal property:

f ◦ in = ϕ ◦ F f ≡ f =(cid:76) ϕ(cid:77)

cata-CHARN

sition κατ α meaning ‘downwards’).

The arrows in form(cid:76) ϕ(cid:77) are called catamorphisms (derived from the Greek prepo-
Alg(F), and the catamorphism(cid:76) ϕ(cid:77) is the mediating arrow out of it.

In other words, the initial algebra (µF, in) is an initial object in the category

The initial F-algebra may or may not exist. It is guaranteed to exist if F is
ω-cocontinuous (i.e. it preserves the colimits of ω-chains). All polynomial func-
tors (i.e. functors built up from products, sums, the identity functor, and constant
functors) are ω-cocontinuous and, hence, the initial algebras for them exist.

16

/
/




/
/
Corollary 2.1 Let (µF, in) be an initial F-algebra.
• Cancellation: For any F-algebra ϕ : FC → C
(cid:76) ϕ(cid:77) ◦ in = ϕ ◦ F(cid:76) ϕ(cid:77)

cata-SELF

• Reﬂection:

f : C → D

id =(cid:76) in(cid:77)

cata-REFL
• Fusion: For any F-algebras ϕ : FC → C, ψ : FD → D and an arrow

f ◦ ϕ = ψ ◦ F f ⇒ f ◦(cid:76) ϕ(cid:77) =(cid:76) ψ(cid:77)

cata-FUSION
Intuitively, the initial algebra in : FµF → µF denotes the collection of con-
structor functions for inductive data type µF, and the catamorphism is a simple
iteration. When read from left to right, the cancellation law can be viewed as the
reduction rule for terms where catamorphism is applied to a data constructor. The
reduction proceeds recursively by systematically replacing data constructors with
some algebra with same signature.
If constructors are replaced by themselves
nothing is changed. This is exactly what the reﬂection law claims.

The formal justiﬁcation on the identiﬁcation of inductive types with initial al-
gebras is given by the following fundamental theorem, known as Lambek lemma.
Its proof, albeit simple, provides a nice example of using above mentioned laws
in action.
Theorem 2.2 (Lambek [Lam68]) The initial algebra inF : FµF → µF is an
isomorphism with the inverse deﬁned as

in-inv-DEF
Proof. Note that in−1 has indeed the right typing; i.e. in−1 : µF → FµF. We
have to show that it is the pre- and post-inverse of the in. For the ﬁrst we argue:

in−1 = (cid:76) F in(cid:77)

– cata-FUSION –

– cata-REFL –



=

=

in◦(cid:76) F in(cid:77)
(cid:76) in(cid:77)

id

17

To show that it is also the post-inverse, we make use of the just shown fact (in the

step marked “see above”): 

=

=

=

=

– cata-SELF –

(cid:76) F in(cid:77) ◦ in
F in◦F(cid:76) F in(cid:77))
F (in◦(cid:76) F in(cid:77))

– F functor –

– see above –

F id

– F functor –

id

The theorem shows that the carrier of the initial algebra is (up to isomorphism)
a ﬁxed point of the functor. In fact, initial algebras generalize the notion of the
least ﬁxed point from lattice theory in the sense that if the base category is a
preorder and thus an endofunctor is a monotonic function then the carrier of the
initial algebra is the least ﬁxed point of the given function.

Example 2.1 (empty type)
In the category Set of sets and functions, the pair (∅, id∅) is the initial algebra of
the identity functor with the unique arrow out of ∅ as the required unique homo-
morphism. More generally, in any category with initial object, the pair (0, id0) is
the initial Id-algebra.

Example 2.2 (naturals)
Consider the set Nat = {0, 1, 2, . . .} of natural numbers with its zero and succes-
sor function zero : 1 → Nat and succ : Nat → Nat deﬁned by:

zero () = 0
succ n = n + 1.

Using join, these functions combine into a single function [ zero, succ ] : 1 +
Nat → Nat, forming an algebra of the functor N(X) = 1 + X. In fact, the pair
(Nat, [ zero, succ ]) is the initial N-algebra; i.e. µN = Nat and in = [ zero, succ ].
To show this, assume an arbitrary N-algebra (C, ϕ). We have to ﬁnd a function
f : Nat → C which is homomorphism and it should be unique. Because of every
arrow out of sum is join, ϕ = [ c, h ] for some constant c : 1 → C and arrow
h : C → C. So, the homomorphism condition for N-algebras states that f should

18

make the following diagram commute

1

zero

'OOOOOOOOOOOOOOOOOOOOOOO

c

Nat

f

C

succ

h

Nat

f

C

i.e. satisﬁes two equations

f ◦ zero = c
f ◦ succ = h ◦ f.

For instance, the sum and product of two naturals can be deﬁned as follows:

But this equation system has exactly one solution, namely the function deﬁned by
n (cid:55)→ hn(c()), which gives to us the required unique homomorphism.
add(n, m) = (cid:76) [ λx.m, succ ](cid:77)(n)
mul(n, m) = (cid:76) [ λx.m, λx.add(m, x) ](cid:77)(n).

The predecessor function pred : Nat → 1 + Nat which maps 0 (cid:55)→ inl() and
n + 1 (cid:55)→ inr n can be deﬁned by

pred = (cid:76) id +[ zero, succ ](cid:77)

i.e. it is the inverse of the initial N-algebra.

Parametric data types can be easily modeled by initial algebras using bifunc-
tors as their signatures. Let F : C × C → C be a bifunctor, then for any object A
we have an endofunctor FA : C → C deﬁned as FA(X) = F(A, X).
Example 2.3 (lists)
The data type of lists over a given set A can be represented as the initial algebra
(µLA, in) of the functor LA deﬁned by LA(X) = 1 + (A × X). Denote µLA by
List(A). The constructor functions nil : 1 → List(A) and cons : A×List(A) →
List(A) are deﬁned by

= in◦ inl
nil
cons = in◦ inr,

so in = [ nil , cons ]. Given any two functions c : 1 → C and h : A × C → C,
the catamorphism f = (cid:76) [ c, h ](cid:77) : List(A) → C is the unique solution of the

equation system

f ◦ nil
f ◦ cons = h ◦ (id×f),

= c

19

/
/
'


o
o


o
o
i.e., foldr(c, h) from functional programming. For instance, the function length :
List(A) → Nat which ﬁnds the length of the list, can be deﬁned as catamorphism

length = (cid:76) [ zero, λ(a, n).succ(n) ](cid:77).

As another example, the function concat : List(A)× List(A) → List(A), which
concatenates two lists, can be deﬁned as catamorphism

concat(xs, ys) = (cid:76) [ λx.ys, cons ](cid:77)(xs).

Finally, the function map(f) : List(A) → List B, which applies the function
f : A → B to every element of the argument list, can be deﬁned as follows

map(f) = (cid:76) [ nil , cons ◦ (f × id) ](cid:77).

Lots of other examples about list catamorphisms (i.e. function foldr) can be found
in any functional programming textbook (e.g. [Bir98]).

Example 2.4 (binary trees)
Consider the bifunctor B(A, X) = A + X × X. The initial BA-algebra deﬁnes
the data type of binary (leaf) trees Btree(A) = µBA with a constructor functions

= in◦ inl
leaf
branch = in◦ inr

: A → Btree(A)
: Btree(A) × Btree(A) → Btree(A)

For instance, a binary tree of naturals with three leafs can be constructed as

branch(branch(leaf (1), leaf (2)), leaf (3)).

Given any functions l : A → C and b : C × C → C, the catamorphism f =
(cid:76) [ l, b ](cid:77) : Btree(A) → C is the unique solution of the equation system

f ◦ leaf
f ◦ branch = b ◦ (f × f).

= l

For instance, the function ﬂatten : Btree(A) → List(A), which collects ele-
ments in leaves into list in left-to-right order, can be deﬁned as

ﬂatten = (cid:76) [ unit, concat ](cid:77),

where unit(x) = cons(x, nil) : A → List(A) is a function which converts
an element into singleton list, and concat the list concatenation function from
Example 2.3.

20

It is well known from functional programming that the type constructor List
together with the function map form a functor. The next theorem shows that lists
are not exceptional in this respect and every similarly deﬁned parametric data type
can be extended to a functor.
Theorem 2.3 Let F : C × C → C be a bifunctor, such that and for any object A
there exists initial FA-algebra (µFA, in). Then, the mapping T(A) = µFA can
extended to the endofunctor on C by deﬁning
T(f) = (cid:76) in◦F(f, id)(cid:77)

The functor T : C → C is called a data functor of F.
Proof. Note that deﬁnition above has the right typing. We have to show that T
preserves identities and composition. First, identities:

data-map-DEF



=

=

=

T id

– data-map-DEF –

(cid:76) in◦F(id, id)(cid:77)
(cid:76) in(cid:77)

– F bifunctor –

– cata-REFL –

id

For the composition, we show that T(f) is a homomorphism from in◦ F(g, id) to
in◦F(f ◦ g, id) and then use cata-FUSION:



=

=

=

Tf ◦ Tg
Tf ◦(cid:76) in◦F(g, id)(cid:77)

– cata-FUSION –

– data-map-DEF –



=

=

=

=

– cata-SELF –

– data-map-DEF –

Tf ◦ in◦F(g, id)
(cid:76) in◦F(f, id)(cid:77) ◦ in◦F(g, id)
in◦F(f, id) ◦ F(id,(cid:76) in◦F(f, id)(cid:77)) ◦ F(g, id)
in◦F(f ◦ g, id) ◦ F(id,(cid:76) in◦F(f, id)(cid:77))
in◦F(f ◦ g, id) ◦ F(id, Tf)

– data-map-DEF –

– F bifunctor –

(cid:76) in◦F(f ◦ g, id)(cid:77)
T(f ◦ g)

– data-map-DEF –

21

Example 2.5 (bushes)
Consider the bifunctor B(A, X) = A × List(B(A, X)). The initial BA-algebra
deﬁnes the data type of bushes (ﬁnitely branching trees) Bush(A) = µBA with a
constructor function node = in : A × List(Bush(A)) → Bush(A). Given any
function h : A × List(C) → C, the catamorphism f =(cid:76) h(cid:77) : Bush(A) → C is

the unique solution of the equation

f ◦ node = h ◦ (id×map(f)),

where map(f) : List(Bush(A)) → List(C) is the map function on lists deﬁned
in Example 2.3.

2.2 Terminal coalgebras and anamorphisms

We now dualize the material about initial algebras and catamorphisms.

Deﬁnition 2.5 (coalgebra)
Let F : C → C be an endofunctor on category C. A F-coalgebra is a pair (C, ϕ),
where C is an object and ϕ : C → FC an arrow in the category C. The object C
is the carrier and the functor F is the signature of the coalgebra.

Deﬁnition 2.6 (coalgebra homomorphism)
Let (C, ϕ) and (D, ψ) be two F-coalgebras. A homomorphism from (C, ϕ) to
(D, ψ) is an arrow f : C → D in the category C, such that

ψ ◦ f = F f ◦ ϕ

i.e. makes the following diagram to commute:

C

f

D

ϕ

ψ

F C

F f

F D

Similarly to homomorphisms between algebras, homomorphisms between co-

algebras compose with identity arrow as the identity homomorphism.

Deﬁnition 2.7 (category of coalgebras)
The category of F-coalgebras over C — CoAlg(F) — is deﬁned by:

• Objects: F-coalgebras; i.e. arrows ϕ of C such that cod ϕ = F(dom ϕ).

22

/
/




/
/
• Arrows: triples (f, ϕ, ψ) : ϕ → ψ where ϕ and ψ are F-coalgebras and

f : dom ϕ → dom ψ is a homomorphism from ϕ to ψ.
• Identity: idϕ = (iddom ϕ, ϕ, ϕ).
• Composition: (f, ϕ2, ϕ3) ◦ (g, ϕ1, ϕ2) = (f ◦ g, ϕ1, ϕ3).

Deﬁnition 2.8 (terminal coalgebra)
A F-coalgebra (νF, out) is the terminal F-coalgebra if for any F-coalgebra (C, ϕ)
there exists unique arrow [( ϕ )] : C → νF making the following diagram com-
mute:

C

ϕ

F C

[( ϕ )]

F [( ϕ )]

νF

out

F νF

i.e. satisfying the universal property:

out◦f = F f ◦ ϕ ≡ f = [( ϕ )]

ana-CHARN

The arrows in form [( ϕ )] are called anamorphisms (derived from the Greek prepo-
sition ανα meaning ‘upwards’; the name is due to Meijer).

In other words, the terminal coalgebra (νF, out) is the terminal object in the

category CoAlg(F), and the anamorphism [( ϕ )] is the mediating arrow out of it.
Corollary 2.4 Let (νF, out) be a terminal F-coalgebra.
• Cancellation: For any F-coalgebra ϕ : C → FC
out◦[( ϕ )] = F [( ϕ )] ◦ ϕ

ana-SELF

• Reﬂection:

ana-REFL
• Fusion: For any F-coalgebras ϕ : C → FC, ψ : D → FD and an arrow

id = [( out )]

f : C → D

ψ ◦ f = F f ◦ ϕ ⇒ [( ψ )] ◦ f = [( ϕ )]

ana-FUSION

23

/
/




/
/
Terminal coalgebras satisfy the dual version of the Lambek lemma stating that

their carriers are ﬁxed points of F.
Corollary 2.5 The terminal coalgebra out : νF → F νF is an isomorphism with
the inverse out−1 : FνF → νF deﬁned as follows
out−1 = [( F out )]

out-inv-DEF

Dually to initial algebras, terminal coalgebras generalize the notion of the
greatest ﬁxed point, as the carrier of the terminal coalgebra for a monotonic end-
ofunction over preorder is the the greatest ﬁxed point of the given function.

Example 2.6 (unit type)
In the category Set, the pair ({(cid:63)}, id{(cid:63)}) is the terminal coalgebra of the identity
functor, where {(cid:63)} is a one element set. The unique arrow into {(cid:63)} is the required
unique homomorphism. More generally, in any category with terminal object, the
pair (1, id1) is the terminal Id-coalgebra.
Example 2.7 (conaturals)
Consider the endofunctor N(X) = 1 + X from Example 2.2. Recall that its
initial algebra is given by the set Nat = {0, 1, 2, . . .} of natural numbers together
with the join of zero and successor function as algebra structure [ zero, succ ] :
1 + Nat → Nat. The inverse of the initial algebra pred : Nat → 1 + Nat is a
N-coalgebra, but it is not terminal.
The terminal N-coalgebra is given by the pair (CoNat, pred), where CoNat =
{0, 1, 2, . . .}∪{∞} is the set of natural numbers augmented with an extra element
∞, and pred : CoNat → 1 + CoNat is the predecessor function

= inl ()
pred 0
pred (n + 1) = inr n
pred ∞
= inr ∞.

Given an arbitrary N-coalgebra (C, f), there exists a unique function g = [( f )] :
C → CoNat satisfying

pred(g(x)) = (cid:26) inl ()

if f(x) = inl ()
inr(g(y)) if f(x) = inr y

For instance, consider the function f : CoNat×CoNat → 1+(CoNat×CoNat)
deﬁned by

f(x, y) = 

inl ()
(cid:48)
inr(x
inr(x, y

if pred(x) = pred(y) = inl ()

(cid:48)
, y) if pred(x) = inr x
(cid:48)) if pred(x) = inl (), pred(y) = inr y

(cid:48)

,

24

i.e. an N-coalgebra with carrier CoNat×CoNat. The anamorphism add = [( f )] :
CoNat × CoNat → CoNat deﬁnes the addition function on conaturals.

Because the sum appears in the target, we cannot decompose an N-coalgebra
into simpler components in general. Often, however, the N-coalgebra is in the
form f = (!C +h)◦p? for some predicate p : C → Bool and function h : C → C.
In this case, the homomorphism condition translates to

pred(g(x)) = (cid:26) inl ()

if p(x)

inr(g(h(x))) otherwise.

Parametric coinductive types can be modeled by terminal coalgebras using
bifunctors as their signatures. Also, the resulting type constructor can be extended
to a functor.
Corollary 2.6 Let F : C × C → C be a bifunctor, such that and for any object A
there exists terminal FA-coalgebra (νFA, out). Then, the mapping T(A) = νFA
can extended to the endofunctor on C by deﬁning

T(f) = [( F(f, id) ◦ out )]

codata-map-DEF

The functor T : C → C is called a codata functor of F.
Example 2.8 (streams)
The codata type of streams over a given set A is nicely represented by the terminal
coalgebra (νSA, out) of the bifunctor S(A, X) = A × X. Write Stream(A)
for νSA. The functions head : Stream(A) → A and tail
: Stream(A) →
Stream(A) equal fst◦ out and snd◦ out, respectively. Given any two functions
c : C → A and h : C → C, the anamorphism [((cid:104) c, h(cid:105) )] is the unique solution
f : C → Stream A of the equation system

head ◦ f = c
tail ◦ f

= f ◦ h.

The function nats : Nat → Stream(Nat), which returns the stream of all natural
numbers starting with the natural number given as the argument, is the unique
solution of the equation system

head ◦ nats = id
tail ◦ nats = nats ◦ succ,
and is thus deﬁnable as the anamorphism [((cid:104) id, succ (cid:105) )].

25

The function zip : Stream(A)× Stream(B) → Stream(A× B) that zips the

argument streams together is characterized as follows:

head ◦ zip = (fst× fst) ◦ (out× out)
tail ◦ zip = zip ◦ (snd× snd) ◦ (out× out)

This function can, therefore, be deﬁned as [((cid:104) fst× fst, snd× snd(cid:105) ◦ (out× out) )].
The function iterate(f) : A → Stream(A) builds the stream of all repeated
applications of function f : A → A to the argument
iterate(f) = [((cid:104) id, f (cid:105) )]

Example 2.9 (colists)
The codata type of colists over a given set A can be represented as the termi-
nal coalgebra (νLA, out) of the functor LA. Write List(cid:48)
A for νLA. Given any
function g : C → 1 + (A × C), the anamorphism [( g )] is the unique solution
f : C → List(cid:48)
A of the equation out◦f = (id +(id×f)) ◦ g, i.e. the function
unfold(g) from functional programming.

2.3

Implementation in Haskell

In Haskell, like in type theory, functors arise from the association of a morphism
mapping to an object mapping. A functor in Haskell is a type constructor from
the class Functor deﬁned in the Haskell Prelude as follows:

class

Functor f where

fmap :: (a -> b) -> f a -> f b

The type constructor f, in itself, is the object mapping part of a functor. The
morphism mapping is the function fmap. The class deﬁnition forces fmap to
have the correct typing, but cannot force it to preserve identities and composition,
so at each time the programmer deﬁnes the fmap function for a particular type
constructor f, it is his responsibility to ensure that these conditions are met.

Given some type constructor, it can be declared to be a functor by deﬁning the
fmap function for it using instance declaration. For example, the fmap function
for the list type constructor is deﬁned in the Haskell Prelude as follows:

instance Functor [] where

fmap = map

26

The deﬁnition tells, that the fmap for lists is “ordinary” map function.

Inductive types, being carriers of initial algebras, are least ﬁxed points of the
corresponding functors. In Haskell, this can be modeled by the following decla-
ration:

> newtype Mu f = In (f (Mu f))

Given a type constructor f, this deﬁnes a new type Mu f which has the same
representation as the type f(Mu f); i.e. it deﬁnes Mu f as the least ﬁxed point of
f. In addition, it deﬁnes a data constructor In :: f (Mu f) -> Mu f for the
explicit one-way coercion between the types. The coercion in the other way (i.e.
the inverse of In) can be deﬁned by pattern matching:

> unIn :: Mu f -> f (Mu f)
> unIn (In x) = x

Coinductive types are carriers of terminal coalgebras, thus greatest ﬁxed points
of the corresponding functors. Because Haskell allows to use a general recursion,
coinductive types are necessarily isomorphic to the inductive types with the same
base functor. Hence we could use Mu f also for coinductive types. However,
in order to make intended meaning of different usages explicit, we deﬁne them
separately:

> newtype Nu f = Wrap (f (Nu f))

> out :: Nu f -> f (Nu f)
> out (Wrap x) = x

In order to implement cata- and anamorphisms, we make use the correspond-
ing cancellation laws, but in a slightly modiﬁed form1. Namely, we eliminate the
occurrences of the initial algebra in or terminal coalgebra out from the left-hand
side of the equation, by pre- or postcomposing both sides with the corresponding
inverse.

> cata :: Functor f => (f c -> c) -> Mu f -> c
> cata phi = phi . fmap (cata phi) . unIn

> ana
> ana phi

:: Functor f => (c -> f c) -> c -> Nu f

= Wrap . fmap (ana phi)

. phi

1In fact, this is not necessary for catamorphisms, as we could use pattern matching to implement
the cancellation law directly. However, this does not work in the case of anamorphisms, as Haskell
requires that the name of the deﬁned function has to be the outermost in the left-hand side of the
deﬁning equation.

27

The combinator cata takes a function of type f c -> c (i.e. algebra) into func-
tion of type Mu f -> c. Dually, ana takes a function of type c -> f c (i.e.
coalgebra) into function of type c -> Nu f. In both cases, the type constructor
f has to belong into class Functor. The restriction on f is necessary, as the
right-hand sides of the deﬁning equations makes use of the function fmap. Note
that there was no such restriction in the deﬁnitions of Mu or Nu.

Example 2.10 (naturals)
The data type of natural numbers, as given in example 2.2, is an initial algebra for
the functor N(X) = 1 + X. In Haskell, this can be implemented as follows:

> data N x = Z | S x

> instance Functor N where
>
>

fmap f Z
fmap f (S x) = S (f x)

= Z

> type Nat = Mu N

The ﬁrst line deﬁnes a new type constructor N, which corresponds to the object
mapping part of the functor N. Then, the instance declaration deﬁnes the function
fmap for it; i.e. makes it a functor. Finally, the last line deﬁnes data type Nat as
the least ﬁxed point of N.

The constructor functions for naturals (the constant zero and successor func-

tion) can be deﬁned as follows:

> zeroN :: Nat
> zeroN

= In Z

> succN
> succN n = In (S n)

:: Nat -> Nat

Below are listed some illustrative values of type Nat (naturals 1, 2 and 4):

In (S (In Z))
In (S (In (S (In Z))))
In (S (In (S (In (S (In (S (In Z))))))))

The sum of two naturals can be implemented as following catamorphism:

> addN :: Nat -> Nat -> Nat
> addN x y = cata phi x
>
>

where phi Z

= y

phi (S n) = succN n

28

Note that the algebra phi is deﬁned by the case analysis over the structure of type
constructor N, specifying the result separately depending whether the inductive
argument (i.e. x) is zero or not. In the case of non-zero inductive argument, the
result is speciﬁed in terms of the value on its predecessor.

Analogously, the product of two naturals can be implemented by a catamor-

phism:

> mulN :: Nat -> Nat -> Nat
> mulN x y = cata phi x
>
>

where phi Z

= y

phi (S n) = addN y n

Example 2.11 (lists)
The data type of lists can be implemented as follows:

> data L a x = N | C a x

> instance Functor (L a) where
>
>

fmap f N
fmap f (C x xs) = C x (f xs)

= N

> type List a

= Mu (L a)

> nilL :: List a
> nilL

= In N

> consL
> consL x xs = In (C x xs)

:: a -> List a -> List a

The functions nilL and consL are constructor functions for lists. The ﬁrst cor-
responds to an empty list, and the second to the “ordinary” list constructor.

The functions length, concat and map from the example 2.3 can be imple-

mented as follows:

> lengthL :: List a -> Nat
> lengthL = cata phi
>
>

where phi N

phi (C _ n) = succN n

= zeroN

29

> concatL :: List a -> List a -> List a
> concatL xs ys = cata phi xs
>
>

phi (C x xs’) = consL x xs’

where phi N

= ys

> mapList :: (a -> b) -> List a -> List b
> mapList f = cata phi
>
>

phi (C a bs) = consL (f a) bs

where phi N

= nilL

Example 2.12 (streams)
The codata type of streams can be implemented as follows:

> data S a x = St a x

> instance Functor (S a) where
>

fmap f (St x xs) = St x (f xs)

> type Stream a = Nu (S a)

> headS :: Stream a -> a
> headS xs = case out xs of
>

St x _ -> x

> tailS :: Stream a -> Stream a
> tailS xs = case out xs of
>

St _ xs’ -> xs’

Functions headS and tailS are stream destructors, returning the head and the
tail of the given stream respectively.

> zipS :: (Stream a, Stream a) -> Stream (a,a)
> zipS = ana phi
>
>

where phi (xs, ys) = St (headS xs, headS ys)
(tailS xs, tailS ys)

30

> iterateS :: (a -> a) -> a -> Stream a
> iterateS f = ana phi
>

where phi x = St x (f x)

Example 2.13 (colists)
Colists have the same base functor as lists, hence we can implement them as
follows:

> type CoList a = Nu (L a)

The destructor function for conaturals, can not be decomposed in general. How-
ever, as Haskell allows to use partial functions, we deﬁne more intuitive “destruc-
tors” as follows:

> nullCL :: CoList a -> Bool
> nullCL xs = case out xs of
>
>

N
C _ _ -> False

-> True

> headCL :: CoList a -> a
> headCL xs = case out xs of
>
C x _ -> x

> tailCL :: CoList a -> CoList a
> tailCL xs = case out xs of
>

C _ xs’ -> xs’

The function nullCL tests whether the colist is empty or not. Partial functions
headCL and tailCL extract respectively the head and the tail of the given non-
empty colist.

2.4 Related work

The categorical treatment of inductive and coinductive types as initial algebras
and terminal coalgebras for covariant functors comes from Hagino [Hag87], who
designed a typed functional language CPL based on distributive categories and
initial algebras and terminal coalgebras for strong covariant functors. The Charity
language by Cockett et al. [CF92] is a similar programming language.

The program calculation community is rooted in the Bird-Meertens formalism
or Squiggol [Bir87], which, originally, was an equational theory of programming

31

with the parametric data type of lists. Malcolm [Mal90b, Mal90a] made the com-
munity aware of Hagino’s work and much of the subsequent development fol-
lowed the path he set. A classic reference in the area of theory is Fokkinga’s
[Fok92]. The excellent introduction into program calculation is the textbook
[BdM97].

32

CHAPTER 3

PRIMITIVE (CO)RECURSION

This chapter, based on [VU98], is devoted to primitive recursion and primitive
corecursion. Primitive recursion is a well known recursion scheme, where the
value on the current argument is constructed using the value on the previous ar-
gument together with the previous argument itself. Its dualization, primitive core-
cursion, is not so well known, but provides an equally useful corecursive deﬁni-
tion mechanism where a codata structure is generated either step by step (like in
the case of coiteration) or in one big step. Both schemes are generalizations of
the simple (co)iteration and can be embedded in a nice way into the categorical
framework presented in the previous chapter.

3.1 Primitive recursion via tupling

Not every function with inductive type as source can be represented by a single
catamorphism alone. For instance, the factorial function fact : Nat → Nat is
neatly characterized as the unique solution of the equation system

fact(0)
fact(n + 1) = (n + 1) ∗ fact(n)

= 1

However, the recursion pattern of the equations above does not follow that of cata-
morphisms but primitive recursion, i.e. the factorial of a given natural, depends not
only on the factorial of its predecessor, but also on the predecessor itself. So, the
catamorphic deﬁnition of factorial has to compute both in parallel as a pair and
then project the factorial component out:

fact = fst◦(cid:76) [ λx.(1, 0), λ(f, n).((n + 1) ∗ f, n + 1) ](cid:77).

Meertens [Mee92] showed that the same trick of tupling can be also used for other
inductive types. The relevant result is the following:

33

Lemma 3.1 For any two arrows f : µF → C and ϕ : F (C × µF) → C, we have

f ◦ in = ϕ ◦ F(cid:104) f, id(cid:105) ≡ f = fst◦(cid:76)(cid:104) ϕ, in◦F(snd)(cid:105)(cid:77)

Proof. The left-hand equation essentially says that f follows the primitive re-
cursion pattern for µF , while the right one gives its deﬁnition in terms of the
composition of the left projection and a catamorphism.

The equivalence is proved by the following two calculations. First, from left

to right:

(cid:66) f ◦ in = ϕ ◦ F(cid:104) f, id(cid:105)

f
– pairing –
fst◦(cid:104) f, id(cid:105)

=

=

=

=

=



– cata-CHARN –
(cid:104) f, id(cid:105) ◦ in
– pairing –
(cid:104) f ◦ in, in(cid:105)
– F functor –
(cid:104) f ◦ in, in◦F id(cid:105)
(cid:104) f ◦ in, in◦F (snd◦(cid:104) f, id(cid:105))(cid:105)
(cid:104) ϕ ◦ F(cid:104) f, id(cid:105), in◦F snd◦F(cid:104) f, id(cid:105)(cid:105)
(cid:104) ϕ, in◦F snd(cid:105) ◦ F(cid:104) f, id(cid:105)

– pairing –
– (cid:67), F functor –

– pairing –

=

=



fst◦(cid:76)(cid:104) ϕ, in◦F snd(cid:105)(cid:77)

Second, from right to left:

34



=

=

=

=

=

– (cid:67) –

– cata-CHARN –

(cid:66) f = fst◦(cid:76)(cid:104) ϕ, in◦F snd(cid:105)(cid:77)
f ◦ in
fst◦(cid:76)(cid:104) ϕ, in◦F snd(cid:105)(cid:77) ◦ in
fst◦(cid:104) ϕ, in◦F snd(cid:105) ◦ F(cid:76)(cid:104) ϕ, in◦F snd(cid:105)(cid:77)
ϕ ◦ F(cid:104) fst◦(cid:76)(cid:104) ϕ, in◦F snd(cid:105)(cid:77), snd◦(cid:76)(cid:104) ϕ, in◦F snd(cid:105)(cid:77)(cid:105)

snd◦(cid:104) ϕ, in◦F snd(cid:105)
in◦F snd
ϕ ◦ F(cid:104) f,(cid:76) in(cid:77)(cid:105)
ϕ ◦ F(cid:104) f, id(cid:105)

– pairing, 2x –
– (cid:67), cata-FUSION –

– cata-REFL –

– pairing –

=

From the lemma above, it follows that at least every primitive recursive func-
tion can be represented using catamorphism as the only recursive construction.
In the presence of exponentials, one can even deﬁne Ackermann’s function as a
(higher-order) catamorphism, so the expressive power of the “language of cata-
morphisms” is bigger than the class of primitively recursive functions. In fact,
Howard [How96] has shown that the functions expressible in simply typed λ-
calculus extended with inductive and coinductive types are precisely those prov-
ably total in the logic ID<ω (the ﬁrst order arithmetic augmented by ﬁnitely-
iterated inductive deﬁnitions).

However, from the practical point of view, the situation is not very satisfac-
tory. First, using tupling is clearly not the most natural way to program primitive
recursive functions. Second, algorithms corresponding to the deﬁnitions obtained
by the lemma above have additional penalty in terms of complexity, as they have
to reconstruct the argument which is already there.

3.2 Paramorphisms

To make programming and program reasoning easier, let us introduce a new con-
struction and study its properties.

35

Deﬁnition 3.1 (paramorphism)
Let (µF, in) be an initial F-algebra. For any arrow ϕ : F (C×µF) → C, the arrow
(cid:104)| ϕ|(cid:105) : µF → C is deﬁned by

(cid:104)| ϕ|(cid:105) = fst◦(cid:76)(cid:104) ϕ, in◦F(snd)(cid:105)(cid:77)

para-DEF
The arrows in form (cid:104)| ϕ|(cid:105) are called paramorphisms (derived from the Greek
preposition παρα meaning ‘near to’, ‘at the side of’, ‘towards’; the name is due
to Meertens [Mee92]).

The deﬁnition made use of the right-hand side of the equivalence in Lemma 3.1.
Exploiting the left-hand side, we get the characterization of paramorphisms in
terms of universal property.
Corollary 3.2 For any arrow ϕ : F (C × µF) → C, the paramorphism f =
(cid:104)| ϕ|(cid:105) : µF → C is the unique arrow making the following diagram commute:

F µF

F (cid:104) f,id (cid:105)
F (C × µF)

in

ϕ

µF

f

C

i.e. satisfying the universal property:

f ◦ in = ϕ ◦ F(cid:104) f, id(cid:105) ≡ f = (cid:104)| ϕ|(cid:105)

para-CHARN

Example 3.1 (primitive recursion for naturals)
Consider the data type of natural numbers. Given any two functions c : 1 → C
and h : C×Nat → C, the paramorphism f = (cid:104)| [ c, h ]|(cid:105) : Nat → C is the unique
solution of the equation system

f ◦ zero = c
f ◦ succ = h ◦ (cid:104) f, id(cid:105),

i.e. it captures the classical primitive recursion scheme. For instance, the factorial
function fact : Nat → Nat can be deﬁned as paramorphism

fact = (cid:104)| [ one, λ(f, n).mul(succ(n), f) ]|(cid:105),

where one = succ ◦ zero : 1 → Nat and mul
multiplication of naturals deﬁned in Example 2.2.

: Nat × Nat → Nat is the

36

/
/




/
/
Example 3.2 (primitive recursion for lists)
Consider the data type of lists List(A). Given any two functions c : 1 → C and
h : A × C × List(A) → C, the paramorphism f = (cid:104)| [ c, h ]|(cid:105) : List(A) → C is
the unique solution of the equation system

f(nil)
f(cons(x, xs)) = h(x, f(xs), xs).

= c()

For instance, the function tails : List(A) → List(List(A)), which returns the
list of all tail segments of argument list, can be deﬁned as paramorphism
tails = (cid:104)| [ cons(nil , nil), λ(x, r, xs).cons(cons(x, xs), ys) ]|(cid:105).

Another example of list paramorphism is the function dropWhile(p) : List(A) →
List(A), which for given predicate p : A → Bool drops the longest initial seg-
ment of the argument list such that all elements in this segment satisfy p

dropWhile(p) = (cid:104)| [ nil , λ(x, r, xs).if p(x) then r else cons(x, xs) ]|(cid:105).

The calculational properties of paramorphisms are similar to those of catamor-
phisms. In particular, we have “paramorphic” versions of cancellation, reﬂection
and fusion laws.

Proposition 3.3 Let (µF, in) be an initial F-algebra.

• Cancellation: For any arrow ϕ : F (C × µF) → C
(cid:104)| ϕ|(cid:105) ◦ in = ϕ ◦ F(cid:104)(cid:104)| ϕ|(cid:105), id(cid:105)

para-SELF

• Reﬂection:

para-REFL
• Fusion: For any arrows ϕ : F (C × µF) → C, ψ : F (D × µF) → D and

id = (cid:104)| in◦ F(fst)|(cid:105)

f : C → D

f ◦ ϕ = ψ ◦ F(f × id) ⇒ f ◦ (cid:104)| ϕ|(cid:105) = (cid:104)| ψ |(cid:105)

para-FUSION

Proof. The cancellation law is directly obtained form the universal property of
paramorphisms by substituting f := (cid:104)| ϕ|(cid:105) thus making the right-hand equation in

37

para-CHARN trivially true. For the reﬂection law we argue:

id

=

– para-CHARN –



=

=

=

– identity, F functor –

id◦ in
in◦ F(id)
in◦ F(fst◦(cid:104) id, id(cid:105))
in◦ F(fst) ◦ F(cid:104) id, id(cid:105)

– F functor –

– pairing –

(cid:104)| in◦ F(fst)|(cid:105)





Finally, the fusion law is proved as follows:
(cid:66) f ◦ ϕ = ψ ◦ F(f × id)

f ◦ (cid:104)| ϕ|(cid:105)

=

– para-CHARN –



=

=

=

=

(cid:104)| ψ |(cid:105)

– para-SELF –
– (cid:67) –

f ◦ (cid:104)| ϕ|(cid:105) ◦ in
f ◦ ϕ ◦ F(cid:104)(cid:104)| ϕ|(cid:105), id(cid:105)
ψ ◦ F(f × id) ◦ F(cid:104)(cid:104)| ϕ|(cid:105), id(cid:105)
ψ ◦ F((f × id) ◦ (cid:104)(cid:104)| ϕ|(cid:105), id(cid:105))
ψ ◦ F(cid:104) f ◦ (cid:104)| ϕ|(cid:105), id(cid:105)

– F functor –

– pairing –

In addition to the laws above, paramorphisms satisfy several other useful prop-

erties some of which are listed below.

Proposition 3.4

1. Every catamorphism(cid:76) ϕ(cid:77) can be deﬁned as a paramorphism which does

not use the preceding value of the argument directly:

(cid:76) ϕ(cid:77) = (cid:104)| ϕ ◦ F(fst)|(cid:105)

para-CATA

2. Every arrow whose source is the carrier of an initial algebra is a paramor-

phism:

f = (cid:104)| f ◦ in◦F(snd)|(cid:105)

para-FROM-INIT

38




(cid:76) ϕ(cid:77)

=

– para-CHARN –



=

=

=

– cata-SELF –

(cid:76) ϕ(cid:77) ◦ in
ϕ ◦ F(cid:76) ϕ(cid:77)
ϕ ◦ F(fst◦(cid:104)(cid:76) ϕ(cid:77), id(cid:105))
ϕ ◦ F(fst) ◦ F(cid:104)(cid:76) ϕ(cid:77), id(cid:105)

– F functor –

– pairing –

(cid:104)| ϕ ◦ F(fst)|(cid:105)

f

=

– para-CHARN –



=

=

=

– F functor –

f ◦ in
f ◦ in◦F(id)
– pairing –
f ◦ in◦F(snd◦(cid:104) f, id(cid:105))
f ◦ in◦F(snd) ◦ F(cid:104) f, id(cid:105)

– F functor –

(cid:104)| f ◦ in◦F(snd)|(cid:105)

3. The inverse of an initial algebra is a paramorphism:

in−1 = (cid:104)| F(snd)|(cid:105)

para-IN-INV

Proof. The ﬁrst equality is proven as follows:

Similarly, the validity of para-FROM-INIT is shown by:

Finally, para-IN-INV comes directly from the previous law:



– para-FROM-INIT –

in−1
(cid:104)| in−1 ◦ in◦F(snd)|(cid:105)
– in-inv-CHARN –
(cid:104)| F(snd)|(cid:105)

=

=

39

3.3 Apomorphisms

Let us now dualize everything we know about paramorphisms.

Deﬁnition 3.2 (apomorphism)
Let (νF, out) be a terminal F-coalgebra. For any arrow ϕ : C → F(C + νF),
deﬁne the arrow [(cid:104) ϕ(cid:105)] : C → νF as a composition of a certain anamorphism with
the left injection:

[(cid:104) ϕ(cid:105)] = [( [ ϕ, F(inr) ◦ out ] )] ◦ inl

apo-DEF
The arrows in form [(cid:104) ϕ(cid:105)] are called apomorphisms (derived from the Greek prepo-
sition απo meaning ‘apart from’, ‘far from’, ‘away from’; the name was ﬁrst used
by Vos [Vos95]1).
Corollary 3.5 For any arrow ϕ : C → F(C + νF), the apomorphism f = [(cid:104) ϕ(cid:105)] :
C → νF is the unique arrow making the following diagram commute:

C

f

νF

ϕ

out

F (C + νF)

F [ f,id ]

F νF

i.e. satisfying the universal property:

out◦f = F [ f, id ] ◦ ϕ ≡ f = [(cid:104) ϕ(cid:105)]

apo-CHARN

The laws for apomorphisms are just dual to those for paramorphisms.

Corollary 3.6 Let (νF, out) be a terminal F-coalgebra.
• Cancellation: For any arrow ϕ : C → F(C + νF)
out◦[(cid:104) ϕ(cid:105)] = F[ [(cid:104) ϕ(cid:105)], id ] ◦ ϕ

• Reﬂection:

id = [(cid:104) F(inl) ◦ out(cid:105)]

apo-SELF

apo-REFL

1It is interesting to note that Vene and Uustalu [VU98] unaware of the work by Vos happened to

come up with exactly the same new name.

40

/
/




/
/
• Fusion: For any arrows ϕ : C → F(C + νF), ψ : D → F(D + νF) and

f : C → D

ψ ◦ f = F(f + id) ◦ ϕ ⇒ [(cid:104) ψ (cid:105)] ◦ f = [(cid:104) ϕ(cid:105)]

apo-FUSION

Corollary 3.7

1. Every anamorphism [( ϕ )] is an apomorphism:
[( ϕ )] = [(cid:104) F(inl) ◦ ϕ(cid:105)]

apo-ANA

2. Every arrow whose target is the carrier of a terminal coalgebra is an apo-

morphism:

f = [(cid:104) F(inr) ◦ out◦f (cid:105)]

apo-TO-TERM

3. The inverse of a terminal coalgebra is an apomorphism:

out−1 = [(cid:104) F(inr)(cid:105)]

apo-OUT-INV

Example 3.3 (primitive corecursion for streams)
Consider the codata type of streams Stream(A). Given any two functions h :
C → A and t : C → C + Stream(A), the apomorphism f = [(cid:104)(cid:104) h, t(cid:105)(cid:105)] : C →
Stream(A) is the unique solution of the equation system

head ◦ f = h
tail ◦ f

= [ f, id ] ◦ t.

Like in the case of anamorphisms, the head of the stream is computed from the
current seed value using the function h. However, the tail of the stream can be
generated two different ways depending whether the function t computes the
new seed value (in which case the generation process proceeds recursively) or
the rest of stream as whole. For instance, the function maphd(h) : Stream(A) →
Stream(A), which modiﬁes any input stream by applying a function h : A → A
to its head while leaving the tail unchanged, can be deﬁned as following apomor-
phism:

maphd(h) = [(cid:104)(cid:104) h ◦ head , inr◦tail (cid:105)(cid:105)].

41

The role of the function t is more explicit when it is in the form t = [ n, r ] ◦ p?,
where p → Bool is a predicate and n : C → C and r : C → Stream(A) are
functions for computing next seed or rest of the stream respectively. Then the
apomorphism f = [(cid:104)(cid:104) h, [ n, r ] ◦ p?(cid:105)(cid:105)] is characterized by equations:

head(f(x)) = h(x)
tail(f(x)) = f(n(x)) if p(x)

= r(x)

otherwise.

For an example, assume that a given set A is ordered. The function insert(a) :
Stream(A) → Stream(A) inserts the element a : 1 → A into a given stream
immediately before the ﬁrst element that is greater than or equal to a (so that the
returned stream will be a sorted, if the argument was). It can be deﬁned as an
apomorphism:

insert(a) = [(cid:104)(cid:104) h, [ tail , id ] ◦ p?(cid:105)(cid:105)],

where

p(xs) = head(xs) ≤ a()
h(xs) = head(xs)

= a()

if p(xs)
otherwise.

Example 3.4 (primitive corecursion for conaturals)
Given a function h : C → 1 + (C + CoNat), the apomorphism f = [(cid:104) h(cid:105)] : C →
CoNat is the unique solution of the equation system

inl ()
inr(f(x
inr(y)

if h(x) = inl ()

(cid:48))) if h(x) = inr(inl(x

(cid:48)))
if h(x) = inr(inr(y)).

For instance, the addition function on conaturals add = CoNat × CoNat →
CoNat, which was deﬁned as an anamorphism in the Example 2.7, can be more
succinctly deﬁned as add = [(cid:104) f (cid:105)], where

pred(f(x)) = 
f(x, y) = 

if pred(x) = pred(y) = inl ()

inl ()
(cid:48)
(cid:48)
inr(inl(x
, y)) if pred(x) = inr x
(cid:48)))
inr(inr(y

if pred(x) = inl (), pred(y) = inr y

(cid:48)

.

The “structured” corecursion operator can be deﬁned if the function h is in the
form h = [ !C, [ n, r ] ◦ p2? ] ◦ p1?, where p1 : C → Bool and p2 : C → Bool are

42

predicates, n : C → C gives the next seed and r : C → CoNat gives the remain-
der of the conatural under construction. Then f = [(cid:104) [ !C, [ n, r ] ◦ p2? ] ◦ p1?(cid:105)] :
C → CoNat is characterized by the equations:

pred(f(x)) = 

if p1(x)

inl ()
inr(f(n(x))) if ¬p1(x) ∧ p2(x)
inr(r(y))

otherwise.

Example 3.5 (primitive corecursion for colists)
For instance, the function the function append : CoList(A) × CoList(A) →
CoList(A), which appends two colists is naturally deﬁnable as an apomorphism
append = [(cid:104) f (cid:105)], where
f(x, y) = inl()

if null(x) ∧ null(y)
if null(x) ∧ ¬(null(y))

= inr(head(y), inr(tail(y)))
= inr(head(x), inl(tail(x), y)) otherwise.

Here, null : CoList(A) → Bool is a predicate which tests whether the colist is
empty or not, i.e. null = [ id, !A ] ◦ out.

3.4 Para- and apomorphisms in Haskell

Paramorphisms map arrows of type F (C × µF) → C to the arrows of type µF →
C. Thus, the type of paramorphism combinator can be expressed in Haskell as
follows:

> para :: Functor f => (f (c, Mu f) -> c) -> Mu f -> c

For the deﬁning equation of paramorphism combinator we have two possibilities.
First, we can use the deﬁnition of paramorphism in terms of catamorphism:

para phi = fst . cata (fork phi (In . fmap snd))

where fork is pair forming function deﬁned as follows:

> fork :: (a -> b) -> (a -> c) -> a -> (b,c)
> fork f g x = (f x, g x)

However, this deﬁnition is inefﬁcent, as it recursively reconstructs the argument.
The second possibility is to use the cancellation law to obtain the directly recursive
deﬁnition:

> para phi = phi . fmap (fork (para phi) id) . unIn

43

This deﬁnition is more efﬁcent, as the (previous) argument is used directly by
phi.

Example 3.6 (factorial)
The factorial function can be implemented as paramorphism:

> fact :: Nat -> Nat
> fact = para phi
>
where phi Z
>

phi (S (r,x)) = mulN (succN x) r

= succN zeroN

In the second equation of phi, the result (i.e. factorial) on the previous argument
is denoted by r, and the argument itself by x.

Example 3.7 (dropwhile)
The function dropWhile from the example 3.2 can be implemented as follows:

> dropWhileL :: (a -> Bool) -> List a -> List a
> dropWhileL p = para phi
>
>
>

phi (C x (r,xs)) | p x

= r

where phi N

= nilL

| otherwise = consL x xs

Here, again, r denotes the value on the previous argument (i.e. value on the tail
of the list), while x and xs denote the head and tail of the original list.

Dually to paramorphisms, apomorphisms map arrows of type C → F(C +
νF) to arrows of type C → νF. As Haskell does not provide a primitive type
constructor for sums, we have to deﬁne it ﬁrst:

> data Sum a b = InL a | InR b

We also deﬁne a combinator which does the case analysis on the sum:

> join :: (a -> c) -> (b -> c) -> Sum a b -> c
> join f g (InL x) = f x
> join f g (InR y) = g y

Now, the type of the apomorphism combinator can be expressed as follows:

> apo :: Functor f => (c -> f (Sum c (Nu f)))
>

-> c -> Nu f

Like in the case of paramorphisms, we have a choise between two possibilities
to deﬁne the apomorphism combinator. First, the deﬁnition in terms of anamor-
phism:

44

apo phi = ana (join phi (fmap InR . out)) . InL

This deﬁnition is not very efﬁcent, as it constructs the codata structure in a step-
wise fashion even if the whole remaining structure is available (i.e. phi returns
the right summand). The second possibility is to use directly recursive deﬁnition
obtained from the cancellation law:

> apo phi = Wrap . fmap (join (apo phi) id) . phi

In the case of phi returns the right summand, this deﬁnition is more efﬁcient, as
the rest of the structure is returned by one step.

Example 3.8 (insert)
The function insert from the example 3.3 is deﬁned as follows:

> insertS :: Ord a => a -> Stream a -> Stream a
> insertS a = apo phi
>
>
>

| otherwise = St a (InR xs)

where phi xs | x < a

where x = headS xs

= St x (InL (tailS xs))

Example 3.9 (append)
The concatenation of two colists can be implemented as apomorphism:

where phi (xs, ys)

> appendCL :: (CoList a, CoList a) -> CoList a
> appendCL = apo phi
>
>
>
>
>
>

| nullCL xs && nullCL ys = N
= C (headCL ys)
| nullCL xs

= C (headCL xs)

| otherwise

(InR (tailCL ys))

(InL (tailCL xs, ys))

3.5 Related work

Primitive recursion is universally recognized as an important generalization of it-
eration. Paramorphisms were introduced by Meertens [Mee92]. Geuvers [Geu92]
contains a thorough category-theoretic analysis of primitive recursion versus it-
eration and a demonstration that this readily dualizes into an analysis of primi-
tive corecursion versus coiteration. In general, however, it appears that primitive

45

corecursion has largely been overlooked in the theoretical literature, e.g. [Fok92]
ignores it. The sole discussion of primitive corecursion in a programming con-
text that we knew about when writing [VU98] was the laconic report in [Ves97]
on a not very clean extension to the categorical functional language Charity in
which it is possible to deﬁne functions by primitive recursion and primitive core-
cursion. Soon after we got to know of [Vos95]. Citations of [VU98] appear in
[GH99, BBA00].

46

CHAPTER 4

COURSE-OF-VALUE

(CO)ITERATION

In this chapter, which is based on [UV99b], we introduce categorical combina-
tors for course-of-value iteration and coiteration. Course-of-value iteration is a
recursion scheme, where the value on the current argument is constructed using
the values for the subparts of the argument on arbitrary (but ﬁxed) depth. Du-
ally, course-of-value coiteration allows to generate several “levels” of a resulting
codata structure in one step.

4.1 Course-of-value iteration via memoization

The famous Fibonacci function ﬁbo : Nat → Nat is most smoothly characterized
as the unique solution of the equation system

ﬁbo(0) = 1
ﬁbo(1) = 1

ﬁbo(n + 2) = ﬁbo(n + 1) + ﬁbo(n).

This very nice characterization does not give us any deﬁnition of ﬁbo in terms
of catamorphisms. The problem is that the value of ﬁbo for a given argument is
deﬁned not via the values for the immediate subparts of the argument, but via the
values for its subparts of depth 2. But the characterization of ﬁbo together with
the function ﬁbo(cid:48) : Nat → Nat × Nat (which, for any argument n, returns the
pair formed of the value of ﬁbo for n and either zero or the value of ﬁbo for the
predecessor of n) by a much trickier equation system, viz.,

ﬁbo = fst◦ ﬁbo(cid:48)

ﬁbo(cid:48)(0) = (1, 0)

ﬁbo(cid:48)(n + 1) = (cid:104) add , fst(cid:105)(ﬁbo(cid:48)(n)),

47

leads to a deﬁnition of ﬁbo as the composition of the left projection and a cata-
morphism:

ﬁbo = fst◦(cid:76)(cid:104) [ λx.1, add ], [ λx.0, fst ](cid:105)(cid:77).

Now, we could introduce a new construction that would capture the natural
deﬁnition scheme of the Fibonacci function and closely similar functions, and
start studying its properties. But this would only provide us with a partial so-
lution to the problem manifested by the Fibonacci example, as one can imagine
functions whose value for a given argument is naturally deﬁned via the values for
its subparts of depth three, four, etc. Instead of this, we introduce a construction
that captures a general course-of-value iteration by collecting the values on all
subparts into a certain codata structure.

Deﬁnition 4.1 (cv-algebra)
Let F : C → C be an endofunctor for which there exists an initial algebra (µF, in).
Deﬁne a bifunctor F

× : C × C → C as follows:

×(A, X) = A × F(X).

F

×

induces a codata functor Fν(X) = νF

×
A-coalgebra (νF

×
A, out),
×
X. A F-cv-algebra is a pair (C, ϕ),

Assume that for any object A there exists a terminal F
i.e. F
where C is an object and ϕ : F(Fν(C)) → C is an arrow.
Deﬁnition 4.2 (cv-algebra homomorphism)
Let (C, ϕ) and (D, ψ) be two F-cv-algebras. A homomorphism from (C, ϕ) to
(D, ψ) is an arrow f : C → D in the category C, such that
f ◦ ϕ = ψ ◦ F[( (f × id) ◦ out )]

i.e. makes the following diagram to commute:

F(Fν(C))

F[( (f×id)◦out )]

F(Fν(D))

ϕ

ψ

C

f

D

Note that any F-cv-algebra is an ordinary algebra for a functor G(X) =
F(Fν(X)), and homomorphisms between F-cv-algebras are ordinary homomor-
phisms between G-algebras.

48

/
/




/
/
The next result, analogous to Lemma 3.1 for primitive recursion, states that
every function which can be speciﬁed using course-of-value iteration, can be de-
ﬁned in terms of catamorphism which builds a codata structure of values of the
function on the all substructures of its argument (essentially, the catamorphism
builds a memo-table [Mic68] for the function).
Lemma 4.1 For any arrow f : µF → C and F-cv-algebra ϕ : F(Fν(C)) → C,
we have

f ◦ in = ϕ ◦ F [((cid:104) f, in−1 (cid:105) )] ≡ f = fst◦ out◦(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)

Proof. Proving it is quite tricky. From left to right we calculate:



(cid:66) f ◦ in = ϕ ◦ F [((cid:104) f, in−1 (cid:105) )]

f
– pairing –
fst◦(cid:104) f, in−1 (cid:105)
– pairing –
fst◦(id×F [((cid:104) f, in−1 (cid:105) )]) ◦ (cid:104) f, in−1 (cid:105)
fst◦ out◦[((cid:104) f, in−1 (cid:105) )]

– ana-SELF –

– cata-CHARN –

=

=

=

=



=

=

=

=

=

=

– pairing –

– ana-SELF –

– out-inv-CHARN –

[((cid:104) f, in−1 (cid:105) )] ◦ in
out−1◦ out◦[((cid:104) f, in−1 (cid:105) )] ◦ in
out−1◦ (id×F [((cid:104) f, in−1 (cid:105) )]) ◦ (cid:104) f, in−1 (cid:105) ◦ in
out−1◦(cid:104) f, F [((cid:104) f, in−1 (cid:105) )] ◦ in−1 (cid:105) ◦ in
out−1◦(cid:104) f ◦ in, F [((cid:104) f, in−1 (cid:105) )] ◦ in−1 ◦ in(cid:105)
out−1◦(cid:104) ϕ ◦ F [((cid:104) f, in−1 (cid:105) )], F [((cid:104) f, in−1 (cid:105) )](cid:105)
out−1◦(cid:104) ϕ, id(cid:105) ◦ F [((cid:104) f, in−1 (cid:105) )]

– pairing –
– (cid:67), in-inv-CHARN –

– pairing –

fst◦ out◦(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)

49

From right to left we argue:



– pairing –

=

– (cid:67) –

=

=

=

=

– cata-SELF –

– ana-CHARN –

– out-inv-CHARN –

(cid:66) f = fst◦ out◦(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)
f ◦ in
fst◦ out◦(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77) ◦ in
fst◦ out◦ out−1 ◦(cid:104) ϕ, id(cid:105) ◦ F(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)
fst◦(cid:104) ϕ, id(cid:105) ◦ F(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)
ϕ ◦ F(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)
out◦(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)
(cid:104) fst◦ out◦(cid:76) out−1◦(cid:104) ϕ, id(cid:105)(cid:77), snd◦ out◦(cid:76) out−1◦(cid:104) ϕ, id(cid:105)(cid:77)(cid:105)
(cid:104) f, snd◦ out◦(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77) ◦ in◦ in−1 (cid:105)
(cid:104) f, snd◦ out◦ out−1◦(cid:104) ϕ, id(cid:105) ◦ F(cid:76) out−1◦(cid:104) ϕ, id(cid:105)(cid:77) ◦ in−1 (cid:105)
(cid:104) f, snd◦(cid:104) ϕ, id(cid:105) ◦ F(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77) ◦ in−1 (cid:105)
(cid:104) f, F(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77) ◦ in−1 (cid:105)
(id×F(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)) ◦ (cid:104) f, in−1 (cid:105)

– pairing –
– (cid:67), in-inv-CHARN –



– out-inv-CHARN –

– cata-SELF –

ϕ ◦ F [((cid:104) f, in−1 (cid:105) )]

=

=

=

=

=

=

– pairing –

– pairing –

4.2 Histomorphisms

To make programming and program reasoning easier, let us introduce a new con-
struction and study its properties.

Deﬁnition 4.3 (histomorphism)
Let (µF, in) be an initial F-algebra. For any F-cv-algebra ϕ : F(Fν(C)) → C, the
arrow {| ϕ|} : µF → C is deﬁned by

{| ϕ|} = fst◦ out◦(cid:76) out−1 ◦(cid:104) ϕ, id(cid:105)(cid:77)

The arrows in form {| ϕ|} are called histomorphisms.

histo-DEF

50

By Lemma 4.1, we get the characterization of histomorphisms in terms of

universal property.
Corollary 4.2 For any F-cv-algebra ϕ : F(Fν(C)) → C, the histomorphism f =
{| ϕ|} : µF → C is the unique arrow making the following diagram commute:

F(µF)

F [( (cid:104) f,in

−1 (cid:105) )]

F(Fν(C))

in

ϕ

µF

f

C

i.e. satisfying the universal property:

f ◦ in = ϕ ◦ F [((cid:104) f, in−1 (cid:105) )] ≡ f = {| ϕ|}

histo-CHARN

From the universal property, we also get the cancellation, reﬂection and fusion

laws for histomorphisms:

Proposition 4.3 Let (µF, in) be an initial F-algebra.

• Cancellation: For any F-cv-algebra ϕ : F(Fν(C)) → C

{| ϕ|} ◦ in = ϕ ◦ F [((cid:104){| ϕ|}, in−1 (cid:105) )]

histo-SELF

• Reﬂection:

histo-REFL
• Fusion: For any F-cv-algebra ϕ : F(Fν(C)) → C, ψ : F(Fν(D)) → D

id = {| in◦F (fst◦ out)|}

and an arrow f : C → D

f ◦ ϕ = ψ ◦ F [( (f × id) ◦ out )] ⇒ f ◦ {| ϕ|} = {| ψ |}

histo-FUSION

Proof. The cancellation law is directly obtained from the universal property of
histomorphisms by substituting f := {| ϕ|} thus making the right-hand equation

51

/
/




/
/
in histo-CHARN trivially true. For the reﬂection law we argue:

id

=

– histo-CHARN –



=

=

=

=

=

– pairing –

– identity, F functor –

id◦ in
in◦F(id)
in◦F (fst◦(cid:104) id, in−1 (cid:105))
in◦F (fst◦(id×F [((cid:104) id, in−1 (cid:105) )]) ◦ (cid:104) id, in−1 (cid:105))
in◦F (fst◦ out◦[((cid:104) id, in−1 (cid:105) )])
in◦F (fst◦ out) ◦ F [((cid:104) id, in−1 (cid:105) )]

– ana-SELF –

– F functor –

– pairing –

{| in◦F(fst◦ out)|}

Finally, the fusion law is proved as follows:

(cid:66) f ◦ ϕ = ψ ◦ F [( (f × id) ◦ out )]

f ◦ {| ϕ|}

=






=

=

– histo-SELF –
– (cid:67) –

– histo-CHARN –
f ◦ {| ϕ|} ◦ in
f ◦ ϕ ◦ F [((cid:104){| ϕ|}, in−1 (cid:105) )]
ψ ◦ F [( (f × id) ◦ out )] ◦ F [((cid:104){| ϕ|}, in−1 (cid:105) )]
ψ ◦ F ([( (f × id) ◦ out )] ◦ [((cid:104){| ϕ|}, in−1 (cid:105) )])

– F functor –

=

=

– ana-FUSION –



=

=

=

=

– pairing –

– ana-SELF –

(f × id) ◦ out◦[((cid:104){| ϕ|}, in−1 (cid:105) )]
(f × id) ◦ (id×F [((cid:104){| ϕ|}, in−1 (cid:105) )]) ◦ (cid:104){| ϕ|}, in−1 (cid:105)
(f × F [((cid:104){| ϕ|}, in−1 (cid:105) )]) ◦ (cid:104){| ϕ|}, in−1 (cid:105)
(cid:104) f ◦ {| ϕ|}, F [((cid:104){| ϕ|}, in−1 (cid:105) )] ◦ in−1 (cid:105)
(id×F [((cid:104){| ϕ|}, in−1 (cid:105) )]) ◦ (cid:104) f ◦ {| ϕ|}, in−1 (cid:105)

– pairing –

– pairing –

ψ ◦ F [((cid:104) f ◦ {| φ|}, in−1 (cid:105) )]

{| ψ |}

52

Read from left to right, the cancellation law can be treated as the reduction
rule for histomorphisms. Informally it tells that, the value of the histomorphism
on the given argument is computed by ﬁrst building a certain “colist” and then
using a cv-algebra to give the ﬁnal result. The “colist” is generated using an
anamorphism which gets the previous argument as the initial seed. On every step,
the anamorphism computes (recursively) the value of the histomorphism on the
current seed, and also a new seed by taking a “predecessor” of the current one.

The left-hand side of the fusion law states that f is a homomorphism between
cv-algebras ϕ and ψ. Hence every cv-algebra homomorphism can be fused with
a histomorphism.

Similarly to paramorphisms, histomorphisms can be viewed as a generaliza-
tion of catamorphisms. Namely, every catamorphism is a histomorphism which
uses only the value on the “predecessor” of the current argument (i.e. the “head”
of the “colist”).
Proposition 4.4 For any F-algebra ϕ : F(C) → C,
(cid:76) ϕ(cid:77) = {| ϕ ◦ F (fst◦ out)|}

histo-CATA

Proof. It is veriﬁed by the following calculation:

(cid:76) ϕ(cid:77)



=

=

=

=

=



=

– histo-CHARN –

– pairing –

– pairing –

– cata-SELF –

(cid:76) ϕ(cid:77) ◦ in
ϕ ◦ F(cid:76) ϕ(cid:77)
ϕ ◦ F (fst◦(cid:104)(cid:76) ϕ(cid:77), in−1 (cid:105))
ϕ ◦ F (fst◦(id×F [((cid:104)(cid:76) ϕ(cid:77), in−1 (cid:105) )]) ◦ (cid:104)(cid:76) ϕ(cid:77), in−1 (cid:105))
ϕ ◦ F (fst◦ out◦[((cid:104)(cid:76) ϕ(cid:77), in−1 (cid:105) )])
ϕ ◦ F (fst◦ out) ◦ F [((cid:104)(cid:76) ϕ(cid:77), in−1 (cid:105) )]

– ana-SELF –

– F functor –

{| ϕ ◦ F (fst◦ out)|}

Example 4.1 (course-of-value iteration for naturals)
Consider
the initial N-algebra
(Nat, [ zero, succ ]). The codata type Nν(C) consists of nonempty colists over
C, and the terminal coalgebra structure is provided by out = (cid:104) cur , prev (cid:105) :

the data type of natural numbers;

i.e.

53

Nν(C) → C × (1 + Nν(C)), where cur : Nν(C) → C gives the head and
prev : Nν(C) → 1 + Nν(C) the (possible) tail of a colist.
Any N-cv-algebra ϕ : 1 + Nν(C) → C can be decomposed using join ϕ =
[ z0, s0 ], where z0 : 1 → C and s0 : Nν(C) → C. The histomorphism f =
{| [ z0, s0 ]|} : Nat → C is the unique solution of the equation system:

f(zero()) = z0()
f(succ(x)) = s0([((cid:104) f, pred (cid:105) )](x)),

where pred : Nat → 1 + Nat is the predecessor function from the Example 2.2.
In order to get more illuminating version of the course-of-value iteration oper-
ator, assume that the function s0 is in form s0 = [ z1◦ !, s1 ] ◦ distr◦ out for some
constant1 z1 : 1 → C and function s1 : C × Nν(C) → C. Then the correspond-
ing histomorphism f = {| [ z0, [ z1◦ !, s1 ] ◦ distr◦ out ]|} is characterized by the
equations:

f(zero()) = z0()
f(succ(zero())) = z1()
f(succ(x)) = s1(f(x), [((cid:104) f, pred (cid:105) )](x)).

Now, the use of the value on the previous argument is explicit. Particularly, by
taking z0 = one, z1 = one and s1(x, y) = add(x, cur(y)), we get the deﬁnition
of the Fibonacci function; i.e.

ﬁbo = {| [ one, [ one◦ !, add ◦ (id×cur) ] ◦ distr◦ out ]|}.

The general form of course-of-value iteration operator involves n+1 constants
z0, . . . , zn : 1 → C and a function sn : C × (. . . (C × Nν(C)) . . . ) → C (here
the product has n + 1 components). The corresponding histomorphism is
f = {| [ z0, [ z1◦ !, [ z2◦ !, . . . [ zn◦ !, sn ] ◦ dout . . . ] ◦ dout ] ◦ dout ]|},

where dout = distr◦ out. It is characterized by the system of n + 2 equations:

f(zero()) = z0()
f(succ(zero())) = z1()

. . .

f(succn(zero())) = zn()

f(succn(x)) = sn(f n(x), . . . , f(x), [((cid:104) f, pred (cid:105) )](x)).

1Instead of the constant, the left branch of the join could be a function h : C → C which makes
use of the value on the previous argument. However, the previous argument is known to be zero
and the value on it is z0, thus result on the argument succ◦ zero is already known to be z1 = h(z0).

54

Note that in such way we can characterize functions which make use of arbitrary
but ﬁxed number of preceding values. Of course, we can imagine functions which
make use of all preceding values (such recursion scheme is called course-of-value
recursion). The classical example of such function is f(n) = 2n, which can be
characterized as:

f(n) = 1 + f(n − 1) + ··· + f(1) + f(0).

If we rewrite the equation in a more explicit form

f(n) = 1 +

f(i),

n−1(cid:88)

i=0

we see that the use of all preceding values can be achieved by using primitive
recursion and course-of-value iteration at the same time.

4.3 Futumorphisms

We now introduce a construction dual to cv-algebras and histomorphisms.

Deﬁnition 4.4 (cv-coalgebra)
Let F : C → C be an endofunctor for which there exists a terminal coalgebra
(νF, out). Deﬁne a bifunctor F+ : C × C → C as follows:

F+(A, X) = A + F(X).

A-algebra (µF+

A, in), i.e. F+
X. A F-cv-coalgebra is a pair (C, ϕ), where

Assume that for any object A there exists an initial F+
induces a data functor Fµ(X) = µF+
C is an object and ϕ : C → F(F+(C)) is an arrow.
Deﬁnition 4.5 (cv-coalgebra homomorphism)
Let (C, ϕ) and (D, ψ) be two F-cv-algebras. A homomorphism from (C, ϕ) to
(D, ψ) is an arrow f : C → D in the category C, such that
ψ ◦ f = F(cid:76) in◦(f + id)(cid:77) ◦ ϕ

i.e. makes the following diagram to commute:

C

f

D

ϕ /

F(Fµ(C))

F(cid:76) in ◦(f +id)(cid:77)

ψ /

/ F(Fµ(D))

55

/




Note that any F-cv-coalgebra is an ordinary coalgebra for a functor G(X) =
F(Fµ(X)), and homomorphisms between F-cv-coalgebras are ordinary homomor-
phisms between G-coalgebras.

Deﬁnition 4.6 (futumorphism)
Let (νF, out) be a terminal F-coalgebra. For any F-cv-coalgebra ϕ : C →
F(Fµ(C)), the arrow [{ ϕ}] : C → νF is deﬁned by

[{ ϕ}] = [( [ ϕ, id ] ◦ in−1 )] ◦ in◦ inl

futu-DEF

The arrows in form [{ ϕ}] are called futumorphisms.
Corollary 4.5 For any F-cv-coalgebra ϕ : C → F(F+(C)), the futumorphism
f = [{ ϕ}] : C → νF is the unique arrow making the following diagram commute:

C

f

νF

ϕ

out

F(Fµ(C))

F(cid:76) [ f,out

−1 ](cid:77)

/ F(νF)

i.e. satisfying the universal property:

out◦f = F(cid:76) [ f, out−1 ](cid:77) ◦ ϕ ≡ f = [{ ϕ}]

futu-CHARN

By a straightforward dualization of the laws for histomorphisms, we get the

corresponding laws for futumorphisms.

Corollary 4.6 Let (µF, in) be an initial F-algebra.

• Cancellation: For any F-cv-coalgebra ϕ : C → F(F+(C))

futu-SELF

• Reﬂection:

out◦[{ ϕ}] = F(cid:76) [ [{ ϕ}], out−1 ](cid:77) ◦ ϕ
id = [{ F (in◦ inl) ◦ out}]

futu-REFL
• Fusion: For any F-cv-coalgebra ϕ : C → F(F+(C)), ψ : D → F(F+(D))

and an arrow f : C → D
ψ ◦ f = F(cid:76) in◦(f + id)(cid:77) ◦ ϕ ⇒ [{ ψ }] ◦ f = [{ ϕ}]

futu-FUSION

56

/
/




/
• Ana from futu: For any F-coalgebra ϕ : C → F(C)
[( ϕ )] = [{ F (in◦ inl) ◦ ϕ}]

futu-ANA

Example 4.2 (course-of-value coiteration for streams)
Recall, that the terminal coalgebra for a bifunctor S(A, X) = A × X was given
by Stream(A), the codata type of streams over A, with the coalgebra structure
(cid:104) head , tail (cid:105) : Stream(A) → A× Stream(A). The inductive data type manifest-
ing in stream futumorphisms is given by the induced data bifunctor Sµ(C, A) =
C,A, where S+(C, A, X) = C + A × X; i.e. data type of nonempty lists where
µS+
all elements except the last one are from type A, and the last element is of type C.
The initial algebra structure is given by [ l, c ] : C + A × Sµ(C, A) → Sµ(C, A),
where l : C → Sµ(C, A) constructs the singleton list and c : A × Sµ(C, A) →
Sµ(C, A) inserts the new element of type A into ﬁrst position.
Every SA-cv-coalgebra ϕ : C → A × Sµ(C, A) can be decomposed using
fork ϕ = (cid:104) h0, t(cid:105), where h0 : C → A and t : C → Sµ(C, A). The futumorphism
f = [{(cid:104) h0, t(cid:105)}] : C → Stream(A) is the unique solution of the equation system:

head(f(x)) = h0(x)

tail(f(x)) = (cid:76) [ f, cons ](cid:77)(t(x)),

where cons = out−1 : A × Stream(A) → Stream(A). Intuitively, the function
t in produces a list of stream elements going to follow just next after the current
head, and also a new seed as the last element of the list. Then the catamorphism
replaces the list constructors c with the “stream constructor” cons, thus forming
an initial preﬁx of the tail stream. Finally, the last constructor l, which contains
the new seed, is replaced by f, which continues recursively to produce the rest of
the stream.

Assume that the function t explicitly constructs the list of n + 1 elements; i.e.

it is in form

t(x) = c(h1(x), (c(h2(x), . . . c(hn(x), l(s(x))) . . . ))),

where h1, . . . , hn : C → A and s : C → C. Then the futumorphism f =
[{(cid:104) h0, c ◦ (cid:104) h1, . . . c ◦ (cid:104) hn, l ◦ s(cid:105) . . .(cid:105)(cid:105)}] : C → Stream(A) is characterized by a
system of n + 2 equations:

head(f(x)) = h0(x)
head(tail(f(x))) = h1(x)

. . .

head(tail n(f(x))) = hn(x)
tail(tail n(f(x))) = f(s(x)).

57

For instance, the function exch : Stream(A) → Stream(A), which pairwise
exchanges the elements of any given argument, is characterized by the equation
system

head(exch(x)) = head(tail(x))

head(tail(exch(x))) = head(x)
tail(tail(exch(x))) = exch(tail(tail(x))).

Thus it is deﬁnable as a futumorphism:

exch = [{(cid:104) head ◦ tail , c ◦ (cid:104) head , l ◦ tail ◦ tail (cid:105)(cid:105)}].

4.4 Histo- and futumorphisms in Haskell

Histomorphisms map arrows F(Fν(C)) → C to arrows µF → C. Hence, in order
to implement histomorphisms in Haskell, we ﬁrst have to deﬁne the base functor
for the “course-of-values” codata structure:

> newtype ProdF f a x = ProdF (a, f x)

> instance Functor f => Functor (ProdF f a) where
>

fmap f (ProdF (a, fx)) = ProdF (a, fmap f fx)

We also deﬁne the pairing function for ProdF:

> forkF :: (a -> b) -> (a -> f c) -> a
>
> forkF f g = ProdF . fork f g

-> ProdF f b c

In order to ease the navigation on the “course-of-values” codata structure, we
deﬁne destructor functions out of it:

> hdCV :: Nu (ProdF f c) -> c
> hdCV xs = case out xs of
>

ProdF (c, _)

-> c

> tlCV :: Nu (ProdF f c) -> f (Nu (ProdF f c))
> tlCV xs = case out xs of
>

ProdF (_, fx) -> fx

Now, the type of histomorphism combinator can be expressed in Haskell as fol-
lows:

58

> histo :: Functor f => (f (Nu (ProdF f c)) -> c)
>

Mu f

-> c

->

Like in the case of paramorphisms, we have two possibilities for the deﬁning
equation of histo combinator. First, we can deﬁne it in terms of catamorphism:

> histo phi = hdCV . cata (Wrap . forkF phi id)

The second possibility is to use the directly recursive deﬁnition:

histo phi = phi

. fmap (ana (forkF (histo phi) unIn))
. unIn

This time, however, the ﬁrst deﬁnition is more efﬁcient. In the case of directly re-
cursive deﬁnition, “course-of-value” codata structure is recomputed in every step
of iteration. On the other hand, the catamorphic deﬁnition computes the “course-
of-value” codata structure incrementally in a bottom-up fashion, thus effectively
implementing the memoization of the values on previous arguments.

Example 4.3 (Fibonacci)
The Fibonacci function can be implemented as histomorphism (for greater clarity
we use Haskell integers Int as the result type):

where phi Z

> fibo :: Nat -> Int
> fibo = histo phi
>
>
>
>

= 1

phi (S x) = case tlCV x of

-> 1

Z
S y -> hdCV x + hdCV y

Example 4.4 (evens)
The function evens takes from the given list every second element. It can be
deﬁned as histomorphism:

where phi

> evens :: List a -> List a
> evens = histo phi
>
>
>
>

N

= nilL

phi (C _ x) = case tlCV x of

-> nilL

N
C a y -> consL a (hdCV y)

59

Futumorphisms map arrows C → F(Fµ(C)) to arrows C → νF. Hence, in
order to implement futumorphisms in Haskell, we ﬁrst have to deﬁne the base
functor for the inductive data structure Fµ(C):

> newtype SumF f a x = SumF (Sum a (f x))

> instance Functor f => Functor (SumF f a) where
>
>

fmap f (SumF (InL a)) = SumF (InL a)
fmap f (SumF (InR x)) = SumF (InR (fmap f x))

> joinF :: (a -> c) -> (f b -> c) -> SumF f a b -> c
> joinF f g (SumF s) = join f g s

We also deﬁne constructor functions for the inductive data structure:

> lastF :: c -> Mu (SumF f c)
> lastF x = In (SumF (InL x))

> consF :: f (Mu (SumF f c)) -> Mu (SumF f c)
> consF x = In (SumF (InR x))

Now, the type of futumorphism combinator can be expressed in Haskell as fol-
lows:

> futu :: Functor f => (c -> f (Mu (SumF f c)))
>

c -> Nu f

->

Like in the case of histomorphisms, we have two possibilities for the deﬁning
equation of futumorphisms combinator. First, we can deﬁne it in terms of anamor-
phism:

futu phi = ana (joinF phi id . unIn) . lastF

The second possibility is to use the directly recursive deﬁnition obtained from the
cancellation law:

> futu phi = Wrap
>
>

. fmap (cata (joinF (futu phi) Wrap))
. phi

There is no difference between two deﬁnitions in terms of efﬁciency except some
small constant factor.

60

Example 4.5 (exchange)
The function exch from the example 4.2 can be implemented as follows:

> exch :: Stream a -> Stream a
> exch = futu phi
>
>
>

where phi xs = St (headS (tailS xs))

(consF (St (headS xs)

(lastF (tailS xs))))

4.5 Related work

We do not know any other directly comparable work on course-of-value iteration
or coiteration (except our own work in a type-theoretic setting [UV97, UV00b,
Uus98]). The closest is work by Hu, Iwasaki and others [HITT96] about the tu-
pling transformation. They develop calculational rules to eliminate multiple data
traversals on functions deﬁned by course-of-value iteration (and also by mutual
recursion). Instead of using coinductive data structure to represent the course-
of-values, they are using ﬁnite products which essentially are the unfolded ﬁnite
preﬁxes of the course-of-values the function actually uses. This makes the rules
quite hard to follow, but their aim is to use these rules in some automatic program
transformation system, and not in programming itself.

61

62

CHAPTER 5

MENDLER-STYLE INDUCTIVE

TYPES

This chapter is based on [UV99a] and here we consider a novel alternative ap-
proach to inductive types in the categorical setting, inspired from the work by
N. P. Mendler [Men91] in type theory. The basic motivation for this another for-
malization lies in the difﬁculties of extending the traditional approach to inductive
types (and coinductive types) for non-covariant base functors. Freyd’s dialgebras
[Fre90, Fre91] solve the problem for mixed-variant functors, but at the cost that
the distinction between inductive and coinductive types vanishes.

One reason for the difﬁculties in the conventional approach is that the deﬁ-
nition of homomorphism between F-algebras explicitly mentions the arrow map-
ping part of the functor. As a result, if F is not a covariant functor, the deﬁnition
of homomorphisms has to be changed accordingly, otherwise the distributivity
equation the homomorphism must satisfy is incorrectly typed.

The basic idea of so called Mendler-style inductive types is to modify the def-
inition of algebra and their homomorphisms in such a way that the arrow mapping
part of the functor does not manifest itself in the distributivity equation. Instead,
there is an additional condition that the algebra itself has to satisfy, and functor
appears only in the typing. Then the concept can be extended to apply to non-
covariant bases by modifying the condition in the deﬁnition of algebra, but leav-
ing the deﬁnition of algebra homomorphism (and so also the calculational laws)
intact.

5.1 Mendler-style inductive types: covariant case

Recall, that for a given object C of the category C, we can form a contravari-
ant homfunctor C(−, C) : Cop → Set which takes an object A to the hom-set
C(A, C), and an arrow g : A → B to the function C(g, C) : C(B, C) → C(A, C)

63

deﬁned by λβ : B → C. β ◦ g. Similarly, if F : C → C is an endofunctor,
we can deﬁne a contravariant functor C(F(−), C) : Cop → Set which takes any
object A to the hom-set C(F(A), C), and any arrow g : A → B to the function
C(F(g), C) : C(F(B), C) → C(F(A), C) deﬁned by λβ : B → C. β ◦ F(g). In
the following we denote the functor C(F(−), C) by F/C.
Deﬁnition 5.1 (Mendler-style algebra for a functor)
Let F : C → C be an endofunctor. A Mendler-style F-algebra or F-malgebra
is a pair (C, Φ), where C is an object of C and Φ : Id/C .→ F/C is a natural
transformation; i.e. for any arrow g : A → B the following diagram commutes:

C(B, C)

C(g,C)

C(A, C)

ΦB

ΦA

C(F(B), C)

C(F(g),C)

/ C(F(A), C)

In other words, Φ is an operation on arrows with target C which “lifts” the
source of the arrow under the functor F, by taking any arrow α : A → C to the
arrow ΦA(α) : F(A) → C. If the lifted arrow α : C → C is an automorphism
(i.e. an arrow with the same source and target object), then ΦC(α) : F(C) → C
is a conventional F-algebra. In particular, Φ takes the identity arrow on C to a
conventional F-algebra ΦC(id).

The naturality condition says, that the lifting preserves compositions in the
if α = β ◦ g for some object B and arrows β : B → C,

following sense:
g : A → B, then

ΦA(β ◦ g) = ΦB(β) ◦ F(g)

(5.1)

or diagrammatically

g

A

@@@@@@@

α

B

~~~~~~~~

β

⇒

F(A)

!DDDDDDDD

ΦA(α)

F(g)

/ F(B)

}zzzzzzzz

ΦB(β)

C
In particular, by taking B = C and β = idC, we have that

C

ΦA(α) = ΦC(id) ◦ F(α)

(5.2)

So, the lifting on the arrows is determined by the composition the functor with
some F-algebra.

64

/
/




/

/
/
~
!
/
}
Deﬁnition 5.2 (malgebra homomorphism)
Let (C, Φ) and (D, Ψ) be F-malgebras. A homomorphism from (C, Φ) to (D, Ψ)
is an arrow h : C → D such that for any object A the following diagram com-
mutes in Set:

C(A, C)

C(A,h)

C(A, D)

ΦA

C(F(A), C)

ΨA

/ C(F(A), D)

C(F(A),h)

In terms of base category C, the square above tells that for any object A and

arrow γ : A → C, the following equation holds:

h ◦ ΦA(γ) = ΨA(h ◦ γ)

(5.3)

(5.4)

(5.5)

or diagrammatically:

γ

~~~~~~~

 @@@@@@@

δ

A

h

D

C

⇒

F(A)

ΦA(γ)

}zzzzzzzz

ΨA(δ)

!DDDDDDDD

C

h

D

In particular, if we take A = C and α = idC, then
h ◦ ΦC(id) = ΨC(h).
Now, using the equality 5.2 about malgebras we get

h ◦ ΦC(id) = ΨC(id) ◦ F(h).

Thus, homomorphism h is also homomorphism between conventional F-algebras
ΦC(id) and ΨC(id).

Obviously, homomorphisms between malgebras compose, and the identity ar-
row on the carrier object gives the identity homomorphism. So, we can form a
category Alg(F)m of Mendler-style F-algebras and their homomorphisms.
Deﬁnition 5.3 (initial malgebra for a functor)
ler-style F-algebra (C, Φ) there exists an arrow(cid:76) Φ(cid:77)m : µmF → C satisfying the
A Mendler-style F-algebra (µmF, inm) is an initial F-malgebra if for any Mend-

universal property:
f ◦ inm

µmF(id) = ΦµmF(f) ≡ f =(cid:76) Φ(cid:77)m

cataM-CHARN

65

/
/




/

 
/
/
}
!
/
/
In other words, the initial malgebra (µmF, inm) is the initial object in the
category Alg(F)m. The cancellation, reﬂection and fusion laws for Mendler-style
catamorphisms specialize as follows:

Corollary 5.1 Let (µmF, inm) be an initial F-malgebra.

• Cancellation: For any F-malgebra (C, Φ)

(cid:76) Φ(cid:77)m ◦ inm

µmF(id) = ΦµmF((cid:76) Φ(cid:77)m)

cataM-SELF

• Reﬂection:

id =(cid:76) inm(cid:77)m

cataM-REFL
• Fusion: For any F-malgebras (C, Φ) and (D, Ψ) and an arrow f : C → D
cataM-FUSION

f ◦ ΦC(id) = ΨC(f) ⇒ f ◦(cid:76) Φ(cid:77)m =(cid:76) Ψ(cid:77)m

Note that neither the universal property nor the laws derived from it contain
any direct references to the functor F. The functor only appears implicitly on the
typing, and as the naturality condition for Mendler-style algebras involved.

Example 5.1 (naturals)
Consider the data type of natural numbers Nat. Recall, that it forms the initial
algebra (Nat, [ zero, succ ]) for the functor N(X) = 1 + X. For any object A
and arrow γ : A → Nat, deﬁne a mapping inm
A(γ) = [ zero, succ ◦ γ ]. Then
(Nat, inm) forms an initial N-malgebra.

For instance, the sum of two naturals can be deﬁned in terms of Mendler-style

catamorphism as follows:

add(n, m) = (cid:76) λA, γ : A → Nat. [ λx.m, succ ◦ γ ](cid:77)m(n).

5.2 Conventional inductive types reduced to

Mendler-style inductive types

The project of this section is to show that conventional inductive types reduce to
Mendler-style inductive types. To this end, we prove that, for any endofunctor
F : C → C, the categories Alg(F)m and Alg(F) are isomorphic. The proof we
present is a proof from scratch. For a reader versed in category theory, the result
is a consequence from the Yoneda lemma.

66

Deﬁnition 5.4 (malgebra to algebra mapping)
For any F-malgebra (C, Φ), deﬁne

(cid:120)Φ(cid:121) = ΦC(id)

Deﬁnition 5.5 (algebra to malgebra mapping)
For any conventional F-algebra (C, ϕ), deﬁne

(cid:112)ϕ(cid:113) = λA, γ : A → C. ϕ ◦ F(γ)

Proposition 5.2 If (C, Φ) is a F-malgebra, then (C, (cid:120)Φ(cid:121)) is a F-algebra.
Proof. Trivial.
Proposition 5.3 If (C, ϕ) is a F-algebra, then (C, (cid:112)ϕ(cid:113)) is a F-malgebra.
Proof. We have to check that (cid:112)ϕ(cid:113) is a natural transformation.
(cid:66) pick A, B, g : A → B, β : B → C



=

=

=

– (cid:112)−(cid:113)-def –

(cid:112)ϕ(cid:113)A(β ◦ g)
ϕ ◦ F(β ◦ g)
– F functor –
ϕ ◦ F(β) ◦ F(g)
– (cid:112)−(cid:113)-def –
(cid:112)ϕ(cid:113)B(β) ◦ F(g)

Proposition 5.4 If (C, Φ) is a Mendler-style F-algebra, then

(cid:112)(cid:120)Φ(cid:121)(cid:113) = Φ.

Proof.



(cid:66) pick A, γ : A → C

(cid:112)(cid:120)Φ(cid:121)(cid:113)A(γ)
– (cid:112)−(cid:113)-def –
(cid:120)Φ(cid:121) ◦ F (γ)
– (cid:120)−(cid:121)-def –
ΦC(id) ◦ F (γ)
– Φ natural –

=

=

=

ΦA(γ)

67

Proposition 5.5 If (C, ϕ) is a conventional F -algebra, then

Proof.

(cid:120)(cid:112)ϕ(cid:113)(cid:121) = ϕ.



=

=

=

(cid:120)(cid:112)ϕ(cid:113)(cid:121)
(cid:112)ϕ(cid:113)C(id)
ϕ ◦ F (id)

– (cid:120)−(cid:121)-def –
– (cid:112)−(cid:113)-def –

– F functorial –

ϕ

Proposition 5.6 If h is a Mendler-style F-algebra homomorphism between
(C, Φ) and (D, Ψ), then h is also a conventional F-algebra homomorphism be-
tween (C, (cid:120)Φ(cid:121)) and (D, (cid:120)Ψ(cid:121)).

Proof. Already shown, see the equation 5.5 and the discussion before it.

Proposition 5.7 If h is a conventional F-algebra homomorphism between (C, ϕ)
and (D, ψ), then h is also a Mendler-style F-algebra homomorphism between
(C, (cid:112)ϕ(cid:113)) and (D, (cid:112)ψ(cid:113)).

Proof.



=

=

=

=

(cid:66) h ◦ ϕ = ψ ◦ F(h)
(cid:66) pick A, γ : A → C

– (cid:112)−(cid:113)-def –
– (cid:67) –

h ◦ (cid:112)ϕ(cid:113)A(γ)
h ◦ ϕ ◦ F(γ)
ψ ◦ F(h) ◦ F(γ)
– F functorial –
ψ ◦ F(h ◦ γ)
– (cid:112)−(cid:113)-def –
(cid:112)ψ(cid:113)A(h ◦ γ)

These propositions tell us that there exists a functor between the categories

Alg(F)m and Alg(F) and a left-and-right inverse for it.

68

Theorem 5.8 The categories Alg(F)m and Alg(F) are isomorphic.

The following is now immediate:

Corollary 5.9 If (µmF, inm) is an initial Mendler-style F-algebra,
then
(µmF, (cid:120)inm(cid:121)) is an initial (conventional) F-algebra. For any F-algebra ϕ :
F(C) → C, the unique homomorphism into it (i.e. catamorphism) is given by
(cid:76) (cid:112)ϕ(cid:113)(cid:77)m : µmF → C.
(cid:76) (cid:120)Φ(cid:121)(cid:77) : µF → C.

Corollary 5.10 If (µF, in) is an initial (conventional) F-algebra, then (µF, (cid:112)in(cid:113))
is an initial Mendler-style F-algebra. For any Mendler-style F-algebra (C, Φ),
the unique homomorphism into it (i.e. Mendler-style catamorphism) is given by

5.3 Mendler-style inductive types: mixed variant case

The idea of Mendler-style inductive types makes sense not only for covariant base
functors F : C → C, but also for mixed variant functors G : Cop × C → C. The
mixed variant case is, in fact, more general, as covariant functors are a degenerate
case of mixed variant functors: for any F : C → C, one can trivially deﬁne
(cid:111) : Cop × C → C, a padding of F
with a “dummy” contravariant argument, by
F
letting F

(cid:111)(Y, X) = F(X).

(cid:111)

Deﬁnition 5.6 (Mendler-style algebra for a difunctor)
Let G : Cop × C → C be an endodifunctor. A Mendler-style G-algebra or G-
malgebra is a pair (C, Φ), where C is an object of C and Φ : Id
/C ..→ G/C is
(cid:111)
a dinatural transformation; i.e. for any arrow g : A → B the following diagram
commutes:

mmmmm

C(g,C)

vmmmmm

C(B, C)

QQQQQQQQQQQQQ
QQQQQQQQQQQQQ

C(B, C)

ΦB

C(A, C)

ΦA

C(G(B, B), C)
C(G(A, A), C)
QQQQQ
mmmmm
C(G(idB,g),C)
C(G(g,idA),C)
(QQQQQ
vmmmmm
C(G(B, A), C)

69

v




(
v
In terms of the base category, Φ is a mapping that takes any arrow γ : A → C
to the arrow ΦA(α) : G(A, A) → C in such a way that if α = β ◦ g for some
object B and arrows β : B → C, g : A → B, then the following equation holds:
(5.6)

ΦA(β ◦ g) ◦ G(g, idA) = ΦB(β) ◦ G(idB, g)

or diagrammatically:

G(B, A)

G(g,idA)

yrrrrrrrrrr
&LLLLLLLLLLL

ΦA(α)

G(idB,g)

%LLLLLLLLLL
xqqqqqqqqqqq

ΦB(β)

G(A, A)

G(B, B)

A

g

@
>>>>>>>>

α

B

β

C

⇒

C

If the contravariant argument of the difunctor G is “dummy” (i.e. G(X, Y ) =
F(Y ) for some covariant functor F : C → C) then the dinaturality condition boils
down to the naturality condition in deﬁnition 5.1, and equation 5.6 simpliﬁes to
equation 5.1. So in this case the deﬁnitions 5.1 and 5.6 coincide.

Deﬁnition 5.7 (malgebra homomorphism)
Let (C, Φ) and (D, Ψ) be G-malgebras for a difunctor G : Cop × C → C. A
homomorphism from (C, Φ) to (D, Ψ) is an arrow h : C → D such that for any
object A the following diagram commutes in Set:

C(A, C)

C(A,h)

C(A, D)

ΦA 

C(G(A, A), C) C(G(A,A),h)

ΨA

/ C(G(A, A), D)

In terms of base category C, the square above tells that for any object A and

arrow γ : A → C, the following equation holds:

h ◦ ΦA(γ) = ΨA(h ◦ γ)

(5.7)

or diagrammatically:

γ

~~~~~~~

 @@@@@@@

δ

A

h

D

C

⇒

70

G(A, A)

ΦA(γ)

{wwwwwwwww

ΨA(δ)

#GGGGGGGGG

C

h

D



y
%
@

&
x
/
/


/

 
/
/
{
#
/
/
Like in the covariant case, G-malgebras and their homomorphisms (for a di-

Note that the equation 5.7 looks exactly the same as the equation 5.3. The only
difference between two is on the typing of Φ and Ψ.
functor G) form a category Alg(G)m.
Deﬁnition 5.8 (initial malgebra for a difunctor)
ler-style G-algebra (C, Φ) there exists a unique arrow(cid:76) Φ(cid:77)m : µmG → C satisfy-
A Mendler-style G-algebra (µmG, inm) is the initial G-malgebra if for any Mend-

ing the universal property:

f ◦ inm

µmG(id) = Φ(f) ≡ f =(cid:76) Φ(cid:77)m

cataM-CHARN

In other words, the initial malgebra (µmG, inm) is an initial object in the cat-
egory Alg(G)m. The cancellation, reﬂection and fusion laws for Mendler-style
catamorphisms specialize as follows:

Corollary 5.11 Let (µmG, inm) be an initial G-malgebra.

• Cancellation: For any G-malgebra (C, Φ)

(cid:76) Φ(cid:77)m ◦ inm

µmG(id) = ΦµmG((cid:76) Φ(cid:77)m)

• Reﬂection:

cataM-SELF

id =(cid:76) inm(cid:77)m

cataM-REFL
• Fusion: For any G-malgebras (C, Φ) and (D, Ψ) and an arrow f : C → D

f ◦ ΦC(id) = ΨC(f) ⇒ f ◦(cid:76) Φ(cid:77)m =(cid:76) Ψ(cid:77)m

cataM-FUSION

Note the fact that the arrow mapping part of the signature difunctor is not
mentioned manifestly in the calculational laws for an initial Mendler-style alge-
bra, it only appears in the dinaturality condition and this would in normal practice
always be a “theorem for free” `a la Wadler [Wad89].

Example 5.2 (course-of-value naturals)
Let G(Y, X) = [Y → N(X)] × N(X) and write Nat(cid:48)
for the carrier of the ini-
tial Mendler-style G-algebra (µmG, inm). Assume that there exists a predecessor
function pred(cid:48) : Nat(cid:48) → 1 + Nat(cid:48)
which satisﬁes the following speciﬁcation: for
any object A and morphism γ : A → Nat(cid:48)

pred(cid:48) ◦ inm(γ) = N(γ) ◦ snd .

71

Then the functions zero(cid:48) : 1 → Nat(cid:48)
zero(cid:48) = inm
succ(cid:48) = inm

Nat

Nat

and succ(cid:48) : Nat(cid:48) → Nat(cid:48)
, inl(cid:105)
(cid:48)(id) ◦ (cid:104) λx. pred(cid:48)
(cid:48)(id) ◦ (cid:104) λx. pred(cid:48)
, inr(cid:105).

can be deﬁned as

Now, the Fibonacci function can be deﬁned as a Mendler-style catamorphism

ﬁbo =(cid:76) Φ(cid:77)m : Nat(cid:48) → Nat, where
ΦA(γ : A → Nat)(p, inl())
ΦA(γ : A → Nat)(p, inr(n)) = [ one, λn

= one()

(cid:48)

. add(γ(n), γ(n

(cid:48))) ](p(n))

5.4 Restricted existential types

The project opposite to that of the Section 5.2 — reducing Mendler-style inductive
types to conventional inductive types — is unperformable in general. But, as we
will see in Section 5.5, it can be carried out, if certain restricted existential types
are available. Let us explain what these are.

Deﬁnition 5.9 (restricted cowedge)
Let G : Cop × C → C be an endodifunctor and H : Cop × C → Set a difunctor to
Set. An H-restricted G-cowedge (cowedge from G) is a pair (C, Φ) formed of an
object C of C and dinatural transformation Φ between the difunctors H and G/C,
i.e., a family of functions {ΦA}A∈C between the sets H(A, A) and C(G(A, A), C)
indexed over objects of C such that, for any arrow g : A → B the following
diagram commutes:

H(B, A)

QQQQQ

H(idB,g)

(QQQQQ

mmmmm

H(g,idA)

vmmmmm

H(A, A)

ΦA

H(B, B)

ΦB

C(G(A, A), C)
C(G(B, B), C)
QQQQQ
mmmmm
C(G(g,idA),C)
C(G(idB,g),C)
(QQQQQ
vmmmmm
C(G(B, A), C)

72

v
(




(
v
In other words, Φ is a function that takes objects A of C to functions ΦA
sending elements a of H(A, A) to morphisms ΦA(a) : G(A, A) → C so that the
following condition is met: for any objects A, B and morphism g : A → B of C
and any element c of H(B, A), it holds in C that

ΦA(H(g, idA)c) ◦ G(g, idA) = ΦB(H(idB, g)c) ◦ G(idB, g)

or diagrammatically

G(B, A)

G(idB,g)

/ G(B, B)

G(g,idA)

ΦB (H(idB,g)c)

G(A, A)

ΦA (H(g,idA)c)

C

Deﬁnition 5.10 (restricted cowedge homomorphism)
An H-restricted G-cowedge homomorphism between H-restricted G-cowedges
(C, Φ) and (D, Ψ) is an arrow h : C → D of C with the property that, for
any object A of C, it holds in Set that

C(G(A, A), h) ◦ ΦA = ΨA

or diagrammatically

H(A, A)

ΦA

wooooooooooo

'OOOOOOOOOOO

ΨA

C(G(A, A), C)

C(G(A,A),h)

/ C(G(A, A), D)

This condition is equivalent to the following one: for any object A of C and

any element a of H(A, A), it is the case in C that h ◦ ΦA(a) = ΨA(a).

ΦA(a)

{wwwwwwwww

G(A, A)

ΨA(a)

#GGGGGGGGG

C

h

D

The H-restricted G-cowedges and homomorphisms between them form a cat-

egory, Cow H
G.

73



/


/
/
w
'
/
{
#
/
/
Deﬁnition 5.11 (restricted coend)
An H-restricted G-cowedge (Σ(H, G), injH
initial object of Cow H
unique arrow f = [ Φ ]H
(∀A, a ∈ H(A, A). f ◦ (injH

G) is a H-restricted G-coend if it is an
G; i.e. for any H-restricted G-cowedge (C, Φ) there exists an
G : Σ(H, G) → C satisfying the universal property:

G)A(a) = ΦA(a)) ≡ f = [ Φ ]H

G case-CHARN

The cancellation, reﬂection and fusion laws for restricted coends specialize as

follows:

Corollary 5.12 Let (Σ(H, G), injH

G) be a H-restricted G-coend.

• Cancellation: For any H-restricted G-cowedge (C, Φ)

∀A, a ∈ H(A, A). [ Φ ]H

G

◦ (injH

G)A(a) = ΦA(a)

case-SELF

• Reﬂection:

case-REFL
• Fusion: For any H-restricted G-cowedges (C, Φ) and (D, Ψ) and arrow

idΣ(H,G) = [ injH

G ]H
G

h : C → D

(∀A, a ∈ H(A, A). h ◦ ΦA(a) = ΨA(a)) ⇒ h ◦ [ Φ ]H

G = [ Ψ ]H
G
case-FUSION

Example 5.3 (coends)
Consider the constant functor 1 : Cop × C → Set, which sends everything into a
singleton set (i.e. an terminal object of Set). Given an endodifunctor G : Cop ×
C → C, a pair (C, Φ) is a 1-restricted G-cowedge if Φ is a family of arrows
ΦA = G(A, A) → C which make the diagram

G(B, A)

G(idB,g)

/ G(B, B)

G(g,idA)

G(A, A)

ΦA

74

ΦB

C



/


/
/
commute for every g : A → B. In other words, the pair (C, Φ) is a cowedge
of G in ordinary sense1 (i.e. Φ is a dinatural transformation from G to a constant
functor C). Given two cowedges (C, Φ) and (D, Ψ), an arrow h : C → D is
a homomorphism between them iff h ◦ ΦA = ΨA for any object A. Finally,
(cid:82) c G(c, c) is used for Σ(1, G)).
a 1-restricted G-coend is the coend of G (see e.g. [Mac97], where the notation

5.5 Mendler-styles inductive types reduced to

conventional inductive types

The necessary preparations made in the previous section, we are now in a position
to construct a reduction of Mendler-style inductive types to conventional inductive
types. We will obtain it in the same fashion as we obtained the reduction of
conventional inductive types to Mendler-style inductive types in Section 5.2.
Let G be an endodifunctor on C such that, for any object C of C, there exists a
(cid:111)
). Then, we can deﬁne
/C-restricted G-coend ((Σ(Id

), [· ]Id

(cid:111)
/C, G), injId
G

/C

/C

G

(cid:111)

(cid:111)
Id
the following endofunction Ge on C:
(cid:111)
GeC = Σ(Id

/C, G)

Ge(h : C → D) = [ λA, γ : A → C. (injId

(cid:111)

/D

)A(h ◦ γ) ]Id

(cid:111)

G

/C

.

G

The function Ge turns out to be functorial (as one might expect), so Ge is an
endofunctor on C.
Deﬁnition 5.12
Given a Mendler-style G-algebra (C, Φ). Deﬁne

(cid:111)
(cid:120)Φ(cid:121) = [ Φ ]Id

G

/C

Deﬁnition 5.13
Given a conventional Ge-algebra (C, ϕ). Deﬁne

(cid:112)ϕ(cid:113) = λA, γ : A → C. ϕ ◦ (injId

(cid:111)

G

/C

)A(γ)

Proposition 5.13 If (C, ϕ) is a conventional Ge-algebra, then (C, (cid:112)ϕ(cid:113)) is a
Mendler-style G-algebra.

1Mac Lane [Mac97] uses the term wedge for both, the dinatural transformations from and to
constant functor. However, universal wedges are called ends and coends respectively, hence our use
of the term cowedge

75

Proof. It has to be checked that (cid:112)C, ϕ(cid:113) is dinatural.



(cid:66) pick A, B, g : A → B, β : B → C

(cid:111)

– (cid:112)−(cid:113)-def –

(cid:112)ϕ(cid:113)A(β ◦ g) ◦ G(g, idA)
ϕ ◦ (injId
/C
G
(cid:111)
– injId
G
(cid:111)
ϕ ◦ (injId
– (cid:112)−(cid:113)-def –
(cid:112)ϕ(cid:113)B(β) ◦ G(idB, g)

)A(β ◦ g) ◦ G(g, idA)
dinatural –
)Bβ ◦ G(idB, g)

/C

/C

G

=

=

=

Proposition 5.14 If (C, Φ) is a Mendler-style G-algebra, then (C, (cid:120)Φ(cid:121)) is a con-
ventional Ge-algebra.

Proof. Trivial.

Proposition 5.15 If (C, ϕ) is a conventional Ge-algebra, then

(cid:120)(cid:112)ϕ(cid:113)(cid:121) = ϕ.

Proof.



=

=

=

=

(cid:120)(cid:112)ϕ(cid:113)(cid:121)

G

/C

– (cid:120)−(cid:121)-def –
– (cid:112)−(cid:113)-def –

(cid:111)
[ (cid:112)ϕ(cid:113) ]Id
[ λA, γ : A → C.ϕ ◦ (injId
ϕ ◦ [ injId

– case fusion –
/C

/C

G

(cid:111)

(cid:111)
]Id
G

G

– case reﬂection –

(cid:111)

/C

(cid:111)
)A(γ) ]Id
G

/C

ϕ

Proposition 5.16 If (C, Φ) is a Mendler-style G-algebra, then

(cid:112)(cid:120)Φ(cid:121)(cid:113) = Φ.

76

Proof.



=

=

=

(cid:66) pick A, γ : A → C

(cid:112)(cid:120)Φ(cid:121)(cid:113)A(γ)
(cid:120)Φ(cid:121) ◦ (injId

– (cid:112)−(cid:113)-def –
– (cid:120)−(cid:121)-def –
◦ (injId

/C

G

(cid:111)

(cid:111)

/C

(cid:111)
[ Φ ]Id
G
– case cancellation –

)A(γ)

/C

G

)A(γ)

ΦA(γ)

Proposition 5.17 If h is a conventional Ge-algebra homomorphism between
(C, ϕ) and (D, ψ), then h is also a Mendler-style G-algebra homomorphism be-
tween (C, (cid:112)ϕ(cid:113)) and (D, (cid:112)ψ(cid:113)).

Proof.

=

=

=

=

=

(cid:66) h ◦ ϕ = ψ ◦ Geh
(cid:66) pick A, γ : A → C

(cid:111)

(cid:111)

G

/C

/C

)A(γ)

– (cid:67) –

h ◦ (cid:112)ϕ(cid:113)A(γ)
– (cid:112)−(cid:113)-def –
h ◦ ϕ ◦ (injId
ψ ◦ Geh ◦ (injId
)A(γ)
– Ge-def –
ψ ◦ [ λA, γ : A → C. (injId
– case cancellation –
)A(h ◦ γ)
ψ ◦ (injId
– (cid:112)−(cid:113)-def –
(cid:112)ψ(cid:113)A(h ◦ γ)

/D

G

G

G

(cid:111)

(cid:111)

/D

)A(h ◦ γ) ]Id

(cid:111)

G

/C

(cid:111)

◦ (injId

G

/C

)A(γ)

Proposition 5.18 If h is a Mendler-style G-algebra homomorphism between
(C, Φ) and (D, Ψ), then h is also a conventional Ge-algebra homomorphism be-
tween (C, (cid:120)Φ(cid:121)) and (D, (cid:120)Ψ(cid:121)).

77

(cid:66) ∀A, γ : A → C. h ◦ ΦA(γ) = ΨA(h ◦ γ)

G

(cid:111)

(cid:111)

/D

/D

)A(h ◦ γ) ]Id
)A(h ◦ γ) ]Id

G

(cid:111)

(cid:111)

G

/C

/C

Proof.



=

=

=

=

=

=

=

G

/C

(cid:111)

/C

– case fusion –

– (cid:120)−(cid:121)-def –

h ◦ (cid:120)Φ(cid:121)
h ◦ [ Φ ]Id
(cid:111)
[ λA, γ : A → C. h ◦ ΦA(γ) ]Id
– (cid:67), with A := A, γ := γ –
[ λA, γ : A → C. ΨA(h ◦ γ) ]Id
– case cancellation –
(cid:111)
[ λA, γ : A → C. [ Ψ ]Id

◦ (injId
(cid:111)
◦ [ λA, γ : A → C. (injId
[ Ψ ]Id
G
– Ge-def –
◦ Ge(h)
– (cid:120)−(cid:121)-def –

– case fusion –

/D

(cid:111)
[ Ψ ]Id
G
(cid:120)Ψ(cid:121) ◦ Ge(h)

/D

/D

/C

G

G

G

(cid:111)

G

These propositions tell us that there exists a functor between the categories

Alg(Ge) and Alg(G)m and a left-and-right inverse for it.
Theorem 5.19 The categories Alg(Ge) and Alg(G)m are isomorphic.

From here, the following is obvious already.

Corollary 5.20 If (µGe, in) is an initial Ge-algebra, then (µGe, (cid:112)in(cid:113)) is an initial

G-malgebra. For any G-malgebra (C, Φ), the catamorphism(cid:76) (cid:120)Φ(cid:121)(cid:77) : µGe → C

is the unique homomorphism from (µGe, in) to (C, Φ).

Corollary 5.21 If (µmG, inm) is an initial Mendler-style G-algebra,
then
(µmG, (cid:120)inm(cid:121)) is an initial conventional Ge-algebra. For any conventional Ge-

algebra (C, ϕ), the Mendler-style catamorphism(cid:76) (cid:112)ϕ(cid:113)(cid:77)m : µmG → C is the

unique conventional homomorphism from (µmG, inm) to (C, ϕ).

5.6 Mendler-style inductive types in Haskell

Mendler-style inductive types can be modeled in Haskell by using existential types
and rank-2 type signatures. While not part of the ofﬁcial Haskell98 language

78

deﬁnition, several Haskell implementations (e.g. Hugs, ghc, hbc) support them as
language extensions.

According to Corollary 5.20, an initial Mendler-style algebra for a difunctor
G is an initial (conventional) Ge-algebra, where functor Ge is constructed from
G by terms of certain restricted coends. Hence, in order to model Mendler-style
inductive types, we ﬁrst have to implement restricted coends.

The Haskell correspondent for a H-restricted G-cowedge (C, Φ) is a polymor-
phic function phi :: H a -> G a -> C (together with the type C), where H
and G are type constructors. Thus, H-restricted G-coends can be implemented as
follows:

> data RCoEnd h g = forall a . InjRCE (h a) (g a)

Given type constructors h and g, this deﬁnes the type RCoEnd h g as a pair
of values of type h a and g a respectively. The type variable a is existentially
quantiﬁed2 and does not appear in RCoEnd h g. It also deﬁnes the data construc-
tor InjRCE :: h a -> g a -> RCoEnd g c which corresponds to the re-
stricted coend. The universal cowedge homomorphism out of InjRCE can be
deﬁned as follows:

> caseRCE :: (forall a . h a -> g a -> c)

-> RCoEnd h g -> c

> caseRCE phi (InjRCE ha ga) = phi ha ga

Note the use of rank 2 type signature to ensure that the ﬁrst argument is a poly-
morphic function (i.e. is a restricted cowedge).

The type constructor corresponding to Ge can be deﬁned by instantiating the
ﬁrst parameter of RCoEnd with a type constructor represented by (->c). Unfor-
tunately, Haskell does not allow sectioning of inﬁx type constructors (as it does
for “ordinary” inﬁx operators). Hence, we have to deﬁne the corresponding type
constructor explicitly.

> newtype Fun c a = Fun (a -> c)

> newtype Ext g c = Ext (RCoEnd (Fun c) g)

We also “lift” the deﬁnitions of restricted coends and universal cowedge homo-
morphisms for Ext g c.

> injExt :: (a -> c) -> g a -> Ext g c
> injExt h x = Ext (InjRCE (Fun h) x)

2The apparently counterintuitive use of forall to capture existentially quantiﬁed variables is

justiﬁed by the logical equivalence ∀A.P ⇒ Q ≡ (∃A.P ) ⇒ Q, if A is not free in Q.

79

> caseExt :: (forall a . (a -> c) -> g a -> d)
>
> caseExt phi (Ext (InjRCE (Fun h) x)) = phi h x

-> Ext g c -> d

The arrow mapping part of the functor Ge can be deﬁned as follows:

> instance Functor (Ext g) where
>

fmap f = caseExt (\ h -> injExt (f . h))

Now, using the Corollary 5.20, we can deﬁne Mendler-style inductive types, initial
malgebras and Mendler-style catamorphisms as follows:

> type MuM g = Mu (Ext g)

> inM :: (a -> MuM g) -> g a -> MuM g
> inM h x = In (injExt h x)

> cataM :: (forall a . (a -> c) -> g a -> c)
>
> cataM phi = cata (caseExt phi)

-> MuM g -> c

Instead of going through conventional inductive types, we could also imple-
ment Mendler-style inductive types directly as ﬁxed points of certain existential
types.

data MuM g = forall a. InM (a -> MuM g) (g a)

cataM :: (forall a. (a -> c) -> g a -> c)

-> MuM g -> c

cataM phi (InM h x) = phi (cataM phi . h) x

In this case, according to Corollary 5.9, we could deﬁne conventional inductive
types in terms of Mendler-style inductive types (only for type constructors which
are functors).

type Mu f = MuM f

inMu :: f (Mu f) -> Mu f
inMu = InM id

cata :: Functor f => (f c -> c) -> Mu f -> c
cata phi = cataM (\ f -> phi . fmap f)

80

It may be helpful to think about the existentially quantiﬁed type variable a as
some (abstract) type of internal representations for the data type. Then, values of
type MuM g are constructed from a function which converts internal representa-
tions to the data type together with the actual value itself, where the “outer” struc-
ture (given by type constructor g) is explicit but substructures are in the internal
form. In particular, the deﬁnition of conventional inductive types is obtained by
using the data type itself also for the internal representation.

Example 5.4 (naturals)
The Mendler-style deﬁnition of natural numbers involves the same type construc-
tor N as the conventional deﬁniton (see example 2.10).

> type NatM = MuM N

The constructor functions for naturals can be deﬁned as follows:

> zeroNM :: NatM
> zeroNM

= inM id Z

> succNM
:: NatM -> NatM
> succNM n = inM id (S n)

The sum of two naturals can be deﬁned in terms of Mendler-style catamorphism
as follows:

> addNM :: NatM -> NatM -> NatM
> addNM x y = cataM phi x
>
>

where phi add_y Z

= y

phi add_y (S n) = succNM (add_y n)

Example 5.5 (course-of-value naturals)
Course-of-value naturals from example 5.2 can be implemented as follows:

> data N’ x = N’ (x -> N x) (N x)
> type NatCM = MuM N’

In order to deﬁne “standard” constructor functions, we ﬁrst have to deﬁne the
predecessor function for course-of-value naturals:

> predC :: NatCM -> N NatCM
> predC = caseExt phi . unIn
>
>

where phi h (N’ _

Z)

phi h (N’ _ (S n)) = S (h n)

= Z

81

Now, constructor functions can be deﬁned as follows:

> zeroC
> zeroC

:: NatCM

= inM id (N’ predC Z)

> succC
> succC n = inM id (N’ predC (S n))

:: NatCM -> NatCM

The Fibonacci function from course-of-value naturals to integers can be deﬁned
as follows:

= cataM phi

> fibC :: NatCM -> Int
> fibC
>
>
>
>
>

where phi fib (N’ p Z) = 1
phi fib (N’ p (S n))

= case p n of

-> fib n

Z
S m -> fib n + fib m

5.7 Related work

The concept of Mendler-style inductive type is an abstraction from N. P. Mendler’s
work [Men91] on an extension of system F (2nd-order simply-typed lambda-
calculus) with inductive and coinductive types. This system supported iteration
and coiteration through unusual operators whose beta-reduction rules did not men-
tion the arrow mapping component of the base functor of the (co)inductive type.
In [UV97, UV00b, Uus98, Mat98, Mat00], an observation was emphasized that
the system does not loose any of its desirable meta-theoretic properties, if the
base functor is permitted to be non-covariant. It was also shown how to interpret
the liberalized system in lattice theory (µF is not necessarily of (pre-)ﬁxed point
of F, if F is non-monotonic). The same lattice theory explanations reappeared
in [SU99]. The category-theoretic account given here is a “gloriﬁcation” of the
lattice-theoretic semantics.

82

CHAPTER 6

MENDLER-STYLE RECURSION

SCHEMES

In this chapter we present an alternative formalization of recursion operators (for
conventional inductive types) which is based on Mendler-style algebras. In par-
ticular, we develop Mendler-style operators for basic iteration, primitive recur-
sion and course-of-value iteration. The new operators are equivalent to the cor-
responding conventional ones, but are somewhat more intuitive (at least in our
opinion) against the background of “ordinary” (general-)recursive programming.
This chapter is based on [UV00a].
In order to explain the difference between conventional and Mendler-style
approach, consider the function f : µF → C deﬁned by simple iteration. The
recursive deﬁning equation for it is in the form
f ◦ in = Φ(f),

where Φ is some deﬁnable function from arrows µF → C to arrows FµF → C.
Just in this form, the equation does not necessarily deﬁne f iteratively. Indeed,
the characterizing equations for primitive recursion and course-of-value iteration
are exactly in the same form. In fact, the equation may have no solution in which
case it does not deﬁne f at all.
The conventional method to ensure that the equation deﬁnes f by a simple
iteration consists in insisting that Φ(f) = ϕ◦ F(f), where ϕ : F(C) → C is some
F-algebra. This means imposing a relatively syntactic condition on the right-hand
side of the equation: no expression other than ‘ϕ ◦ F(f)’ is acceptable unless we
are eager and able to prove that it equals ϕ ◦ F(f) (which may require quite a bit
of equational reasoning).

The Mendler-style method to ensure that the equation deﬁnes f by a simple
iteration is leave the form of its right-hand side as it is (i.e. ‘Φ(f)’) but to require
Φ not to use any speciﬁcs about the type µF. This is achievable by insisting that Φ

83

is an instance of a function parametric in A from arrows of type A → C to arrows
of type F(A) → C (which is veriﬁable by type-checking). This means adopting
a considerably more semantic approach to controlling the right-hand side of the
equation.

6.1 Simple iteration

Mendler-style coding of the simple iteration follows directly from the properties
of initial Mendler-style algebras for a (covariant) functor presented in Section 5.2.
According to Theorem 5.8 and its corollaries any initial algebra determines an
initial Mendler-style algebra and vice versa. Hence, we can take an initial al-
gebra (µF, in) and characterize Mendler-style homomorphisms out of the initial
malgebra (µF, (cid:112)in(cid:113)) directly in terms of it.

Deﬁnition 6.1 (m-catamorphism)
Let (µF, in) be an initial F-algebra. For any F-malgebra (C, Φ), a m-catamorphism

f =(cid:76) Φ(cid:77)m : µF → C is a unique arrow satisfying the universal property

f ◦ in = ΦµF(f) ≡ f =(cid:76) Φ(cid:77)m

mcata-CHARN

From this, the cancellation, reﬂection, and fusion laws for m-catamorphism

follow straightforwardly.

Corollary 6.1 Let (µF, in) be an initial F-algebra.

• Cancellation: For any F-malgebra (C, Φ)
(cid:76) Φ(cid:77)m ◦ in = ΦµF((cid:76) Φ(cid:77)m)

• Reﬂection:

mcata-SELF

id = (cid:76) λA, γ : A → µF. in◦ F(γ)(cid:77)m

mcata-REFL
• Fusion: For any F-malgebras (C, Φ) and (D, Ψ) and an arrow f : C → D
(∀A, γ : A → C. f ◦ ΦA(γ) = ΨA(f ◦ γ)) ⇒ f ◦(cid:76) Φ(cid:77)m =(cid:76) Ψ(cid:77)m

mcata-FUSION

84

Note that the left-hand side of the fusion law is equivalent to the simpler
equation f ◦ ΦµF(id) = ΨµF(f). However, for calculational purposes the one
in mcata-FUSION is preferable, as it can be directly instantiated in different con-
texts.

From the Corollary 5.10, we get the deﬁnition of m-catamorphism as con-
ventional catamorphism. Similarly, the Corollary 5.9 gives to us the deﬁnition of
conventional catamorphism as m-catamorphism.

Corollary 6.2 Let (C, Φ) be a F-malgebra, then

(cid:76) Φ(cid:77)m =(cid:76) ΦµF(id)(cid:77)

Corollary 6.3 Let (C, ϕ) be a F-algebra, then

(cid:76) ϕ(cid:77) =(cid:76) λA, γ : A → C. ϕ ◦ F(γ)(cid:77)m

mcata-DEF

mcata-CATA

6.2 Primitive recursion

In this section we formalize the primitive recursion operator in the Mendler-style
setting. For this, we ﬁrst introduce the notions of rec-malgebra and their homo-
morphisms.

Deﬁnition 6.2 (rec-malgebra)
Let F : C → C be an endofunctor for which there exists an initial algebra (µF, in).
A F-rec-malgebra is a pair (C, Φ), where C is an object and Φ : C(−, C ×
µF) .→ C(F(−), C) is a natural transformation; i.e. for any arrow g : A → B
the following diagram commutes:

C(B, C × µF)

C(g, C×idµF)

C(A, C × µF)

ΦB

ΦA

C(F(B), C)

C(F(g),C)

/ C(F(A), C)

In other words, Φ is a family of functions {ΦA}A∈C which take arrows α :
A → C × µF to the arrows ΦA(α) : F(A) → C. The naturality condition says,

85

/
/




/
that Φ preserves compositions in the following sense: if α = β◦ g for some object
B and arrows β : B → C × µF, g : A → B, then

ΦA(β ◦ g) = ΦB(β) ◦ F(g)

(6.1)

or diagrammatically

g

A

#GGGGGGGGG

α

C × µF

{wwwwwwwww

β

B

⇒

F(g)

F(A)

!DDDDDDDD

ΦA(α)

/ F(B)

}zzzzzzzz

ΦB(β)

C

In particular, by taking B = C × µF and β = idC×µF, we get an equivalent
condition:

ΦA(α) = ΦC×µF(id) ◦ F(α)

(6.2)

Deﬁnition 6.3 (rec-malgebra homomorphism)
Let (C, Φ) and (D, Ψ) be two F-rec-malgebras. A homomorphism from (C, Φ) to
(D, Ψ) is an arrow h : C → D in the category C, such that for any object A the
following diagram commutes in Set:

C(A, C × µF)

C(A,h×idµF) /

C(A, D × µF)

ΦA 
C(F(A), C)

ΨA

/ C(F(A), D)

C(F(A),h)

In terms of the base category, the square above tells that for any object A and

arrow γ : A → C × µF, the following equation holds:

h ◦ ΦA(γ) = ΨA((h × id) ◦ γ)

(6.3)

or diagrammatically:

γ

{wwwwwwwww

A

#GGGGGGGGG

δ

C × µF

/ D × µF

h×idµF

⇒

F(A)

ΦA(γ)

}zzzzzzzz

ΨA(δ)

!DDDDDDDD

C

h

D

In particular, if we take A = C × µF and γ = idC×µF, then

h ◦ ΦC(id) = ΨC(h × id).

(6.4)

86

#
/
/
{
!
/
}
/


/
{
#
/
}
!
/
/
Note that, in a cartesian closed base category, F-rec-malgebras and their ho-
momorphisms are equivalent to ordinary Mendler-style algebras and homomor-
phisms for a difunctor G(Y, X) = [Y → µF] × F(X).
Deﬁnition 6.4 (m-paramorphism)
Let (µF, in) be an initial F-algebra. For any F-rec-malgebra (C, Φ), a m-para-
morphism f = (cid:104)| Φ|(cid:105)m : µF → C is a unique arrow satisfying the universal
property

f ◦ in = ΦµF(cid:104) f, id(cid:105) ≡ f = (cid:104)| Φ|(cid:105)m

mpara-CHARN

Proposition 6.4 Let (µF, in) be an initial F-algebra.
• Cancellation: For any F-rec-malgebra (C, Φ)
(cid:104)| Φ|(cid:105)m ◦ in = ΦµF(cid:104)(cid:104)| Φ|(cid:105)m, id(cid:105)

• Reﬂection:

mpara-SELF

id = (cid:104)| λA, γ : A → µF × µF. in◦ F(fst◦ α)|(cid:105)m

mpara-REFL
• Fusion: For any F-rec-malgebras (C, Φ) and (D, Ψ) and an arrow f :

C → D

(∀A, γ : A → C × µF. f ◦ ΦA(γ) = ΨA((f × id) ◦ γ))
⇒ f ◦ (cid:104)| Φ|(cid:105)m = (cid:104)| Ψ|(cid:105)m

mpara-FUSION

Proof. The cancellation law is directly obtained form the universal property of
paramorphisms by substituting f := (cid:104)| Φ|(cid:105)m thus making the right-hand equation
in mpara-CHARN trivially true. For the reﬂection law we argue:



id

=

– mpara-CHARN –



=

=

– identity, F functor –

id◦ in
in◦ F(id)
in◦ F(fst◦(cid:104) id, id(cid:105))

– pairing –

(cid:104)| λA, γ : A → µF × µF. in◦ F(fst◦ γ)|(cid:105)m

87

Finally, the fusion law is proved as follows:

(cid:66) ∀A, γ : A → C × µF. f ◦ ΦA(γ) = ΨA((f × id) ◦ γ)

f ◦ (cid:104)| Φ|(cid:105)m

=

– mpara-CHARN –

=

=



=
(cid:104)| Ψ|(cid:105)m

f ◦ (cid:104)| Φ|(cid:105)m ◦ in
– mpara-SELF –
f ◦ ΦµF(cid:104)(cid:104)| Φ|(cid:105)m, id(cid:105)
– (cid:67) –
ΨµF((f × id) ◦ (cid:104)(cid:104)| Φ|(cid:105)m, id(cid:105))
ΨµF(cid:104) f ◦ (cid:104)| Φ|(cid:105)m, id(cid:105)

– pairing –



Proposition 6.5 For any F-rec-malgebras (C, Φ)

(cid:104)| Φ|(cid:105)m = (cid:104)| ΦµF×µF(id)|(cid:105)

mpara-DEF

(cid:104)| ΦµF×µF(id)|(cid:105)

– mpara-CHARN –

Proof.

=





=

=
(cid:104)| Φ|(cid:105)m

(cid:104)| ΦµF×µF(id)|(cid:105) ◦ in
– para-SELF –
ΦµF×µF(id) ◦ F(cid:104)(cid:104)| ΦµF×µF(id)|(cid:105), id(cid:105)
ΦµF(cid:104)(cid:104)| ΦµF×µF(id)|(cid:105), id(cid:105)

– 6.2 –

Proposition 6.6 For any arrow ϕ : F(C × µF) → C

(cid:104)| ϕ|(cid:105) = (cid:104)| λA, γ : A → C × µF. ϕ ◦ F(γ)|(cid:105)m

mpara-PARA

=

Proof.



(cid:104)| ϕ|(cid:105)

(cid:104)| λA, γ : A → C × µF. ϕ ◦ F(γ)|(cid:105)m

– para-CHARN –

(cid:104)| λA, γ : A → C × µF. ϕ ◦ F(γ)|(cid:105)m ◦ in
ϕ ◦ F(cid:104)(cid:104)| λA, γ : A → C × µF. ϕ ◦ F(γ)|(cid:105)m, id(cid:105)

– mpara-SELF –

=

88

Proposition 6.7 For any F-malgebra (C, Φ)

(cid:76) Φ(cid:77)m = (cid:104)| λA, γ : A → C × µF. ΦA(fst◦ γ)|(cid:105)m
(cid:104)| λA, γ : A → C × µF. ΦA(fst◦ γ)|(cid:105)m

– mcata-CHARN –

mpara-MCATA

=

Proof.



=

=

(cid:76) Φ(cid:77)m

– mpara-SELF –

(cid:104)| λA, γ : A → C × µF. ΦA(fst◦ γ)|(cid:105)m ◦ in
ΦµF(fst◦(cid:104)(cid:104)| λA, γ : A → C × µF. ΦA(fst◦ γ)|(cid:105)m, id(cid:105))
ΦµF(cid:104)| λA, γ : A → C × µF. ΦA(fst◦ γ)|(cid:105)m

– pairing –

6.3 Course-of-value iteration

In this section we formalize the course-of-value iteration operator in the Mendler-
style setting. We do it in the analogous way to the primitive recursion by intro-
ducing the notions of cv-malgebra and their homomorphisms. For this, we need
Mulry’s notion of strong dinaturality [Mul91].

Deﬁnition 6.5 (strong dinaturality)
Let H, G : Cop × C → A be difunctors. A strong dinatural transformation Φ :
H ..→G is a family of maps ΦA for all A ∈ C, such that for every arrow g : A → B
the following diagram commutes:

W

&MMMMMMMMMMM

xrrrrrrrrrrr

LLLL
H(idA,g)

H(A, A)

H(B, B)

rrrr
H(g,idB)
yrrrr

%LLLL
H(A, B)

ΦB

ΦA

G(A, A)

LLLL
G(idA,g)

rrrr
G(g,idB)
yrrrr

%LLLL
G(A, B)

G(B, B)

where W is the pullback of H(idA, g) and H(g, idB).

89

x
&


%


y
%
y
Proposition 6.8 ([Mul91]) Every strong dinatural transformation Φ : H ..→G is a
dinatural transformation.
Proof. Since H(idA, g) ◦ H(g, idA) = H(g, idB) ◦ H(idB, g), the pair of arrows
H(g, idA) and H(idB, g) factors through W and thus G(idA, g)◦ΦA◦H(g, idA) =
G(g, idB) ◦ ΦB ◦ H(idB, g).

Note that malgebras and rec-malgebras, which by deﬁnition are dinatural
transformations, are also strong dinatural transformations, as the pullback squares
for them are trivial.

Deﬁnition 6.6 (cv-malgebra)
Let F : C → C be an endofunctor. A F-cv-malgebra is a pair (C, Φ), where
C is an object and Φ : C(−, C × F(=)) ..→ C(F(−), C) is a strong dinatural
transformation; i.e. for any arrow g : A → B the following diagram commutes:

ukkkkkkkkkkkkkkkk

W

)SSSSSSSSSSSSSSSS

C(B, C × F(B))
C(A, C × F(A))
RRRRR
lllll
C(g,idC×F(B))
C(idA,idC×F(g))
)RRRRR
ulllll
C(A, C × F(B))

ΦB

ΦA

C(F(A), C)

C(F(B), C)

RRRRRRRRRRRRRR
RRRRRRRRRRRRRR

lllll

C(F(g),C)

ulllll

C(F(A), C)

where W = {(α : A → C×F(A), β : A → C×F(A)) | (idC× F(g))◦α = β◦g}
is a pullback of C(idA, idC×F(g)) and C(g, idC×F(B)).

In terms of the base category C, Φ is a family of functions {ΦA}A∈C which
C-coalgebras (see Deﬁnition 4.1) α : A → C × F(A) to the arrows
×
take F
ΦA(α) : F(A) → C. The strong dinaturality condition means, that for arbi-
C-coalgebras α : A → C × F(A) and β : B → C × F(B), and an arrow
×
trary F
g : A → B, the following holds:

(idC× F(g)) ◦ α = β ◦ g ⇒ ΦA(α) = ΦB(β) ◦ F(g)

(6.5)

90

u
)


)


u
u
or diagrammatically

A

g

B

/ C × F(A)

idC× F(g)

/ C × F(B)

α

β

⇒

F(A)

!DDDDDDDD

ΦA(α)

F(g)

/ F(B)

}zzzzzzzz

ΦB(β)

C

×
C-coalgebras α and β.

Note that the left-hand side of the implication says, that g is a homomorphism
between F
×
C and β = out, the condition 6.5 simpliﬁes to the following equation:

×
C, out). Then, by taking

Assume that there exists a terminal F

×
C-coalgebra (νF

B = νF

ΦA(α) = ΦνF
×
C

(out) ◦ F([( α )])

(6.6)

As the calculation below shows, the equation is equivalent to the previous impli-
cation. Indeed, if equation 6.6 holds, then

(cid:66) pick A, B, g : A → B, α : A → C × F(A), β : B → C × F(B)
(cid:66) (idC ×F(g)) ◦ α = β ◦ g



=

=

=

=

ΦA(α)

– 6.6 –
(out) ◦ F([( α )])
ΦνF
×
– (cid:67), ana-FUSION –
C
(out) ◦ F([( β )] ◦ g)
ΦνF
×
C
– F functor –
(out) ◦ F([( β )]) ◦ F(g)
ΦνF
×
C
– 6.6 –
ΦB(β) ◦ F(g)

Deﬁnition 6.7 (cv-malgebra homomorphism)
Let (C, Φ) and (D, Ψ) be two F-cv-malgebras. A homomorphism from (C, Φ) to
(D, Ψ) is an arrow h : C → D in the category C, such that for any object A the
following diagram commutes in Set:

C(A, C × F(A))

C(idA,h×idF(A))/

C(A, D × F(A))

ΦA 
C(F(A), C)

ΨA

/ C(F(A), D)

C(idF(A),h)

91



/


/
!
/
}
/


/
In terms of the base category, the square above tells that for any object A and
C-coalgebra γ : A → C × F(A), the following equation holds:
×

F

h ◦ ΦA(γ) = ΨA((h × id) ◦ γ)

(6.7)

or diagrammatically:

zuuuuuuuuuu

γ

A

$IIIIIIIIII

δ

C × F(A)

/ D × F(A)

h×idF(A)

⇒

F(A)

ΦA(γ)

}zzzzzzzz

ΨA(δ)

!DDDDDDDD

C

h

D

Assuming that there exists a terminal F
above simpliﬁes to the equivalent equation:

×
D-coalgebra (νF
h ◦ ΦA(out) = ΨA((h × id) ◦ out)

×
D, out), the condition

(6.8)

Note that, in a cartesian closed base category, F-cv-malgebras and their ho-
momorphisms are equivalent to ordinary Mendler-style algebras and homomor-
phisms for a difunctor G(Y, X) = [Y → F(X)] × F(X) (the instance of which
we used in the example 5.2 for course-of-value naturals).

Deﬁnition 6.8 (m-histomorphism)
Let (µF, in) be an initial F-algebra. For any F-cv-malgebra (C, Φ), a m-histo-
morphism f = {| Φ|}m : µF → C is a unique arrow satisfying the universal
property

f ◦ in = ΦµF(cid:104) f, in−1 (cid:105) ≡ f = {| Φ|}m

mhisto-CHARN

mhisto-SELF

Proposition 6.9 Let (µF, in) be an initial F-algebra.
• Cancellation: For any F-cv-malgebra (C, Φ)

{| Φ|}m ◦ in = ΦµF(cid:104){| Φ|}m, in−1 (cid:105)

• Reﬂection:

f : C → D

id = {| λA, γ : A → µF × F(A). in◦F(fst◦ γ)|}m

mhisto-REFL
• Fusion: For any F-cv-malgebras (C, Φ) and (D, Ψ) and an arrow

(∀A, γ : A → C × F(A). f ◦ ΦA(γ) = ΨA((f × id) ◦ γ))
⇒ f ◦ {| Φ|}m = {| Ψ|}m

mhisto-FUSION

92

z
$
/
}
!
/
/
Proof. The cancellation law is directly obtained form the universal property. For
the reﬂection law we argue:



id

=

– mhisto-CHARN –



=

=

– identity, F functor –

id◦ in
in◦ F(id)
in◦ F (fst◦(cid:104) id, in−1 (cid:105))

– pairing –

{| λA, γ : A → µF × F(A). in◦F(fst◦ γ)|}m

Finally, the fusion law is proved as follows:

(cid:66) ∀A, γ : A → C × F(A). f ◦ ΦA(γ) = ΨA((f × id) ◦ γ)



=

– mhisto-CHARN –

f ◦ {| Φ|}m



=

=
{| Ψ|}m

f ◦ {| Φ|}m ◦ in
f ◦ ΦµF(cid:104){| Φ|}m, in−1 (cid:105)
ΨµF(cid:104) f ◦ {| Φ|}m, in−1 (cid:105)

– mhisto-SELF –
– (cid:67) –

If there exists a terminal F

×
D-coalgebra (νF

×
D, out), then any m-histomorphism

can be deﬁned in terms of a (conventional) histomorphism, and vice versa.
Proposition 6.10 Let (νF
malgebra (C, Φ)

×
C-coalgebra, then for any F-cv-

×
C, out) be a terminal F
{| Φ|}m = {| ΦνF

×
C

(out)|}

mhisto-DEF

Proof.

=



{| ΦνF

×
C

(out)|}
{| ΦνF

=

– mhisto-CHARN –



=
{| Φ|}m

×
C

(out)|} ◦ in
– histo-SELF –
(out) ◦ F [((cid:104){| ΦνF
ΦνF
×
C
– 6.6 –
ΦµF(cid:104){| ΦνF

(out)|}, in−1 (cid:105)

×
C

×
C

(out)|}, in−1 (cid:105) )]

93

Proposition 6.11 For any F-cv-algebra ϕ : F(Fν(C)) → C
{| ϕ|} = {| λA, γ : A → C × F(A). ϕ ◦ F[( γ )]|}m

mhisto-HISTO

=

Proof.



=

{| ϕ|}

{| λA, γ : A → C × F(A). ϕ ◦ F[( γ )]|}m

– histo-CHARN –

{| λA, γ : A → C × F(A). ϕ ◦ F[( γ )]|}m ◦ in
ϕ ◦ F[((cid:104){| λA, γ : A → C × F(A). ϕ ◦ F[( γ )]|}m, in−1 (cid:105) )]

– mhisto-SELF –

Every m-catamorphism can be deﬁned as m-histomorphism, which uses only

the value on the “predecessor” of the current argument.

Proposition 6.12 For any F-malgebra (C, Φ)

(cid:76) Φ(cid:77)m = {| λA, γ : A → C × F(A). Φ(fst◦ γ)|}m
{| λA, γ : A → C × F(A). Φ(fst◦ γ)|}m

– mcata-CHARN –

mhisto-MCATA

=

Proof.



=

=

(cid:76) Φ(cid:77)m

– mhisto-SELF –

{| λA, γ : A → C × F(A). Φ(fst◦ γ)|}m ◦ in
Φ(fst◦(cid:104){| λA, γ : A → C × F(A). Φ(fst◦ γ)|}m, in−1 (cid:105))
Φ{| λA, γ : A → C × F(A). Φ(fst◦ γ)|}m

– pairing –

6.4 Mendler-style recursion operators in Haskell

In Haskell, we can implement m-catamorphisms as follows:

> mcata :: (forall a. (a -> c) -> f a -> c)
>
-> Mu f -> c
> mcata phi (In x) = phi (mcata phi) x

94

The constraint for phi, that it is Mendler-style algebra, is expressed by its typing,
which requires phi to be polymorphic on a. Differently from conventional cata-
morphisms, the type for mcata does not contain the restriction for type construc-
tor f to be an instance of class Functor. This is not required, as the deﬁning
equation (which expresses the cancellation law), does not use fmap. Note that
there was no such requirement in the deﬁnition of type Mu f either. Hence, if we
use mcata combinator instead of cata, we can deﬁne inductive types only by
deﬁning the corresponding type constructor, and no instance declaration for class
Functor is required.
Example 6.1 (naturals to integers)
The function nat2int, which converts naturals to corresponding integers, can be
deﬁned as m-catamorphism:

> nat2int :: Nat -> Int
> nat2int = mcata phi
>
>

where phi n2i Z

phi n2i (S n) = 1 + n2i n

= 0

Note that n in the second equation of phi corresponds to the original predecessor,
and not to the value of the function on it (as it had been case if we had used cata).
The value on the predecessor is computed by applying to it the function provided
as the ﬁrst argument of phi. Using the suitable naming of this argument, the
deﬁnition of phi becomes very similar to the directly recursive deﬁnition for the
function nat2int.
Example 6.2 (length)
The function, which computes the length of a given list, can be deﬁned as follows:

> lengthM :: List a -> Nat
> lengthM = mcata phi
>
where phi len N
>

phi len (C _ xs) = succN (len xs)

= zeroN

The Haskell correspondent for a F-rec-malgebra is a polymorphic function of
type (a -> (c, Mu f)) -> (f a -> c) for some ﬁxed type constructor f
and type c. However, for convenience, we use an equivalent version of it; namely,
(a -> c) -> (a -> Mu f) -> (f a -> c). Now, we can implement
m-paramorphisms, by using the accordingly modiﬁed cancellation law, as follows:

> mpara :: (forall a. (a -> c) -> (a -> Mu f)
>
>
> mpara phi (In x) = phi (mpara phi) id x

f a -> c)
Mu f -> c

->
->

95

Example 6.3 (factorial)
The factorial function can be implemented as Mendler-style paramorphism:

> factM :: Nat -> Nat
> factM = mpara phi
>
>
>

where phi fac i Z = oneN

phi fac i (S x)

= mulN (succN (i x)) (fac x)

The ﬁrst functional argument of phi is used for computing the value on the previ-
ous argument x (like in the case of mcata combinator). However, now phi has
also the second functional argument i, which is applied to the previous argument
in places where the argument itself is needed.

Example 6.4 (dropwhile)
The function dropWhile can be implemented as follows:

where phi dropW i N

> dropWhileM :: (a -> Bool) -> List a -> List a
> dropWhileM p = mpara phi
>
>
>
>

| p x
| otherwise = consL x (dropW xs)

phi dropW i (C x xs)

= nilL

= i xs

The Haskell correspondent for a F-cv-malgebra is a polymorphic function of
type (a -> (c, f a)) -> (f a -> c) for some ﬁxed type constructor f
and type c. Again, for convenience, we use a slightly modiﬁed, but equivalent,
version of it; namely, (a -> c) -> (a -> f a) -> (f a -> c). Now,
we can implement m-histomorphisms, by using the accordingly modiﬁed cancel-
lation law, as follows:

> mhisto :: (forall a. (a -> c) -> (a -> f a)
f a -> c)
>
>
Mu f -> c
> mhisto phi (In x) = phi (mhisto phi) unIn x

->
->

Note, that the deﬁnition does not use any intermediate data or codata structure.
Hence, it does not memoize values on previous arguments. (However, it is possi-
ble to arrive to the memoizing version by exploiting mhisto-DEF.)

96

Example 6.5 (Fibonacci)
The Fibonacci function can be implemented as Mendler-style histomorphism:

where phi fib pre Z

=

1

phi fib pre (S x)

> fiboM :: Nat -> Int
> fiboM = mhisto phi
>
>
>
>
>

= case pre x of

-> 1

Z
S y -> fib x + fib y

The ﬁrst functional argument of phi is used for computing the value on the pre-
vious argument x (like in the case of mcata or mpara combinator). However,
now phi has also the second functional argument pre, which is applied to the
previous argument x in places where its predecessor is needed.

Example 6.6 (evens)
The function evens, which takes from the given list every second element, can
be deﬁned as follows:

where phi eve pre N

> evensM :: List a -> List a
> evensM = mhisto phi
>
>
>
>
>

phi eve pre (C _ x)

= case pre x of

=

nilL

-> nilL

N
C a y -> consL a (eve y)

6.5 Related work

Mendler-style recursion combinators were invented in type theory by
N. P. Mendler. In [Men87] (a conference paper), he studied an extension of sys-
tem F with (co)inductive types and primitive (co)recursion; [Men91] (its journal
version) treats a simpliﬁed calculus that only supported (co)iteration. Some im-
portant works commenting on [Men87]/[Men91] and, in particular, on the em-
beddings between simply typed lambda calculi with conventional- and Mendler-
style iterators and primitive-recursors and system F are [Lei90, Geu92, Spł93].
Mendler-style course-of-value iteration was studied by us in a type-theoretic set-
ting in [UV97, UV00b, Uus98].
In [UV00a] we also studied a Mendler-style
combinator for simultaneous iteration.

97

98

CHAPTER 7

CONCLUSIONS

In this last chapter we summarize the contribution of this thesis and outline some
possible directions for future work.

7.1 Summary

We have studied the theory of inductive and coinductive types in a categorical
framework. The goal of this thesis was to develop new recursion combinators that
capture more complex recursion patterns than simple (co)iteration but still possess
nice reasoning properties. In particular, we considered combinators for primitive
(co)recursion and course-of-value (co)iteration using two different approaches.

The ﬁrst approach was based on the treatment of inductive and coinductive
types as initial algebras and terminal coalgebras. In this setting, it is well known
that the primitive recursion can be simulated by a simple iteration which com-
putes a value paired together with the argument, and that this construction leads
to the notion of paramorphism which captures the primitive recursion directly.
We showed (in Chapter 3), that the obvious dualization of this construction leads
to notion of apomorphism which captures the recursion pattern known as prim-
itive corecursion. More importantly, we also showed (in Chapter 4) that a more
involved generic simulation of memoization by iteration leads to the notion of his-
tomorphism, a direct formalization of course-of-value iteration, and also described
the dual notion of futumorphism, a formalization of course-of-value coiteration.
The second approach, inspired by type-theoretic work by N. P. Mendler, was
here pursued for inductive types only. To recast Mendler’s work in category-
theoretic terms, we invented the concepts of malgebra and malgebra homomor-
phism and treated inductive types as initial malgebras (chapter 5). From that basis,
we then introduced Mendler-style analogs for the cata, para and histo combinators
(chapter 6). From the theory developed, it appears that Mender-style recursion

99

combinators are just as well-suited for program calculation as the conventional
ones, but support a programming style more close to customary (general-) recur-
sive programming.

7.2 Future work

Semantics of Mendler-style inductive and coinductive types. While the basic
theory of Mendler-style inductive and coinductive types has been settled, many
questions remain still unresolved. First, the precise conditions of the existence of
initial (terminal) Mendler-style (co)algebras for mixed-variant base functors and
their relationship to Freyd’s dialgebras [Fre90, Fre91] need further study. Also,
recently, Bird and others [BM98, BP99] have proposed a new approach for nested
data types. How this work relates to ours is currently unclear and is a very inter-
esting topic to investigate.

Modeling of interactive processes. Coalgebras and coinductive types have re-
ceived much attention recently. They facilitate elegant modeling of interactive
processes and several very important notions of object-oriented programming like
objects, classes and inheritance. Our preliminary investigations on Mendler-style
coinductive types show that at least modeling of simple processes is easily achiev-
able by them. As the next step, we plan to use Mendler-style coinductive types
to model more complex process calculi (like CSP or CCS), and, if we succeed
in this, we start to develop the speciﬁcation methodology of processes based on
these models. We also plan to provide several case studies for specifying pro-
cesses using the methodology.

Computations with side-effects and (co)inductive types. The use of monads to
represent side-effecting computations is nowadays considered standard, and for
instance in lazy functional language Haskell they are the main structuring lan-
guage construction for side-effects including input/output. The popularity of using
monads is caused by the fact that they provide a simple and effective way to handle
computations that interact purely functionally but internally use side-effects. At
the same time, the monadic approach is not without shortcomings, as the model it
provides for input/output assumes that the environment is closed (i.e. the program
is the only one which interacts with environment). Recently Kieburtz [Kie99]
proposed a conjecture that comonads (duals of monads) together with coinductive
types yield a more appropriate formalism for modeling the interaction with outer
environment. We plan to verify this conjecture, and more generally to investi-
gate the possibilities for integration of monads and comonads with Mendler-style
(co)inductive types.

100

Generic programming. Genericity and reusability are two important issues for
simplifying the design and maintenance of programs. The purpose of generic pro-
gramming [BJJM99] is to develop new methods to parameterize algorithms and
programs. For instance, while traditional polymorphism allows parameterization
with respect to types, the so-called polytypism [JJ96] allows also parameterization
also with respect to type constructors. Most of the approaches for generic pro-
gramming are using inductive and coinductive types, as they come equipped with
universal combinators representing different generic recursion schemes. Mendler-
style inductive and coinductive types have the same potential, but their real utility
in generic programming needs further investigation.

Program transformation. The genericity and reusability of programs have a
side-effect that resulting programs can be very resource-consuming. The prob-
lem can be solved by using different program transformation techniques, like
partial evaluation or deforestation. In the context of inductive and coinductive
types, the last is especially interesting, as it allows to eliminate data structures
constructed during intermediate computations, and can be made fully automatic.
Traditional deforestation is based on the unfold-fold method by Burstall and Dar-
lington [BD77], and is quite inefﬁcient as it requires keeping the full computation
history to guarantee the termination. Takano and Meijer [TM95] proposed an
alternative approach based on (co)inductive types, called “acid rain”, where in-
termediate data structures are removed using pure calculation, and keeping the
computation history is not required. We hope that this method can be generalized
for Mendler-style (co)inductive types. Also, we plan to investigate other program
transformation methods in this setting.

101

REFERENCES

[BBA00]

L. S. Barbosa, J. B. Barros, and J. J. Almeida. Polytypic recursion
patterns. To appear in Proc. SBLP’00, vol. of ENTCS, May 2000.

[BD77]

[BdM97]

[Bir87]

Rod M. Burstall and John Darlington. A transformation system for
developing recursive programs. Journal of the ACM, 24(1):44–67,
January 1977.

Richard Bird and Oege de Moor. Algebra of Programming, volume
100 of Prentice Hall Int. Series in Computer Science. Prentice Hall,
London, 1997.

Richard S. Bird. An introduction to the theory of lists. In M. Broy,
editor, Logic of Programming and Calculi of Discrete Design, vol-
ume 36 of NATO ASI Series F, pages 3–42. Springer-Verlag, Berlin,
1987.

[Bir98]

Richard S. Bird.
Introduction to Functional Programming using
Haskell. Prentice Hall Int. Series in Computer Science. Prentice
Hall, London, 2nd edition, 1998.

[BJJM99] Roland Backhouse, Patrik Jansson, Johan Jeuring, and Lambert
Meertens. Generic programming –an introduction–. In S. Doaitse
Swierstra, Pedro R. Henriques, and Jos´e N. Oliveira, editors, Re-
vised Lectures 3rd Int. School on Advanced Functional Program-
ming, AFP’98, Braga, Portugal, 12–19 Sept. 1998, volume 1608 of
Lecture Notes in Computer Science, pages 28–115. Springer-Verlag,
Berlin, 1999.

[BM98]

Richard Bird and Lambert Meertens. Nested datatypes. In J. Jeuring,
editor, Proceedings 4th Int. Conf. on Mathematics of Program Con-
struction, MPC’98, Marstrand, Sweden, 15–17 June 1998, volume
1422 of Lecture Notes in Computer Science, pages 52–67. Springer-
Verlag, Berlin, 1998.

102

[BP99]

[CF92]

[Fok92]

[Fre90]

[Fre91]

[Geu92]

[GH99]

[Gru96]

[Hag87]

Richard Bird and Ross Paterson. Generalised folds for nested
datatypes. Formal Aspects of Computing, 11(2):200–222, 1999.

Robin Cockett and Tom Fukushima. About Charity. Yellow Se-
ries Report 92/480/18, Dept. of Computer Science, Univ. of Calgary,
June 1992.

M. M. (Maarten) Fokkinga. Law and Order in Algorithmics. PhD
thesis, Dept. of Informatics, Univ. of Twente, 1992.

Peter J. Freyd. Recursive types reduced to inductive types. In Pro-
ceedings 5th IEEE Annual Symp. on Logic in Computer Science,
LICS’90, Philadelphia, PA, USA, 4–7 June 1990, pages 498–507.
IEEE Computer Society Press, Los Alamitos, CA, 1990.

Peter J. Freyd. Algebraically complete categories. In A. Carboni,
M. C. Pedicchio, and G. Rosolini, editors, Proceedings Int. Conf.
Category Theory ’90, CT’90, Como, Italy, 22–28 July 1990, vol-
ume 1488 of Lecture Notes in Mathematics, pages 95–104. Springer-
Verlag, Berlin, 1991.

Herman Geuvers. Inductive and coinductive types with iteration and
recursion. In B. Nordstr¨om, K. Pettersson, and G. Plotkin, editors,
Informal Proceedings Workshop on Types for Proofs and Programs,
B˚astad, Sweden, 8–12 June 1992, pages 193–217. Dept. of Com-
puting Science, Chalmers Univ. of Technology and G¨oteborg Univ.,
1992. ftp://ftp.cs.chalmers.se/pub/cs-reports/baastad.92/proc.ps.Z.

Jeremy Gibbons and Graham Hutton. Proof methods for structured
corecursive programs. In Proceedings 1st Scottish Functional Pro-
gramming Workshop, Stirling, Scotland, Aug/Sept 1999, page ???
1999.

Jim Grundy.
sentation.
http://saxon.pip.com.pl/MathUniversalis/2/.

Mathesis Universalis,

A browsable

pre-
URL

format
2,

for
1996.

proof

Tatsuya Hagino. A Categorical Programming Language. PhD thesis
CST-47-87, Laboratory for Foundations of Computer Science, Dept.
of Computer Science, Univ. of Edinburgh, September 1987.

[HITT96]

Zhenjiang Hu, Hideya Iwasaki, Masato Takeichi, and Akihiko
Takano. Tupling calculation eliminates multiple data traversals.

103

In Proceedings 2nd ACM SIGPLAN Int. Conf. on Functional Pro-
gramming, ICFP’97, Amsterdam, The Netherlands, 9–11 June 1997,
pages 164–175. ACM Press, New York, 1996.

C. A. R. Hoare. Notes on data structuring. In O.-J. Dahl, E.W. Dijk-
stra, and C.A.R. Hoare, editors, Structured Programming. Academic
Press, 1972.

Brian T. Howard. Inductive, coinductive, and pointed types. In Pro-
ceedings 1st ACM SIGPLAN Int. Conf. on Functional Programming,
ICFP’96, Philadelphia, PA, USA, 24–26 May 1996, SIGPLAN No-
tices 31(6), pages 102–109. ACM Press, New York, 1996.

Johan Jeuring and Patrik Jansson. Polytypic programming.
In
J. Launchbury, E. Meijer, and T. Sheard, editors, Tutorial Text 2nd
Int. School on Advanced Functional Programming, Olympia, WA,
USA, 26–30 Aug 1996, volume 1129 of Lecture Notes in Computer
Science, pages 68–114. Springer-Verlag, Berlin, 1996.

Richard Kieburtz. Codata and comonads in Haskell. Unpublished
manuscript, July 1999.

Joachim Lambek. A ﬁxpoint theorem for complete categories. Math-
ematische Zeitschrift, 103:151–161, 1968.

Daniel Leivant. Contracting proofs to programs.
In P. Odifreddi,
editor, Logic and Computer Science, volume 31 of APIC Studies in
Data Processing, pages 279–327. Academic Press, London, 1990.

Saunders Mac Lane. Categories for the Working Mathematician,
volume 5 of Graduate Texts in Mathematics.
Springer-Verlag,
Berlin, 2nd edition, 1997. (1st ed., 1971).

[Hoa72]

[How96]

[JJ96]

[Kie99]

[Lam68]

[Lei90]

[Mac97]

[Mal90a]

Grant Malcolm. Data structures and program transformation. Sci-
ence of Computer Programming, 14(2–3):255–279, 1990.

[Mal90b]

[Mat98]

Grant R. Malcolm. Algebraic Data Types and Program Transforma-
tion. PhD thesis, Dept. of Computer Science, Univ. of Groningen,
1990.

Ralph Matthes. Extensions of System F by Iteration and Primitive
Recursion on Monotone Inductive Types. PhD thesis, Fachbereich
Mathematik, Ludwig-Maximilians-Universit¨at M¨unchen, 1998.

104

[Mat00]

[Mee92]

[Men87]

Ralph Matthes. Tarski’s ﬁxed-point theorem and lambda calculi with
monotone inductive types. In Benedikt L¨owe and Florian Rudolph,
editors, Refereed Papers of Research Coll. on Foundations of the
Formal Sciences, Berlin, Germany, 7–9 May 1999, pages 91–112.
Kluwer Academic Publishers, Dordrecht, 2000.

Lambert Meertens. Paramorphisms. Formal Aspects of Computing,
4(5):413–424, 1992.

Nax Paul Mendler. Recursive types and type constraints in second-
order lambda-calculus. In Proceedings 2nd Annual IEEE Symp. on
Logic in Computer Science, LICS’87, Ithaca, NY, USA, 22–25 June
1987, pages 30–36. IEEE Computer Society Press, Washington, DC,
1987.

[Men91]

Nax Paul Mendler.
Inductive types and type constraints in the
second-order lambda-calculus. Annals of Pure and Applied Logic,
51(1–2):159–172, 1991.

[Mic68]

Donald Michie. Memo functions and machine learning. Nature,
(218):19–22, April 1968.

[MTHM97] Robin Milner, Mads Tofte, Robert Harper, and David MacQueen.

The Deﬁnition of Standard ML (Revised). The MIT Press, 1997.

[Mul91]

[PJH99]

[Spł93]

[SU99]

Philip S. Mulry. Strong monads, algebras and ﬁxed points. In M. P.
Fourman, P. T. Johnstone, and A. M. Pitts, editors, Applications of
Categories in Computer Science: Proceedings LMS Symp., Durham,
UK, 20–30 July 1991, volume 177 of London Math. Society Lec-
ture Note Series, pages 202–216. Cambridge University Press, Cam-
bridge, 1991.

Simon Peyton Jones and John Hughes, editors.
Report on
the Programming Language Haskell98, A Non-strict Purely
Functional Language,
from
http://www.haskell.org/definition/.

Available

February

1999.

Zdzisław Spławski. Proof-Theoretic Approach to Inductive Deﬁ-
nitions in ML-Like Programming Languages versus Second-Order
Lambda Calculus. PhD thesis, Wrocław Univ., 1993.

Itera-
Zdzisław Spławski and Paweł Urzyczyn. Type ﬁxpoints:
tion vs. recursion.
In Proceedings 4th ACM SIGPLAN Int. Conf.
on Functional Programming, ICFP’99, Paris, France, 27–29 Sept
1999, pages 102–113. ACM Press, New York, 1999.

105

[TM95]

[Uus98]

[UV97]

[UV99a]

[UV99b]

[UV00a]

Akihiko Takano and Erik Meijer. Shortcut deforestation in calcu-
lational form. In Conf. Record 7th ACM SIGPLAN/SIGARCH Intl.
Conf. on Functional Programming Languages and Computer Archi-
tecture, FPCA’95, La Jolla, San Diego, CA, USA, 25–28 June 1995,
pages 306–316. ACM Press, New York, 1995.

Tarmo Uustalu. Natural Deduction for Intuitionistic Least and
Greatest Fixedpoint Logics, with an Application to Program Con-
struction. PhD thesis (Dissertation TRITA-IT AVH 98:03), Dept. of
Teleinformatics, Royal Inst. of Technology, Stockholm, May 1998.

Tarmo Uustalu and Varmo Vene. A cube of proof systems for the in-
tuitionistic predicate µ, ν-logic. In Magne Haveraaen and Olaf Owe,
editors, Selected Papers 8th Nordic Workshop on Programming The-
ory, NPWT’96, Oslo, Norway, 4–6 Dec 1996, Research Report 248,
Dept. of Informatics, Univ. of Oslo, pages 237–246. May 1997.

Tarmo Uustalu and Varmo Vene. Mendler-style inductive types, cat-
egorically. Nordic Journal of Computing, 6(3):343–361, 1999.

Tarmo Uustalu and Varmo Vene. Primitive (co)recursion and course-
of-value (co)iteration, categorically.
INFORMATICA, 10(1):5–26,
1999.

Tarmo Uustalu and Varmo Vene. Coding recursion a la Mendler (ex-
tended abstract). In Johan Jeuring, editor, Proceedings 2nd Work-
shop on Generic Programming, WGP’2000, Ponte de Lima, Portu-
gal, 6 July 2000, Tech. Report UU-CS-2000-19, Dept. of Computer
Science, Utrecht Univ., pages 69–85. June 2000.

[UV00b]

Tarmo Uustalu and Varmo Vene. Least and greatest ﬁxedpoints in
intuitionistic natural deduction. To appear in Theoretical Computer
Science, March 2000.

[Ves97]

[Vos95]

[VU98]

Peter Vesely. Typechecking the Charity term logic. Unpublished
notes, April 1997.

Tanja Vos. Program construction and generation based on recur-
sive types. MSc thesis INF/SCR-95-12, Dept. of Computer Science,
Univ. of Utrecht, March 1995.

Varmo Vene and Tarmo Uustalu. Functional programming with apo-
morphisms (corecursion). Proceedings of the Estonian Academy of
Sciences: Physics, Mathematics, 47(3):147–161, 1998.

106

[Wad89]

Philip Wadler. Theorems for free!
In Proceedings 4th Int. Conf.
on Funct. Prog. Languages and Computer Arch., FPCA’89, London,
UK, 11–13 Sept 1989, pages 347–359. ACM Press, New York, 1989.

107

108

KATEGOORNE PROGRAMMEERIMINE
INDUKTIIVSETE JA KOINDUKTIIVSETE

T ¨U ¨UPIDEGA

Kokkuv˜ote

Algoritmika ehk programmide konstrueerimise matemaatika on teoreetilise in-
formaatika haru, mille eesm¨argiks on uute matemaatiliselt p˜ohjendatud tarkvara-
tehnika meetodide v¨aljat¨o¨otamine. Seejuures kasutatav matemaatiline aparatuur
baseerub p˜ohiliselt universaalalgebral ja loogikal, ning eriti just viimasel ajal
kategooriate teoorial. Algoritmika ¨uks olulisemaid tunnuseid on, et tulempro-
grammi korrektsus spetsiﬁkatsiooni suhtes garanteeritakse konstruktsiooni k¨aigus
ning selle eraldi veriﬁtseerimist ei ole vaja. Eelistatakse deklaratiivseid program-
meerimisparadigmasid, ise¨aranis t¨u¨ubitud funktsionaalseid keeli, kuna nende se-
mantiline baas on v¨aga l¨ahedane kasutatava matemaatilise aparatuuriga. Muuhul-
gas v˜oimaldab see nii spetsiﬁtseerimis- kui ka realiseerimisfaasis j¨a¨ada ¨uhe para-
digma piiresse.

K¨aesolevas doktorit¨o¨os on kategooriate teooria abil uuritud induktiivseid ja
koinduktiivseid andmet¨u¨upe ja nendega seotud rekursiooniskeeme. T¨o¨o k¨aigus
j˜outi j¨argmiste uute tulemusteni:

• Uuriti korekursiivsete funktsioonide deﬁneerimise skeemi, mille formali-
satsiooniks terminaalsete koalgebratega distributiivsetes kategooriates on
nn. apomorﬁsmid (primitiivne korekursioon); s˜onastati ja t˜oestati apomor-
ﬁsmide iseloomulikud omadused, v˜orreldi neid anamorﬁsmidega (lihtsa ko-
iteratsiooniga); esitati lihtsaid n¨aiteid koandmet¨u¨upidega funktsionaalpro-
grammeerimisest, kus apomorﬁsmid on tululikud.

• Uuriti rekursiivsete ja korekursiivsete funktsioonide deﬁneerimise erinevaid
skeeme. N¨aidati, et course-of-value-iteratiivsed funktsioonid on formali-
seeritavad initsiaalsete algebratega distributiivsetes kategooriates nn. histo-
morﬁsmidena ning course-of-value-koiteratiivsed funktsioonid on duaalselt
formaliseeritavad terminaalsete koalgebratega distributiivsetes kategoori-
ates nn. futumorﬁsmidena.

• Formaliseeriti nn. Mendleri-laadi induktiivsete t¨u¨upide kategoorne seman-
tika, tuues selleks sisse Mendleri-laadi algebrate ning nende vaheliste ho-
momorﬁsmide m˜oisteid. N¨aidati, et kovariantse baasfunktori korral on in-
dutseeritud Mendleri-laadi algebrate kategooria ekvivalentne sama funktori
(tavaliste) algebrate kategooriaga. Segavariantse baasfunktori jaoks n¨aidati,
et kui baaskategoorias leiduvad teatud suured summad (t¨apsemalt teatud

109

tensorite kol˜opud), siis saab konstrueerida uue kovariantse funktori, mille
algebrate kategooria on esialgse funktori Mendleri-laadi algebrate kategoo-
riaga ekvivalentne. Lisaks uuriti Mendleri-laadi induktiivsete t¨u¨upidega
seotud rekursioonioperaatorite omadusi ning nende kasutatavust program-
mide konstrueerimisel.

110

ACKNOWLEDGEMENTS

First and foremost, my greatest thanks go to Tarmo Uustalu who has been not
only a direct partner of the research reported here, but also a good friend. Our
collaboration has been great pleasure and I can only hope that it will continue.
The discussions we had in Spring 1996 during my visit to Stockholm were the
starting point of the work and is still one of the greatest experience I have had in
my academic life.

Special thanks to my supervisor Merik Meriste who is responsible for ignit-
ing my interest in programming language theory and functional languages in par-
ticular. He has always been very supportive and patient, especially at difﬁcult
moments throughout my PhD study.

I want to thank Prof. Enn T˜ougu for inviting me to the Royal Institute of
Technology in Stockholm for a two two-month periods during 1996. These visits
were ﬁnanced by the Stockholm-Ladug˚ardslandet Club of District 2350 of Rotary
International for which I am very grateful.

I would like to thank all my friends, who often wondered whether this thesis

will ever be ﬁnished, for their support.

Last but not least, I am grateful to my mother for the support and encourage-

ment all over the years.

The work reported in this thesis was partially supported by the Estonian Sci-

ence Foundation grant no. 2976.

111

112

CURRICULUM VITAE

VARMO VENE

Citizenship: Estonian Republic.

Born: July 2, 1968, Tartu, Estonia.

Marital status: single.

Address: Anne 90-58, Tartu, EE-50705 Estonia,

phone.: +372 7 482 460,
e-mail: varmo@cs.ut.ee

Education

1986 – 1992 Applied mathematics, Faculty of Mathematics, University of Tartu.

1992 – 1994 MSc studies in Computer Science, Faculty of Mathematics, Univer-

sity of Tartu.

1996 – 2000 PhD studies in Computer Science, Faculty of Mathematics, Univer-

sity of Tartu.

Professional employment

1994 – 2000 Researcher, Institute of Computer Science, University of Tartu.

1998 –

2000 –

Researcher, Institute of Cybernetics, Tallinn Technical University.

Lecturer, Institute of Computer Science, University of Tartu.

113

CURRICULUM VITAE

VARMO VENE

Kodakondsus: Eesti Vabariik.

S¨unniaeg ja -koht: 2. juuli, 1968, Tartu, Eesti.

Perekonnaseis: vallaline.

Aadress: Anne 90-58, Tartu, EE-50705 Eesti,

tel.: +372 7 482 460,
e-post: varmo@cs.ut.ee

Haridus

1986 – 1992 Tartu ¨Ulikool, matemaatikateaduskond, rakendusmatemaatika eri-

ala.

1992 – 1994 Tartu ¨Ulikool, matemaatikateaduskond, informaatika magistratuur.

1996 – 2000 Tartu ¨Ulikool, matemaatikateaduskond, informaatika doktorantuur.

Erialane teenistusk¨aik

1994 – 2000 Tartu ¨Ulikool, Arvutiteaduse Instituut, teadur.

1998 –

2000 –

Tallinna Tehnika¨ulikool, K¨uberneetika Instituut, teadur (0.3 kohta).

Tartu ¨Ulikool, Arvutiteaduse Instituut, lektor.

114

DISSERTATIONES MATHEMATICAE

UNIVERSITATIS TARTUENSIS

1. Mati Heinloo. The design of nonhomogeneous spherical vessels, cylindri-

cal tubes and circular discs. Tartu, 1991. 23 p.

2. Boris Komrakov. Primitive actions and the Sophus Lie problem. Tartu,

1991. 14 p.

3. Jaak Heinloo. Phenomenological (continuum) theory of turbulence. Tartu,

1992. 47 p.

4. Ants Tauts. Inﬁnite formulae in intuitionistic logic of higher order. Tartu,

1992. 15 p.

5. Tarmo Soomere. Kinetic theory of Rossby waves. Tartu, 1992. 32 p.
6. J¨uri Majak. Optimization of plastic axisymmetric plates and shells in the

case of Von Mises yield condition. Tartu, 1992. 32 p.

7. Ants Aasma. Matrix transformations of summability and absolute summa-

bility ﬁelds of matrix methods. Tartu, 1993. 32 p.

8. Helle Hein. Optimization of plastic axisymmetric plates and shells with

piece-wise constant thickness. Tartu, 1993. 28 p.

9. Toomas Kiho. Study of optimality of iterated Lavrentiev method and its

generalizations. Tartu, 1994. 23 p.

10. Arne Kokk. Joint spectral theory and extension of non-trivial multiplica-

tive linear functionals. Tartu, 1995. 165 p.

11. Toomas Lepikult. Automated calculation of dynamically loaded rigidplas-

tic structures. Tartu, 1995. 93 p. (in russian)

12. Sander Hannus. Parametrical optimization of the plastic cylindrical shells
by taking into account geometrical and physical nonlinearities. Tartu,
1995. 74 p. (in russian)

13. Sergrei Tupailo. Hilbert’s epsilon-symbol in predicative subsystems of

analysis. Tartu, 1996. 134 p.

14. Enno Saks. Analysis and optimization of elastic-plastic shafts in torsion.

Tartu, 1996. 96 p.

15. Valdis Laan. Pullbacks and ﬂatness properties of acts. Tartu, 1999. 90 p.
16. M¨art P˜oldvere. Subspaces of Banach spaces having Phelps’ uniqueness

property. Tartu, 1999. 74 p.

17. Jelena Ausekle. Compactness of operators in Lorentz and Orlicz sequence

spaces. Tartu, 1999. 72 p.

115

18. Krista Fischer. Structural mean models for analyzing the effects of com-

pliance in clinical trials. Tartu, 1999. 125 p.

19. Helger Lipmaa. Secure and efﬁcent time-stamping systems. Tartu, 1999.

56 p.

20. J¨uri Lember. Consistency of empirical k-centres. Tartu, 1999. 148 p.
21. Ella Puman. Optimization of plastic conical shells. Tartu, 2000. 102 p.
22. Kaili M¨u¨urisep. Eesti keele arvutigrammatika: s¨untaks. Tartu, 2000.

109 lk.

116

