DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS

23

CATEGORICAL PROGRAMMING

WITH

INDUCTIVE AND COINDUCTIVE

TYPES

VARMO VENE

TARTU 2000

DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS

23

DISSERTATIONES MATHEMATICAE UNIVERSITATIS TARTUENSIS

23

CATEGORICAL PROGRAMMING

WITH

INDUCTIVE AND COINDUCTIVE

TYPES

VARMO VENE

TARTU 2000

Faculty of Mathematics, University of Tartu, Estonia

Dissertation accepted for public defense of the degree of Doctor of Philosophy
(PhD) on May 26, 2000 by the Council of the Faculty of Mathematics, University
of Tartu.

Opponent:

PhD, University Lecturer

Jeremy Gibbons
Oxford University Computing Laboratory
Oxford, England

The public defense will take place on Sept. 3, 2000.

The publication of this dissertation was ï¬nanced by Institute of Computer Science,
University of Tartu.

c(cid:13) Varmo Vene, 2000

Tartu Â¨Ulikooli Kirjastuse trÂ¨ukikoda
Tiigi 78, 50410 Tartu
Tellimus nr. 365

CONTENTS

1

2

Introduction
1.1 Motivation .
1.2 Overview of the thesis
1.3 Notation .

.

.

.

.

.

.

.

.

. . . . . . . . . . . . . . . . . . .

. .

. .

. . . . . . . . . . . . . . . .

. .

. .

. .

.

. . . . . . . . . . . . . . . . . . .

Initial algebras and catamorphisms . . . . . . . . . . .
. . . . . . . .

Inductive and coinductive types
2.1
2.2 Terminal coalgebras and anamorphisms
2.3
2.4 Related work .

. . . . . . . . . . . . . . . . . . .

Implementation in Haskell

. . . . . . . . . . . . . .

.

.

. .

. .

. .

3 Primitive (co)recursion

. .
. . . . . . . . . . . . . . . . . . .

3.1 Primitive recursion via tupling . . . . . . . . . . .
3.2 Paramorphisms .
3.3 Apomorphisms
.
3.4 Para- and apomorphisms in Haskell
3.5 Related work .

.
. . . . . . . . . . . . . . . . . . .
. . . . . . . . .

. . . . . . . . . . . . . . . . . . .

.

.

. .
. .

. .
. .

. .
. .

. .

. .

. .
. .

. .
. .

. .

. .

. .
. .

. .
. .

. .

. .

. .
. .

. .
. .

. .

9
9
. 12
. . 14

15
. . 15
. . 22
. 26
. . 31

33
. . 33
. . 35
. 40
. 43
. . 45

47
. . 47
. . 50
. 55
. 58
. . 61

4 Course-of-value (co)iteration

. .
4.1 Course-of-value iteration via memoization . . . . .
. . . . . . . . . . . . . . . . . . .
4.2 Histomorphisms .
4.3 Futumorphisms .
. . . . . . . . . . . . . . . . . .
4.4 Histo- and futumorphisms in Haskell . . . . . . . . .
4.5 Related work .

. . . . . . . . . . . . . . . . . . .

.
.

.

.

. .
. .

. .
. .

. .
. .

. .

. .

5 Mendler-style inductive types

5.1 Mendler-style inductive types: covariant case . . . .
. .
5.2 Conventional inductive types reduced to Mendler-style inductive

. .

. .

63
. 63

types .

.

.

.

. .

. .

. . . . . . . . . . . . . . . . . . . . . . .

5.3 Mendler-style inductive types: mixed variant case . .
5.4 Restricted existential types . . . . . . . . . . . . . .

. .
. .

. .
. .

5

. . 66
. 69
. 72

. .
. .

5.5 Mendler-styles inductive types reduced to conventional inductive

types .

.

.

.

. .

. .

. . . . . . . . . . . . . . . . . . . . . . .

5.6 Mendler-style inductive types in Haskell . . . . . . .
5.7 Related work .

. . . . . . . . . . . . . . . . . . .

.

.

. .

. .

. .

. .

. .

. . 75
. 78
. . 82

83
. 84
. 85
. . 89
. . 94
. . 97

6 Mendler-style recursion schemes

.

6.1 Simple iteration .
. . . . . . . . . . . . . . . . . .
6.2 Primitive recursion . . . . . . . . . . . . . . . . . .
6.3 Course-of-value iteration . . . . . . . . . . . . . .
. .
6.4 Mendler-style recursion operators in Haskell . . . . . .
6.5 Related work .
. . . . . . . . . . . . . . . . . . .

.

.

. .
. .

. .
. .

. .
. .

. .
. .
. .

. .
. .
. .

7 Conclusions

7.1 Summary . .
7.2 Future work .

. .
.
.

References

KokkuvËœote

Acknowledgements

. . . . . . . . . . . . . . . . . . .
.

. . . . . . . . . . . . . . . . . . .

. .

. .

. .

. .

. .

99
. 99
. . 100

102

109

111

6

LIST OF ORIGINAL PUBLICATIONS

1. Varmo Vene and Tarmo Uustalu. Functional programming with apomor-
phisms (corecursion). Proceedings Estonian Academy of Sciences: Phys.,
Maths., 47(3):147â€“161. Sept. 1998.

2. Tarmo Uustalu and Varmo Vene. Primitive (co)recursion and course-of-
value (co)iteration, categorically. INFORMATICA, 10(1):5â€“26, March 1999.

3. Tarmo Uustalu and Varmo Vene. Mendler-style inductive types, categori-

cally. Nordic Journal of Computing, 6(3):343â€“361. Autumn 1999.

4. Tarmo Uustalu and Varmo Vene. Coding recursion a la Mendler (extended
abstract). In J. Jeuring, ed., Proceedings 2nd Workshop on Generic Pro-
gramming, WGPâ€™2000, Ponte de Lima, Portugal, 6 July 2000, Tech. Report
UU-CS-2000-19, Dept. of Computer Science, Utrecht Univ., pp. 69â€“85.
June 2000.

7

8

CHAPTER 1

INTRODUCTION

1.1 Motivation

Data types are one of the key components of every program. They allow to or-
ganize values according to their purpose and properties. Already the very ï¬rst
programming languages had some concept of data types, containing at least a
ï¬xed collection of base types, like integers, reals, characters, but also means to
form compound data types like records, arrays or lists. Soon it was realized (e.g.
by Hoare [Hoa72]) that the structure of a program is intimately related with to the
data structures it uses. Hence the ability to express and manipulate complex data
structures in a ï¬‚exible and intuitive way is an important measure of the usability
and expressiveness of a programming language. Especially notable in this respect
are modern functional languages like Haskell [PJH99] and ML [MTHM97] which
possess rich type systems supporting algebraic data types, polymorphism, static
type checking, etc.

In this thesis we explore two particular kinds of data types, inductive and
coinductive types, and several programming constructs related to them. The char-
acteristic property of inductive types (like natural numbers or lists) is that they
provide very simple means for construction of data structures, but in order to use
these values one often needs recursion. Coinductive types (like streams, possibly
inï¬nite lists) are dual to inductive ones. They come together with basic operations
to destruct the values, however, their construction often involves recursion. Gen-
eral recursion can be quite difï¬cult to reason about, and it is sometimes called the
goto of functional programming.

In this thesis we use a categorical theory of initial algebras and terminal coal-
gebras as the abstract framework for inductive and coinductive types. This ap-
proach is attractive, as it equips (co)inductive types with generic (co)iteration op-
erations. As these operations capture a very simple form of recursion, namely
the structural (co)recursion, they are very easy to reason about. While the class

9

of functions expressible easily in terms of (co)iteration is quite large, not all
useful functions fall under it. The main objective of this thesis is to ï¬nd new
(co)recursive operations which capture some useful programming constructs, but
still possess nice reasoning properties.

Algebraic data types in Haskell

Algebraic data types as provided by Haskell are intuitive yet powerful way to de-
scribe data structures. Essentially, new data types are deï¬ned by listing all possi-
ble canonical ways to construct its values. For instance, the following declaration
in Haskell deï¬nes a new data type Shape together with two data constructors:

data Shape = Circle Float | Rectangle Float Float

Functions can manipulate such data types using pattern matching to â€œdestructâ€
the data structure into its components:

perimeter :: Shape -> Float
perimeter (Circle r)
perimeter (Rectangle h w) = 2 * (h + w)

= 2 * pi * r

Data deï¬nitions can be recursive allowing to describe data structures of varying
size. For instance, below are deï¬ned natural numbers and (polymorphic) lists as
recursive data types:

data Nat
data List a = Nil | Cons a (List a)

= Zero | Succ Nat

Functions which operate on recursive data types are often recursive too. For in-
stance, below is deï¬ned a function which ï¬nds the sum of the elements in the
argument list (here we use the standard notation for lists in Haskell, where []
denotes the empty list, i.e. the Nil constructor above, and (:) corresponds to
the Cons constructor):

:: [Int] -> Int

sum
sum []
sum (x:xs) = x + sum xs

= 0

The deï¬nition can be read as follows: the sum of the empty list is 0; in the case of
non-empty list, the sum of the whole list is obtained by adding the head of the list
to the sum of the tail of the list.

10

Folds

The same recursion pattern, occurs so often when deï¬ning list processing func-
tions, that Haskell provides a standard higher-order function which captures its
essence:

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f b []
foldr f b (x:xs) = f x (foldr f b xs)

= b

For instance, the sum function can be deï¬ned using foldr as follows:

sum = foldr (+) 0

Below are some other useful functions deï¬ned as instances of foldr:

= foldr (\x n -> 1+n) 0

length
xs ++ ys = foldr (:) ys xs
map f

= foldr (\x xs -> f x : xs) []

The ï¬rst function computes the the length of the argument list, the second concate-
nates two lists, and ï¬nally, the third maps the given function to the every element
of the argument list.

The function foldr has a very nice algebraic reading: it â€œreplacesâ€ the binary
list constructor (:) by a binary function f, and the empty list [] by a constant
b; i.e. foldr f b is a homomorphism between the algebras formed by list con-
structors and by f and b. This observation leads naturally to the generalization
of foldr to other algebraic data types, and forms the basis of the categorical
treatment of the inductive data types. For instance, the function which â€œreplacesâ€
constructors of natural numbers can be deï¬ned as follows:

foldNat :: (a -> a) -> a -> Nat -> a
foldNat f b Zero
foldNat f b (Succ n) = f (foldNat f b n)

= b

Calculating with folds

The function foldr satisï¬es two important laws. The ï¬rst law, known as identity
law, is rather obvious. It states that â€œreplacingâ€ the constructor functions with
themselves gives the identity function:

foldr (:) [ ] = id

The second law, known as fusion law, gives conditions under which intermediate
values produced by folding can be eliminated:

h (f a b) = g a (h b) â‡’ h â—¦ foldr f b = foldr g (h b)

11

To illustrate the use of these laws (and also the structured calculational proof
style [Gru96] we use throughout the thesis) we give a proof of the fact, that map
is a functor. First, the proof that map preserves identities:

=

=

=

map id
foldr(Î»x xs â†’ id x : xs) [ ]

â€“ deï¬nition of map â€“

â€“ deï¬nition of id â€“

foldr(:) [ ]

â€“ identity law â€“

id

Next, we use fusion to show that map preserves compositions:

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

map f â—¦ map g
map f â—¦ foldr(Î»x xs â†’ g x : xs) [ ]

â€“ deï¬nition of map â€“

â€“ fusion law â€“

â€“ deï¬nition of map â€“

map f (g a : [ ])
foldr(Î»x xs â†’ f x : xs) [ ] (g a : [ ])
f(g a) : foldr(Î»x xs â†’ f x : xs) [ ] [ ]

â€“ deï¬nition of foldr â€“

f(g a) : map f [ ]

â€“ deï¬nition of map â€“
foldr(Î»x xs â†’ f(g x) : xs) [ ]
map (f â—¦ g)

â€“ deï¬nition of map â€“

The identity and fusion law for foldr can be proved by induction over lists.
However, in categorical treatment of the inductive data types as initial algebras,
these laws are simple corollaries of the initiality. Hence they are not speciï¬c to
foldr and folds for any inductive data type satisfy similar laws.

1.2 Overview of the thesis

In this thesis we develop new recursion combinators that capture more complex
recursion patterns than simple (co)iteration but still possess nice reasoning prop-
erties.
In particular, we consider combinators for primitive (co)recursion and
course-of-value (co)iteration.

It is well known that the primitive recursion can be simulated by a simple it-
eration which computes a value paired together with the argument, and that this

12

construction leads to the notion of paramorphism which captures the primitive re-
cursion directly. We will show, that the obvious dualization of this construction
leads to notion of apomorphism which captures the recursion pattern known as
primitive corecursion. More importantly, we will also show that a more involved
generic simulation of memoization by iteration leads to the notion of histomor-
phism, a direct formalization of course-of-value iteration, and describe the dual
notion of futumorphism, a formalization of course-of-value coiteration.

Inspired by type-theoretic work by N. P. Mendler [Men87, Men91], we will
introduce the concepts of Mendler-style algebra and homomorphism and treat in-
ductive types as initial Mendler-style algebras. From that basis, we will introduce
Mendler-style analogs for the cata, para and histo combinators. From the theory
developed, it appears that Mender-style recursion combinators are just as well-
suited for program calculation as the conventional ones, but support a program-
ming style more close to customary (general-)recursive programming.

The remainder of the thesis is organized as follows: Chapter 2 reviews the
conventional treatment of inductive and coinductive types as initial algebras and
terminal coalgebras of a functor. The calculational properties of basic iteration
and coiteration are studied.

Chapter 3 studies the properties of operators corresponding to primitive recur-
sion and corecursion. This is the ï¬rst chapter which contains our original contri-
bution. Namely, we formalize primitive corecursive functions as apomorphisms,
and show their utility on several simple examples (the â€œstandardâ€ example being
the concatenation of two colists).

The next three chapters contain our main contribution to the theory of cate-

gorical data types.

Chapter 4 is devoted to course-of-value iteration and coiteration. They are
formalized respectively as histo- and futumorphisms, the latter being functions
which generate several elements of codata type at once.

Chapter 5 presents an alternative treatment of inductive types as initial Mend-
ler-style algebras. It shows that, in the case of covariant functor, the conventional
treatment coincides with the Mendler-style one. However, Mendler-style induc-
tive types can be deï¬ned also for mixed variant base functor. In this case, it is
shown, that if certain restricted existential types are available, then Mendler-style
inductive types are equivalent with the conventional ones, but for a different (co-
variant) functor.

Chapter 6 uses Mendler-style algebras to deï¬ne recursion operators which
operate on conventional inductive types. Mendler-style versions of cata-, para-
and histomorphisms are formalized and their properties are studied.

The concluding chapter 7 outlines possible future work.

13

1.3 Notation

Throughout the thesis C is the default category, in which we shall assume the
existence of ï¬nite products (Ã—, 1) and coproducts (+, 0), as well as the distribu-
tivity of products over coproducts (i.e. C is distributive). The typical example of a
distributive category is Set â€” the category of sets and total functions.
We make use of the following quite standard notation. Given two objects A,
B, we write fst : A Ã— B â†’ A and snd : A Ã— B â†’ B to denote the left and
right projections for the product A Ã— B. For f : C â†’ A and g : C â†’ B,
pairing (we also use name fork) is the unique arrow (cid:104) f, g (cid:105) : C â†’ A Ã— B, such
that fstâ—¦(cid:104) f, g (cid:105) = f and sndâ—¦(cid:104) f, g (cid:105) = g. The left and right injections for the
coproduct A + B are inl : A â†’ A + B and inr : B â†’ A + B. For f : A â†’ C
and g : B â†’ C, case analysis (we also use name join) is the unique morphism
[ f, g ] : A + B â†’ C, such that [ f, g ] â—¦ inl = f and [ f, g ] â—¦ inr = g. Besides,
given an object C, we have the unique morphism !C : C â†’ 1. The inverse of the
canonical map [ inlÃ— id, inrÃ— id ] : (AÃ—C)+(BÃ—C) â†’ (A+B)Ã—C is denoted
by distr : (A+ B)Ã— C â†’ (AÃ— C)+(BÃ— C). Finally, given a predicate p : A â†’
1 + 1, the guard p? : A â†’ A + A is deï¬ned as (snd + snd) â—¦ distrâ—¦(cid:104) p, idA (cid:105).

14

CHAPTER 2

INDUCTIVE AND COINDUCTIVE

TYPES

In this chapter we review the traditional treatment of inductive and coinductive
types as initial algebras and terminal coalgebras of a functor.

2.1

Initial algebras and catamorphisms

Deï¬nition 2.1 (algebra)
Let F : C â†’ C be an endofunctor on category C. An F-algebra is a pair (C, Ï•),
where C is an object and Ï• : FC â†’ C an arrow in the category C. The object C
is the carrier and the functor F is the signature of the algebra.

Deï¬nition 2.2 (algebra homomorphism)
Let (C, Ï•) and (D, Ïˆ) be two F-algebras. A homomorphism from (C, Ï•) to
(D, Ïˆ) is an arrow f : C â†’ D in the category C, such that

f â—¦ Ï• = Ïˆ â—¦ F f

i.e. makes the following diagram to commute:

C

f

D

F C

F f

F D

Ï•

Ïˆ

15

/
/




/
/
For any F-algebra, the identity arrow on its carrier is a homomorphism from
it to itself and also the composition of two homomorphisms is always a homo-
morphism, so we can deï¬ne a category where objects are F-algebras and arrows
are homomorphisms between them. However we have to be a little careful, as the
same arrow from the base category can be homomorphism between more than one
pair of F-algebras. For instance, the identity arrow idC is a homomorphism from
any F-algebra with carrier C to itself.

Deï¬nition 2.3 (category of algebras)
The category of F-algebras over C â€” Alg(F) â€” is deï¬ned by:

â€¢ Objects: F-algebras; i.e. arrows Ï• of C such that dom Ï• = F(cod Ï•).
â€¢ Arrows:

triples (f, Ï•, Ïˆ) : Ï• â†’ Ïˆ where Ï• and Ïˆ are F-algebras and

f : cod Ï• â†’ cod Ïˆ is a homomorphism from Ï• to Ïˆ.
â€¢ Identity: idÏ• = (idcod Ï•, Ï•, Ï•).
â€¢ Composition: (f, Ï•2, Ï•3) â—¦ (g, Ï•1, Ï•2) = (f â—¦ g, Ï•1, Ï•3).

Deï¬nition 2.4 (initial algebra)
A F-algebra (ÂµF, in) is the initial F-algebra if for any F-algebra (C, Ï•) there exists

a unique arrow(cid:76) Ï•(cid:77) : ÂµF â†’ C making the following diagram commute:

F ÂµF

F(cid:76) Ï•(cid:77)

F C

in

Ï•

ÂµF

(cid:76) Ï•(cid:77)

C

i.e. satisfying the universal property:

f â—¦ in = Ï• â—¦ F f â‰¡ f =(cid:76) Ï•(cid:77)

cata-CHARN

sition ÎºÎ±Ï„ Î± meaning â€˜downwardsâ€™).

The arrows in form(cid:76) Ï•(cid:77) are called catamorphisms (derived from the Greek prepo-
Alg(F), and the catamorphism(cid:76) Ï•(cid:77) is the mediating arrow out of it.

In other words, the initial algebra (ÂµF, in) is an initial object in the category

The initial F-algebra may or may not exist. It is guaranteed to exist if F is
Ï‰-cocontinuous (i.e. it preserves the colimits of Ï‰-chains). All polynomial func-
tors (i.e. functors built up from products, sums, the identity functor, and constant
functors) are Ï‰-cocontinuous and, hence, the initial algebras for them exist.

16

/
/




/
/
Corollary 2.1 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-algebra Ï• : FC â†’ C
(cid:76) Ï•(cid:77) â—¦ in = Ï• â—¦ F(cid:76) Ï•(cid:77)

cata-SELF

â€¢ Reï¬‚ection:

f : C â†’ D

id =(cid:76) in(cid:77)

cata-REFL
â€¢ Fusion: For any F-algebras Ï• : FC â†’ C, Ïˆ : FD â†’ D and an arrow

f â—¦ Ï• = Ïˆ â—¦ F f â‡’ f â—¦(cid:76) Ï•(cid:77) =(cid:76) Ïˆ(cid:77)

cata-FUSION
Intuitively, the initial algebra in : FÂµF â†’ ÂµF denotes the collection of con-
structor functions for inductive data type ÂµF, and the catamorphism is a simple
iteration. When read from left to right, the cancellation law can be viewed as the
reduction rule for terms where catamorphism is applied to a data constructor. The
reduction proceeds recursively by systematically replacing data constructors with
some algebra with same signature.
If constructors are replaced by themselves
nothing is changed. This is exactly what the reï¬‚ection law claims.

The formal justiï¬cation on the identiï¬cation of inductive types with initial al-
gebras is given by the following fundamental theorem, known as Lambek lemma.
Its proof, albeit simple, provides a nice example of using above mentioned laws
in action.
Theorem 2.2 (Lambek [Lam68]) The initial algebra inF : FÂµF â†’ ÂµF is an
isomorphism with the inverse deï¬ned as

in-inv-DEF
Proof. Note that inâˆ’1 has indeed the right typing; i.e. inâˆ’1 : ÂµF â†’ FÂµF. We
have to show that it is the pre- and post-inverse of the in. For the ï¬rst we argue:

inâˆ’1 = (cid:76) F in(cid:77)

â€“ cata-FUSION â€“

â€“ cata-REFL â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£°

=

=

inâ—¦(cid:76) F in(cid:77)
(cid:76) in(cid:77)

id

17

To show that it is also the post-inverse, we make use of the just shown fact (in the

step marked â€œsee aboveâ€): ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

â€“ cata-SELF â€“

(cid:76) F in(cid:77) â—¦ in
F inâ—¦F(cid:76) F in(cid:77))
F (inâ—¦(cid:76) F in(cid:77))

â€“ F functor â€“

â€“ see above â€“

F id

â€“ F functor â€“

id

The theorem shows that the carrier of the initial algebra is (up to isomorphism)
a ï¬xed point of the functor. In fact, initial algebras generalize the notion of the
least ï¬xed point from lattice theory in the sense that if the base category is a
preorder and thus an endofunctor is a monotonic function then the carrier of the
initial algebra is the least ï¬xed point of the given function.

Example 2.1 (empty type)
In the category Set of sets and functions, the pair (âˆ…, idâˆ…) is the initial algebra of
the identity functor with the unique arrow out of âˆ… as the required unique homo-
morphism. More generally, in any category with initial object, the pair (0, id0) is
the initial Id-algebra.

Example 2.2 (naturals)
Consider the set Nat = {0, 1, 2, . . .} of natural numbers with its zero and succes-
sor function zero : 1 â†’ Nat and succ : Nat â†’ Nat deï¬ned by:

zero () = 0
succ n = n + 1.

Using join, these functions combine into a single function [ zero, succ ] : 1 +
Nat â†’ Nat, forming an algebra of the functor N(X) = 1 + X. In fact, the pair
(Nat, [ zero, succ ]) is the initial N-algebra; i.e. ÂµN = Nat and in = [ zero, succ ].
To show this, assume an arbitrary N-algebra (C, Ï•). We have to ï¬nd a function
f : Nat â†’ C which is homomorphism and it should be unique. Because of every
arrow out of sum is join, Ï• = [ c, h ] for some constant c : 1 â†’ C and arrow
h : C â†’ C. So, the homomorphism condition for N-algebras states that f should

18

make the following diagram commute

1

zero

'OOOOOOOOOOOOOOOOOOOOOOO

c

Nat

f

C

succ

h

Nat

f

C

i.e. satisï¬es two equations

f â—¦ zero = c
f â—¦ succ = h â—¦ f.

For instance, the sum and product of two naturals can be deï¬ned as follows:

But this equation system has exactly one solution, namely the function deï¬ned by
n (cid:55)â†’ hn(c()), which gives to us the required unique homomorphism.
add(n, m) = (cid:76) [ Î»x.m, succ ](cid:77)(n)
mul(n, m) = (cid:76) [ Î»x.m, Î»x.add(m, x) ](cid:77)(n).

The predecessor function pred : Nat â†’ 1 + Nat which maps 0 (cid:55)â†’ inl() and
n + 1 (cid:55)â†’ inr n can be deï¬ned by

pred = (cid:76) id +[ zero, succ ](cid:77)

i.e. it is the inverse of the initial N-algebra.

Parametric data types can be easily modeled by initial algebras using bifunc-
tors as their signatures. Let F : C Ã— C â†’ C be a bifunctor, then for any object A
we have an endofunctor FA : C â†’ C deï¬ned as FA(X) = F(A, X).
Example 2.3 (lists)
The data type of lists over a given set A can be represented as the initial algebra
(ÂµLA, in) of the functor LA deï¬ned by LA(X) = 1 + (A Ã— X). Denote ÂµLA by
List(A). The constructor functions nil : 1 â†’ List(A) and cons : AÃ—List(A) â†’
List(A) are deï¬ned by

= inâ—¦ inl
nil
cons = inâ—¦ inr,

so in = [ nil , cons ]. Given any two functions c : 1 â†’ C and h : A Ã— C â†’ C,
the catamorphism f = (cid:76) [ c, h ](cid:77) : List(A) â†’ C is the unique solution of the

equation system

f â—¦ nil
f â—¦ cons = h â—¦ (idÃ—f),

= c

19

/
/
'


o
o


o
o
i.e., foldr(c, h) from functional programming. For instance, the function length :
List(A) â†’ Nat which ï¬nds the length of the list, can be deï¬ned as catamorphism

length = (cid:76) [ zero, Î»(a, n).succ(n) ](cid:77).

As another example, the function concat : List(A)Ã— List(A) â†’ List(A), which
concatenates two lists, can be deï¬ned as catamorphism

concat(xs, ys) = (cid:76) [ Î»x.ys, cons ](cid:77)(xs).

Finally, the function map(f) : List(A) â†’ List B, which applies the function
f : A â†’ B to every element of the argument list, can be deï¬ned as follows

map(f) = (cid:76) [ nil , cons â—¦ (f Ã— id) ](cid:77).

Lots of other examples about list catamorphisms (i.e. function foldr) can be found
in any functional programming textbook (e.g. [Bir98]).

Example 2.4 (binary trees)
Consider the bifunctor B(A, X) = A + X Ã— X. The initial BA-algebra deï¬nes
the data type of binary (leaf) trees Btree(A) = ÂµBA with a constructor functions

= inâ—¦ inl
leaf
branch = inâ—¦ inr

: A â†’ Btree(A)
: Btree(A) Ã— Btree(A) â†’ Btree(A)

For instance, a binary tree of naturals with three leafs can be constructed as

branch(branch(leaf (1), leaf (2)), leaf (3)).

Given any functions l : A â†’ C and b : C Ã— C â†’ C, the catamorphism f =
(cid:76) [ l, b ](cid:77) : Btree(A) â†’ C is the unique solution of the equation system

f â—¦ leaf
f â—¦ branch = b â—¦ (f Ã— f).

= l

For instance, the function ï¬‚atten : Btree(A) â†’ List(A), which collects ele-
ments in leaves into list in left-to-right order, can be deï¬ned as

ï¬‚atten = (cid:76) [ unit, concat ](cid:77),

where unit(x) = cons(x, nil) : A â†’ List(A) is a function which converts
an element into singleton list, and concat the list concatenation function from
Example 2.3.

20

It is well known from functional programming that the type constructor List
together with the function map form a functor. The next theorem shows that lists
are not exceptional in this respect and every similarly deï¬ned parametric data type
can be extended to a functor.
Theorem 2.3 Let F : C Ã— C â†’ C be a bifunctor, such that and for any object A
there exists initial FA-algebra (ÂµFA, in). Then, the mapping T(A) = ÂµFA can
extended to the endofunctor on C by deï¬ning
T(f) = (cid:76) inâ—¦F(f, id)(cid:77)

The functor T : C â†’ C is called a data functor of F.
Proof. Note that deï¬nition above has the right typing. We have to show that T
preserves identities and composition. First, identities:

data-map-DEF

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

T id

â€“ data-map-DEF â€“

(cid:76) inâ—¦F(id, id)(cid:77)
(cid:76) in(cid:77)

â€“ F bifunctor â€“

â€“ cata-REFL â€“

id

For the composition, we show that T(f) is a homomorphism from inâ—¦ F(g, id) to
inâ—¦F(f â—¦ g, id) and then use cata-FUSION:

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

Tf â—¦ Tg
Tf â—¦(cid:76) inâ—¦F(g, id)(cid:77)

â€“ cata-FUSION â€“

â€“ data-map-DEF â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

â€“ cata-SELF â€“

â€“ data-map-DEF â€“

Tf â—¦ inâ—¦F(g, id)
(cid:76) inâ—¦F(f, id)(cid:77) â—¦ inâ—¦F(g, id)
inâ—¦F(f, id) â—¦ F(id,(cid:76) inâ—¦F(f, id)(cid:77)) â—¦ F(g, id)
inâ—¦F(f â—¦ g, id) â—¦ F(id,(cid:76) inâ—¦F(f, id)(cid:77))
inâ—¦F(f â—¦ g, id) â—¦ F(id, Tf)

â€“ data-map-DEF â€“

â€“ F bifunctor â€“

(cid:76) inâ—¦F(f â—¦ g, id)(cid:77)
T(f â—¦ g)

â€“ data-map-DEF â€“

21

Example 2.5 (bushes)
Consider the bifunctor B(A, X) = A Ã— List(B(A, X)). The initial BA-algebra
deï¬nes the data type of bushes (ï¬nitely branching trees) Bush(A) = ÂµBA with a
constructor function node = in : A Ã— List(Bush(A)) â†’ Bush(A). Given any
function h : A Ã— List(C) â†’ C, the catamorphism f =(cid:76) h(cid:77) : Bush(A) â†’ C is

the unique solution of the equation

f â—¦ node = h â—¦ (idÃ—map(f)),

where map(f) : List(Bush(A)) â†’ List(C) is the map function on lists deï¬ned
in Example 2.3.

2.2 Terminal coalgebras and anamorphisms

We now dualize the material about initial algebras and catamorphisms.

Deï¬nition 2.5 (coalgebra)
Let F : C â†’ C be an endofunctor on category C. A F-coalgebra is a pair (C, Ï•),
where C is an object and Ï• : C â†’ FC an arrow in the category C. The object C
is the carrier and the functor F is the signature of the coalgebra.

Deï¬nition 2.6 (coalgebra homomorphism)
Let (C, Ï•) and (D, Ïˆ) be two F-coalgebras. A homomorphism from (C, Ï•) to
(D, Ïˆ) is an arrow f : C â†’ D in the category C, such that

Ïˆ â—¦ f = F f â—¦ Ï•

i.e. makes the following diagram to commute:

C

f

D

Ï•

Ïˆ

F C

F f

F D

Similarly to homomorphisms between algebras, homomorphisms between co-

algebras compose with identity arrow as the identity homomorphism.

Deï¬nition 2.7 (category of coalgebras)
The category of F-coalgebras over C â€” CoAlg(F) â€” is deï¬ned by:

â€¢ Objects: F-coalgebras; i.e. arrows Ï• of C such that cod Ï• = F(dom Ï•).

22

/
/




/
/
â€¢ Arrows: triples (f, Ï•, Ïˆ) : Ï• â†’ Ïˆ where Ï• and Ïˆ are F-coalgebras and

f : dom Ï• â†’ dom Ïˆ is a homomorphism from Ï• to Ïˆ.
â€¢ Identity: idÏ• = (iddom Ï•, Ï•, Ï•).
â€¢ Composition: (f, Ï•2, Ï•3) â—¦ (g, Ï•1, Ï•2) = (f â—¦ g, Ï•1, Ï•3).

Deï¬nition 2.8 (terminal coalgebra)
A F-coalgebra (Î½F, out) is the terminal F-coalgebra if for any F-coalgebra (C, Ï•)
there exists unique arrow [( Ï• )] : C â†’ Î½F making the following diagram com-
mute:

C

Ï•

F C

[( Ï• )]

F [( Ï• )]

Î½F

out

F Î½F

i.e. satisfying the universal property:

outâ—¦f = F f â—¦ Ï• â‰¡ f = [( Ï• )]

ana-CHARN

The arrows in form [( Ï• )] are called anamorphisms (derived from the Greek prepo-
sition Î±Î½Î± meaning â€˜upwardsâ€™; the name is due to Meijer).

In other words, the terminal coalgebra (Î½F, out) is the terminal object in the

category CoAlg(F), and the anamorphism [( Ï• )] is the mediating arrow out of it.
Corollary 2.4 Let (Î½F, out) be a terminal F-coalgebra.
â€¢ Cancellation: For any F-coalgebra Ï• : C â†’ FC
outâ—¦[( Ï• )] = F [( Ï• )] â—¦ Ï•

ana-SELF

â€¢ Reï¬‚ection:

ana-REFL
â€¢ Fusion: For any F-coalgebras Ï• : C â†’ FC, Ïˆ : D â†’ FD and an arrow

id = [( out )]

f : C â†’ D

Ïˆ â—¦ f = F f â—¦ Ï• â‡’ [( Ïˆ )] â—¦ f = [( Ï• )]

ana-FUSION

23

/
/




/
/
Terminal coalgebras satisfy the dual version of the Lambek lemma stating that

their carriers are ï¬xed points of F.
Corollary 2.5 The terminal coalgebra out : Î½F â†’ F Î½F is an isomorphism with
the inverse outâˆ’1 : FÎ½F â†’ Î½F deï¬ned as follows
outâˆ’1 = [( F out )]

out-inv-DEF

Dually to initial algebras, terminal coalgebras generalize the notion of the
greatest ï¬xed point, as the carrier of the terminal coalgebra for a monotonic end-
ofunction over preorder is the the greatest ï¬xed point of the given function.

Example 2.6 (unit type)
In the category Set, the pair ({(cid:63)}, id{(cid:63)}) is the terminal coalgebra of the identity
functor, where {(cid:63)} is a one element set. The unique arrow into {(cid:63)} is the required
unique homomorphism. More generally, in any category with terminal object, the
pair (1, id1) is the terminal Id-coalgebra.
Example 2.7 (conaturals)
Consider the endofunctor N(X) = 1 + X from Example 2.2. Recall that its
initial algebra is given by the set Nat = {0, 1, 2, . . .} of natural numbers together
with the join of zero and successor function as algebra structure [ zero, succ ] :
1 + Nat â†’ Nat. The inverse of the initial algebra pred : Nat â†’ 1 + Nat is a
N-coalgebra, but it is not terminal.
The terminal N-coalgebra is given by the pair (CoNat, pred), where CoNat =
{0, 1, 2, . . .}âˆª{âˆ} is the set of natural numbers augmented with an extra element
âˆ, and pred : CoNat â†’ 1 + CoNat is the predecessor function

= inl ()
pred 0
pred (n + 1) = inr n
pred âˆ
= inr âˆ.

Given an arbitrary N-coalgebra (C, f), there exists a unique function g = [( f )] :
C â†’ CoNat satisfying

pred(g(x)) = (cid:26) inl ()

if f(x) = inl ()
inr(g(y)) if f(x) = inr y

For instance, consider the function f : CoNatÃ—CoNat â†’ 1+(CoNatÃ—CoNat)
deï¬ned by

f(x, y) = ï£±ï£²ï£³

inl ()
(cid:48)
inr(x
inr(x, y

if pred(x) = pred(y) = inl ()

(cid:48)
, y) if pred(x) = inr x
(cid:48)) if pred(x) = inl (), pred(y) = inr y

(cid:48)

,

24

i.e. an N-coalgebra with carrier CoNatÃ—CoNat. The anamorphism add = [( f )] :
CoNat Ã— CoNat â†’ CoNat deï¬nes the addition function on conaturals.

Because the sum appears in the target, we cannot decompose an N-coalgebra
into simpler components in general. Often, however, the N-coalgebra is in the
form f = (!C +h)â—¦p? for some predicate p : C â†’ Bool and function h : C â†’ C.
In this case, the homomorphism condition translates to

pred(g(x)) = (cid:26) inl ()

if p(x)

inr(g(h(x))) otherwise.

Parametric coinductive types can be modeled by terminal coalgebras using
bifunctors as their signatures. Also, the resulting type constructor can be extended
to a functor.
Corollary 2.6 Let F : C Ã— C â†’ C be a bifunctor, such that and for any object A
there exists terminal FA-coalgebra (Î½FA, out). Then, the mapping T(A) = Î½FA
can extended to the endofunctor on C by deï¬ning

T(f) = [( F(f, id) â—¦ out )]

codata-map-DEF

The functor T : C â†’ C is called a codata functor of F.
Example 2.8 (streams)
The codata type of streams over a given set A is nicely represented by the terminal
coalgebra (Î½SA, out) of the bifunctor S(A, X) = A Ã— X. Write Stream(A)
for Î½SA. The functions head : Stream(A) â†’ A and tail
: Stream(A) â†’
Stream(A) equal fstâ—¦ out and sndâ—¦ out, respectively. Given any two functions
c : C â†’ A and h : C â†’ C, the anamorphism [((cid:104) c, h(cid:105) )] is the unique solution
f : C â†’ Stream A of the equation system

head â—¦ f = c
tail â—¦ f

= f â—¦ h.

The function nats : Nat â†’ Stream(Nat), which returns the stream of all natural
numbers starting with the natural number given as the argument, is the unique
solution of the equation system

head â—¦ nats = id
tail â—¦ nats = nats â—¦ succ,
and is thus deï¬nable as the anamorphism [((cid:104) id, succ (cid:105) )].

25

The function zip : Stream(A)Ã— Stream(B) â†’ Stream(AÃ— B) that zips the

argument streams together is characterized as follows:

head â—¦ zip = (fstÃ— fst) â—¦ (outÃ— out)
tail â—¦ zip = zip â—¦ (sndÃ— snd) â—¦ (outÃ— out)

This function can, therefore, be deï¬ned as [((cid:104) fstÃ— fst, sndÃ— snd(cid:105) â—¦ (outÃ— out) )].
The function iterate(f) : A â†’ Stream(A) builds the stream of all repeated
applications of function f : A â†’ A to the argument
iterate(f) = [((cid:104) id, f (cid:105) )]

Example 2.9 (colists)
The codata type of colists over a given set A can be represented as the termi-
nal coalgebra (Î½LA, out) of the functor LA. Write List(cid:48)
A for Î½LA. Given any
function g : C â†’ 1 + (A Ã— C), the anamorphism [( g )] is the unique solution
f : C â†’ List(cid:48)
A of the equation outâ—¦f = (id +(idÃ—f)) â—¦ g, i.e. the function
unfold(g) from functional programming.

2.3

Implementation in Haskell

In Haskell, like in type theory, functors arise from the association of a morphism
mapping to an object mapping. A functor in Haskell is a type constructor from
the class Functor deï¬ned in the Haskell Prelude as follows:

class

Functor f where

fmap :: (a -> b) -> f a -> f b

The type constructor f, in itself, is the object mapping part of a functor. The
morphism mapping is the function fmap. The class deï¬nition forces fmap to
have the correct typing, but cannot force it to preserve identities and composition,
so at each time the programmer deï¬nes the fmap function for a particular type
constructor f, it is his responsibility to ensure that these conditions are met.

Given some type constructor, it can be declared to be a functor by deï¬ning the
fmap function for it using instance declaration. For example, the fmap function
for the list type constructor is deï¬ned in the Haskell Prelude as follows:

instance Functor [] where

fmap = map

26

The deï¬nition tells, that the fmap for lists is â€œordinaryâ€ map function.

Inductive types, being carriers of initial algebras, are least ï¬xed points of the
corresponding functors. In Haskell, this can be modeled by the following decla-
ration:

> newtype Mu f = In (f (Mu f))

Given a type constructor f, this deï¬nes a new type Mu f which has the same
representation as the type f(Mu f); i.e. it deï¬nes Mu f as the least ï¬xed point of
f. In addition, it deï¬nes a data constructor In :: f (Mu f) -> Mu f for the
explicit one-way coercion between the types. The coercion in the other way (i.e.
the inverse of In) can be deï¬ned by pattern matching:

> unIn :: Mu f -> f (Mu f)
> unIn (In x) = x

Coinductive types are carriers of terminal coalgebras, thus greatest ï¬xed points
of the corresponding functors. Because Haskell allows to use a general recursion,
coinductive types are necessarily isomorphic to the inductive types with the same
base functor. Hence we could use Mu f also for coinductive types. However,
in order to make intended meaning of different usages explicit, we deï¬ne them
separately:

> newtype Nu f = Wrap (f (Nu f))

> out :: Nu f -> f (Nu f)
> out (Wrap x) = x

In order to implement cata- and anamorphisms, we make use the correspond-
ing cancellation laws, but in a slightly modiï¬ed form1. Namely, we eliminate the
occurrences of the initial algebra in or terminal coalgebra out from the left-hand
side of the equation, by pre- or postcomposing both sides with the corresponding
inverse.

> cata :: Functor f => (f c -> c) -> Mu f -> c
> cata phi = phi . fmap (cata phi) . unIn

> ana
> ana phi

:: Functor f => (c -> f c) -> c -> Nu f

= Wrap . fmap (ana phi)

. phi

1In fact, this is not necessary for catamorphisms, as we could use pattern matching to implement
the cancellation law directly. However, this does not work in the case of anamorphisms, as Haskell
requires that the name of the deï¬ned function has to be the outermost in the left-hand side of the
deï¬ning equation.

27

The combinator cata takes a function of type f c -> c (i.e. algebra) into func-
tion of type Mu f -> c. Dually, ana takes a function of type c -> f c (i.e.
coalgebra) into function of type c -> Nu f. In both cases, the type constructor
f has to belong into class Functor. The restriction on f is necessary, as the
right-hand sides of the deï¬ning equations makes use of the function fmap. Note
that there was no such restriction in the deï¬nitions of Mu or Nu.

Example 2.10 (naturals)
The data type of natural numbers, as given in example 2.2, is an initial algebra for
the functor N(X) = 1 + X. In Haskell, this can be implemented as follows:

> data N x = Z | S x

> instance Functor N where
>
>

fmap f Z
fmap f (S x) = S (f x)

= Z

> type Nat = Mu N

The ï¬rst line deï¬nes a new type constructor N, which corresponds to the object
mapping part of the functor N. Then, the instance declaration deï¬nes the function
fmap for it; i.e. makes it a functor. Finally, the last line deï¬nes data type Nat as
the least ï¬xed point of N.

The constructor functions for naturals (the constant zero and successor func-

tion) can be deï¬ned as follows:

> zeroN :: Nat
> zeroN

= In Z

> succN
> succN n = In (S n)

:: Nat -> Nat

Below are listed some illustrative values of type Nat (naturals 1, 2 and 4):

In (S (In Z))
In (S (In (S (In Z))))
In (S (In (S (In (S (In (S (In Z))))))))

The sum of two naturals can be implemented as following catamorphism:

> addN :: Nat -> Nat -> Nat
> addN x y = cata phi x
>
>

where phi Z

= y

phi (S n) = succN n

28

Note that the algebra phi is deï¬ned by the case analysis over the structure of type
constructor N, specifying the result separately depending whether the inductive
argument (i.e. x) is zero or not. In the case of non-zero inductive argument, the
result is speciï¬ed in terms of the value on its predecessor.

Analogously, the product of two naturals can be implemented by a catamor-

phism:

> mulN :: Nat -> Nat -> Nat
> mulN x y = cata phi x
>
>

where phi Z

= y

phi (S n) = addN y n

Example 2.11 (lists)
The data type of lists can be implemented as follows:

> data L a x = N | C a x

> instance Functor (L a) where
>
>

fmap f N
fmap f (C x xs) = C x (f xs)

= N

> type List a

= Mu (L a)

> nilL :: List a
> nilL

= In N

> consL
> consL x xs = In (C x xs)

:: a -> List a -> List a

The functions nilL and consL are constructor functions for lists. The ï¬rst cor-
responds to an empty list, and the second to the â€œordinaryâ€ list constructor.

The functions length, concat and map from the example 2.3 can be imple-

mented as follows:

> lengthL :: List a -> Nat
> lengthL = cata phi
>
>

where phi N

phi (C _ n) = succN n

= zeroN

29

> concatL :: List a -> List a -> List a
> concatL xs ys = cata phi xs
>
>

phi (C x xsâ€™) = consL x xsâ€™

where phi N

= ys

> mapList :: (a -> b) -> List a -> List b
> mapList f = cata phi
>
>

phi (C a bs) = consL (f a) bs

where phi N

= nilL

Example 2.12 (streams)
The codata type of streams can be implemented as follows:

> data S a x = St a x

> instance Functor (S a) where
>

fmap f (St x xs) = St x (f xs)

> type Stream a = Nu (S a)

> headS :: Stream a -> a
> headS xs = case out xs of
>

St x _ -> x

> tailS :: Stream a -> Stream a
> tailS xs = case out xs of
>

St _ xsâ€™ -> xsâ€™

Functions headS and tailS are stream destructors, returning the head and the
tail of the given stream respectively.

> zipS :: (Stream a, Stream a) -> Stream (a,a)
> zipS = ana phi
>
>

where phi (xs, ys) = St (headS xs, headS ys)
(tailS xs, tailS ys)

30

> iterateS :: (a -> a) -> a -> Stream a
> iterateS f = ana phi
>

where phi x = St x (f x)

Example 2.13 (colists)
Colists have the same base functor as lists, hence we can implement them as
follows:

> type CoList a = Nu (L a)

The destructor function for conaturals, can not be decomposed in general. How-
ever, as Haskell allows to use partial functions, we deï¬ne more intuitive â€œdestruc-
torsâ€ as follows:

> nullCL :: CoList a -> Bool
> nullCL xs = case out xs of
>
>

N
C _ _ -> False

-> True

> headCL :: CoList a -> a
> headCL xs = case out xs of
>
C x _ -> x

> tailCL :: CoList a -> CoList a
> tailCL xs = case out xs of
>

C _ xsâ€™ -> xsâ€™

The function nullCL tests whether the colist is empty or not. Partial functions
headCL and tailCL extract respectively the head and the tail of the given non-
empty colist.

2.4 Related work

The categorical treatment of inductive and coinductive types as initial algebras
and terminal coalgebras for covariant functors comes from Hagino [Hag87], who
designed a typed functional language CPL based on distributive categories and
initial algebras and terminal coalgebras for strong covariant functors. The Charity
language by Cockett et al. [CF92] is a similar programming language.

The program calculation community is rooted in the Bird-Meertens formalism
or Squiggol [Bir87], which, originally, was an equational theory of programming

31

with the parametric data type of lists. Malcolm [Mal90b, Mal90a] made the com-
munity aware of Haginoâ€™s work and much of the subsequent development fol-
lowed the path he set. A classic reference in the area of theory is Fokkingaâ€™s
[Fok92]. The excellent introduction into program calculation is the textbook
[BdM97].

32

CHAPTER 3

PRIMITIVE (CO)RECURSION

This chapter, based on [VU98], is devoted to primitive recursion and primitive
corecursion. Primitive recursion is a well known recursion scheme, where the
value on the current argument is constructed using the value on the previous ar-
gument together with the previous argument itself. Its dualization, primitive core-
cursion, is not so well known, but provides an equally useful corecursive deï¬ni-
tion mechanism where a codata structure is generated either step by step (like in
the case of coiteration) or in one big step. Both schemes are generalizations of
the simple (co)iteration and can be embedded in a nice way into the categorical
framework presented in the previous chapter.

3.1 Primitive recursion via tupling

Not every function with inductive type as source can be represented by a single
catamorphism alone. For instance, the factorial function fact : Nat â†’ Nat is
neatly characterized as the unique solution of the equation system

fact(0)
fact(n + 1) = (n + 1) âˆ— fact(n)

= 1

However, the recursion pattern of the equations above does not follow that of cata-
morphisms but primitive recursion, i.e. the factorial of a given natural, depends not
only on the factorial of its predecessor, but also on the predecessor itself. So, the
catamorphic deï¬nition of factorial has to compute both in parallel as a pair and
then project the factorial component out:

fact = fstâ—¦(cid:76) [ Î»x.(1, 0), Î»(f, n).((n + 1) âˆ— f, n + 1) ](cid:77).

Meertens [Mee92] showed that the same trick of tupling can be also used for other
inductive types. The relevant result is the following:

33

Lemma 3.1 For any two arrows f : ÂµF â†’ C and Ï• : F (C Ã— ÂµF) â†’ C, we have

f â—¦ in = Ï• â—¦ F(cid:104) f, id(cid:105) â‰¡ f = fstâ—¦(cid:76)(cid:104) Ï•, inâ—¦F(snd)(cid:105)(cid:77)

Proof. The left-hand equation essentially says that f follows the primitive re-
cursion pattern for ÂµF , while the right one gives its deï¬nition in terms of the
composition of the left projection and a catamorphism.

The equivalence is proved by the following two calculations. First, from left

to right:

(cid:66) f â—¦ in = Ï• â—¦ F(cid:104) f, id(cid:105)

f
â€“ pairing â€“
fstâ—¦(cid:104) f, id(cid:105)

=

=

=

=

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

â€“ cata-CHARN â€“
(cid:104) f, id(cid:105) â—¦ in
â€“ pairing â€“
(cid:104) f â—¦ in, in(cid:105)
â€“ F functor â€“
(cid:104) f â—¦ in, inâ—¦F id(cid:105)
(cid:104) f â—¦ in, inâ—¦F (sndâ—¦(cid:104) f, id(cid:105))(cid:105)
(cid:104) Ï• â—¦ F(cid:104) f, id(cid:105), inâ—¦F sndâ—¦F(cid:104) f, id(cid:105)(cid:105)
(cid:104) Ï•, inâ—¦F snd(cid:105) â—¦ F(cid:104) f, id(cid:105)

â€“ pairing â€“
â€“ (cid:67), F functor â€“

â€“ pairing â€“

=

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

fstâ—¦(cid:76)(cid:104) Ï•, inâ—¦F snd(cid:105)(cid:77)

Second, from right to left:

34

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

=

â€“ (cid:67) â€“

â€“ cata-CHARN â€“

(cid:66) f = fstâ—¦(cid:76)(cid:104) Ï•, inâ—¦F snd(cid:105)(cid:77)
f â—¦ in
fstâ—¦(cid:76)(cid:104) Ï•, inâ—¦F snd(cid:105)(cid:77) â—¦ in
fstâ—¦(cid:104) Ï•, inâ—¦F snd(cid:105) â—¦ F(cid:76)(cid:104) Ï•, inâ—¦F snd(cid:105)(cid:77)
Ï• â—¦ F(cid:104) fstâ—¦(cid:76)(cid:104) Ï•, inâ—¦F snd(cid:105)(cid:77), sndâ—¦(cid:76)(cid:104) Ï•, inâ—¦F snd(cid:105)(cid:77)(cid:105)
ï£®ï£°
sndâ—¦(cid:104) Ï•, inâ—¦F snd(cid:105)
inâ—¦F snd
Ï• â—¦ F(cid:104) f,(cid:76) in(cid:77)(cid:105)
Ï• â—¦ F(cid:104) f, id(cid:105)

â€“ pairing, 2x â€“
â€“ (cid:67), cata-FUSION â€“

â€“ cata-REFL â€“

â€“ pairing â€“

=

From the lemma above, it follows that at least every primitive recursive func-
tion can be represented using catamorphism as the only recursive construction.
In the presence of exponentials, one can even deï¬ne Ackermannâ€™s function as a
(higher-order) catamorphism, so the expressive power of the â€œlanguage of cata-
morphismsâ€ is bigger than the class of primitively recursive functions. In fact,
Howard [How96] has shown that the functions expressible in simply typed Î»-
calculus extended with inductive and coinductive types are precisely those prov-
ably total in the logic ID<Ï‰ (the ï¬rst order arithmetic augmented by ï¬nitely-
iterated inductive deï¬nitions).

However, from the practical point of view, the situation is not very satisfac-
tory. First, using tupling is clearly not the most natural way to program primitive
recursive functions. Second, algorithms corresponding to the deï¬nitions obtained
by the lemma above have additional penalty in terms of complexity, as they have
to reconstruct the argument which is already there.

3.2 Paramorphisms

To make programming and program reasoning easier, let us introduce a new con-
struction and study its properties.

35

Deï¬nition 3.1 (paramorphism)
Let (ÂµF, in) be an initial F-algebra. For any arrow Ï• : F (CÃ—ÂµF) â†’ C, the arrow
(cid:104)| Ï•|(cid:105) : ÂµF â†’ C is deï¬ned by

(cid:104)| Ï•|(cid:105) = fstâ—¦(cid:76)(cid:104) Ï•, inâ—¦F(snd)(cid:105)(cid:77)

para-DEF
The arrows in form (cid:104)| Ï•|(cid:105) are called paramorphisms (derived from the Greek
preposition Ï€Î±ÏÎ± meaning â€˜near toâ€™, â€˜at the side ofâ€™, â€˜towardsâ€™; the name is due
to Meertens [Mee92]).

The deï¬nition made use of the right-hand side of the equivalence in Lemma 3.1.
Exploiting the left-hand side, we get the characterization of paramorphisms in
terms of universal property.
Corollary 3.2 For any arrow Ï• : F (C Ã— ÂµF) â†’ C, the paramorphism f =
(cid:104)| Ï•|(cid:105) : ÂµF â†’ C is the unique arrow making the following diagram commute:

F ÂµF

F (cid:104) f,id (cid:105)
F (C Ã— ÂµF)

in

Ï•

ÂµF

f

C

i.e. satisfying the universal property:

f â—¦ in = Ï• â—¦ F(cid:104) f, id(cid:105) â‰¡ f = (cid:104)| Ï•|(cid:105)

para-CHARN

Example 3.1 (primitive recursion for naturals)
Consider the data type of natural numbers. Given any two functions c : 1 â†’ C
and h : CÃ—Nat â†’ C, the paramorphism f = (cid:104)| [ c, h ]|(cid:105) : Nat â†’ C is the unique
solution of the equation system

f â—¦ zero = c
f â—¦ succ = h â—¦ (cid:104) f, id(cid:105),

i.e. it captures the classical primitive recursion scheme. For instance, the factorial
function fact : Nat â†’ Nat can be deï¬ned as paramorphism

fact = (cid:104)| [ one, Î»(f, n).mul(succ(n), f) ]|(cid:105),

where one = succ â—¦ zero : 1 â†’ Nat and mul
multiplication of naturals deï¬ned in Example 2.2.

: Nat Ã— Nat â†’ Nat is the

36

/
/




/
/
Example 3.2 (primitive recursion for lists)
Consider the data type of lists List(A). Given any two functions c : 1 â†’ C and
h : A Ã— C Ã— List(A) â†’ C, the paramorphism f = (cid:104)| [ c, h ]|(cid:105) : List(A) â†’ C is
the unique solution of the equation system

f(nil)
f(cons(x, xs)) = h(x, f(xs), xs).

= c()

For instance, the function tails : List(A) â†’ List(List(A)), which returns the
list of all tail segments of argument list, can be deï¬ned as paramorphism
tails = (cid:104)| [ cons(nil , nil), Î»(x, r, xs).cons(cons(x, xs), ys) ]|(cid:105).

Another example of list paramorphism is the function dropWhile(p) : List(A) â†’
List(A), which for given predicate p : A â†’ Bool drops the longest initial seg-
ment of the argument list such that all elements in this segment satisfy p

dropWhile(p) = (cid:104)| [ nil , Î»(x, r, xs).if p(x) then r else cons(x, xs) ]|(cid:105).

The calculational properties of paramorphisms are similar to those of catamor-
phisms. In particular, we have â€œparamorphicâ€ versions of cancellation, reï¬‚ection
and fusion laws.

Proposition 3.3 Let (ÂµF, in) be an initial F-algebra.

â€¢ Cancellation: For any arrow Ï• : F (C Ã— ÂµF) â†’ C
(cid:104)| Ï•|(cid:105) â—¦ in = Ï• â—¦ F(cid:104)(cid:104)| Ï•|(cid:105), id(cid:105)

para-SELF

â€¢ Reï¬‚ection:

para-REFL
â€¢ Fusion: For any arrows Ï• : F (C Ã— ÂµF) â†’ C, Ïˆ : F (D Ã— ÂµF) â†’ D and

id = (cid:104)| inâ—¦ F(fst)|(cid:105)

f : C â†’ D

f â—¦ Ï• = Ïˆ â—¦ F(f Ã— id) â‡’ f â—¦ (cid:104)| Ï•|(cid:105) = (cid:104)| Ïˆ |(cid:105)

para-FUSION

Proof. The cancellation law is directly obtained form the universal property of
paramorphisms by substituting f := (cid:104)| Ï•|(cid:105) thus making the right-hand equation in

37

para-CHARN trivially true. For the reï¬‚ection law we argue:

id

=

â€“ para-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

â€“ identity, F functor â€“

idâ—¦ in
inâ—¦ F(id)
inâ—¦ F(fstâ—¦(cid:104) id, id(cid:105))
inâ—¦ F(fst) â—¦ F(cid:104) id, id(cid:105)

â€“ F functor â€“

â€“ pairing â€“

(cid:104)| inâ—¦ F(fst)|(cid:105)

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

Finally, the fusion law is proved as follows:
(cid:66) f â—¦ Ï• = Ïˆ â—¦ F(f Ã— id)

f â—¦ (cid:104)| Ï•|(cid:105)

=

â€“ para-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

(cid:104)| Ïˆ |(cid:105)

â€“ para-SELF â€“
â€“ (cid:67) â€“

f â—¦ (cid:104)| Ï•|(cid:105) â—¦ in
f â—¦ Ï• â—¦ F(cid:104)(cid:104)| Ï•|(cid:105), id(cid:105)
Ïˆ â—¦ F(f Ã— id) â—¦ F(cid:104)(cid:104)| Ï•|(cid:105), id(cid:105)
Ïˆ â—¦ F((f Ã— id) â—¦ (cid:104)(cid:104)| Ï•|(cid:105), id(cid:105))
Ïˆ â—¦ F(cid:104) f â—¦ (cid:104)| Ï•|(cid:105), id(cid:105)

â€“ F functor â€“

â€“ pairing â€“

In addition to the laws above, paramorphisms satisfy several other useful prop-

erties some of which are listed below.

Proposition 3.4

1. Every catamorphism(cid:76) Ï•(cid:77) can be deï¬ned as a paramorphism which does

not use the preceding value of the argument directly:

(cid:76) Ï•(cid:77) = (cid:104)| Ï• â—¦ F(fst)|(cid:105)

para-CATA

2. Every arrow whose source is the carrier of an initial algebra is a paramor-

phism:

f = (cid:104)| f â—¦ inâ—¦F(snd)|(cid:105)

para-FROM-INIT

38

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

(cid:76) Ï•(cid:77)

=

â€“ para-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

â€“ cata-SELF â€“

(cid:76) Ï•(cid:77) â—¦ in
Ï• â—¦ F(cid:76) Ï•(cid:77)
Ï• â—¦ F(fstâ—¦(cid:104)(cid:76) Ï•(cid:77), id(cid:105))
Ï• â—¦ F(fst) â—¦ F(cid:104)(cid:76) Ï•(cid:77), id(cid:105)

â€“ F functor â€“

â€“ pairing â€“

(cid:104)| Ï• â—¦ F(fst)|(cid:105)

f

=

â€“ para-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

â€“ F functor â€“

f â—¦ in
f â—¦ inâ—¦F(id)
â€“ pairing â€“
f â—¦ inâ—¦F(sndâ—¦(cid:104) f, id(cid:105))
f â—¦ inâ—¦F(snd) â—¦ F(cid:104) f, id(cid:105)

â€“ F functor â€“

(cid:104)| f â—¦ inâ—¦F(snd)|(cid:105)

3. The inverse of an initial algebra is a paramorphism:

inâˆ’1 = (cid:104)| F(snd)|(cid:105)

para-IN-INV

Proof. The ï¬rst equality is proven as follows:

Similarly, the validity of para-FROM-INIT is shown by:

Finally, para-IN-INV comes directly from the previous law:

ï£®ï£¯ï£¯ï£¯ï£¯ï£°

â€“ para-FROM-INIT â€“

inâˆ’1
(cid:104)| inâˆ’1 â—¦ inâ—¦F(snd)|(cid:105)
â€“ in-inv-CHARN â€“
(cid:104)| F(snd)|(cid:105)

=

=

39

3.3 Apomorphisms

Let us now dualize everything we know about paramorphisms.

Deï¬nition 3.2 (apomorphism)
Let (Î½F, out) be a terminal F-coalgebra. For any arrow Ï• : C â†’ F(C + Î½F),
deï¬ne the arrow [(cid:104) Ï•(cid:105)] : C â†’ Î½F as a composition of a certain anamorphism with
the left injection:

[(cid:104) Ï•(cid:105)] = [( [ Ï•, F(inr) â—¦ out ] )] â—¦ inl

apo-DEF
The arrows in form [(cid:104) Ï•(cid:105)] are called apomorphisms (derived from the Greek prepo-
sition Î±Ï€o meaning â€˜apart fromâ€™, â€˜far fromâ€™, â€˜away fromâ€™; the name was ï¬rst used
by Vos [Vos95]1).
Corollary 3.5 For any arrow Ï• : C â†’ F(C + Î½F), the apomorphism f = [(cid:104) Ï•(cid:105)] :
C â†’ Î½F is the unique arrow making the following diagram commute:

C

f

Î½F

Ï•

out

F (C + Î½F)

F [ f,id ]

F Î½F

i.e. satisfying the universal property:

outâ—¦f = F [ f, id ] â—¦ Ï• â‰¡ f = [(cid:104) Ï•(cid:105)]

apo-CHARN

The laws for apomorphisms are just dual to those for paramorphisms.

Corollary 3.6 Let (Î½F, out) be a terminal F-coalgebra.
â€¢ Cancellation: For any arrow Ï• : C â†’ F(C + Î½F)
outâ—¦[(cid:104) Ï•(cid:105)] = F[ [(cid:104) Ï•(cid:105)], id ] â—¦ Ï•

â€¢ Reï¬‚ection:

id = [(cid:104) F(inl) â—¦ out(cid:105)]

apo-SELF

apo-REFL

1It is interesting to note that Vene and Uustalu [VU98] unaware of the work by Vos happened to

come up with exactly the same new name.

40

/
/




/
/
â€¢ Fusion: For any arrows Ï• : C â†’ F(C + Î½F), Ïˆ : D â†’ F(D + Î½F) and

f : C â†’ D

Ïˆ â—¦ f = F(f + id) â—¦ Ï• â‡’ [(cid:104) Ïˆ (cid:105)] â—¦ f = [(cid:104) Ï•(cid:105)]

apo-FUSION

Corollary 3.7

1. Every anamorphism [( Ï• )] is an apomorphism:
[( Ï• )] = [(cid:104) F(inl) â—¦ Ï•(cid:105)]

apo-ANA

2. Every arrow whose target is the carrier of a terminal coalgebra is an apo-

morphism:

f = [(cid:104) F(inr) â—¦ outâ—¦f (cid:105)]

apo-TO-TERM

3. The inverse of a terminal coalgebra is an apomorphism:

outâˆ’1 = [(cid:104) F(inr)(cid:105)]

apo-OUT-INV

Example 3.3 (primitive corecursion for streams)
Consider the codata type of streams Stream(A). Given any two functions h :
C â†’ A and t : C â†’ C + Stream(A), the apomorphism f = [(cid:104)(cid:104) h, t(cid:105)(cid:105)] : C â†’
Stream(A) is the unique solution of the equation system

head â—¦ f = h
tail â—¦ f

= [ f, id ] â—¦ t.

Like in the case of anamorphisms, the head of the stream is computed from the
current seed value using the function h. However, the tail of the stream can be
generated two different ways depending whether the function t computes the
new seed value (in which case the generation process proceeds recursively) or
the rest of stream as whole. For instance, the function maphd(h) : Stream(A) â†’
Stream(A), which modiï¬es any input stream by applying a function h : A â†’ A
to its head while leaving the tail unchanged, can be deï¬ned as following apomor-
phism:

maphd(h) = [(cid:104)(cid:104) h â—¦ head , inrâ—¦tail (cid:105)(cid:105)].

41

The role of the function t is more explicit when it is in the form t = [ n, r ] â—¦ p?,
where p â†’ Bool is a predicate and n : C â†’ C and r : C â†’ Stream(A) are
functions for computing next seed or rest of the stream respectively. Then the
apomorphism f = [(cid:104)(cid:104) h, [ n, r ] â—¦ p?(cid:105)(cid:105)] is characterized by equations:

head(f(x)) = h(x)
tail(f(x)) = f(n(x)) if p(x)

= r(x)

otherwise.

For an example, assume that a given set A is ordered. The function insert(a) :
Stream(A) â†’ Stream(A) inserts the element a : 1 â†’ A into a given stream
immediately before the ï¬rst element that is greater than or equal to a (so that the
returned stream will be a sorted, if the argument was). It can be deï¬ned as an
apomorphism:

insert(a) = [(cid:104)(cid:104) h, [ tail , id ] â—¦ p?(cid:105)(cid:105)],

where

p(xs) = head(xs) â‰¤ a()
h(xs) = head(xs)

= a()

if p(xs)
otherwise.

Example 3.4 (primitive corecursion for conaturals)
Given a function h : C â†’ 1 + (C + CoNat), the apomorphism f = [(cid:104) h(cid:105)] : C â†’
CoNat is the unique solution of the equation system

inl ()
inr(f(x
inr(y)

if h(x) = inl ()

(cid:48))) if h(x) = inr(inl(x

(cid:48)))
if h(x) = inr(inr(y)).

For instance, the addition function on conaturals add = CoNat Ã— CoNat â†’
CoNat, which was deï¬ned as an anamorphism in the Example 2.7, can be more
succinctly deï¬ned as add = [(cid:104) f (cid:105)], where

pred(f(x)) = ï£±ï£²ï£³
f(x, y) = ï£±ï£²ï£³

if pred(x) = pred(y) = inl ()

inl ()
(cid:48)
(cid:48)
inr(inl(x
, y)) if pred(x) = inr x
(cid:48)))
inr(inr(y

if pred(x) = inl (), pred(y) = inr y

(cid:48)

.

The â€œstructuredâ€ corecursion operator can be deï¬ned if the function h is in the
form h = [ !C, [ n, r ] â—¦ p2? ] â—¦ p1?, where p1 : C â†’ Bool and p2 : C â†’ Bool are

42

predicates, n : C â†’ C gives the next seed and r : C â†’ CoNat gives the remain-
der of the conatural under construction. Then f = [(cid:104) [ !C, [ n, r ] â—¦ p2? ] â—¦ p1?(cid:105)] :
C â†’ CoNat is characterized by the equations:

pred(f(x)) = ï£±ï£²ï£³

if p1(x)

inl ()
inr(f(n(x))) if Â¬p1(x) âˆ§ p2(x)
inr(r(y))

otherwise.

Example 3.5 (primitive corecursion for colists)
For instance, the function the function append : CoList(A) Ã— CoList(A) â†’
CoList(A), which appends two colists is naturally deï¬nable as an apomorphism
append = [(cid:104) f (cid:105)], where
f(x, y) = inl()

if null(x) âˆ§ null(y)
if null(x) âˆ§ Â¬(null(y))

= inr(head(y), inr(tail(y)))
= inr(head(x), inl(tail(x), y)) otherwise.

Here, null : CoList(A) â†’ Bool is a predicate which tests whether the colist is
empty or not, i.e. null = [ id, !A ] â—¦ out.

3.4 Para- and apomorphisms in Haskell

Paramorphisms map arrows of type F (C Ã— ÂµF) â†’ C to the arrows of type ÂµF â†’
C. Thus, the type of paramorphism combinator can be expressed in Haskell as
follows:

> para :: Functor f => (f (c, Mu f) -> c) -> Mu f -> c

For the deï¬ning equation of paramorphism combinator we have two possibilities.
First, we can use the deï¬nition of paramorphism in terms of catamorphism:

para phi = fst . cata (fork phi (In . fmap snd))

where fork is pair forming function deï¬ned as follows:

> fork :: (a -> b) -> (a -> c) -> a -> (b,c)
> fork f g x = (f x, g x)

However, this deï¬nition is inefï¬cent, as it recursively reconstructs the argument.
The second possibility is to use the cancellation law to obtain the directly recursive
deï¬nition:

> para phi = phi . fmap (fork (para phi) id) . unIn

43

This deï¬nition is more efï¬cent, as the (previous) argument is used directly by
phi.

Example 3.6 (factorial)
The factorial function can be implemented as paramorphism:

> fact :: Nat -> Nat
> fact = para phi
>
where phi Z
>

phi (S (r,x)) = mulN (succN x) r

= succN zeroN

In the second equation of phi, the result (i.e. factorial) on the previous argument
is denoted by r, and the argument itself by x.

Example 3.7 (dropwhile)
The function dropWhile from the example 3.2 can be implemented as follows:

> dropWhileL :: (a -> Bool) -> List a -> List a
> dropWhileL p = para phi
>
>
>

phi (C x (r,xs)) | p x

= r

where phi N

= nilL

| otherwise = consL x xs

Here, again, r denotes the value on the previous argument (i.e. value on the tail
of the list), while x and xs denote the head and tail of the original list.

Dually to paramorphisms, apomorphisms map arrows of type C â†’ F(C +
Î½F) to arrows of type C â†’ Î½F. As Haskell does not provide a primitive type
constructor for sums, we have to deï¬ne it ï¬rst:

> data Sum a b = InL a | InR b

We also deï¬ne a combinator which does the case analysis on the sum:

> join :: (a -> c) -> (b -> c) -> Sum a b -> c
> join f g (InL x) = f x
> join f g (InR y) = g y

Now, the type of the apomorphism combinator can be expressed as follows:

> apo :: Functor f => (c -> f (Sum c (Nu f)))
>

-> c -> Nu f

Like in the case of paramorphisms, we have a choise between two possibilities
to deï¬ne the apomorphism combinator. First, the deï¬nition in terms of anamor-
phism:

44

apo phi = ana (join phi (fmap InR . out)) . InL

This deï¬nition is not very efï¬cent, as it constructs the codata structure in a step-
wise fashion even if the whole remaining structure is available (i.e. phi returns
the right summand). The second possibility is to use directly recursive deï¬nition
obtained from the cancellation law:

> apo phi = Wrap . fmap (join (apo phi) id) . phi

In the case of phi returns the right summand, this deï¬nition is more efï¬cient, as
the rest of the structure is returned by one step.

Example 3.8 (insert)
The function insert from the example 3.3 is deï¬ned as follows:

> insertS :: Ord a => a -> Stream a -> Stream a
> insertS a = apo phi
>
>
>

| otherwise = St a (InR xs)

where phi xs | x < a

where x = headS xs

= St x (InL (tailS xs))

Example 3.9 (append)
The concatenation of two colists can be implemented as apomorphism:

where phi (xs, ys)

> appendCL :: (CoList a, CoList a) -> CoList a
> appendCL = apo phi
>
>
>
>
>
>

| nullCL xs && nullCL ys = N
= C (headCL ys)
| nullCL xs

= C (headCL xs)

| otherwise

(InR (tailCL ys))

(InL (tailCL xs, ys))

3.5 Related work

Primitive recursion is universally recognized as an important generalization of it-
eration. Paramorphisms were introduced by Meertens [Mee92]. Geuvers [Geu92]
contains a thorough category-theoretic analysis of primitive recursion versus it-
eration and a demonstration that this readily dualizes into an analysis of primi-
tive corecursion versus coiteration. In general, however, it appears that primitive

45

corecursion has largely been overlooked in the theoretical literature, e.g. [Fok92]
ignores it. The sole discussion of primitive corecursion in a programming con-
text that we knew about when writing [VU98] was the laconic report in [Ves97]
on a not very clean extension to the categorical functional language Charity in
which it is possible to deï¬ne functions by primitive recursion and primitive core-
cursion. Soon after we got to know of [Vos95]. Citations of [VU98] appear in
[GH99, BBA00].

46

CHAPTER 4

COURSE-OF-VALUE

(CO)ITERATION

In this chapter, which is based on [UV99b], we introduce categorical combina-
tors for course-of-value iteration and coiteration. Course-of-value iteration is a
recursion scheme, where the value on the current argument is constructed using
the values for the subparts of the argument on arbitrary (but ï¬xed) depth. Du-
ally, course-of-value coiteration allows to generate several â€œlevelsâ€ of a resulting
codata structure in one step.

4.1 Course-of-value iteration via memoization

The famous Fibonacci function ï¬bo : Nat â†’ Nat is most smoothly characterized
as the unique solution of the equation system

ï¬bo(0) = 1
ï¬bo(1) = 1

ï¬bo(n + 2) = ï¬bo(n + 1) + ï¬bo(n).

This very nice characterization does not give us any deï¬nition of ï¬bo in terms
of catamorphisms. The problem is that the value of ï¬bo for a given argument is
deï¬ned not via the values for the immediate subparts of the argument, but via the
values for its subparts of depth 2. But the characterization of ï¬bo together with
the function ï¬bo(cid:48) : Nat â†’ Nat Ã— Nat (which, for any argument n, returns the
pair formed of the value of ï¬bo for n and either zero or the value of ï¬bo for the
predecessor of n) by a much trickier equation system, viz.,

ï¬bo = fstâ—¦ ï¬bo(cid:48)

ï¬bo(cid:48)(0) = (1, 0)

ï¬bo(cid:48)(n + 1) = (cid:104) add , fst(cid:105)(ï¬bo(cid:48)(n)),

47

leads to a deï¬nition of ï¬bo as the composition of the left projection and a cata-
morphism:

ï¬bo = fstâ—¦(cid:76)(cid:104) [ Î»x.1, add ], [ Î»x.0, fst ](cid:105)(cid:77).

Now, we could introduce a new construction that would capture the natural
deï¬nition scheme of the Fibonacci function and closely similar functions, and
start studying its properties. But this would only provide us with a partial so-
lution to the problem manifested by the Fibonacci example, as one can imagine
functions whose value for a given argument is naturally deï¬ned via the values for
its subparts of depth three, four, etc. Instead of this, we introduce a construction
that captures a general course-of-value iteration by collecting the values on all
subparts into a certain codata structure.

Deï¬nition 4.1 (cv-algebra)
Let F : C â†’ C be an endofunctor for which there exists an initial algebra (ÂµF, in).
Deï¬ne a bifunctor F

Ã— : C Ã— C â†’ C as follows:

Ã—(A, X) = A Ã— F(X).

F

Ã—

induces a codata functor FÎ½(X) = Î½F

Ã—
A-coalgebra (Î½F

Ã—
A, out),
Ã—
X. A F-cv-algebra is a pair (C, Ï•),

Assume that for any object A there exists a terminal F
i.e. F
where C is an object and Ï• : F(FÎ½(C)) â†’ C is an arrow.
Deï¬nition 4.2 (cv-algebra homomorphism)
Let (C, Ï•) and (D, Ïˆ) be two F-cv-algebras. A homomorphism from (C, Ï•) to
(D, Ïˆ) is an arrow f : C â†’ D in the category C, such that
f â—¦ Ï• = Ïˆ â—¦ F[( (f Ã— id) â—¦ out )]

i.e. makes the following diagram to commute:

F(FÎ½(C))

F[( (fÃ—id)â—¦out )]

F(FÎ½(D))

Ï•

Ïˆ

C

f

D

Note that any F-cv-algebra is an ordinary algebra for a functor G(X) =
F(FÎ½(X)), and homomorphisms between F-cv-algebras are ordinary homomor-
phisms between G-algebras.

48

/
/




/
/
The next result, analogous to Lemma 3.1 for primitive recursion, states that
every function which can be speciï¬ed using course-of-value iteration, can be de-
ï¬ned in terms of catamorphism which builds a codata structure of values of the
function on the all substructures of its argument (essentially, the catamorphism
builds a memo-table [Mic68] for the function).
Lemma 4.1 For any arrow f : ÂµF â†’ C and F-cv-algebra Ï• : F(FÎ½(C)) â†’ C,
we have

f â—¦ in = Ï• â—¦ F [((cid:104) f, inâˆ’1 (cid:105) )] â‰¡ f = fstâ—¦ outâ—¦(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)

Proof. Proving it is quite tricky. From left to right we calculate:

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

(cid:66) f â—¦ in = Ï• â—¦ F [((cid:104) f, inâˆ’1 (cid:105) )]

f
â€“ pairing â€“
fstâ—¦(cid:104) f, inâˆ’1 (cid:105)
â€“ pairing â€“
fstâ—¦(idÃ—F [((cid:104) f, inâˆ’1 (cid:105) )]) â—¦ (cid:104) f, inâˆ’1 (cid:105)
fstâ—¦ outâ—¦[((cid:104) f, inâˆ’1 (cid:105) )]

â€“ ana-SELF â€“

â€“ cata-CHARN â€“

=

=

=

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

=

=

â€“ pairing â€“

â€“ ana-SELF â€“

â€“ out-inv-CHARN â€“

[((cid:104) f, inâˆ’1 (cid:105) )] â—¦ in
outâˆ’1â—¦ outâ—¦[((cid:104) f, inâˆ’1 (cid:105) )] â—¦ in
outâˆ’1â—¦ (idÃ—F [((cid:104) f, inâˆ’1 (cid:105) )]) â—¦ (cid:104) f, inâˆ’1 (cid:105) â—¦ in
outâˆ’1â—¦(cid:104) f, F [((cid:104) f, inâˆ’1 (cid:105) )] â—¦ inâˆ’1 (cid:105) â—¦ in
outâˆ’1â—¦(cid:104) f â—¦ in, F [((cid:104) f, inâˆ’1 (cid:105) )] â—¦ inâˆ’1 â—¦ in(cid:105)
outâˆ’1â—¦(cid:104) Ï• â—¦ F [((cid:104) f, inâˆ’1 (cid:105) )], F [((cid:104) f, inâˆ’1 (cid:105) )](cid:105)
outâˆ’1â—¦(cid:104) Ï•, id(cid:105) â—¦ F [((cid:104) f, inâˆ’1 (cid:105) )]

â€“ pairing â€“
â€“ (cid:67), in-inv-CHARN â€“

â€“ pairing â€“

fstâ—¦ outâ—¦(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)

49

From right to left we argue:

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

â€“ pairing â€“

=

â€“ (cid:67) â€“

=

=

=

=

â€“ cata-SELF â€“

â€“ ana-CHARN â€“

â€“ out-inv-CHARN â€“

(cid:66) f = fstâ—¦ outâ—¦(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)
f â—¦ in
fstâ—¦ outâ—¦(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77) â—¦ in
fstâ—¦ outâ—¦ outâˆ’1 â—¦(cid:104) Ï•, id(cid:105) â—¦ F(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)
fstâ—¦(cid:104) Ï•, id(cid:105) â—¦ F(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)
Ï• â—¦ F(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)
outâ—¦(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)
(cid:104) fstâ—¦ outâ—¦(cid:76) outâˆ’1â—¦(cid:104) Ï•, id(cid:105)(cid:77), sndâ—¦ outâ—¦(cid:76) outâˆ’1â—¦(cid:104) Ï•, id(cid:105)(cid:77)(cid:105)
(cid:104) f, sndâ—¦ outâ—¦(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77) â—¦ inâ—¦ inâˆ’1 (cid:105)
(cid:104) f, sndâ—¦ outâ—¦ outâˆ’1â—¦(cid:104) Ï•, id(cid:105) â—¦ F(cid:76) outâˆ’1â—¦(cid:104) Ï•, id(cid:105)(cid:77) â—¦ inâˆ’1 (cid:105)
(cid:104) f, sndâ—¦(cid:104) Ï•, id(cid:105) â—¦ F(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77) â—¦ inâˆ’1 (cid:105)
(cid:104) f, F(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77) â—¦ inâˆ’1 (cid:105)
(idÃ—F(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)) â—¦ (cid:104) f, inâˆ’1 (cid:105)

â€“ pairing â€“
â€“ (cid:67), in-inv-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

â€“ out-inv-CHARN â€“

â€“ cata-SELF â€“

Ï• â—¦ F [((cid:104) f, inâˆ’1 (cid:105) )]

=

=

=

=

=

=

â€“ pairing â€“

â€“ pairing â€“

4.2 Histomorphisms

To make programming and program reasoning easier, let us introduce a new con-
struction and study its properties.

Deï¬nition 4.3 (histomorphism)
Let (ÂµF, in) be an initial F-algebra. For any F-cv-algebra Ï• : F(FÎ½(C)) â†’ C, the
arrow {| Ï•|} : ÂµF â†’ C is deï¬ned by

{| Ï•|} = fstâ—¦ outâ—¦(cid:76) outâˆ’1 â—¦(cid:104) Ï•, id(cid:105)(cid:77)

The arrows in form {| Ï•|} are called histomorphisms.

histo-DEF

50

By Lemma 4.1, we get the characterization of histomorphisms in terms of

universal property.
Corollary 4.2 For any F-cv-algebra Ï• : F(FÎ½(C)) â†’ C, the histomorphism f =
{| Ï•|} : ÂµF â†’ C is the unique arrow making the following diagram commute:

F(ÂµF)

F [( (cid:104) f,in

âˆ’1 (cid:105) )]

F(FÎ½(C))

in

Ï•

ÂµF

f

C

i.e. satisfying the universal property:

f â—¦ in = Ï• â—¦ F [((cid:104) f, inâˆ’1 (cid:105) )] â‰¡ f = {| Ï•|}

histo-CHARN

From the universal property, we also get the cancellation, reï¬‚ection and fusion

laws for histomorphisms:

Proposition 4.3 Let (ÂµF, in) be an initial F-algebra.

â€¢ Cancellation: For any F-cv-algebra Ï• : F(FÎ½(C)) â†’ C

{| Ï•|} â—¦ in = Ï• â—¦ F [((cid:104){| Ï•|}, inâˆ’1 (cid:105) )]

histo-SELF

â€¢ Reï¬‚ection:

histo-REFL
â€¢ Fusion: For any F-cv-algebra Ï• : F(FÎ½(C)) â†’ C, Ïˆ : F(FÎ½(D)) â†’ D

id = {| inâ—¦F (fstâ—¦ out)|}

and an arrow f : C â†’ D

f â—¦ Ï• = Ïˆ â—¦ F [( (f Ã— id) â—¦ out )] â‡’ f â—¦ {| Ï•|} = {| Ïˆ |}

histo-FUSION

Proof. The cancellation law is directly obtained from the universal property of
histomorphisms by substituting f := {| Ï•|} thus making the right-hand equation

51

/
/




/
/
in histo-CHARN trivially true. For the reï¬‚ection law we argue:

id

=

â€“ histo-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

=

â€“ pairing â€“

â€“ identity, F functor â€“

idâ—¦ in
inâ—¦F(id)
inâ—¦F (fstâ—¦(cid:104) id, inâˆ’1 (cid:105))
inâ—¦F (fstâ—¦(idÃ—F [((cid:104) id, inâˆ’1 (cid:105) )]) â—¦ (cid:104) id, inâˆ’1 (cid:105))
inâ—¦F (fstâ—¦ outâ—¦[((cid:104) id, inâˆ’1 (cid:105) )])
inâ—¦F (fstâ—¦ out) â—¦ F [((cid:104) id, inâˆ’1 (cid:105) )]

â€“ ana-SELF â€“

â€“ F functor â€“

â€“ pairing â€“

{| inâ—¦F(fstâ—¦ out)|}

Finally, the fusion law is proved as follows:

(cid:66) f â—¦ Ï• = Ïˆ â—¦ F [( (f Ã— id) â—¦ out )]

f â—¦ {| Ï•|}

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°
ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

â€“ histo-SELF â€“
â€“ (cid:67) â€“

â€“ histo-CHARN â€“
f â—¦ {| Ï•|} â—¦ in
f â—¦ Ï• â—¦ F [((cid:104){| Ï•|}, inâˆ’1 (cid:105) )]
Ïˆ â—¦ F [( (f Ã— id) â—¦ out )] â—¦ F [((cid:104){| Ï•|}, inâˆ’1 (cid:105) )]
Ïˆ â—¦ F ([( (f Ã— id) â—¦ out )] â—¦ [((cid:104){| Ï•|}, inâˆ’1 (cid:105) )])

â€“ F functor â€“

=

=

â€“ ana-FUSION â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

â€“ pairing â€“

â€“ ana-SELF â€“

(f Ã— id) â—¦ outâ—¦[((cid:104){| Ï•|}, inâˆ’1 (cid:105) )]
(f Ã— id) â—¦ (idÃ—F [((cid:104){| Ï•|}, inâˆ’1 (cid:105) )]) â—¦ (cid:104){| Ï•|}, inâˆ’1 (cid:105)
(f Ã— F [((cid:104){| Ï•|}, inâˆ’1 (cid:105) )]) â—¦ (cid:104){| Ï•|}, inâˆ’1 (cid:105)
(cid:104) f â—¦ {| Ï•|}, F [((cid:104){| Ï•|}, inâˆ’1 (cid:105) )] â—¦ inâˆ’1 (cid:105)
(idÃ—F [((cid:104){| Ï•|}, inâˆ’1 (cid:105) )]) â—¦ (cid:104) f â—¦ {| Ï•|}, inâˆ’1 (cid:105)

â€“ pairing â€“

â€“ pairing â€“

Ïˆ â—¦ F [((cid:104) f â—¦ {| Ï†|}, inâˆ’1 (cid:105) )]

{| Ïˆ |}

52

Read from left to right, the cancellation law can be treated as the reduction
rule for histomorphisms. Informally it tells that, the value of the histomorphism
on the given argument is computed by ï¬rst building a certain â€œcolistâ€ and then
using a cv-algebra to give the ï¬nal result. The â€œcolistâ€ is generated using an
anamorphism which gets the previous argument as the initial seed. On every step,
the anamorphism computes (recursively) the value of the histomorphism on the
current seed, and also a new seed by taking a â€œpredecessorâ€ of the current one.

The left-hand side of the fusion law states that f is a homomorphism between
cv-algebras Ï• and Ïˆ. Hence every cv-algebra homomorphism can be fused with
a histomorphism.

Similarly to paramorphisms, histomorphisms can be viewed as a generaliza-
tion of catamorphisms. Namely, every catamorphism is a histomorphism which
uses only the value on the â€œpredecessorâ€ of the current argument (i.e. the â€œheadâ€
of the â€œcolistâ€).
Proposition 4.4 For any F-algebra Ï• : F(C) â†’ C,
(cid:76) Ï•(cid:77) = {| Ï• â—¦ F (fstâ—¦ out)|}

histo-CATA

Proof. It is veriï¬ed by the following calculation:

(cid:76) Ï•(cid:77)

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

â€“ histo-CHARN â€“

â€“ pairing â€“

â€“ pairing â€“

â€“ cata-SELF â€“

(cid:76) Ï•(cid:77) â—¦ in
Ï• â—¦ F(cid:76) Ï•(cid:77)
Ï• â—¦ F (fstâ—¦(cid:104)(cid:76) Ï•(cid:77), inâˆ’1 (cid:105))
Ï• â—¦ F (fstâ—¦(idÃ—F [((cid:104)(cid:76) Ï•(cid:77), inâˆ’1 (cid:105) )]) â—¦ (cid:104)(cid:76) Ï•(cid:77), inâˆ’1 (cid:105))
Ï• â—¦ F (fstâ—¦ outâ—¦[((cid:104)(cid:76) Ï•(cid:77), inâˆ’1 (cid:105) )])
Ï• â—¦ F (fstâ—¦ out) â—¦ F [((cid:104)(cid:76) Ï•(cid:77), inâˆ’1 (cid:105) )]

â€“ ana-SELF â€“

â€“ F functor â€“

{| Ï• â—¦ F (fstâ—¦ out)|}

Example 4.1 (course-of-value iteration for naturals)
Consider
the initial N-algebra
(Nat, [ zero, succ ]). The codata type NÎ½(C) consists of nonempty colists over
C, and the terminal coalgebra structure is provided by out = (cid:104) cur , prev (cid:105) :

the data type of natural numbers;

i.e.

53

NÎ½(C) â†’ C Ã— (1 + NÎ½(C)), where cur : NÎ½(C) â†’ C gives the head and
prev : NÎ½(C) â†’ 1 + NÎ½(C) the (possible) tail of a colist.
Any N-cv-algebra Ï• : 1 + NÎ½(C) â†’ C can be decomposed using join Ï• =
[ z0, s0 ], where z0 : 1 â†’ C and s0 : NÎ½(C) â†’ C. The histomorphism f =
{| [ z0, s0 ]|} : Nat â†’ C is the unique solution of the equation system:

f(zero()) = z0()
f(succ(x)) = s0([((cid:104) f, pred (cid:105) )](x)),

where pred : Nat â†’ 1 + Nat is the predecessor function from the Example 2.2.
In order to get more illuminating version of the course-of-value iteration oper-
ator, assume that the function s0 is in form s0 = [ z1â—¦ !, s1 ] â—¦ distrâ—¦ out for some
constant1 z1 : 1 â†’ C and function s1 : C Ã— NÎ½(C) â†’ C. Then the correspond-
ing histomorphism f = {| [ z0, [ z1â—¦ !, s1 ] â—¦ distrâ—¦ out ]|} is characterized by the
equations:

f(zero()) = z0()
f(succ(zero())) = z1()
f(succ(x)) = s1(f(x), [((cid:104) f, pred (cid:105) )](x)).

Now, the use of the value on the previous argument is explicit. Particularly, by
taking z0 = one, z1 = one and s1(x, y) = add(x, cur(y)), we get the deï¬nition
of the Fibonacci function; i.e.

ï¬bo = {| [ one, [ oneâ—¦ !, add â—¦ (idÃ—cur) ] â—¦ distrâ—¦ out ]|}.

The general form of course-of-value iteration operator involves n+1 constants
z0, . . . , zn : 1 â†’ C and a function sn : C Ã— (. . . (C Ã— NÎ½(C)) . . . ) â†’ C (here
the product has n + 1 components). The corresponding histomorphism is
f = {| [ z0, [ z1â—¦ !, [ z2â—¦ !, . . . [ znâ—¦ !, sn ] â—¦ dout . . . ] â—¦ dout ] â—¦ dout ]|},

where dout = distrâ—¦ out. It is characterized by the system of n + 2 equations:

f(zero()) = z0()
f(succ(zero())) = z1()

. . .

f(succn(zero())) = zn()

f(succn(x)) = sn(f n(x), . . . , f(x), [((cid:104) f, pred (cid:105) )](x)).

1Instead of the constant, the left branch of the join could be a function h : C â†’ C which makes
use of the value on the previous argument. However, the previous argument is known to be zero
and the value on it is z0, thus result on the argument succâ—¦ zero is already known to be z1 = h(z0).

54

Note that in such way we can characterize functions which make use of arbitrary
but ï¬xed number of preceding values. Of course, we can imagine functions which
make use of all preceding values (such recursion scheme is called course-of-value
recursion). The classical example of such function is f(n) = 2n, which can be
characterized as:

f(n) = 1 + f(n âˆ’ 1) + Â·Â·Â· + f(1) + f(0).

If we rewrite the equation in a more explicit form

f(n) = 1 +

f(i),

nâˆ’1(cid:88)

i=0

we see that the use of all preceding values can be achieved by using primitive
recursion and course-of-value iteration at the same time.

4.3 Futumorphisms

We now introduce a construction dual to cv-algebras and histomorphisms.

Deï¬nition 4.4 (cv-coalgebra)
Let F : C â†’ C be an endofunctor for which there exists a terminal coalgebra
(Î½F, out). Deï¬ne a bifunctor F+ : C Ã— C â†’ C as follows:

F+(A, X) = A + F(X).

A-algebra (ÂµF+

A, in), i.e. F+
X. A F-cv-coalgebra is a pair (C, Ï•), where

Assume that for any object A there exists an initial F+
induces a data functor FÂµ(X) = ÂµF+
C is an object and Ï• : C â†’ F(F+(C)) is an arrow.
Deï¬nition 4.5 (cv-coalgebra homomorphism)
Let (C, Ï•) and (D, Ïˆ) be two F-cv-algebras. A homomorphism from (C, Ï•) to
(D, Ïˆ) is an arrow f : C â†’ D in the category C, such that
Ïˆ â—¦ f = F(cid:76) inâ—¦(f + id)(cid:77) â—¦ Ï•

i.e. makes the following diagram to commute:

C

f

D

Ï• /

F(FÂµ(C))

F(cid:76) in â—¦(f +id)(cid:77)

Ïˆ /

/ F(FÂµ(D))

55

/




Note that any F-cv-coalgebra is an ordinary coalgebra for a functor G(X) =
F(FÂµ(X)), and homomorphisms between F-cv-coalgebras are ordinary homomor-
phisms between G-coalgebras.

Deï¬nition 4.6 (futumorphism)
Let (Î½F, out) be a terminal F-coalgebra. For any F-cv-coalgebra Ï• : C â†’
F(FÂµ(C)), the arrow [{ Ï•}] : C â†’ Î½F is deï¬ned by

[{ Ï•}] = [( [ Ï•, id ] â—¦ inâˆ’1 )] â—¦ inâ—¦ inl

futu-DEF

The arrows in form [{ Ï•}] are called futumorphisms.
Corollary 4.5 For any F-cv-coalgebra Ï• : C â†’ F(F+(C)), the futumorphism
f = [{ Ï•}] : C â†’ Î½F is the unique arrow making the following diagram commute:

C

f

Î½F

Ï•

out

F(FÂµ(C))

F(cid:76) [ f,out

âˆ’1 ](cid:77)

/ F(Î½F)

i.e. satisfying the universal property:

outâ—¦f = F(cid:76) [ f, outâˆ’1 ](cid:77) â—¦ Ï• â‰¡ f = [{ Ï•}]

futu-CHARN

By a straightforward dualization of the laws for histomorphisms, we get the

corresponding laws for futumorphisms.

Corollary 4.6 Let (ÂµF, in) be an initial F-algebra.

â€¢ Cancellation: For any F-cv-coalgebra Ï• : C â†’ F(F+(C))

futu-SELF

â€¢ Reï¬‚ection:

outâ—¦[{ Ï•}] = F(cid:76) [ [{ Ï•}], outâˆ’1 ](cid:77) â—¦ Ï•
id = [{ F (inâ—¦ inl) â—¦ out}]

futu-REFL
â€¢ Fusion: For any F-cv-coalgebra Ï• : C â†’ F(F+(C)), Ïˆ : D â†’ F(F+(D))

and an arrow f : C â†’ D
Ïˆ â—¦ f = F(cid:76) inâ—¦(f + id)(cid:77) â—¦ Ï• â‡’ [{ Ïˆ }] â—¦ f = [{ Ï•}]

futu-FUSION

56

/
/




/
â€¢ Ana from futu: For any F-coalgebra Ï• : C â†’ F(C)
[( Ï• )] = [{ F (inâ—¦ inl) â—¦ Ï•}]

futu-ANA

Example 4.2 (course-of-value coiteration for streams)
Recall, that the terminal coalgebra for a bifunctor S(A, X) = A Ã— X was given
by Stream(A), the codata type of streams over A, with the coalgebra structure
(cid:104) head , tail (cid:105) : Stream(A) â†’ AÃ— Stream(A). The inductive data type manifest-
ing in stream futumorphisms is given by the induced data bifunctor SÂµ(C, A) =
C,A, where S+(C, A, X) = C + A Ã— X; i.e. data type of nonempty lists where
ÂµS+
all elements except the last one are from type A, and the last element is of type C.
The initial algebra structure is given by [ l, c ] : C + A Ã— SÂµ(C, A) â†’ SÂµ(C, A),
where l : C â†’ SÂµ(C, A) constructs the singleton list and c : A Ã— SÂµ(C, A) â†’
SÂµ(C, A) inserts the new element of type A into ï¬rst position.
Every SA-cv-coalgebra Ï• : C â†’ A Ã— SÂµ(C, A) can be decomposed using
fork Ï• = (cid:104) h0, t(cid:105), where h0 : C â†’ A and t : C â†’ SÂµ(C, A). The futumorphism
f = [{(cid:104) h0, t(cid:105)}] : C â†’ Stream(A) is the unique solution of the equation system:

head(f(x)) = h0(x)

tail(f(x)) = (cid:76) [ f, cons ](cid:77)(t(x)),

where cons = outâˆ’1 : A Ã— Stream(A) â†’ Stream(A). Intuitively, the function
t in produces a list of stream elements going to follow just next after the current
head, and also a new seed as the last element of the list. Then the catamorphism
replaces the list constructors c with the â€œstream constructorâ€ cons, thus forming
an initial preï¬x of the tail stream. Finally, the last constructor l, which contains
the new seed, is replaced by f, which continues recursively to produce the rest of
the stream.

Assume that the function t explicitly constructs the list of n + 1 elements; i.e.

it is in form

t(x) = c(h1(x), (c(h2(x), . . . c(hn(x), l(s(x))) . . . ))),

where h1, . . . , hn : C â†’ A and s : C â†’ C. Then the futumorphism f =
[{(cid:104) h0, c â—¦ (cid:104) h1, . . . c â—¦ (cid:104) hn, l â—¦ s(cid:105) . . .(cid:105)(cid:105)}] : C â†’ Stream(A) is characterized by a
system of n + 2 equations:

head(f(x)) = h0(x)
head(tail(f(x))) = h1(x)

. . .

head(tail n(f(x))) = hn(x)
tail(tail n(f(x))) = f(s(x)).

57

For instance, the function exch : Stream(A) â†’ Stream(A), which pairwise
exchanges the elements of any given argument, is characterized by the equation
system

head(exch(x)) = head(tail(x))

head(tail(exch(x))) = head(x)
tail(tail(exch(x))) = exch(tail(tail(x))).

Thus it is deï¬nable as a futumorphism:

exch = [{(cid:104) head â—¦ tail , c â—¦ (cid:104) head , l â—¦ tail â—¦ tail (cid:105)(cid:105)}].

4.4 Histo- and futumorphisms in Haskell

Histomorphisms map arrows F(FÎ½(C)) â†’ C to arrows ÂµF â†’ C. Hence, in order
to implement histomorphisms in Haskell, we ï¬rst have to deï¬ne the base functor
for the â€œcourse-of-valuesâ€ codata structure:

> newtype ProdF f a x = ProdF (a, f x)

> instance Functor f => Functor (ProdF f a) where
>

fmap f (ProdF (a, fx)) = ProdF (a, fmap f fx)

We also deï¬ne the pairing function for ProdF:

> forkF :: (a -> b) -> (a -> f c) -> a
>
> forkF f g = ProdF . fork f g

-> ProdF f b c

In order to ease the navigation on the â€œcourse-of-valuesâ€ codata structure, we
deï¬ne destructor functions out of it:

> hdCV :: Nu (ProdF f c) -> c
> hdCV xs = case out xs of
>

ProdF (c, _)

-> c

> tlCV :: Nu (ProdF f c) -> f (Nu (ProdF f c))
> tlCV xs = case out xs of
>

ProdF (_, fx) -> fx

Now, the type of histomorphism combinator can be expressed in Haskell as fol-
lows:

58

> histo :: Functor f => (f (Nu (ProdF f c)) -> c)
>

Mu f

-> c

->

Like in the case of paramorphisms, we have two possibilities for the deï¬ning
equation of histo combinator. First, we can deï¬ne it in terms of catamorphism:

> histo phi = hdCV . cata (Wrap . forkF phi id)

The second possibility is to use the directly recursive deï¬nition:

histo phi = phi

. fmap (ana (forkF (histo phi) unIn))
. unIn

This time, however, the ï¬rst deï¬nition is more efï¬cient. In the case of directly re-
cursive deï¬nition, â€œcourse-of-valueâ€ codata structure is recomputed in every step
of iteration. On the other hand, the catamorphic deï¬nition computes the â€œcourse-
of-valueâ€ codata structure incrementally in a bottom-up fashion, thus effectively
implementing the memoization of the values on previous arguments.

Example 4.3 (Fibonacci)
The Fibonacci function can be implemented as histomorphism (for greater clarity
we use Haskell integers Int as the result type):

where phi Z

> fibo :: Nat -> Int
> fibo = histo phi
>
>
>
>

= 1

phi (S x) = case tlCV x of

-> 1

Z
S y -> hdCV x + hdCV y

Example 4.4 (evens)
The function evens takes from the given list every second element. It can be
deï¬ned as histomorphism:

where phi

> evens :: List a -> List a
> evens = histo phi
>
>
>
>

N

= nilL

phi (C _ x) = case tlCV x of

-> nilL

N
C a y -> consL a (hdCV y)

59

Futumorphisms map arrows C â†’ F(FÂµ(C)) to arrows C â†’ Î½F. Hence, in
order to implement futumorphisms in Haskell, we ï¬rst have to deï¬ne the base
functor for the inductive data structure FÂµ(C):

> newtype SumF f a x = SumF (Sum a (f x))

> instance Functor f => Functor (SumF f a) where
>
>

fmap f (SumF (InL a)) = SumF (InL a)
fmap f (SumF (InR x)) = SumF (InR (fmap f x))

> joinF :: (a -> c) -> (f b -> c) -> SumF f a b -> c
> joinF f g (SumF s) = join f g s

We also deï¬ne constructor functions for the inductive data structure:

> lastF :: c -> Mu (SumF f c)
> lastF x = In (SumF (InL x))

> consF :: f (Mu (SumF f c)) -> Mu (SumF f c)
> consF x = In (SumF (InR x))

Now, the type of futumorphism combinator can be expressed in Haskell as fol-
lows:

> futu :: Functor f => (c -> f (Mu (SumF f c)))
>

c -> Nu f

->

Like in the case of histomorphisms, we have two possibilities for the deï¬ning
equation of futumorphisms combinator. First, we can deï¬ne it in terms of anamor-
phism:

futu phi = ana (joinF phi id . unIn) . lastF

The second possibility is to use the directly recursive deï¬nition obtained from the
cancellation law:

> futu phi = Wrap
>
>

. fmap (cata (joinF (futu phi) Wrap))
. phi

There is no difference between two deï¬nitions in terms of efï¬ciency except some
small constant factor.

60

Example 4.5 (exchange)
The function exch from the example 4.2 can be implemented as follows:

> exch :: Stream a -> Stream a
> exch = futu phi
>
>
>

where phi xs = St (headS (tailS xs))

(consF (St (headS xs)

(lastF (tailS xs))))

4.5 Related work

We do not know any other directly comparable work on course-of-value iteration
or coiteration (except our own work in a type-theoretic setting [UV97, UV00b,
Uus98]). The closest is work by Hu, Iwasaki and others [HITT96] about the tu-
pling transformation. They develop calculational rules to eliminate multiple data
traversals on functions deï¬ned by course-of-value iteration (and also by mutual
recursion). Instead of using coinductive data structure to represent the course-
of-values, they are using ï¬nite products which essentially are the unfolded ï¬nite
preï¬xes of the course-of-values the function actually uses. This makes the rules
quite hard to follow, but their aim is to use these rules in some automatic program
transformation system, and not in programming itself.

61

62

CHAPTER 5

MENDLER-STYLE INDUCTIVE

TYPES

This chapter is based on [UV99a] and here we consider a novel alternative ap-
proach to inductive types in the categorical setting, inspired from the work by
N. P. Mendler [Men91] in type theory. The basic motivation for this another for-
malization lies in the difï¬culties of extending the traditional approach to inductive
types (and coinductive types) for non-covariant base functors. Freydâ€™s dialgebras
[Fre90, Fre91] solve the problem for mixed-variant functors, but at the cost that
the distinction between inductive and coinductive types vanishes.

One reason for the difï¬culties in the conventional approach is that the deï¬-
nition of homomorphism between F-algebras explicitly mentions the arrow map-
ping part of the functor. As a result, if F is not a covariant functor, the deï¬nition
of homomorphisms has to be changed accordingly, otherwise the distributivity
equation the homomorphism must satisfy is incorrectly typed.

The basic idea of so called Mendler-style inductive types is to modify the def-
inition of algebra and their homomorphisms in such a way that the arrow mapping
part of the functor does not manifest itself in the distributivity equation. Instead,
there is an additional condition that the algebra itself has to satisfy, and functor
appears only in the typing. Then the concept can be extended to apply to non-
covariant bases by modifying the condition in the deï¬nition of algebra, but leav-
ing the deï¬nition of algebra homomorphism (and so also the calculational laws)
intact.

5.1 Mendler-style inductive types: covariant case

Recall, that for a given object C of the category C, we can form a contravari-
ant homfunctor C(âˆ’, C) : Cop â†’ Set which takes an object A to the hom-set
C(A, C), and an arrow g : A â†’ B to the function C(g, C) : C(B, C) â†’ C(A, C)

63

deï¬ned by Î»Î² : B â†’ C. Î² â—¦ g. Similarly, if F : C â†’ C is an endofunctor,
we can deï¬ne a contravariant functor C(F(âˆ’), C) : Cop â†’ Set which takes any
object A to the hom-set C(F(A), C), and any arrow g : A â†’ B to the function
C(F(g), C) : C(F(B), C) â†’ C(F(A), C) deï¬ned by Î»Î² : B â†’ C. Î² â—¦ F(g). In
the following we denote the functor C(F(âˆ’), C) by F/C.
Deï¬nition 5.1 (Mendler-style algebra for a functor)
Let F : C â†’ C be an endofunctor. A Mendler-style F-algebra or F-malgebra
is a pair (C, Î¦), where C is an object of C and Î¦ : Id/C .â†’ F/C is a natural
transformation; i.e. for any arrow g : A â†’ B the following diagram commutes:

C(B, C)

C(g,C)

C(A, C)

Î¦B

Î¦A

C(F(B), C)

C(F(g),C)

/ C(F(A), C)

In other words, Î¦ is an operation on arrows with target C which â€œliftsâ€ the
source of the arrow under the functor F, by taking any arrow Î± : A â†’ C to the
arrow Î¦A(Î±) : F(A) â†’ C. If the lifted arrow Î± : C â†’ C is an automorphism
(i.e. an arrow with the same source and target object), then Î¦C(Î±) : F(C) â†’ C
is a conventional F-algebra. In particular, Î¦ takes the identity arrow on C to a
conventional F-algebra Î¦C(id).

The naturality condition says, that the lifting preserves compositions in the
if Î± = Î² â—¦ g for some object B and arrows Î² : B â†’ C,

following sense:
g : A â†’ B, then

Î¦A(Î² â—¦ g) = Î¦B(Î²) â—¦ F(g)

(5.1)

or diagrammatically

g

A

@@@@@@@

Î±

B

~~~~~~~~

Î²

â‡’

F(A)

!DDDDDDDD

Î¦A(Î±)

F(g)

/ F(B)

}zzzzzzzz

Î¦B(Î²)

C
In particular, by taking B = C and Î² = idC, we have that

C

Î¦A(Î±) = Î¦C(id) â—¦ F(Î±)

(5.2)

So, the lifting on the arrows is determined by the composition the functor with
some F-algebra.

64

/
/




/

/
/
~
!
/
}
Deï¬nition 5.2 (malgebra homomorphism)
Let (C, Î¦) and (D, Î¨) be F-malgebras. A homomorphism from (C, Î¦) to (D, Î¨)
is an arrow h : C â†’ D such that for any object A the following diagram com-
mutes in Set:

C(A, C)

C(A,h)

C(A, D)

Î¦A

C(F(A), C)

Î¨A

/ C(F(A), D)

C(F(A),h)

In terms of base category C, the square above tells that for any object A and

arrow Î³ : A â†’ C, the following equation holds:

h â—¦ Î¦A(Î³) = Î¨A(h â—¦ Î³)

(5.3)

(5.4)

(5.5)

or diagrammatically:

Î³

~~~~~~~

 @@@@@@@

Î´

A

h

D

C

â‡’

F(A)

Î¦A(Î³)

}zzzzzzzz

Î¨A(Î´)

!DDDDDDDD

C

h

D

In particular, if we take A = C and Î± = idC, then
h â—¦ Î¦C(id) = Î¨C(h).
Now, using the equality 5.2 about malgebras we get

h â—¦ Î¦C(id) = Î¨C(id) â—¦ F(h).

Thus, homomorphism h is also homomorphism between conventional F-algebras
Î¦C(id) and Î¨C(id).

Obviously, homomorphisms between malgebras compose, and the identity ar-
row on the carrier object gives the identity homomorphism. So, we can form a
category Alg(F)m of Mendler-style F-algebras and their homomorphisms.
Deï¬nition 5.3 (initial malgebra for a functor)
ler-style F-algebra (C, Î¦) there exists an arrow(cid:76) Î¦(cid:77)m : ÂµmF â†’ C satisfying the
A Mendler-style F-algebra (ÂµmF, inm) is an initial F-malgebra if for any Mend-

universal property:
f â—¦ inm

ÂµmF(id) = Î¦ÂµmF(f) â‰¡ f =(cid:76) Î¦(cid:77)m

cataM-CHARN

65

/
/




/

 
/
/
}
!
/
/
In other words, the initial malgebra (ÂµmF, inm) is the initial object in the
category Alg(F)m. The cancellation, reï¬‚ection and fusion laws for Mendler-style
catamorphisms specialize as follows:

Corollary 5.1 Let (ÂµmF, inm) be an initial F-malgebra.

â€¢ Cancellation: For any F-malgebra (C, Î¦)

(cid:76) Î¦(cid:77)m â—¦ inm

ÂµmF(id) = Î¦ÂµmF((cid:76) Î¦(cid:77)m)

cataM-SELF

â€¢ Reï¬‚ection:

id =(cid:76) inm(cid:77)m

cataM-REFL
â€¢ Fusion: For any F-malgebras (C, Î¦) and (D, Î¨) and an arrow f : C â†’ D
cataM-FUSION

f â—¦ Î¦C(id) = Î¨C(f) â‡’ f â—¦(cid:76) Î¦(cid:77)m =(cid:76) Î¨(cid:77)m

Note that neither the universal property nor the laws derived from it contain
any direct references to the functor F. The functor only appears implicitly on the
typing, and as the naturality condition for Mendler-style algebras involved.

Example 5.1 (naturals)
Consider the data type of natural numbers Nat. Recall, that it forms the initial
algebra (Nat, [ zero, succ ]) for the functor N(X) = 1 + X. For any object A
and arrow Î³ : A â†’ Nat, deï¬ne a mapping inm
A(Î³) = [ zero, succ â—¦ Î³ ]. Then
(Nat, inm) forms an initial N-malgebra.

For instance, the sum of two naturals can be deï¬ned in terms of Mendler-style

catamorphism as follows:

add(n, m) = (cid:76) Î»A, Î³ : A â†’ Nat. [ Î»x.m, succ â—¦ Î³ ](cid:77)m(n).

5.2 Conventional inductive types reduced to

Mendler-style inductive types

The project of this section is to show that conventional inductive types reduce to
Mendler-style inductive types. To this end, we prove that, for any endofunctor
F : C â†’ C, the categories Alg(F)m and Alg(F) are isomorphic. The proof we
present is a proof from scratch. For a reader versed in category theory, the result
is a consequence from the Yoneda lemma.

66

Deï¬nition 5.4 (malgebra to algebra mapping)
For any F-malgebra (C, Î¦), deï¬ne

(cid:120)Î¦(cid:121) = Î¦C(id)

Deï¬nition 5.5 (algebra to malgebra mapping)
For any conventional F-algebra (C, Ï•), deï¬ne

(cid:112)Ï•(cid:113) = Î»A, Î³ : A â†’ C. Ï• â—¦ F(Î³)

Proposition 5.2 If (C, Î¦) is a F-malgebra, then (C, (cid:120)Î¦(cid:121)) is a F-algebra.
Proof. Trivial.
Proposition 5.3 If (C, Ï•) is a F-algebra, then (C, (cid:112)Ï•(cid:113)) is a F-malgebra.
Proof. We have to check that (cid:112)Ï•(cid:113) is a natural transformation.
(cid:66) pick A, B, g : A â†’ B, Î² : B â†’ C

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

â€“ (cid:112)âˆ’(cid:113)-def â€“

(cid:112)Ï•(cid:113)A(Î² â—¦ g)
Ï• â—¦ F(Î² â—¦ g)
â€“ F functor â€“
Ï• â—¦ F(Î²) â—¦ F(g)
â€“ (cid:112)âˆ’(cid:113)-def â€“
(cid:112)Ï•(cid:113)B(Î²) â—¦ F(g)

Proposition 5.4 If (C, Î¦) is a Mendler-style F-algebra, then

(cid:112)(cid:120)Î¦(cid:121)(cid:113) = Î¦.

Proof.

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

(cid:66) pick A, Î³ : A â†’ C

(cid:112)(cid:120)Î¦(cid:121)(cid:113)A(Î³)
â€“ (cid:112)âˆ’(cid:113)-def â€“
(cid:120)Î¦(cid:121) â—¦ F (Î³)
â€“ (cid:120)âˆ’(cid:121)-def â€“
Î¦C(id) â—¦ F (Î³)
â€“ Î¦ natural â€“

=

=

=

Î¦A(Î³)

67

Proposition 5.5 If (C, Ï•) is a conventional F -algebra, then

Proof.

(cid:120)(cid:112)Ï•(cid:113)(cid:121) = Ï•.

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

(cid:120)(cid:112)Ï•(cid:113)(cid:121)
(cid:112)Ï•(cid:113)C(id)
Ï• â—¦ F (id)

â€“ (cid:120)âˆ’(cid:121)-def â€“
â€“ (cid:112)âˆ’(cid:113)-def â€“

â€“ F functorial â€“

Ï•

Proposition 5.6 If h is a Mendler-style F-algebra homomorphism between
(C, Î¦) and (D, Î¨), then h is also a conventional F-algebra homomorphism be-
tween (C, (cid:120)Î¦(cid:121)) and (D, (cid:120)Î¨(cid:121)).

Proof. Already shown, see the equation 5.5 and the discussion before it.

Proposition 5.7 If h is a conventional F-algebra homomorphism between (C, Ï•)
and (D, Ïˆ), then h is also a Mendler-style F-algebra homomorphism between
(C, (cid:112)Ï•(cid:113)) and (D, (cid:112)Ïˆ(cid:113)).

Proof.

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

(cid:66) h â—¦ Ï• = Ïˆ â—¦ F(h)
(cid:66) pick A, Î³ : A â†’ C

â€“ (cid:112)âˆ’(cid:113)-def â€“
â€“ (cid:67) â€“

h â—¦ (cid:112)Ï•(cid:113)A(Î³)
h â—¦ Ï• â—¦ F(Î³)
Ïˆ â—¦ F(h) â—¦ F(Î³)
â€“ F functorial â€“
Ïˆ â—¦ F(h â—¦ Î³)
â€“ (cid:112)âˆ’(cid:113)-def â€“
(cid:112)Ïˆ(cid:113)A(h â—¦ Î³)

These propositions tell us that there exists a functor between the categories

Alg(F)m and Alg(F) and a left-and-right inverse for it.

68

Theorem 5.8 The categories Alg(F)m and Alg(F) are isomorphic.

The following is now immediate:

Corollary 5.9 If (ÂµmF, inm) is an initial Mendler-style F-algebra,
then
(ÂµmF, (cid:120)inm(cid:121)) is an initial (conventional) F-algebra. For any F-algebra Ï• :
F(C) â†’ C, the unique homomorphism into it (i.e. catamorphism) is given by
(cid:76) (cid:112)Ï•(cid:113)(cid:77)m : ÂµmF â†’ C.
(cid:76) (cid:120)Î¦(cid:121)(cid:77) : ÂµF â†’ C.

Corollary 5.10 If (ÂµF, in) is an initial (conventional) F-algebra, then (ÂµF, (cid:112)in(cid:113))
is an initial Mendler-style F-algebra. For any Mendler-style F-algebra (C, Î¦),
the unique homomorphism into it (i.e. Mendler-style catamorphism) is given by

5.3 Mendler-style inductive types: mixed variant case

The idea of Mendler-style inductive types makes sense not only for covariant base
functors F : C â†’ C, but also for mixed variant functors G : Cop Ã— C â†’ C. The
mixed variant case is, in fact, more general, as covariant functors are a degenerate
case of mixed variant functors: for any F : C â†’ C, one can trivially deï¬ne
(cid:111) : Cop Ã— C â†’ C, a padding of F
with a â€œdummyâ€ contravariant argument, by
F
letting F

(cid:111)(Y, X) = F(X).

(cid:111)

Deï¬nition 5.6 (Mendler-style algebra for a difunctor)
Let G : Cop Ã— C â†’ C be an endodifunctor. A Mendler-style G-algebra or G-
malgebra is a pair (C, Î¦), where C is an object of C and Î¦ : Id
/C ..â†’ G/C is
(cid:111)
a dinatural transformation; i.e. for any arrow g : A â†’ B the following diagram
commutes:

mmmmm

C(g,C)

vmmmmm

C(B, C)

QQQQQQQQQQQQQ
QQQQQQQQQQQQQ

C(B, C)

Î¦B

C(A, C)

Î¦A

C(G(B, B), C)
C(G(A, A), C)
QQQQQ
mmmmm
C(G(idB,g),C)
C(G(g,idA),C)
(QQQQQ
vmmmmm
C(G(B, A), C)

69

v




(
v
In terms of the base category, Î¦ is a mapping that takes any arrow Î³ : A â†’ C
to the arrow Î¦A(Î±) : G(A, A) â†’ C in such a way that if Î± = Î² â—¦ g for some
object B and arrows Î² : B â†’ C, g : A â†’ B, then the following equation holds:
(5.6)

Î¦A(Î² â—¦ g) â—¦ G(g, idA) = Î¦B(Î²) â—¦ G(idB, g)

or diagrammatically:

G(B, A)

G(g,idA)

yrrrrrrrrrr
&LLLLLLLLLLL

Î¦A(Î±)

G(idB,g)

%LLLLLLLLLL
xqqqqqqqqqqq

Î¦B(Î²)

G(A, A)

G(B, B)

A

g

@
>>>>>>>>

Î±

B

Î²

C

â‡’

C

If the contravariant argument of the difunctor G is â€œdummyâ€ (i.e. G(X, Y ) =
F(Y ) for some covariant functor F : C â†’ C) then the dinaturality condition boils
down to the naturality condition in deï¬nition 5.1, and equation 5.6 simpliï¬es to
equation 5.1. So in this case the deï¬nitions 5.1 and 5.6 coincide.

Deï¬nition 5.7 (malgebra homomorphism)
Let (C, Î¦) and (D, Î¨) be G-malgebras for a difunctor G : Cop Ã— C â†’ C. A
homomorphism from (C, Î¦) to (D, Î¨) is an arrow h : C â†’ D such that for any
object A the following diagram commutes in Set:

C(A, C)

C(A,h)

C(A, D)

Î¦A 

C(G(A, A), C) C(G(A,A),h)

Î¨A

/ C(G(A, A), D)

In terms of base category C, the square above tells that for any object A and

arrow Î³ : A â†’ C, the following equation holds:

h â—¦ Î¦A(Î³) = Î¨A(h â—¦ Î³)

(5.7)

or diagrammatically:

Î³

~~~~~~~

 @@@@@@@

Î´

A

h

D

C

â‡’

70

G(A, A)

Î¦A(Î³)

{wwwwwwwww

Î¨A(Î´)

#GGGGGGGGG

C

h

D



y
%
@

&
x
/
/


/

 
/
/
{
#
/
/
Like in the covariant case, G-malgebras and their homomorphisms (for a di-

Note that the equation 5.7 looks exactly the same as the equation 5.3. The only
difference between two is on the typing of Î¦ and Î¨.
functor G) form a category Alg(G)m.
Deï¬nition 5.8 (initial malgebra for a difunctor)
ler-style G-algebra (C, Î¦) there exists a unique arrow(cid:76) Î¦(cid:77)m : ÂµmG â†’ C satisfy-
A Mendler-style G-algebra (ÂµmG, inm) is the initial G-malgebra if for any Mend-

ing the universal property:

f â—¦ inm

ÂµmG(id) = Î¦(f) â‰¡ f =(cid:76) Î¦(cid:77)m

cataM-CHARN

In other words, the initial malgebra (ÂµmG, inm) is an initial object in the cat-
egory Alg(G)m. The cancellation, reï¬‚ection and fusion laws for Mendler-style
catamorphisms specialize as follows:

Corollary 5.11 Let (ÂµmG, inm) be an initial G-malgebra.

â€¢ Cancellation: For any G-malgebra (C, Î¦)

(cid:76) Î¦(cid:77)m â—¦ inm

ÂµmG(id) = Î¦ÂµmG((cid:76) Î¦(cid:77)m)

â€¢ Reï¬‚ection:

cataM-SELF

id =(cid:76) inm(cid:77)m

cataM-REFL
â€¢ Fusion: For any G-malgebras (C, Î¦) and (D, Î¨) and an arrow f : C â†’ D

f â—¦ Î¦C(id) = Î¨C(f) â‡’ f â—¦(cid:76) Î¦(cid:77)m =(cid:76) Î¨(cid:77)m

cataM-FUSION

Note the fact that the arrow mapping part of the signature difunctor is not
mentioned manifestly in the calculational laws for an initial Mendler-style alge-
bra, it only appears in the dinaturality condition and this would in normal practice
always be a â€œtheorem for freeâ€ `a la Wadler [Wad89].

Example 5.2 (course-of-value naturals)
Let G(Y, X) = [Y â†’ N(X)] Ã— N(X) and write Nat(cid:48)
for the carrier of the ini-
tial Mendler-style G-algebra (ÂµmG, inm). Assume that there exists a predecessor
function pred(cid:48) : Nat(cid:48) â†’ 1 + Nat(cid:48)
which satisï¬es the following speciï¬cation: for
any object A and morphism Î³ : A â†’ Nat(cid:48)

pred(cid:48) â—¦ inm(Î³) = N(Î³) â—¦ snd .

71

Then the functions zero(cid:48) : 1 â†’ Nat(cid:48)
zero(cid:48) = inm
succ(cid:48) = inm

Nat

Nat

and succ(cid:48) : Nat(cid:48) â†’ Nat(cid:48)
, inl(cid:105)
(cid:48)(id) â—¦ (cid:104) Î»x. pred(cid:48)
(cid:48)(id) â—¦ (cid:104) Î»x. pred(cid:48)
, inr(cid:105).

can be deï¬ned as

Now, the Fibonacci function can be deï¬ned as a Mendler-style catamorphism

ï¬bo =(cid:76) Î¦(cid:77)m : Nat(cid:48) â†’ Nat, where
Î¦A(Î³ : A â†’ Nat)(p, inl())
Î¦A(Î³ : A â†’ Nat)(p, inr(n)) = [ one, Î»n

= one()

(cid:48)

. add(Î³(n), Î³(n

(cid:48))) ](p(n))

5.4 Restricted existential types

The project opposite to that of the Section 5.2 â€” reducing Mendler-style inductive
types to conventional inductive types â€” is unperformable in general. But, as we
will see in Section 5.5, it can be carried out, if certain restricted existential types
are available. Let us explain what these are.

Deï¬nition 5.9 (restricted cowedge)
Let G : Cop Ã— C â†’ C be an endodifunctor and H : Cop Ã— C â†’ Set a difunctor to
Set. An H-restricted G-cowedge (cowedge from G) is a pair (C, Î¦) formed of an
object C of C and dinatural transformation Î¦ between the difunctors H and G/C,
i.e., a family of functions {Î¦A}AâˆˆC between the sets H(A, A) and C(G(A, A), C)
indexed over objects of C such that, for any arrow g : A â†’ B the following
diagram commutes:

H(B, A)

QQQQQ

H(idB,g)

(QQQQQ

mmmmm

H(g,idA)

vmmmmm

H(A, A)

Î¦A

H(B, B)

Î¦B

C(G(A, A), C)
C(G(B, B), C)
QQQQQ
mmmmm
C(G(g,idA),C)
C(G(idB,g),C)
(QQQQQ
vmmmmm
C(G(B, A), C)

72

v
(




(
v
In other words, Î¦ is a function that takes objects A of C to functions Î¦A
sending elements a of H(A, A) to morphisms Î¦A(a) : G(A, A) â†’ C so that the
following condition is met: for any objects A, B and morphism g : A â†’ B of C
and any element c of H(B, A), it holds in C that

Î¦A(H(g, idA)c) â—¦ G(g, idA) = Î¦B(H(idB, g)c) â—¦ G(idB, g)

or diagrammatically

G(B, A)

G(idB,g)

/ G(B, B)

G(g,idA)

Î¦B (H(idB,g)c)

G(A, A)

Î¦A (H(g,idA)c)

C

Deï¬nition 5.10 (restricted cowedge homomorphism)
An H-restricted G-cowedge homomorphism between H-restricted G-cowedges
(C, Î¦) and (D, Î¨) is an arrow h : C â†’ D of C with the property that, for
any object A of C, it holds in Set that

C(G(A, A), h) â—¦ Î¦A = Î¨A

or diagrammatically

H(A, A)

Î¦A

wooooooooooo

'OOOOOOOOOOO

Î¨A

C(G(A, A), C)

C(G(A,A),h)

/ C(G(A, A), D)

This condition is equivalent to the following one: for any object A of C and

any element a of H(A, A), it is the case in C that h â—¦ Î¦A(a) = Î¨A(a).

Î¦A(a)

{wwwwwwwww

G(A, A)

Î¨A(a)

#GGGGGGGGG

C

h

D

The H-restricted G-cowedges and homomorphisms between them form a cat-

egory, Cow H
G.

73



/


/
/
w
'
/
{
#
/
/
Deï¬nition 5.11 (restricted coend)
An H-restricted G-cowedge (Î£(H, G), injH
initial object of Cow H
unique arrow f = [ Î¦ ]H
(âˆ€A, a âˆˆ H(A, A). f â—¦ (injH

G) is a H-restricted G-coend if it is an
G; i.e. for any H-restricted G-cowedge (C, Î¦) there exists an
G : Î£(H, G) â†’ C satisfying the universal property:

G)A(a) = Î¦A(a)) â‰¡ f = [ Î¦ ]H

G case-CHARN

The cancellation, reï¬‚ection and fusion laws for restricted coends specialize as

follows:

Corollary 5.12 Let (Î£(H, G), injH

G) be a H-restricted G-coend.

â€¢ Cancellation: For any H-restricted G-cowedge (C, Î¦)

âˆ€A, a âˆˆ H(A, A). [ Î¦ ]H

G

â—¦ (injH

G)A(a) = Î¦A(a)

case-SELF

â€¢ Reï¬‚ection:

case-REFL
â€¢ Fusion: For any H-restricted G-cowedges (C, Î¦) and (D, Î¨) and arrow

idÎ£(H,G) = [ injH

G ]H
G

h : C â†’ D

(âˆ€A, a âˆˆ H(A, A). h â—¦ Î¦A(a) = Î¨A(a)) â‡’ h â—¦ [ Î¦ ]H

G = [ Î¨ ]H
G
case-FUSION

Example 5.3 (coends)
Consider the constant functor 1 : Cop Ã— C â†’ Set, which sends everything into a
singleton set (i.e. an terminal object of Set). Given an endodifunctor G : Cop Ã—
C â†’ C, a pair (C, Î¦) is a 1-restricted G-cowedge if Î¦ is a family of arrows
Î¦A = G(A, A) â†’ C which make the diagram

G(B, A)

G(idB,g)

/ G(B, B)

G(g,idA)

G(A, A)

Î¦A

74

Î¦B

C



/


/
/
commute for every g : A â†’ B. In other words, the pair (C, Î¦) is a cowedge
of G in ordinary sense1 (i.e. Î¦ is a dinatural transformation from G to a constant
functor C). Given two cowedges (C, Î¦) and (D, Î¨), an arrow h : C â†’ D is
a homomorphism between them iff h â—¦ Î¦A = Î¨A for any object A. Finally,
(cid:82) c G(c, c) is used for Î£(1, G)).
a 1-restricted G-coend is the coend of G (see e.g. [Mac97], where the notation

5.5 Mendler-styles inductive types reduced to

conventional inductive types

The necessary preparations made in the previous section, we are now in a position
to construct a reduction of Mendler-style inductive types to conventional inductive
types. We will obtain it in the same fashion as we obtained the reduction of
conventional inductive types to Mendler-style inductive types in Section 5.2.
Let G be an endodifunctor on C such that, for any object C of C, there exists a
(cid:111)
). Then, we can deï¬ne
/C-restricted G-coend ((Î£(Id

), [Â· ]Id

(cid:111)
/C, G), injId
G

/C

/C

G

(cid:111)

(cid:111)
Id
the following endofunction Ge on C:
(cid:111)
GeC = Î£(Id

/C, G)

Ge(h : C â†’ D) = [ Î»A, Î³ : A â†’ C. (injId

(cid:111)

/D

)A(h â—¦ Î³) ]Id

(cid:111)

G

/C

.

G

The function Ge turns out to be functorial (as one might expect), so Ge is an
endofunctor on C.
Deï¬nition 5.12
Given a Mendler-style G-algebra (C, Î¦). Deï¬ne

(cid:111)
(cid:120)Î¦(cid:121) = [ Î¦ ]Id

G

/C

Deï¬nition 5.13
Given a conventional Ge-algebra (C, Ï•). Deï¬ne

(cid:112)Ï•(cid:113) = Î»A, Î³ : A â†’ C. Ï• â—¦ (injId

(cid:111)

G

/C

)A(Î³)

Proposition 5.13 If (C, Ï•) is a conventional Ge-algebra, then (C, (cid:112)Ï•(cid:113)) is a
Mendler-style G-algebra.

1Mac Lane [Mac97] uses the term wedge for both, the dinatural transformations from and to
constant functor. However, universal wedges are called ends and coends respectively, hence our use
of the term cowedge

75

Proof. It has to be checked that (cid:112)C, Ï•(cid:113) is dinatural.

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

(cid:66) pick A, B, g : A â†’ B, Î² : B â†’ C

(cid:111)

â€“ (cid:112)âˆ’(cid:113)-def â€“

(cid:112)Ï•(cid:113)A(Î² â—¦ g) â—¦ G(g, idA)
Ï• â—¦ (injId
/C
G
(cid:111)
â€“ injId
G
(cid:111)
Ï• â—¦ (injId
â€“ (cid:112)âˆ’(cid:113)-def â€“
(cid:112)Ï•(cid:113)B(Î²) â—¦ G(idB, g)

)A(Î² â—¦ g) â—¦ G(g, idA)
dinatural â€“
)BÎ² â—¦ G(idB, g)

/C

/C

G

=

=

=

Proposition 5.14 If (C, Î¦) is a Mendler-style G-algebra, then (C, (cid:120)Î¦(cid:121)) is a con-
ventional Ge-algebra.

Proof. Trivial.

Proposition 5.15 If (C, Ï•) is a conventional Ge-algebra, then

(cid:120)(cid:112)Ï•(cid:113)(cid:121) = Ï•.

Proof.

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

(cid:120)(cid:112)Ï•(cid:113)(cid:121)

G

/C

â€“ (cid:120)âˆ’(cid:121)-def â€“
â€“ (cid:112)âˆ’(cid:113)-def â€“

(cid:111)
[ (cid:112)Ï•(cid:113) ]Id
[ Î»A, Î³ : A â†’ C.Ï• â—¦ (injId
Ï• â—¦ [ injId

â€“ case fusion â€“
/C

/C

G

(cid:111)

(cid:111)
]Id
G

G

â€“ case reï¬‚ection â€“

(cid:111)

/C

(cid:111)
)A(Î³) ]Id
G

/C

Ï•

Proposition 5.16 If (C, Î¦) is a Mendler-style G-algebra, then

(cid:112)(cid:120)Î¦(cid:121)(cid:113) = Î¦.

76

Proof.

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

(cid:66) pick A, Î³ : A â†’ C

(cid:112)(cid:120)Î¦(cid:121)(cid:113)A(Î³)
(cid:120)Î¦(cid:121) â—¦ (injId

â€“ (cid:112)âˆ’(cid:113)-def â€“
â€“ (cid:120)âˆ’(cid:121)-def â€“
â—¦ (injId

/C

G

(cid:111)

(cid:111)

/C

(cid:111)
[ Î¦ ]Id
G
â€“ case cancellation â€“

)A(Î³)

/C

G

)A(Î³)

Î¦A(Î³)

Proposition 5.17 If h is a conventional Ge-algebra homomorphism between
(C, Ï•) and (D, Ïˆ), then h is also a Mendler-style G-algebra homomorphism be-
tween (C, (cid:112)Ï•(cid:113)) and (D, (cid:112)Ïˆ(cid:113)).

Proof.ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

=

(cid:66) h â—¦ Ï• = Ïˆ â—¦ Geh
(cid:66) pick A, Î³ : A â†’ C

(cid:111)

(cid:111)

G

/C

/C

)A(Î³)

â€“ (cid:67) â€“

h â—¦ (cid:112)Ï•(cid:113)A(Î³)
â€“ (cid:112)âˆ’(cid:113)-def â€“
h â—¦ Ï• â—¦ (injId
Ïˆ â—¦ Geh â—¦ (injId
)A(Î³)
â€“ Ge-def â€“
Ïˆ â—¦ [ Î»A, Î³ : A â†’ C. (injId
â€“ case cancellation â€“
)A(h â—¦ Î³)
Ïˆ â—¦ (injId
â€“ (cid:112)âˆ’(cid:113)-def â€“
(cid:112)Ïˆ(cid:113)A(h â—¦ Î³)

/D

G

G

G

(cid:111)

(cid:111)

/D

)A(h â—¦ Î³) ]Id

(cid:111)

G

/C

(cid:111)

â—¦ (injId

G

/C

)A(Î³)

Proposition 5.18 If h is a Mendler-style G-algebra homomorphism between
(C, Î¦) and (D, Î¨), then h is also a conventional Ge-algebra homomorphism be-
tween (C, (cid:120)Î¦(cid:121)) and (D, (cid:120)Î¨(cid:121)).

77

(cid:66) âˆ€A, Î³ : A â†’ C. h â—¦ Î¦A(Î³) = Î¨A(h â—¦ Î³)

G

(cid:111)

(cid:111)

/D

/D

)A(h â—¦ Î³) ]Id
)A(h â—¦ Î³) ]Id

G

(cid:111)

(cid:111)

G

/C

/C

Proof.

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

=

=

=

G

/C

(cid:111)

/C

â€“ case fusion â€“

â€“ (cid:120)âˆ’(cid:121)-def â€“

h â—¦ (cid:120)Î¦(cid:121)
h â—¦ [ Î¦ ]Id
(cid:111)
[ Î»A, Î³ : A â†’ C. h â—¦ Î¦A(Î³) ]Id
â€“ (cid:67), with A := A, Î³ := Î³ â€“
[ Î»A, Î³ : A â†’ C. Î¨A(h â—¦ Î³) ]Id
â€“ case cancellation â€“
(cid:111)
[ Î»A, Î³ : A â†’ C. [ Î¨ ]Id

â—¦ (injId
(cid:111)
â—¦ [ Î»A, Î³ : A â†’ C. (injId
[ Î¨ ]Id
G
â€“ Ge-def â€“
â—¦ Ge(h)
â€“ (cid:120)âˆ’(cid:121)-def â€“

â€“ case fusion â€“

/D

(cid:111)
[ Î¨ ]Id
G
(cid:120)Î¨(cid:121) â—¦ Ge(h)

/D

/D

/C

G

G

G

(cid:111)

G

These propositions tell us that there exists a functor between the categories

Alg(Ge) and Alg(G)m and a left-and-right inverse for it.
Theorem 5.19 The categories Alg(Ge) and Alg(G)m are isomorphic.

From here, the following is obvious already.

Corollary 5.20 If (ÂµGe, in) is an initial Ge-algebra, then (ÂµGe, (cid:112)in(cid:113)) is an initial

G-malgebra. For any G-malgebra (C, Î¦), the catamorphism(cid:76) (cid:120)Î¦(cid:121)(cid:77) : ÂµGe â†’ C

is the unique homomorphism from (ÂµGe, in) to (C, Î¦).

Corollary 5.21 If (ÂµmG, inm) is an initial Mendler-style G-algebra,
then
(ÂµmG, (cid:120)inm(cid:121)) is an initial conventional Ge-algebra. For any conventional Ge-

algebra (C, Ï•), the Mendler-style catamorphism(cid:76) (cid:112)Ï•(cid:113)(cid:77)m : ÂµmG â†’ C is the

unique conventional homomorphism from (ÂµmG, inm) to (C, Ï•).

5.6 Mendler-style inductive types in Haskell

Mendler-style inductive types can be modeled in Haskell by using existential types
and rank-2 type signatures. While not part of the ofï¬cial Haskell98 language

78

deï¬nition, several Haskell implementations (e.g. Hugs, ghc, hbc) support them as
language extensions.

According to Corollary 5.20, an initial Mendler-style algebra for a difunctor
G is an initial (conventional) Ge-algebra, where functor Ge is constructed from
G by terms of certain restricted coends. Hence, in order to model Mendler-style
inductive types, we ï¬rst have to implement restricted coends.

The Haskell correspondent for a H-restricted G-cowedge (C, Î¦) is a polymor-
phic function phi :: H a -> G a -> C (together with the type C), where H
and G are type constructors. Thus, H-restricted G-coends can be implemented as
follows:

> data RCoEnd h g = forall a . InjRCE (h a) (g a)

Given type constructors h and g, this deï¬nes the type RCoEnd h g as a pair
of values of type h a and g a respectively. The type variable a is existentially
quantiï¬ed2 and does not appear in RCoEnd h g. It also deï¬nes the data construc-
tor InjRCE :: h a -> g a -> RCoEnd g c which corresponds to the re-
stricted coend. The universal cowedge homomorphism out of InjRCE can be
deï¬ned as follows:

> caseRCE :: (forall a . h a -> g a -> c)

-> RCoEnd h g -> c

> caseRCE phi (InjRCE ha ga) = phi ha ga

Note the use of rank 2 type signature to ensure that the ï¬rst argument is a poly-
morphic function (i.e. is a restricted cowedge).

The type constructor corresponding to Ge can be deï¬ned by instantiating the
ï¬rst parameter of RCoEnd with a type constructor represented by (->c). Unfor-
tunately, Haskell does not allow sectioning of inï¬x type constructors (as it does
for â€œordinaryâ€ inï¬x operators). Hence, we have to deï¬ne the corresponding type
constructor explicitly.

> newtype Fun c a = Fun (a -> c)

> newtype Ext g c = Ext (RCoEnd (Fun c) g)

We also â€œliftâ€ the deï¬nitions of restricted coends and universal cowedge homo-
morphisms for Ext g c.

> injExt :: (a -> c) -> g a -> Ext g c
> injExt h x = Ext (InjRCE (Fun h) x)

2The apparently counterintuitive use of forall to capture existentially quantiï¬ed variables is

justiï¬ed by the logical equivalence âˆ€A.P â‡’ Q â‰¡ (âˆƒA.P ) â‡’ Q, if A is not free in Q.

79

> caseExt :: (forall a . (a -> c) -> g a -> d)
>
> caseExt phi (Ext (InjRCE (Fun h) x)) = phi h x

-> Ext g c -> d

The arrow mapping part of the functor Ge can be deï¬ned as follows:

> instance Functor (Ext g) where
>

fmap f = caseExt (\ h -> injExt (f . h))

Now, using the Corollary 5.20, we can deï¬ne Mendler-style inductive types, initial
malgebras and Mendler-style catamorphisms as follows:

> type MuM g = Mu (Ext g)

> inM :: (a -> MuM g) -> g a -> MuM g
> inM h x = In (injExt h x)

> cataM :: (forall a . (a -> c) -> g a -> c)
>
> cataM phi = cata (caseExt phi)

-> MuM g -> c

Instead of going through conventional inductive types, we could also imple-
ment Mendler-style inductive types directly as ï¬xed points of certain existential
types.

data MuM g = forall a. InM (a -> MuM g) (g a)

cataM :: (forall a. (a -> c) -> g a -> c)

-> MuM g -> c

cataM phi (InM h x) = phi (cataM phi . h) x

In this case, according to Corollary 5.9, we could deï¬ne conventional inductive
types in terms of Mendler-style inductive types (only for type constructors which
are functors).

type Mu f = MuM f

inMu :: f (Mu f) -> Mu f
inMu = InM id

cata :: Functor f => (f c -> c) -> Mu f -> c
cata phi = cataM (\ f -> phi . fmap f)

80

It may be helpful to think about the existentially quantiï¬ed type variable a as
some (abstract) type of internal representations for the data type. Then, values of
type MuM g are constructed from a function which converts internal representa-
tions to the data type together with the actual value itself, where the â€œouterâ€ struc-
ture (given by type constructor g) is explicit but substructures are in the internal
form. In particular, the deï¬nition of conventional inductive types is obtained by
using the data type itself also for the internal representation.

Example 5.4 (naturals)
The Mendler-style deï¬nition of natural numbers involves the same type construc-
tor N as the conventional deï¬niton (see example 2.10).

> type NatM = MuM N

The constructor functions for naturals can be deï¬ned as follows:

> zeroNM :: NatM
> zeroNM

= inM id Z

> succNM
:: NatM -> NatM
> succNM n = inM id (S n)

The sum of two naturals can be deï¬ned in terms of Mendler-style catamorphism
as follows:

> addNM :: NatM -> NatM -> NatM
> addNM x y = cataM phi x
>
>

where phi add_y Z

= y

phi add_y (S n) = succNM (add_y n)

Example 5.5 (course-of-value naturals)
Course-of-value naturals from example 5.2 can be implemented as follows:

> data Nâ€™ x = Nâ€™ (x -> N x) (N x)
> type NatCM = MuM Nâ€™

In order to deï¬ne â€œstandardâ€ constructor functions, we ï¬rst have to deï¬ne the
predecessor function for course-of-value naturals:

> predC :: NatCM -> N NatCM
> predC = caseExt phi . unIn
>
>

where phi h (Nâ€™ _

Z)

phi h (Nâ€™ _ (S n)) = S (h n)

= Z

81

Now, constructor functions can be deï¬ned as follows:

> zeroC
> zeroC

:: NatCM

= inM id (Nâ€™ predC Z)

> succC
> succC n = inM id (Nâ€™ predC (S n))

:: NatCM -> NatCM

The Fibonacci function from course-of-value naturals to integers can be deï¬ned
as follows:

= cataM phi

> fibC :: NatCM -> Int
> fibC
>
>
>
>
>

where phi fib (Nâ€™ p Z) = 1
phi fib (Nâ€™ p (S n))

= case p n of

-> fib n

Z
S m -> fib n + fib m

5.7 Related work

The concept of Mendler-style inductive type is an abstraction from N. P. Mendlerâ€™s
work [Men91] on an extension of system F (2nd-order simply-typed lambda-
calculus) with inductive and coinductive types. This system supported iteration
and coiteration through unusual operators whose beta-reduction rules did not men-
tion the arrow mapping component of the base functor of the (co)inductive type.
In [UV97, UV00b, Uus98, Mat98, Mat00], an observation was emphasized that
the system does not loose any of its desirable meta-theoretic properties, if the
base functor is permitted to be non-covariant. It was also shown how to interpret
the liberalized system in lattice theory (ÂµF is not necessarily of (pre-)ï¬xed point
of F, if F is non-monotonic). The same lattice theory explanations reappeared
in [SU99]. The category-theoretic account given here is a â€œgloriï¬cationâ€ of the
lattice-theoretic semantics.

82

CHAPTER 6

MENDLER-STYLE RECURSION

SCHEMES

In this chapter we present an alternative formalization of recursion operators (for
conventional inductive types) which is based on Mendler-style algebras. In par-
ticular, we develop Mendler-style operators for basic iteration, primitive recur-
sion and course-of-value iteration. The new operators are equivalent to the cor-
responding conventional ones, but are somewhat more intuitive (at least in our
opinion) against the background of â€œordinaryâ€ (general-)recursive programming.
This chapter is based on [UV00a].
In order to explain the difference between conventional and Mendler-style
approach, consider the function f : ÂµF â†’ C deï¬ned by simple iteration. The
recursive deï¬ning equation for it is in the form
f â—¦ in = Î¦(f),

where Î¦ is some deï¬nable function from arrows ÂµF â†’ C to arrows FÂµF â†’ C.
Just in this form, the equation does not necessarily deï¬ne f iteratively. Indeed,
the characterizing equations for primitive recursion and course-of-value iteration
are exactly in the same form. In fact, the equation may have no solution in which
case it does not deï¬ne f at all.
The conventional method to ensure that the equation deï¬nes f by a simple
iteration consists in insisting that Î¦(f) = Ï•â—¦ F(f), where Ï• : F(C) â†’ C is some
F-algebra. This means imposing a relatively syntactic condition on the right-hand
side of the equation: no expression other than â€˜Ï• â—¦ F(f)â€™ is acceptable unless we
are eager and able to prove that it equals Ï• â—¦ F(f) (which may require quite a bit
of equational reasoning).

The Mendler-style method to ensure that the equation deï¬nes f by a simple
iteration is leave the form of its right-hand side as it is (i.e. â€˜Î¦(f)â€™) but to require
Î¦ not to use any speciï¬cs about the type ÂµF. This is achievable by insisting that Î¦

83

is an instance of a function parametric in A from arrows of type A â†’ C to arrows
of type F(A) â†’ C (which is veriï¬able by type-checking). This means adopting
a considerably more semantic approach to controlling the right-hand side of the
equation.

6.1 Simple iteration

Mendler-style coding of the simple iteration follows directly from the properties
of initial Mendler-style algebras for a (covariant) functor presented in Section 5.2.
According to Theorem 5.8 and its corollaries any initial algebra determines an
initial Mendler-style algebra and vice versa. Hence, we can take an initial al-
gebra (ÂµF, in) and characterize Mendler-style homomorphisms out of the initial
malgebra (ÂµF, (cid:112)in(cid:113)) directly in terms of it.

Deï¬nition 6.1 (m-catamorphism)
Let (ÂµF, in) be an initial F-algebra. For any F-malgebra (C, Î¦), a m-catamorphism

f =(cid:76) Î¦(cid:77)m : ÂµF â†’ C is a unique arrow satisfying the universal property

f â—¦ in = Î¦ÂµF(f) â‰¡ f =(cid:76) Î¦(cid:77)m

mcata-CHARN

From this, the cancellation, reï¬‚ection, and fusion laws for m-catamorphism

follow straightforwardly.

Corollary 6.1 Let (ÂµF, in) be an initial F-algebra.

â€¢ Cancellation: For any F-malgebra (C, Î¦)
(cid:76) Î¦(cid:77)m â—¦ in = Î¦ÂµF((cid:76) Î¦(cid:77)m)

â€¢ Reï¬‚ection:

mcata-SELF

id = (cid:76) Î»A, Î³ : A â†’ ÂµF. inâ—¦ F(Î³)(cid:77)m

mcata-REFL
â€¢ Fusion: For any F-malgebras (C, Î¦) and (D, Î¨) and an arrow f : C â†’ D
(âˆ€A, Î³ : A â†’ C. f â—¦ Î¦A(Î³) = Î¨A(f â—¦ Î³)) â‡’ f â—¦(cid:76) Î¦(cid:77)m =(cid:76) Î¨(cid:77)m

mcata-FUSION

84

Note that the left-hand side of the fusion law is equivalent to the simpler
equation f â—¦ Î¦ÂµF(id) = Î¨ÂµF(f). However, for calculational purposes the one
in mcata-FUSION is preferable, as it can be directly instantiated in different con-
texts.

From the Corollary 5.10, we get the deï¬nition of m-catamorphism as con-
ventional catamorphism. Similarly, the Corollary 5.9 gives to us the deï¬nition of
conventional catamorphism as m-catamorphism.

Corollary 6.2 Let (C, Î¦) be a F-malgebra, then

(cid:76) Î¦(cid:77)m =(cid:76) Î¦ÂµF(id)(cid:77)

Corollary 6.3 Let (C, Ï•) be a F-algebra, then

(cid:76) Ï•(cid:77) =(cid:76) Î»A, Î³ : A â†’ C. Ï• â—¦ F(Î³)(cid:77)m

mcata-DEF

mcata-CATA

6.2 Primitive recursion

In this section we formalize the primitive recursion operator in the Mendler-style
setting. For this, we ï¬rst introduce the notions of rec-malgebra and their homo-
morphisms.

Deï¬nition 6.2 (rec-malgebra)
Let F : C â†’ C be an endofunctor for which there exists an initial algebra (ÂµF, in).
A F-rec-malgebra is a pair (C, Î¦), where C is an object and Î¦ : C(âˆ’, C Ã—
ÂµF) .â†’ C(F(âˆ’), C) is a natural transformation; i.e. for any arrow g : A â†’ B
the following diagram commutes:

C(B, C Ã— ÂµF)

C(g, CÃ—idÂµF)

C(A, C Ã— ÂµF)

Î¦B

Î¦A

C(F(B), C)

C(F(g),C)

/ C(F(A), C)

In other words, Î¦ is a family of functions {Î¦A}AâˆˆC which take arrows Î± :
A â†’ C Ã— ÂµF to the arrows Î¦A(Î±) : F(A) â†’ C. The naturality condition says,

85

/
/




/
that Î¦ preserves compositions in the following sense: if Î± = Î²â—¦ g for some object
B and arrows Î² : B â†’ C Ã— ÂµF, g : A â†’ B, then

Î¦A(Î² â—¦ g) = Î¦B(Î²) â—¦ F(g)

(6.1)

or diagrammatically

g

A

#GGGGGGGGG

Î±

C Ã— ÂµF

{wwwwwwwww

Î²

B

â‡’

F(g)

F(A)

!DDDDDDDD

Î¦A(Î±)

/ F(B)

}zzzzzzzz

Î¦B(Î²)

C

In particular, by taking B = C Ã— ÂµF and Î² = idCÃ—ÂµF, we get an equivalent
condition:

Î¦A(Î±) = Î¦CÃ—ÂµF(id) â—¦ F(Î±)

(6.2)

Deï¬nition 6.3 (rec-malgebra homomorphism)
Let (C, Î¦) and (D, Î¨) be two F-rec-malgebras. A homomorphism from (C, Î¦) to
(D, Î¨) is an arrow h : C â†’ D in the category C, such that for any object A the
following diagram commutes in Set:

C(A, C Ã— ÂµF)

C(A,hÃ—idÂµF) /

C(A, D Ã— ÂµF)

Î¦A 
C(F(A), C)

Î¨A

/ C(F(A), D)

C(F(A),h)

In terms of the base category, the square above tells that for any object A and

arrow Î³ : A â†’ C Ã— ÂµF, the following equation holds:

h â—¦ Î¦A(Î³) = Î¨A((h Ã— id) â—¦ Î³)

(6.3)

or diagrammatically:

Î³

{wwwwwwwww

A

#GGGGGGGGG

Î´

C Ã— ÂµF

/ D Ã— ÂµF

hÃ—idÂµF

â‡’

F(A)

Î¦A(Î³)

}zzzzzzzz

Î¨A(Î´)

!DDDDDDDD

C

h

D

In particular, if we take A = C Ã— ÂµF and Î³ = idCÃ—ÂµF, then

h â—¦ Î¦C(id) = Î¨C(h Ã— id).

(6.4)

86

#
/
/
{
!
/
}
/


/
{
#
/
}
!
/
/
Note that, in a cartesian closed base category, F-rec-malgebras and their ho-
momorphisms are equivalent to ordinary Mendler-style algebras and homomor-
phisms for a difunctor G(Y, X) = [Y â†’ ÂµF] Ã— F(X).
Deï¬nition 6.4 (m-paramorphism)
Let (ÂµF, in) be an initial F-algebra. For any F-rec-malgebra (C, Î¦), a m-para-
morphism f = (cid:104)| Î¦|(cid:105)m : ÂµF â†’ C is a unique arrow satisfying the universal
property

f â—¦ in = Î¦ÂµF(cid:104) f, id(cid:105) â‰¡ f = (cid:104)| Î¦|(cid:105)m

mpara-CHARN

Proposition 6.4 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-rec-malgebra (C, Î¦)
(cid:104)| Î¦|(cid:105)m â—¦ in = Î¦ÂµF(cid:104)(cid:104)| Î¦|(cid:105)m, id(cid:105)

â€¢ Reï¬‚ection:

mpara-SELF

id = (cid:104)| Î»A, Î³ : A â†’ ÂµF Ã— ÂµF. inâ—¦ F(fstâ—¦ Î±)|(cid:105)m

mpara-REFL
â€¢ Fusion: For any F-rec-malgebras (C, Î¦) and (D, Î¨) and an arrow f :

C â†’ D

(âˆ€A, Î³ : A â†’ C Ã— ÂµF. f â—¦ Î¦A(Î³) = Î¨A((f Ã— id) â—¦ Î³))
â‡’ f â—¦ (cid:104)| Î¦|(cid:105)m = (cid:104)| Î¨|(cid:105)m

mpara-FUSION

Proof. The cancellation law is directly obtained form the universal property of
paramorphisms by substituting f := (cid:104)| Î¦|(cid:105)m thus making the right-hand equation
in mpara-CHARN trivially true. For the reï¬‚ection law we argue:

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

id

=

â€“ mpara-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£°

=

=

â€“ identity, F functor â€“

idâ—¦ in
inâ—¦ F(id)
inâ—¦ F(fstâ—¦(cid:104) id, id(cid:105))

â€“ pairing â€“

(cid:104)| Î»A, Î³ : A â†’ ÂµF Ã— ÂµF. inâ—¦ F(fstâ—¦ Î³)|(cid:105)m

87

Finally, the fusion law is proved as follows:

(cid:66) âˆ€A, Î³ : A â†’ C Ã— ÂµF. f â—¦ Î¦A(Î³) = Î¨A((f Ã— id) â—¦ Î³)

f â—¦ (cid:104)| Î¦|(cid:105)m

=

â€“ mpara-CHARN â€“

=

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=
(cid:104)| Î¨|(cid:105)m

f â—¦ (cid:104)| Î¦|(cid:105)m â—¦ in
â€“ mpara-SELF â€“
f â—¦ Î¦ÂµF(cid:104)(cid:104)| Î¦|(cid:105)m, id(cid:105)
â€“ (cid:67) â€“
Î¨ÂµF((f Ã— id) â—¦ (cid:104)(cid:104)| Î¦|(cid:105)m, id(cid:105))
Î¨ÂµF(cid:104) f â—¦ (cid:104)| Î¦|(cid:105)m, id(cid:105)

â€“ pairing â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

Proposition 6.5 For any F-rec-malgebras (C, Î¦)

(cid:104)| Î¦|(cid:105)m = (cid:104)| Î¦ÂµFÃ—ÂµF(id)|(cid:105)

mpara-DEF

(cid:104)| Î¦ÂµFÃ—ÂµF(id)|(cid:105)

â€“ mpara-CHARN â€“

Proof.

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

ï£®ï£¯ï£¯ï£¯ï£¯ï£°

=

=
(cid:104)| Î¦|(cid:105)m

(cid:104)| Î¦ÂµFÃ—ÂµF(id)|(cid:105) â—¦ in
â€“ para-SELF â€“
Î¦ÂµFÃ—ÂµF(id) â—¦ F(cid:104)(cid:104)| Î¦ÂµFÃ—ÂµF(id)|(cid:105), id(cid:105)
Î¦ÂµF(cid:104)(cid:104)| Î¦ÂµFÃ—ÂµF(id)|(cid:105), id(cid:105)

â€“ 6.2 â€“

Proposition 6.6 For any arrow Ï• : F(C Ã— ÂµF) â†’ C

(cid:104)| Ï•|(cid:105) = (cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Ï• â—¦ F(Î³)|(cid:105)m

mpara-PARA

=

Proof.ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

ï£®ï£°

(cid:104)| Ï•|(cid:105)

(cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Ï• â—¦ F(Î³)|(cid:105)m

â€“ para-CHARN â€“

(cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Ï• â—¦ F(Î³)|(cid:105)m â—¦ in
Ï• â—¦ F(cid:104)(cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Ï• â—¦ F(Î³)|(cid:105)m, id(cid:105)

â€“ mpara-SELF â€“

=

88

Proposition 6.7 For any F-malgebra (C, Î¦)

(cid:76) Î¦(cid:77)m = (cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Î¦A(fstâ—¦ Î³)|(cid:105)m
(cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Î¦A(fstâ—¦ Î³)|(cid:105)m

â€“ mcata-CHARN â€“

mpara-MCATA

=

Proof.ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

ï£®ï£¯ï£¯ï£¯ï£¯ï£°

=

=

(cid:76) Î¦(cid:77)m

â€“ mpara-SELF â€“

(cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Î¦A(fstâ—¦ Î³)|(cid:105)m â—¦ in
Î¦ÂµF(fstâ—¦(cid:104)(cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Î¦A(fstâ—¦ Î³)|(cid:105)m, id(cid:105))
Î¦ÂµF(cid:104)| Î»A, Î³ : A â†’ C Ã— ÂµF. Î¦A(fstâ—¦ Î³)|(cid:105)m

â€“ pairing â€“

6.3 Course-of-value iteration

In this section we formalize the course-of-value iteration operator in the Mendler-
style setting. We do it in the analogous way to the primitive recursion by intro-
ducing the notions of cv-malgebra and their homomorphisms. For this, we need
Mulryâ€™s notion of strong dinaturality [Mul91].

Deï¬nition 6.5 (strong dinaturality)
Let H, G : Cop Ã— C â†’ A be difunctors. A strong dinatural transformation Î¦ :
H ..â†’G is a family of maps Î¦A for all A âˆˆ C, such that for every arrow g : A â†’ B
the following diagram commutes:

W

&MMMMMMMMMMM

xrrrrrrrrrrr

LLLL
H(idA,g)

H(A, A)

H(B, B)

rrrr
H(g,idB)
yrrrr

%LLLL
H(A, B)

Î¦B

Î¦A

G(A, A)

LLLL
G(idA,g)

rrrr
G(g,idB)
yrrrr

%LLLL
G(A, B)

G(B, B)

where W is the pullback of H(idA, g) and H(g, idB).

89

x
&


%


y
%
y
Proposition 6.8 ([Mul91]) Every strong dinatural transformation Î¦ : H ..â†’G is a
dinatural transformation.
Proof. Since H(idA, g) â—¦ H(g, idA) = H(g, idB) â—¦ H(idB, g), the pair of arrows
H(g, idA) and H(idB, g) factors through W and thus G(idA, g)â—¦Î¦Aâ—¦H(g, idA) =
G(g, idB) â—¦ Î¦B â—¦ H(idB, g).

Note that malgebras and rec-malgebras, which by deï¬nition are dinatural
transformations, are also strong dinatural transformations, as the pullback squares
for them are trivial.

Deï¬nition 6.6 (cv-malgebra)
Let F : C â†’ C be an endofunctor. A F-cv-malgebra is a pair (C, Î¦), where
C is an object and Î¦ : C(âˆ’, C Ã— F(=)) ..â†’ C(F(âˆ’), C) is a strong dinatural
transformation; i.e. for any arrow g : A â†’ B the following diagram commutes:

ukkkkkkkkkkkkkkkk

W

)SSSSSSSSSSSSSSSS

C(B, C Ã— F(B))
C(A, C Ã— F(A))
RRRRR
lllll
C(g,idCÃ—F(B))
C(idA,idCÃ—F(g))
)RRRRR
ulllll
C(A, C Ã— F(B))

Î¦B

Î¦A

C(F(A), C)

C(F(B), C)

RRRRRRRRRRRRRR
RRRRRRRRRRRRRR

lllll

C(F(g),C)

ulllll

C(F(A), C)

where W = {(Î± : A â†’ CÃ—F(A), Î² : A â†’ CÃ—F(A)) | (idCÃ— F(g))â—¦Î± = Î²â—¦g}
is a pullback of C(idA, idCÃ—F(g)) and C(g, idCÃ—F(B)).

In terms of the base category C, Î¦ is a family of functions {Î¦A}AâˆˆC which
C-coalgebras (see Deï¬nition 4.1) Î± : A â†’ C Ã— F(A) to the arrows
Ã—
take F
Î¦A(Î±) : F(A) â†’ C. The strong dinaturality condition means, that for arbi-
C-coalgebras Î± : A â†’ C Ã— F(A) and Î² : B â†’ C Ã— F(B), and an arrow
Ã—
trary F
g : A â†’ B, the following holds:

(idCÃ— F(g)) â—¦ Î± = Î² â—¦ g â‡’ Î¦A(Î±) = Î¦B(Î²) â—¦ F(g)

(6.5)

90

u
)


)


u
u
or diagrammatically

A

g

B

/ C Ã— F(A)

idCÃ— F(g)

/ C Ã— F(B)

Î±

Î²

â‡’

F(A)

!DDDDDDDD

Î¦A(Î±)

F(g)

/ F(B)

}zzzzzzzz

Î¦B(Î²)

C

Ã—
C-coalgebras Î± and Î².

Note that the left-hand side of the implication says, that g is a homomorphism
between F
Ã—
C and Î² = out, the condition 6.5 simpliï¬es to the following equation:

Ã—
C, out). Then, by taking

Assume that there exists a terminal F

Ã—
C-coalgebra (Î½F

B = Î½F

Î¦A(Î±) = Î¦Î½F
Ã—
C

(out) â—¦ F([( Î± )])

(6.6)

As the calculation below shows, the equation is equivalent to the previous impli-
cation. Indeed, if equation 6.6 holds, then

(cid:66) pick A, B, g : A â†’ B, Î± : A â†’ C Ã— F(A), Î² : B â†’ C Ã— F(B)
(cid:66) (idC Ã—F(g)) â—¦ Î± = Î² â—¦ g

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

=

=

=

Î¦A(Î±)

â€“ 6.6 â€“
(out) â—¦ F([( Î± )])
Î¦Î½F
Ã—
â€“ (cid:67), ana-FUSION â€“
C
(out) â—¦ F([( Î² )] â—¦ g)
Î¦Î½F
Ã—
C
â€“ F functor â€“
(out) â—¦ F([( Î² )]) â—¦ F(g)
Î¦Î½F
Ã—
C
â€“ 6.6 â€“
Î¦B(Î²) â—¦ F(g)

Deï¬nition 6.7 (cv-malgebra homomorphism)
Let (C, Î¦) and (D, Î¨) be two F-cv-malgebras. A homomorphism from (C, Î¦) to
(D, Î¨) is an arrow h : C â†’ D in the category C, such that for any object A the
following diagram commutes in Set:

C(A, C Ã— F(A))

C(idA,hÃ—idF(A))/

C(A, D Ã— F(A))

Î¦A 
C(F(A), C)

Î¨A

/ C(F(A), D)

C(idF(A),h)

91



/


/
!
/
}
/


/
In terms of the base category, the square above tells that for any object A and
C-coalgebra Î³ : A â†’ C Ã— F(A), the following equation holds:
Ã—

F

h â—¦ Î¦A(Î³) = Î¨A((h Ã— id) â—¦ Î³)

(6.7)

or diagrammatically:

zuuuuuuuuuu

Î³

A

$IIIIIIIIII

Î´

C Ã— F(A)

/ D Ã— F(A)

hÃ—idF(A)

â‡’

F(A)

Î¦A(Î³)

}zzzzzzzz

Î¨A(Î´)

!DDDDDDDD

C

h

D

Assuming that there exists a terminal F
above simpliï¬es to the equivalent equation:

Ã—
D-coalgebra (Î½F
h â—¦ Î¦A(out) = Î¨A((h Ã— id) â—¦ out)

Ã—
D, out), the condition

(6.8)

Note that, in a cartesian closed base category, F-cv-malgebras and their ho-
momorphisms are equivalent to ordinary Mendler-style algebras and homomor-
phisms for a difunctor G(Y, X) = [Y â†’ F(X)] Ã— F(X) (the instance of which
we used in the example 5.2 for course-of-value naturals).

Deï¬nition 6.8 (m-histomorphism)
Let (ÂµF, in) be an initial F-algebra. For any F-cv-malgebra (C, Î¦), a m-histo-
morphism f = {| Î¦|}m : ÂµF â†’ C is a unique arrow satisfying the universal
property

f â—¦ in = Î¦ÂµF(cid:104) f, inâˆ’1 (cid:105) â‰¡ f = {| Î¦|}m

mhisto-CHARN

mhisto-SELF

Proposition 6.9 Let (ÂµF, in) be an initial F-algebra.
â€¢ Cancellation: For any F-cv-malgebra (C, Î¦)

{| Î¦|}m â—¦ in = Î¦ÂµF(cid:104){| Î¦|}m, inâˆ’1 (cid:105)

â€¢ Reï¬‚ection:

f : C â†’ D

id = {| Î»A, Î³ : A â†’ ÂµF Ã— F(A). inâ—¦F(fstâ—¦ Î³)|}m

mhisto-REFL
â€¢ Fusion: For any F-cv-malgebras (C, Î¦) and (D, Î¨) and an arrow

(âˆ€A, Î³ : A â†’ C Ã— F(A). f â—¦ Î¦A(Î³) = Î¨A((f Ã— id) â—¦ Î³))
â‡’ f â—¦ {| Î¦|}m = {| Î¨|}m

mhisto-FUSION

92

z
$
/
}
!
/
/
Proof. The cancellation law is directly obtained form the universal property. For
the reï¬‚ection law we argue:

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

id

=

â€“ mhisto-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£°

=

=

â€“ identity, F functor â€“

idâ—¦ in
inâ—¦ F(id)
inâ—¦ F (fstâ—¦(cid:104) id, inâˆ’1 (cid:105))

â€“ pairing â€“

{| Î»A, Î³ : A â†’ ÂµF Ã— F(A). inâ—¦F(fstâ—¦ Î³)|}m

Finally, the fusion law is proved as follows:

(cid:66) âˆ€A, Î³ : A â†’ C Ã— F(A). f â—¦ Î¦A(Î³) = Î¨A((f Ã— id) â—¦ Î³)

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=

â€“ mhisto-CHARN â€“

f â—¦ {| Î¦|}m

ï£®ï£¯ï£¯ï£¯ï£¯ï£°

=

=
{| Î¨|}m

f â—¦ {| Î¦|}m â—¦ in
f â—¦ Î¦ÂµF(cid:104){| Î¦|}m, inâˆ’1 (cid:105)
Î¨ÂµF(cid:104) f â—¦ {| Î¦|}m, inâˆ’1 (cid:105)

â€“ mhisto-SELF â€“
â€“ (cid:67) â€“

If there exists a terminal F

Ã—
D-coalgebra (Î½F

Ã—
D, out), then any m-histomorphism

can be deï¬ned in terms of a (conventional) histomorphism, and vice versa.
Proposition 6.10 Let (Î½F
malgebra (C, Î¦)

Ã—
C-coalgebra, then for any F-cv-

Ã—
C, out) be a terminal F
{| Î¦|}m = {| Î¦Î½F

Ã—
C

(out)|}

mhisto-DEF

Proof.

=

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

{| Î¦Î½F

Ã—
C

(out)|}
{| Î¦Î½F

=

â€“ mhisto-CHARN â€“

ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

=
{| Î¦|}m

Ã—
C

(out)|} â—¦ in
â€“ histo-SELF â€“
(out) â—¦ F [((cid:104){| Î¦Î½F
Î¦Î½F
Ã—
C
â€“ 6.6 â€“
Î¦ÂµF(cid:104){| Î¦Î½F

(out)|}, inâˆ’1 (cid:105)

Ã—
C

Ã—
C

(out)|}, inâˆ’1 (cid:105) )]

93

Proposition 6.11 For any F-cv-algebra Ï• : F(FÎ½(C)) â†’ C
{| Ï•|} = {| Î»A, Î³ : A â†’ C Ã— F(A). Ï• â—¦ F[( Î³ )]|}m

mhisto-HISTO

=

Proof.ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

ï£®ï£°

=

{| Ï•|}

{| Î»A, Î³ : A â†’ C Ã— F(A). Ï• â—¦ F[( Î³ )]|}m

â€“ histo-CHARN â€“

{| Î»A, Î³ : A â†’ C Ã— F(A). Ï• â—¦ F[( Î³ )]|}m â—¦ in
Ï• â—¦ F[((cid:104){| Î»A, Î³ : A â†’ C Ã— F(A). Ï• â—¦ F[( Î³ )]|}m, inâˆ’1 (cid:105) )]

â€“ mhisto-SELF â€“

Every m-catamorphism can be deï¬ned as m-histomorphism, which uses only

the value on the â€œpredecessorâ€ of the current argument.

Proposition 6.12 For any F-malgebra (C, Î¦)

(cid:76) Î¦(cid:77)m = {| Î»A, Î³ : A â†’ C Ã— F(A). Î¦(fstâ—¦ Î³)|}m
{| Î»A, Î³ : A â†’ C Ã— F(A). Î¦(fstâ—¦ Î³)|}m

â€“ mcata-CHARN â€“

mhisto-MCATA

=

Proof.ï£®ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£¯ï£°

ï£®ï£¯ï£¯ï£¯ï£¯ï£°

=

=

(cid:76) Î¦(cid:77)m

â€“ mhisto-SELF â€“

{| Î»A, Î³ : A â†’ C Ã— F(A). Î¦(fstâ—¦ Î³)|}m â—¦ in
Î¦(fstâ—¦(cid:104){| Î»A, Î³ : A â†’ C Ã— F(A). Î¦(fstâ—¦ Î³)|}m, inâˆ’1 (cid:105))
Î¦{| Î»A, Î³ : A â†’ C Ã— F(A). Î¦(fstâ—¦ Î³)|}m

â€“ pairing â€“

6.4 Mendler-style recursion operators in Haskell

In Haskell, we can implement m-catamorphisms as follows:

> mcata :: (forall a. (a -> c) -> f a -> c)
>
-> Mu f -> c
> mcata phi (In x) = phi (mcata phi) x

94

The constraint for phi, that it is Mendler-style algebra, is expressed by its typing,
which requires phi to be polymorphic on a. Differently from conventional cata-
morphisms, the type for mcata does not contain the restriction for type construc-
tor f to be an instance of class Functor. This is not required, as the deï¬ning
equation (which expresses the cancellation law), does not use fmap. Note that
there was no such requirement in the deï¬nition of type Mu f either. Hence, if we
use mcata combinator instead of cata, we can deï¬ne inductive types only by
deï¬ning the corresponding type constructor, and no instance declaration for class
Functor is required.
Example 6.1 (naturals to integers)
The function nat2int, which converts naturals to corresponding integers, can be
deï¬ned as m-catamorphism:

> nat2int :: Nat -> Int
> nat2int = mcata phi
>
>

where phi n2i Z

phi n2i (S n) = 1 + n2i n

= 0

Note that n in the second equation of phi corresponds to the original predecessor,
and not to the value of the function on it (as it had been case if we had used cata).
The value on the predecessor is computed by applying to it the function provided
as the ï¬rst argument of phi. Using the suitable naming of this argument, the
deï¬nition of phi becomes very similar to the directly recursive deï¬nition for the
function nat2int.
Example 6.2 (length)
The function, which computes the length of a given list, can be deï¬ned as follows:

> lengthM :: List a -> Nat
> lengthM = mcata phi
>
where phi len N
>

phi len (C _ xs) = succN (len xs)

= zeroN

The Haskell correspondent for a F-rec-malgebra is a polymorphic function of
type (a -> (c, Mu f)) -> (f a -> c) for some ï¬xed type constructor f
and type c. However, for convenience, we use an equivalent version of it; namely,
(a -> c) -> (a -> Mu f) -> (f a -> c). Now, we can implement
m-paramorphisms, by using the accordingly modiï¬ed cancellation law, as follows:

> mpara :: (forall a. (a -> c) -> (a -> Mu f)
>
>
> mpara phi (In x) = phi (mpara phi) id x

f a -> c)
Mu f -> c

->
->

95

Example 6.3 (factorial)
The factorial function can be implemented as Mendler-style paramorphism:

> factM :: Nat -> Nat
> factM = mpara phi
>
>
>

where phi fac i Z = oneN

phi fac i (S x)

= mulN (succN (i x)) (fac x)

The ï¬rst functional argument of phi is used for computing the value on the previ-
ous argument x (like in the case of mcata combinator). However, now phi has
also the second functional argument i, which is applied to the previous argument
in places where the argument itself is needed.

Example 6.4 (dropwhile)
The function dropWhile can be implemented as follows:

where phi dropW i N

> dropWhileM :: (a -> Bool) -> List a -> List a
> dropWhileM p = mpara phi
>
>
>
>

| p x
| otherwise = consL x (dropW xs)

phi dropW i (C x xs)

= nilL

= i xs

The Haskell correspondent for a F-cv-malgebra is a polymorphic function of
type (a -> (c, f a)) -> (f a -> c) for some ï¬xed type constructor f
and type c. Again, for convenience, we use a slightly modiï¬ed, but equivalent,
version of it; namely, (a -> c) -> (a -> f a) -> (f a -> c). Now,
we can implement m-histomorphisms, by using the accordingly modiï¬ed cancel-
lation law, as follows:

> mhisto :: (forall a. (a -> c) -> (a -> f a)
f a -> c)
>
>
Mu f -> c
> mhisto phi (In x) = phi (mhisto phi) unIn x

->
->

Note, that the deï¬nition does not use any intermediate data or codata structure.
Hence, it does not memoize values on previous arguments. (However, it is possi-
ble to arrive to the memoizing version by exploiting mhisto-DEF.)

96

Example 6.5 (Fibonacci)
The Fibonacci function can be implemented as Mendler-style histomorphism:

where phi fib pre Z

=

1

phi fib pre (S x)

> fiboM :: Nat -> Int
> fiboM = mhisto phi
>
>
>
>
>

= case pre x of

-> 1

Z
S y -> fib x + fib y

The ï¬rst functional argument of phi is used for computing the value on the pre-
vious argument x (like in the case of mcata or mpara combinator). However,
now phi has also the second functional argument pre, which is applied to the
previous argument x in places where its predecessor is needed.

Example 6.6 (evens)
The function evens, which takes from the given list every second element, can
be deï¬ned as follows:

where phi eve pre N

> evensM :: List a -> List a
> evensM = mhisto phi
>
>
>
>
>

phi eve pre (C _ x)

= case pre x of

=

nilL

-> nilL

N
C a y -> consL a (eve y)

6.5 Related work

Mendler-style recursion combinators were invented in type theory by
N. P. Mendler. In [Men87] (a conference paper), he studied an extension of sys-
tem F with (co)inductive types and primitive (co)recursion; [Men91] (its journal
version) treats a simpliï¬ed calculus that only supported (co)iteration. Some im-
portant works commenting on [Men87]/[Men91] and, in particular, on the em-
beddings between simply typed lambda calculi with conventional- and Mendler-
style iterators and primitive-recursors and system F are [Lei90, Geu92, SpÅ‚93].
Mendler-style course-of-value iteration was studied by us in a type-theoretic set-
ting in [UV97, UV00b, Uus98].
In [UV00a] we also studied a Mendler-style
combinator for simultaneous iteration.

97

98

CHAPTER 7

CONCLUSIONS

In this last chapter we summarize the contribution of this thesis and outline some
possible directions for future work.

7.1 Summary

We have studied the theory of inductive and coinductive types in a categorical
framework. The goal of this thesis was to develop new recursion combinators that
capture more complex recursion patterns than simple (co)iteration but still possess
nice reasoning properties. In particular, we considered combinators for primitive
(co)recursion and course-of-value (co)iteration using two different approaches.

The ï¬rst approach was based on the treatment of inductive and coinductive
types as initial algebras and terminal coalgebras. In this setting, it is well known
that the primitive recursion can be simulated by a simple iteration which com-
putes a value paired together with the argument, and that this construction leads
to the notion of paramorphism which captures the primitive recursion directly.
We showed (in Chapter 3), that the obvious dualization of this construction leads
to notion of apomorphism which captures the recursion pattern known as prim-
itive corecursion. More importantly, we also showed (in Chapter 4) that a more
involved generic simulation of memoization by iteration leads to the notion of his-
tomorphism, a direct formalization of course-of-value iteration, and also described
the dual notion of futumorphism, a formalization of course-of-value coiteration.
The second approach, inspired by type-theoretic work by N. P. Mendler, was
here pursued for inductive types only. To recast Mendlerâ€™s work in category-
theoretic terms, we invented the concepts of malgebra and malgebra homomor-
phism and treated inductive types as initial malgebras (chapter 5). From that basis,
we then introduced Mendler-style analogs for the cata, para and histo combinators
(chapter 6). From the theory developed, it appears that Mender-style recursion

99

combinators are just as well-suited for program calculation as the conventional
ones, but support a programming style more close to customary (general-) recur-
sive programming.

7.2 Future work

Semantics of Mendler-style inductive and coinductive types. While the basic
theory of Mendler-style inductive and coinductive types has been settled, many
questions remain still unresolved. First, the precise conditions of the existence of
initial (terminal) Mendler-style (co)algebras for mixed-variant base functors and
their relationship to Freydâ€™s dialgebras [Fre90, Fre91] need further study. Also,
recently, Bird and others [BM98, BP99] have proposed a new approach for nested
data types. How this work relates to ours is currently unclear and is a very inter-
esting topic to investigate.

Modeling of interactive processes. Coalgebras and coinductive types have re-
ceived much attention recently. They facilitate elegant modeling of interactive
processes and several very important notions of object-oriented programming like
objects, classes and inheritance. Our preliminary investigations on Mendler-style
coinductive types show that at least modeling of simple processes is easily achiev-
able by them. As the next step, we plan to use Mendler-style coinductive types
to model more complex process calculi (like CSP or CCS), and, if we succeed
in this, we start to develop the speciï¬cation methodology of processes based on
these models. We also plan to provide several case studies for specifying pro-
cesses using the methodology.

Computations with side-effects and (co)inductive types. The use of monads to
represent side-effecting computations is nowadays considered standard, and for
instance in lazy functional language Haskell they are the main structuring lan-
guage construction for side-effects including input/output. The popularity of using
monads is caused by the fact that they provide a simple and effective way to handle
computations that interact purely functionally but internally use side-effects. At
the same time, the monadic approach is not without shortcomings, as the model it
provides for input/output assumes that the environment is closed (i.e. the program
is the only one which interacts with environment). Recently Kieburtz [Kie99]
proposed a conjecture that comonads (duals of monads) together with coinductive
types yield a more appropriate formalism for modeling the interaction with outer
environment. We plan to verify this conjecture, and more generally to investi-
gate the possibilities for integration of monads and comonads with Mendler-style
(co)inductive types.

100

Generic programming. Genericity and reusability are two important issues for
simplifying the design and maintenance of programs. The purpose of generic pro-
gramming [BJJM99] is to develop new methods to parameterize algorithms and
programs. For instance, while traditional polymorphism allows parameterization
with respect to types, the so-called polytypism [JJ96] allows also parameterization
also with respect to type constructors. Most of the approaches for generic pro-
gramming are using inductive and coinductive types, as they come equipped with
universal combinators representing different generic recursion schemes. Mendler-
style inductive and coinductive types have the same potential, but their real utility
in generic programming needs further investigation.

Program transformation. The genericity and reusability of programs have a
side-effect that resulting programs can be very resource-consuming. The prob-
lem can be solved by using different program transformation techniques, like
partial evaluation or deforestation. In the context of inductive and coinductive
types, the last is especially interesting, as it allows to eliminate data structures
constructed during intermediate computations, and can be made fully automatic.
Traditional deforestation is based on the unfold-fold method by Burstall and Dar-
lington [BD77], and is quite inefï¬cient as it requires keeping the full computation
history to guarantee the termination. Takano and Meijer [TM95] proposed an
alternative approach based on (co)inductive types, called â€œacid rainâ€, where in-
termediate data structures are removed using pure calculation, and keeping the
computation history is not required. We hope that this method can be generalized
for Mendler-style (co)inductive types. Also, we plan to investigate other program
transformation methods in this setting.

101

REFERENCES

[BBA00]

L. S. Barbosa, J. B. Barros, and J. J. Almeida. Polytypic recursion
patterns. To appear in Proc. SBLPâ€™00, vol. of ENTCS, May 2000.

[BD77]

[BdM97]

[Bir87]

Rod M. Burstall and John Darlington. A transformation system for
developing recursive programs. Journal of the ACM, 24(1):44â€“67,
January 1977.

Richard Bird and Oege de Moor. Algebra of Programming, volume
100 of Prentice Hall Int. Series in Computer Science. Prentice Hall,
London, 1997.

Richard S. Bird. An introduction to the theory of lists. In M. Broy,
editor, Logic of Programming and Calculi of Discrete Design, vol-
ume 36 of NATO ASI Series F, pages 3â€“42. Springer-Verlag, Berlin,
1987.

[Bir98]

Richard S. Bird.
Introduction to Functional Programming using
Haskell. Prentice Hall Int. Series in Computer Science. Prentice
Hall, London, 2nd edition, 1998.

[BJJM99] Roland Backhouse, Patrik Jansson, Johan Jeuring, and Lambert
Meertens. Generic programming â€“an introductionâ€“. In S. Doaitse
Swierstra, Pedro R. Henriques, and JosÂ´e N. Oliveira, editors, Re-
vised Lectures 3rd Int. School on Advanced Functional Program-
ming, AFPâ€™98, Braga, Portugal, 12â€“19 Sept. 1998, volume 1608 of
Lecture Notes in Computer Science, pages 28â€“115. Springer-Verlag,
Berlin, 1999.

[BM98]

Richard Bird and Lambert Meertens. Nested datatypes. In J. Jeuring,
editor, Proceedings 4th Int. Conf. on Mathematics of Program Con-
struction, MPCâ€™98, Marstrand, Sweden, 15â€“17 June 1998, volume
1422 of Lecture Notes in Computer Science, pages 52â€“67. Springer-
Verlag, Berlin, 1998.

102

[BP99]

[CF92]

[Fok92]

[Fre90]

[Fre91]

[Geu92]

[GH99]

[Gru96]

[Hag87]

Richard Bird and Ross Paterson. Generalised folds for nested
datatypes. Formal Aspects of Computing, 11(2):200â€“222, 1999.

Robin Cockett and Tom Fukushima. About Charity. Yellow Se-
ries Report 92/480/18, Dept. of Computer Science, Univ. of Calgary,
June 1992.

M. M. (Maarten) Fokkinga. Law and Order in Algorithmics. PhD
thesis, Dept. of Informatics, Univ. of Twente, 1992.

Peter J. Freyd. Recursive types reduced to inductive types. In Pro-
ceedings 5th IEEE Annual Symp. on Logic in Computer Science,
LICSâ€™90, Philadelphia, PA, USA, 4â€“7 June 1990, pages 498â€“507.
IEEE Computer Society Press, Los Alamitos, CA, 1990.

Peter J. Freyd. Algebraically complete categories. In A. Carboni,
M. C. Pedicchio, and G. Rosolini, editors, Proceedings Int. Conf.
Category Theory â€™90, CTâ€™90, Como, Italy, 22â€“28 July 1990, vol-
ume 1488 of Lecture Notes in Mathematics, pages 95â€“104. Springer-
Verlag, Berlin, 1991.

Herman Geuvers. Inductive and coinductive types with iteration and
recursion. In B. NordstrÂ¨om, K. Pettersson, and G. Plotkin, editors,
Informal Proceedings Workshop on Types for Proofs and Programs,
BËšastad, Sweden, 8â€“12 June 1992, pages 193â€“217. Dept. of Com-
puting Science, Chalmers Univ. of Technology and GÂ¨oteborg Univ.,
1992. ftp://ftp.cs.chalmers.se/pub/cs-reports/baastad.92/proc.ps.Z.

Jeremy Gibbons and Graham Hutton. Proof methods for structured
corecursive programs. In Proceedings 1st Scottish Functional Pro-
gramming Workshop, Stirling, Scotland, Aug/Sept 1999, page ???
1999.

Jim Grundy.
sentation.
http://saxon.pip.com.pl/MathUniversalis/2/.

Mathesis Universalis,

A browsable

pre-
URL

format
2,

for
1996.

proof

Tatsuya Hagino. A Categorical Programming Language. PhD thesis
CST-47-87, Laboratory for Foundations of Computer Science, Dept.
of Computer Science, Univ. of Edinburgh, September 1987.

[HITT96]

Zhenjiang Hu, Hideya Iwasaki, Masato Takeichi, and Akihiko
Takano. Tupling calculation eliminates multiple data traversals.

103

In Proceedings 2nd ACM SIGPLAN Int. Conf. on Functional Pro-
gramming, ICFPâ€™97, Amsterdam, The Netherlands, 9â€“11 June 1997,
pages 164â€“175. ACM Press, New York, 1996.

C. A. R. Hoare. Notes on data structuring. In O.-J. Dahl, E.W. Dijk-
stra, and C.A.R. Hoare, editors, Structured Programming. Academic
Press, 1972.

Brian T. Howard. Inductive, coinductive, and pointed types. In Pro-
ceedings 1st ACM SIGPLAN Int. Conf. on Functional Programming,
ICFPâ€™96, Philadelphia, PA, USA, 24â€“26 May 1996, SIGPLAN No-
tices 31(6), pages 102â€“109. ACM Press, New York, 1996.

Johan Jeuring and Patrik Jansson. Polytypic programming.
In
J. Launchbury, E. Meijer, and T. Sheard, editors, Tutorial Text 2nd
Int. School on Advanced Functional Programming, Olympia, WA,
USA, 26â€“30 Aug 1996, volume 1129 of Lecture Notes in Computer
Science, pages 68â€“114. Springer-Verlag, Berlin, 1996.

Richard Kieburtz. Codata and comonads in Haskell. Unpublished
manuscript, July 1999.

Joachim Lambek. A ï¬xpoint theorem for complete categories. Math-
ematische Zeitschrift, 103:151â€“161, 1968.

Daniel Leivant. Contracting proofs to programs.
In P. Odifreddi,
editor, Logic and Computer Science, volume 31 of APIC Studies in
Data Processing, pages 279â€“327. Academic Press, London, 1990.

Saunders Mac Lane. Categories for the Working Mathematician,
volume 5 of Graduate Texts in Mathematics.
Springer-Verlag,
Berlin, 2nd edition, 1997. (1st ed., 1971).

[Hoa72]

[How96]

[JJ96]

[Kie99]

[Lam68]

[Lei90]

[Mac97]

[Mal90a]

Grant Malcolm. Data structures and program transformation. Sci-
ence of Computer Programming, 14(2â€“3):255â€“279, 1990.

[Mal90b]

[Mat98]

Grant R. Malcolm. Algebraic Data Types and Program Transforma-
tion. PhD thesis, Dept. of Computer Science, Univ. of Groningen,
1990.

Ralph Matthes. Extensions of System F by Iteration and Primitive
Recursion on Monotone Inductive Types. PhD thesis, Fachbereich
Mathematik, Ludwig-Maximilians-UniversitÂ¨at MÂ¨unchen, 1998.

104

[Mat00]

[Mee92]

[Men87]

Ralph Matthes. Tarskiâ€™s ï¬xed-point theorem and lambda calculi with
monotone inductive types. In Benedikt LÂ¨owe and Florian Rudolph,
editors, Refereed Papers of Research Coll. on Foundations of the
Formal Sciences, Berlin, Germany, 7â€“9 May 1999, pages 91â€“112.
Kluwer Academic Publishers, Dordrecht, 2000.

Lambert Meertens. Paramorphisms. Formal Aspects of Computing,
4(5):413â€“424, 1992.

Nax Paul Mendler. Recursive types and type constraints in second-
order lambda-calculus. In Proceedings 2nd Annual IEEE Symp. on
Logic in Computer Science, LICSâ€™87, Ithaca, NY, USA, 22â€“25 June
1987, pages 30â€“36. IEEE Computer Society Press, Washington, DC,
1987.

[Men91]

Nax Paul Mendler.
Inductive types and type constraints in the
second-order lambda-calculus. Annals of Pure and Applied Logic,
51(1â€“2):159â€“172, 1991.

[Mic68]

Donald Michie. Memo functions and machine learning. Nature,
(218):19â€“22, April 1968.

[MTHM97] Robin Milner, Mads Tofte, Robert Harper, and David MacQueen.

The Deï¬nition of Standard ML (Revised). The MIT Press, 1997.

[Mul91]

[PJH99]

[SpÅ‚93]

[SU99]

Philip S. Mulry. Strong monads, algebras and ï¬xed points. In M. P.
Fourman, P. T. Johnstone, and A. M. Pitts, editors, Applications of
Categories in Computer Science: Proceedings LMS Symp., Durham,
UK, 20â€“30 July 1991, volume 177 of London Math. Society Lec-
ture Note Series, pages 202â€“216. Cambridge University Press, Cam-
bridge, 1991.

Simon Peyton Jones and John Hughes, editors.
Report on
the Programming Language Haskell98, A Non-strict Purely
Functional Language,
from
http://www.haskell.org/definition/.

Available

February

1999.

ZdzisÅ‚aw SpÅ‚awski. Proof-Theoretic Approach to Inductive Deï¬-
nitions in ML-Like Programming Languages versus Second-Order
Lambda Calculus. PhD thesis, WrocÅ‚aw Univ., 1993.

Itera-
ZdzisÅ‚aw SpÅ‚awski and PaweÅ‚ Urzyczyn. Type ï¬xpoints:
tion vs. recursion.
In Proceedings 4th ACM SIGPLAN Int. Conf.
on Functional Programming, ICFPâ€™99, Paris, France, 27â€“29 Sept
1999, pages 102â€“113. ACM Press, New York, 1999.

105

[TM95]

[Uus98]

[UV97]

[UV99a]

[UV99b]

[UV00a]

Akihiko Takano and Erik Meijer. Shortcut deforestation in calcu-
lational form. In Conf. Record 7th ACM SIGPLAN/SIGARCH Intl.
Conf. on Functional Programming Languages and Computer Archi-
tecture, FPCAâ€™95, La Jolla, San Diego, CA, USA, 25â€“28 June 1995,
pages 306â€“316. ACM Press, New York, 1995.

Tarmo Uustalu. Natural Deduction for Intuitionistic Least and
Greatest Fixedpoint Logics, with an Application to Program Con-
struction. PhD thesis (Dissertation TRITA-IT AVH 98:03), Dept. of
Teleinformatics, Royal Inst. of Technology, Stockholm, May 1998.

Tarmo Uustalu and Varmo Vene. A cube of proof systems for the in-
tuitionistic predicate Âµ, Î½-logic. In Magne Haveraaen and Olaf Owe,
editors, Selected Papers 8th Nordic Workshop on Programming The-
ory, NPWTâ€™96, Oslo, Norway, 4â€“6 Dec 1996, Research Report 248,
Dept. of Informatics, Univ. of Oslo, pages 237â€“246. May 1997.

Tarmo Uustalu and Varmo Vene. Mendler-style inductive types, cat-
egorically. Nordic Journal of Computing, 6(3):343â€“361, 1999.

Tarmo Uustalu and Varmo Vene. Primitive (co)recursion and course-
of-value (co)iteration, categorically.
INFORMATICA, 10(1):5â€“26,
1999.

Tarmo Uustalu and Varmo Vene. Coding recursion a la Mendler (ex-
tended abstract). In Johan Jeuring, editor, Proceedings 2nd Work-
shop on Generic Programming, WGPâ€™2000, Ponte de Lima, Portu-
gal, 6 July 2000, Tech. Report UU-CS-2000-19, Dept. of Computer
Science, Utrecht Univ., pages 69â€“85. June 2000.

[UV00b]

Tarmo Uustalu and Varmo Vene. Least and greatest ï¬xedpoints in
intuitionistic natural deduction. To appear in Theoretical Computer
Science, March 2000.

[Ves97]

[Vos95]

[VU98]

Peter Vesely. Typechecking the Charity term logic. Unpublished
notes, April 1997.

Tanja Vos. Program construction and generation based on recur-
sive types. MSc thesis INF/SCR-95-12, Dept. of Computer Science,
Univ. of Utrecht, March 1995.

Varmo Vene and Tarmo Uustalu. Functional programming with apo-
morphisms (corecursion). Proceedings of the Estonian Academy of
Sciences: Physics, Mathematics, 47(3):147â€“161, 1998.

106

[Wad89]

Philip Wadler. Theorems for free!
In Proceedings 4th Int. Conf.
on Funct. Prog. Languages and Computer Arch., FPCAâ€™89, London,
UK, 11â€“13 Sept 1989, pages 347â€“359. ACM Press, New York, 1989.

107

108

KATEGOORNE PROGRAMMEERIMINE
INDUKTIIVSETE JA KOINDUKTIIVSETE

T Â¨U Â¨UPIDEGA

KokkuvËœote

Algoritmika ehk programmide konstrueerimise matemaatika on teoreetilise in-
formaatika haru, mille eesmÂ¨argiks on uute matemaatiliselt pËœohjendatud tarkvara-
tehnika meetodide vÂ¨aljatÂ¨oÂ¨otamine. Seejuures kasutatav matemaatiline aparatuur
baseerub pËœohiliselt universaalalgebral ja loogikal, ning eriti just viimasel ajal
kategooriate teoorial. Algoritmika Â¨uks olulisemaid tunnuseid on, et tulempro-
grammi korrektsus spetsiï¬katsiooni suhtes garanteeritakse konstruktsiooni kÂ¨aigus
ning selle eraldi veriï¬tseerimist ei ole vaja. Eelistatakse deklaratiivseid program-
meerimisparadigmasid, iseÂ¨aranis tÂ¨uÂ¨ubitud funktsionaalseid keeli, kuna nende se-
mantiline baas on vÂ¨aga lÂ¨ahedane kasutatava matemaatilise aparatuuriga. Muuhul-
gas vËœoimaldab see nii spetsiï¬tseerimis- kui ka realiseerimisfaasis jÂ¨aÂ¨ada Â¨uhe para-
digma piiresse.

KÂ¨aesolevas doktoritÂ¨oÂ¨os on kategooriate teooria abil uuritud induktiivseid ja
koinduktiivseid andmetÂ¨uÂ¨upe ja nendega seotud rekursiooniskeeme. TÂ¨oÂ¨o kÂ¨aigus
jËœouti jÂ¨argmiste uute tulemusteni:

â€¢ Uuriti korekursiivsete funktsioonide deï¬neerimise skeemi, mille formali-
satsiooniks terminaalsete koalgebratega distributiivsetes kategooriates on
nn. apomorï¬smid (primitiivne korekursioon); sËœonastati ja tËœoestati apomor-
ï¬smide iseloomulikud omadused, vËœorreldi neid anamorï¬smidega (lihtsa ko-
iteratsiooniga); esitati lihtsaid nÂ¨aiteid koandmetÂ¨uÂ¨upidega funktsionaalpro-
grammeerimisest, kus apomorï¬smid on tululikud.

â€¢ Uuriti rekursiivsete ja korekursiivsete funktsioonide deï¬neerimise erinevaid
skeeme. NÂ¨aidati, et course-of-value-iteratiivsed funktsioonid on formali-
seeritavad initsiaalsete algebratega distributiivsetes kategooriates nn. histo-
morï¬smidena ning course-of-value-koiteratiivsed funktsioonid on duaalselt
formaliseeritavad terminaalsete koalgebratega distributiivsetes kategoori-
ates nn. futumorï¬smidena.

â€¢ Formaliseeriti nn. Mendleri-laadi induktiivsete tÂ¨uÂ¨upide kategoorne seman-
tika, tuues selleks sisse Mendleri-laadi algebrate ning nende vaheliste ho-
momorï¬smide mËœoisteid. NÂ¨aidati, et kovariantse baasfunktori korral on in-
dutseeritud Mendleri-laadi algebrate kategooria ekvivalentne sama funktori
(tavaliste) algebrate kategooriaga. Segavariantse baasfunktori jaoks nÂ¨aidati,
et kui baaskategoorias leiduvad teatud suured summad (tÂ¨apsemalt teatud

109

tensorite kolËœopud), siis saab konstrueerida uue kovariantse funktori, mille
algebrate kategooria on esialgse funktori Mendleri-laadi algebrate kategoo-
riaga ekvivalentne. Lisaks uuriti Mendleri-laadi induktiivsete tÂ¨uÂ¨upidega
seotud rekursioonioperaatorite omadusi ning nende kasutatavust program-
mide konstrueerimisel.

110

ACKNOWLEDGEMENTS

First and foremost, my greatest thanks go to Tarmo Uustalu who has been not
only a direct partner of the research reported here, but also a good friend. Our
collaboration has been great pleasure and I can only hope that it will continue.
The discussions we had in Spring 1996 during my visit to Stockholm were the
starting point of the work and is still one of the greatest experience I have had in
my academic life.

Special thanks to my supervisor Merik Meriste who is responsible for ignit-
ing my interest in programming language theory and functional languages in par-
ticular. He has always been very supportive and patient, especially at difï¬cult
moments throughout my PhD study.

I want to thank Prof. Enn TËœougu for inviting me to the Royal Institute of
Technology in Stockholm for a two two-month periods during 1996. These visits
were ï¬nanced by the Stockholm-LadugËšardslandet Club of District 2350 of Rotary
International for which I am very grateful.

I would like to thank all my friends, who often wondered whether this thesis

will ever be ï¬nished, for their support.

Last but not least, I am grateful to my mother for the support and encourage-

ment all over the years.

The work reported in this thesis was partially supported by the Estonian Sci-

ence Foundation grant no. 2976.

111

112

CURRICULUM VITAE

VARMO VENE

Citizenship: Estonian Republic.

Born: July 2, 1968, Tartu, Estonia.

Marital status: single.

Address: Anne 90-58, Tartu, EE-50705 Estonia,

phone.: +372 7 482 460,
e-mail: varmo@cs.ut.ee

Education

1986 â€“ 1992 Applied mathematics, Faculty of Mathematics, University of Tartu.

1992 â€“ 1994 MSc studies in Computer Science, Faculty of Mathematics, Univer-

sity of Tartu.

1996 â€“ 2000 PhD studies in Computer Science, Faculty of Mathematics, Univer-

sity of Tartu.

Professional employment

1994 â€“ 2000 Researcher, Institute of Computer Science, University of Tartu.

1998 â€“

2000 â€“

Researcher, Institute of Cybernetics, Tallinn Technical University.

Lecturer, Institute of Computer Science, University of Tartu.

113

CURRICULUM VITAE

VARMO VENE

Kodakondsus: Eesti Vabariik.

SÂ¨unniaeg ja -koht: 2. juuli, 1968, Tartu, Eesti.

Perekonnaseis: vallaline.

Aadress: Anne 90-58, Tartu, EE-50705 Eesti,

tel.: +372 7 482 460,
e-post: varmo@cs.ut.ee

Haridus

1986 â€“ 1992 Tartu Â¨Ulikool, matemaatikateaduskond, rakendusmatemaatika eri-

ala.

1992 â€“ 1994 Tartu Â¨Ulikool, matemaatikateaduskond, informaatika magistratuur.

1996 â€“ 2000 Tartu Â¨Ulikool, matemaatikateaduskond, informaatika doktorantuur.

Erialane teenistuskÂ¨aik

1994 â€“ 2000 Tartu Â¨Ulikool, Arvutiteaduse Instituut, teadur.

1998 â€“

2000 â€“

Tallinna TehnikaÂ¨ulikool, KÂ¨uberneetika Instituut, teadur (0.3 kohta).

Tartu Â¨Ulikool, Arvutiteaduse Instituut, lektor.

114

DISSERTATIONES MATHEMATICAE

UNIVERSITATIS TARTUENSIS

1. Mati Heinloo. The design of nonhomogeneous spherical vessels, cylindri-

cal tubes and circular discs. Tartu, 1991. 23 p.

2. Boris Komrakov. Primitive actions and the Sophus Lie problem. Tartu,

1991. 14 p.

3. Jaak Heinloo. Phenomenological (continuum) theory of turbulence. Tartu,

1992. 47 p.

4. Ants Tauts. Inï¬nite formulae in intuitionistic logic of higher order. Tartu,

1992. 15 p.

5. Tarmo Soomere. Kinetic theory of Rossby waves. Tartu, 1992. 32 p.
6. JÂ¨uri Majak. Optimization of plastic axisymmetric plates and shells in the

case of Von Mises yield condition. Tartu, 1992. 32 p.

7. Ants Aasma. Matrix transformations of summability and absolute summa-

bility ï¬elds of matrix methods. Tartu, 1993. 32 p.

8. Helle Hein. Optimization of plastic axisymmetric plates and shells with

piece-wise constant thickness. Tartu, 1993. 28 p.

9. Toomas Kiho. Study of optimality of iterated Lavrentiev method and its

generalizations. Tartu, 1994. 23 p.

10. Arne Kokk. Joint spectral theory and extension of non-trivial multiplica-

tive linear functionals. Tartu, 1995. 165 p.

11. Toomas Lepikult. Automated calculation of dynamically loaded rigidplas-

tic structures. Tartu, 1995. 93 p. (in russian)

12. Sander Hannus. Parametrical optimization of the plastic cylindrical shells
by taking into account geometrical and physical nonlinearities. Tartu,
1995. 74 p. (in russian)

13. Sergrei Tupailo. Hilbertâ€™s epsilon-symbol in predicative subsystems of

analysis. Tartu, 1996. 134 p.

14. Enno Saks. Analysis and optimization of elastic-plastic shafts in torsion.

Tartu, 1996. 96 p.

15. Valdis Laan. Pullbacks and ï¬‚atness properties of acts. Tartu, 1999. 90 p.
16. MÂ¨art PËœoldvere. Subspaces of Banach spaces having Phelpsâ€™ uniqueness

property. Tartu, 1999. 74 p.

17. Jelena Ausekle. Compactness of operators in Lorentz and Orlicz sequence

spaces. Tartu, 1999. 72 p.

115

18. Krista Fischer. Structural mean models for analyzing the effects of com-

pliance in clinical trials. Tartu, 1999. 125 p.

19. Helger Lipmaa. Secure and efï¬cent time-stamping systems. Tartu, 1999.

56 p.

20. JÂ¨uri Lember. Consistency of empirical k-centres. Tartu, 1999. 148 p.
21. Ella Puman. Optimization of plastic conical shells. Tartu, 2000. 102 p.
22. Kaili MÂ¨uÂ¨urisep. Eesti keele arvutigrammatika: sÂ¨untaks. Tartu, 2000.

109 lk.

116

