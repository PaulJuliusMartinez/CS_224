Reinforcement Learning for Humanoid Robotics

Jan Peters, Sethu Vijayakumar, Stefan Schaal

Computational Learning and Motor Control Laboratory

Computer Science & Neuroscience, University of Southern California

3461 Watt Way – HNB 103, Los Angeles, CA 90089-2520, USA

&

ATR Computational Neuroscience Laboratories

2-2 Hikaridai, Seika-cho, Soraku-gun, Kyoto 619-0288, Japan

http://www-clmc.usc.edu

{jrpeters,sethu,sschaal}@usc.edu

Abstract. Reinforcement learning oﬀers one of the most general frame-
work to take traditional robotics towards true autonomy and versatility.
However, applying reinforcement learning to high dimensional movement
systems like humanoid robots remains an unsolved problem. In this pa-
per, we discuss diﬀerent approaches of reinforcement learning in terms of
their applicability in humanoid robotics. Methods can be coarsely clas-
siﬁed into three diﬀerent categories, i.e., greedy methods, ‘vanilla’ policy
gradient methods, and natural gradient methods. We discuss that greedy
methods are not likely to scale into the domain humanoid robotics as
they are problematic when used with function approximation. ‘Vanilla’
policy gradient methods on the other hand have been successfully ap-
plied on real-world robots including at least one humanoid robot [3].
We demonstrate that these methods can be signiﬁcantly improved us-
ing the natural policy gradient instead of the regular policy gradient. A
derivation of the natural policy gradient is provided, proving that the av-
erage policy gradient of Kakade [10] is indeed the true natural gradient.
A general algorithm for estimating the natural gradient, the Natural
Actor-Critic algorithm, is introduced. This algorithm converges to the
nearest local minimum of the cost function with respect to the Fisher in-
formation metric under suitable conditions. The algorithm outperforms
non-natural policy gradients by far in a cart-pole balancing evaluation,
and for learning nonlinear dynamic motor primitives for humanoid robot
control. It oﬀers a promising route for the development of reinforcement
learning for truly high-dimensionally continuous state-action systems.

1

Introduction

In spite of tremendous leaps in computing power as well as major advances
in the development of materials, motors, power supplies and sensors, we still
lack the ability to create a humanoid robotic system that even comes close to
a similar level of robustness, versatility and adaptability as biological systems.
Classical robotics and also the more recent wave of humanoid and toy robots
still rely heavily on teleoperation or ﬁxed “pre-canned” behavior based control

Peters J, Vijayakumar S, Schaal S (2003) Reinforcement learning forhumanoid robotics. In: Humanoids2003, Third IEEE-RAS InternationalConference on Humanoid Robots, Karlsruhe, Germany, Sept.29-302

with very little autonomous ability to react to the environment. Among the key
missing elements is the ability to create control systems that can deal with a
large movement repertoire, variable speeds, constraints and most importantly,
uncertainty in the real-world environment in a fast, reactive manner.

One approach of departing from teleoperation and manual ‘hard coding’ of
behaviors is by learning from experience and creating appropriate adaptive con-
trol systems. A rather general approach to learning control is the framework
of ‘reinforcement learning’. Reinforcement learning typically requires an unam-
biguous representation of states and actions and the existence of a scalar reward
function. For a given state, the most traditional of these implementations would
take an action, observe a reward, update the value function, and select as the
new control output the action with the highest expected value in each state
(for a greedy policy evaluation). Updating of value function and controls is re-
peated until convergence of the value function and/or the policy. This procedure
is usually summarized under “value update – policy improvement” iterations.

The reinforcement learning paradigm described above has been successfully
implemented for many well-deﬁned, low dimensional and discrete problems [14]
and has also yielded a variety of impressive applications in rather complex do-
mains in the last decade. These applications range from backgammon playing
on grandmaster level to robotic toy applications such as cart-pole or acrobot
swing-ups. However, various pitfalls have been encountered when trying to scale
up these methods to high dimensional, continuous control problems, as typically
faced in the domain of humanoid robotics. The goal of this paper is to discuss the
state-of-the-art in reinforcement learning and investigate how it may be possible
to make reinforcement learning useful for humanoid robotics. Initially, in Sec-
tion 2.2, we will focus on traditional value function based approaches and policy
gradient methods and discuss their shortcomings in the context of humanoid
control. In Section 2.2, we will motivate and formulate a novel policy gradient
based reinforcement learning method, the natural policy gradient, and in Section
3 derive an eﬃcient Natural Actor-Critic algorithm that can address various of
the current shortcomings of reinforcement learning for humanoid robotics. This
algorithm seems to be a promising candidate for reinforcement learning to be-
come applicable in for complex movement systems like humanoids.

2 Reinforcement Learning Approaches for Humanoid

Robotics

Humanoid Robots and, in general, high dimensional movement systems have
additional demands and requirements as compared to the conventional control
problems in which reinforcement learning approaches have been tried. From a
purely algorithmic perspective, the learning method has to make eﬃcient use of
data, scale to high dimensional state and action spaces and be computationally
cheap in order to work online. In addition, methods have to work in continuous
state and action space and also be easily parametrized through function approx-
imation techniques [20, 21]. The aim of our research is to make progress towards

3

fulﬁlling all of the above mentioned requirements and evaluate reinforcement
learning methods according to which are the most promising for robotics.

2.1 Policy Evaluation

As mentioned in the introduction, most reinforcement learning methods can be
described in terms of two steps: the policy evaluation and the policy improvement
step – we will later discuss a few exceptions, such as direct policy learning,
which can be seen as special cases of this iterative loop. In policy evaluation, the
prospect of a motor command u ∈ U for a given state x ∈ X is evaluated. This
step is usually performed by computing the action-value function:

Qπ (x, u) = E(cid:40) ∞(cid:88)t=0

γtrt(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

x0 = x, u0 = u(cid:41)

(1)

where the superscript π denotes the current (ﬁxed) policy from which actions are
determined in each state, most generally formulated as a conditional probability
p(u|x) = π(u|x), and γ is a discount factor (with γ in [0, 1]) that models the
reduced trust in the reward rt with increasing value of the discrete time t, i.e.,
the further a reward lies in the future. Alternatively, by averaging over all actions
in each state, the value function can be formulated solely as a function of state
as:

V π(x) = E(cid:40) ∞(cid:88)t=0

x0 = x(cid:41) .

γtrt(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

As both motor commands and states are very high-dimensional in complex move-
ment systems, ﬁnding the value function for a given policy is a non-trivial prob-
lem. As discussed in [14], Monte Carlo methods, i.e., methods which evaluate
the expectation operator above directly by averaging over multiple trajectory
rollouts, are usually too ineﬃcient, even for smaller problems, while dynamic
programming solution methods, based on solving the Bellman equations

Qπ (x, u) = r (x, u) + γ(cid:90)X
V π(x) =(cid:90)U

π(u|x)Qπ (x, u) du,

p(x(cid:48)|x, u)V π(x(cid:48))dx(cid:48),

(2)

(3)

(4)

can only be computed numerically or analytically in few restricted cases (e.g.,
discrete state-action spaces of low dimensionality or linear quadratic regulator
problems). In between Monte Carlo methods and dynamic programming lies a
third approach to policy evaluation, temporal diﬀerence learning (TD). In this
approach, the rewards and the Bellman equation are used to obtain the temporal
error in the value function which can be expressed by

δπ (xt, ut) = Eut+1 {r (xt, ut) + γQπ(xt+1, ut+1) − Qπ(xt, ut)},

= r (xt, ut) + γV π(xt+1) − Qπ(xt, ut),

(5)
(6)

4

which can serve as an update for Qπ (xt, ut), and V π(xt). Learning algorithms
using this temporal diﬀerence error have been shown to be rather eﬃcient [14].
The convergence with probability one can be proven for several algorithms such
as TD(λ) in the discrete state-action case [14], and LSTD(λ), a method that
approximates the value function with a function approximator that is linear in
its parameters [12]. Furthermore, Benbrahim and Franklin showed the potential
of these methods to scale into the domain of humanoid robotics [3].

2.2 Policy Improvement

Knowing the approximate value of each motor command u in each state x for
a given policy from the rather well-developed recipes for policy evaluation in
the previous section leads to the question of how a policy can be optimized
– a step known as policy improvement. In the following, we will discuss which
policy improvement method exist and how they scale, particularly in the context
of humanoid robotics. For this purpose, we classify methods into greedy policy
improvements [14], the ‘vanilla’ policy gradient approach [1, 23, 13, 24, 21, 22],
and the natural policy gradient approach [10].

Greedy Policy Improvement. One of the early and most famous solutions to
policy improvement originated in the 1960s due to Richard Bellman, who intro-
duced the policy iteration framework [2]. Here, ﬁrst a value function Qπi(x, u)
of policy πi is computed, and subsequently, an improved policy is derived by al-
ways taking the best motor command u∗ for each state using the value function
of the last policy, i.e., Qπi(x, u). For a deterministic policy, this greedy update
can be formalized as:

πi+1(x, u) =(cid:26) 1 if u = u∗ = argmax ˜u Qπi(x, ˜u),

0 if otherwise.

(7)

In many cases, an -greedy policy is used which introduces a certain amount of
random exploration, thus making the policy stochastic. The greedy action u∗
is now taken with probability  ∈ [0, 1], while all other actions can be drawn
from the remaining probability of 1 −  uniformly distributed over all other
actions. Algorithms which use data generated by either the current policy (i.e.,
on-policy methods) and/or diﬀerent policies (i.e., oﬀ-policy) have been presented
in the literature. When applied to discrete state-action domains (e.g., with a
look-up table representation), and assuming that the value function has been
approximated with perfect accuracy, a policy improvement can be guaranteed
and the policy will converge to the optimal policy within a ﬁnite amount of
policy evaluation – policy improvement steps.

While this approach has been rather successful in discrete problem domains,
it comes with a major drawback in continuous domains or in usage with pa-
rameterized (or function approximation based) policy representations: in these
cases the greedy ”max” operator in (7) can destabilize the policy evaluation and

5

improvement iterations. A small change or error in the value function approx-
imation can translate into a large, discontinuous change in the policy without
guarantee of a policy improvement1. This large change will in turn result in a
large change in the value function estimate [19], often resulting in destabilizing
dynamics. For these reasons, the traditional greedy policy improvement based
approaches seem to be less likely to scale for continuous and high dimensional
domains [1].

‘Vanilla’ Policy Gradients Improvements. In light of the problems that
can be encountered by greedy policy improvement, policy gradient methods with
small incremental steps in the change of the policy are an attractive alternative.
Policy gradient methods diﬀer from greedy methods in several respects. Policies
are usually parameterized with a small number of meaningful parameters θ –
such policies can be conceived of as motor primitives or nonlinear controllers
in humanoid robotics. The optimized objective function is usually more com-
pact, i.e., instead of having a function of state and action, only a single average
expected return J(θ) is employed as an objective function:

J(θ) =(cid:90)X

dπ(x)(cid:90)U

π(u|x)r(x, u)dudx,

(8)

where r(x, u) denotes the reward, and dπ(x) = (1 − γ)(cid:80)∞

i=0 γi Pr{xi = x} de-
notes the discounted state distribution which becomes a stationary distribution
for γ → 1 – the discounted state distribution depends on the start state dis-
tribution, while the stationary distribution does not. The most straightforward
approach of policy improvement is to follow the gradient in policy parameter
space using steepest gradient ascent, i.e.,

θi+1 = θi + α∇θJ(θi).

(9)

The central problem is to estimate the policy gradient ∇θJ(θ). Early meth-
ods like (nonepisodic) REINFORCE [26] focused on optimizing the immediate
reward by approximating the gradient as

∇θJ(θ) ≈(cid:90)X

dπ(x)(cid:90)U

∇θπ(u|x)r(x, u)dudx,

(10)

thus neglecting temporal credit assignment problems for future rewards by as-
suming ∇θdπ(x) ≈ 0. An alternative version, episodic REINFORCE, addressed
the temporal credit assignment problem by performing roll-outs and taking into
account only the ﬁnal reward [26]. These methods were extended by Gullapalli

1 In fact, the greedy improvement can make the policy worse. The only existing guar-
antee is that if the value function approximation has a maximal error ε, then the true
value function of the new policy will fulﬁll V πi+1 (x) ≥ V πi (x) − 2γε/(1 − γ) after a
greedy update for all statesm, indicating that the greedy step is not necessarily an
improvement unless the maximal error ε is zero.

6

[13] who used the temporal diﬀerence error from an additionally estimated value
function as reward signal for computing the policy gradient:

∇θJ(θ) =(cid:90)X

dπ(x)(cid:90)U

∇θπ(u|x)δπ(x, u)dudx.

(11)

In view of the recent results on the policy gradient theory, the above approach
can indeed be shown to be the true gradient ∇θJ(θ) (cf. eq. (12) below).

The early work in policy gradients in the late 1980s and beginning 1990s is
somehow surprising from the view of robotics. While lacking a complete mathe-
matical development, researchers achieved impressive robotic applications using
policy gradients. Gullapalli demonstrated that policy gradient methods can be
used to learn ﬁne manipulation control as it was required for performing the
classical ‘peg in a hole’ task [13]; Benbrahim and Franklin showed that policy
gradient methods can be used for learning biped walking with integrated trajec-
tory generation and execution [3], and Ilg showed similar results for the related
quadruped walking [15]. These early methods have yielded not only some of
the most signiﬁcant applications of reinforcement learning in robotics, but also
probably the ﬁrst using a real humanoid robot [3].

Since one of the major problems of greedy policy improvements arose from
value function estimation and its use in policy updates, several researchers
started estimating policy gradients using Monte Carlo roll-outs [23]. While these
methods avoid problems of learning a value function, they have an increased
variance in their gradient estimates as detailed in the work by Baxter et al. [23]
2. Other researchers extended the work of Gullapalli [1, 23, 22, 24, 20, 21] leading
to a hallmark in the policy gradient theory, the policy gradient theorem. This
theorem proves that the true policy gradient can generally be estimated by

∇J(θ) =(cid:90)X

dπ(x)(cid:90)U

∇θπ(u|x) (Qπ(x, u) − bπ(x)) dudx,

(12)

where bπ(x) denotes an arbitrary function of x, often called a baseline. While
in theory the baseline bπ(x) is irrelevant as it does not introduce bias into the
gradient estimate, it plays an important role in the derivation of algorithms as
it can be used to minimize the estimate’s variance.

A signiﬁcant advance of policy gradient theory was introduced in [20], and
independently in [21]. These authors demonstrated that in eq.(12), the action
value function Qπ(x, u) can be replaced by an approximation f π
w(x, u), param-
eterized by the vector w, without aﬀecting the unbiasedness of the gradient es-
timate. Such unbiasedness, however, requires a special, linear parameterization
of f π

w(x, u) in terms of

f π
w(x, u) = ∇θ log π(u|x)T w

(13)

2 In [23], a discrete Markov decision problem with three states and two actions with
a discount factor of 0.95 required approximately 1000 samples in order to obtain a
policy gradient estimate which had an angle with less than 45 degrees oﬀ the true
gradient. For comparison: Gullapalli’s estimator would have achieved this result in
less than 20 samples.

7

This result is among the ﬁrst that demonstrated how function approximation
can be used safely in reinforcement learning, i.e., without the danger of di-
vergence during learning, constituting an important step forward in order to
scale up reinforcement learning to domains like humanoid robotics. Interest-
ingly, this appealing progress comes at a price: since it is rather easy to verify
∇θπ(u|x)du = 0, it becomes obvious that this so called “compatible function
approximator” in eq.(13) can only approximate an advantage function, i.e., the
advantage of every action over the average performance in a state x:

(cid:82)U

A(x, u) = Qπ(x, u) − V π(x).

(14)

Importantly, the advantage function cannot be learned without knowledge of
the value function and hence, a TD-like bootstrapping using exclusively the
compatible function approximator is impossible – the essence of TD (and the
Bellman equation in general) is to compare the value V π(x) of two adjacent
states, but his value has been subtracted in eq.(14). When re-evaluating Eq. (5)
using the compatible function approximation as value function, the temporal
diﬀerence error would become

δπ (xt, ut) = Eut+1 {r (xt, ut) + γf π
w(xt, ut).

= r (xt, ut) − f π

w(xt+1, ut+1) − f π

w(xt, ut)},

(15)
(16)

This equation implies that the compatible function approximation would only
learn the immidiate reward, i.e., f π
w(xt, ut) = r (xt, ut). TD(λ) methods for
learning f π
w(xt, ut) as used in regular TD learning (as suggested by Konda &
Tsitsiklis [21]), can therefore be shown to bebiased for λ < 1 as they do not
address the temporal credit assignment problem appropriately.

Based on eqs.(12) and (13), a low variance estimate of the policy gradient

can be derived by estimating w and an additional matrix F (θ):

∇θJ(θ) = F (θ)w

(17)

where

F (θ) =(cid:90)X

dπ(x)(cid:90)U

π(u|x)∇θ log π(u|x)∇θ log π(u|x)T dudx.

(18)

As this method integrates over all actions – thus also called an ‘all-action’ algo-
rithm – it does not require baselines [19] anymore. Furthermore, the all-action

matrix F (θ) =(cid:82)X dπ(x)F (θ, x)dx is easier to approximate since

π(u|x)∇θ log π(u|x)∇θ log π(u|x)T du

F (θ, x) =(cid:90)U

can often even be evaluated analytically or, at least, without performing all
actions since π(u|x) is a known function. This algorithm has ﬁrst been suggested
in [19], and appears to perform well in practice. However, it should be noted that
when dealing with problems in high dimensional state spaces X, we still require
expensive roll-outs for estimating F (θ), which can become a severe bottleneck
for applications on actual physical systems.

(19)

8

Fig. 1. When plotting the expected return landscape, the diﬀerences between ‘vanilla’
and natural policy gradients become apparent for simple examples (a-b). ‘Vanilla’ pol-
icy gradients (c) point onto a plateau at θ2 = 0, while natural policy gradients direct
to the optimal solution (d). The gradients are normalized for improved visability.

Natural Policy Gradient Improvement. In supervised learning, a variety
of signiﬁcantly faster second order gradient optimization methods have been
suggested. Among others, these algorithms include well-established algorithms
such as Conjugate Gradient, Levenberg-Marquard, and Natural Gradients. It
turns out that the latter has an interesting application to reinforcement learning,
similar to natural gradient methods for supervised learning originally suggested

by Amari [27]. If an objective function L(θ) =(cid:82)X p(x)l(x, θ)dx and its gradient

∇θL(θ) are given, the steepest ascent in a Riemannian space with respect to
the Fisher information metric G(θ) does not point along ∇θL(θ) but along

The metric G(θ) is deﬁned as

(cid:101)∇θL(θ) = G−1(θ)∇θL(θ).

G(θ) =(cid:90)X

p(x)∇θ log p(x)∇θ log p(x)T dx.

(20)

(21)

It is guaranteed that the angle between natural and ordinary gradient is never
larger than ninety degrees, i.e., convergence to a local optimum is guaranteed.
This result has surprising implications for policy gradients, when examining the
meaning of the matrix F (θ) in eq.(18). Kakade [10] argued that F (θ, x) is the
point Fisher information matrix for state x, and that F (θ), therefore, denotes
the ‘average Fisher information matrix’. However, going one step further, we can
show here that F (θ) is indeed the true Fisher information matrix and does not
have to be interpreted as the ‘average’ of the point Fisher information matrices.
The proof of this key result is given in Section 3.1. This result does in fact
imply that for reinforcement learning, the natural gradient (c.f. eq.(17 )) can be
computed as

since F (θ) = G(θ) based on the proof outlined in Section 3.1. An illustrative
example comparing regular and natural policy gradients is given in Figure 1.

(cid:101)∇θJ(θ) = G−1(θ)F (θ)w = w,

(22)

9

The signiﬁcance of this result can be appreciated by considering a control
problem in the domain of humanoid robotics. For a robot with 30 degrees of
freedom (DOF), at least 60 dimensional state vectors and 30 dimensional action
vectors need to be considered (assuming rigid body dynamics). An update of
the symmetric ’All-Action Matrix’ F (θ) would involve estimation of at least
4140 open parameters for gradient updates, which can be quite costly in the
context of Monte-Carlo roll-outs. Since normally, signiﬁcantly more data are
required in order to obtain a good estimate of F (θ) than for a good estimate
of w, it makes a compelling case for avoiding estimation of the former. The
theory of natural policy gradients and the result of eq.(22) allow us to get a
better(natural) gradient estimate at lower cost. In the next section, we present
an algorithm which is capable of exploiting this result and of estimating the
natural gradient online.

3 Natural Actor-Critic

In this section, we present a novel reinforcement learning algorithm, the Natural
Actor-Critic algorithm, which exploits the natural gradient formulation from
the previous section. As the equivalence of the All-Action matrix and the Fisher
information matrix has not been presented in the literature so far, we ﬁrst provide
an outline this proof. Then we derive the Natural Actor-Critic Algorithm for the
general case, and as an empirical evaluation, we apply it to the classical ‘cart-
pole’ problem, illustrating that this approach has the potential to scale well to
continuous, high dimensional domains. For an application to humanoid robotics,
we show that a special version of Natural Actor-Critic for episodic tasks can be
applied for eﬃciently optimizing nonlinear motor primitives.

3.1 Proof of the Equivalence of Fisher Information Matric and

All-Action Matrix

In Section 22, we explained that the all-action matrix F (θ) equals in general the
Fisher information matrix G(θ). As this result has not been presented yet, we
outline the proof in following paragraphs. In [25], we can ﬁnd the well-known

lemma that by diﬀerentiating(cid:82)Rn p(x)dx = 1 twice with respect to the param-

eters θ, we can obtain

p(x)∇θ log p(x)∇θ log p(x)T dx

(23)

(cid:90)Rn

p(x)∇2

θ log p(x)dx = −(cid:90)Rn

for any probability density function p(x). Furthermore, we can rewrite the prob-
ability p(τ 0:n) of a rollout or trajectory τ 0:n = [x0, u0, r0, x1, u1, r1, . . ., xn,
un, rn, xn+1]T as

p (xt+1 |xt, ut ) π (ut |xt ) ,

(24)

=⇒ ∇2

θ log p (τ 0:n) =

∇2

θ log π (ut |xt ) .

n(cid:88)t=0

10

p (τ 0:n) = p (x0)

n(cid:89)t=0

Using Equations (23, 24), and the deﬁnition of the Fisher information matrix
[27], we can determine the Fisher information matrix for the average reward case
in sample notation, i.e,

(25)

G(θ) = lim
n→∞

1
n

1
n
1
n

θ log p(τ 0:n)(cid:9) ,
θ log π (ut |xt )(cid:41) ,

Eτ 0:n(cid:8)∇θ log p(τ 0:n)∇θ log p(τ 0:n)T(cid:9) ,
Eτ 0:n(cid:8)∇2
Eτ 0:n(cid:40) n(cid:88)t=0
dπ(x)(cid:90)U
dπ(x)(cid:90)U

θ log π(u|x)dudx,

π(u|x)∇2

∇2

= − lim
n→∞

= − lim
n→∞

= −(cid:90)X
=(cid:90)X

= F (θ)

π(u|x)∇θ log π(u|x)∇θ log π(u|x)T dudx,

This development proves that the all-action matrix is indeed the Fisher informa-
tion matrix for the average reward case. For the discounted case, with a discount
factor γ, we realize that we can rewrite the problem where the probability of
i=0 γiIxi,ui). It is straightforward to
show that ∇2
θ log pγ(τ 0:n). This rewritten probability allows us
to repeat the transformations in Equation 25, and show that again the all-action
matrix equals the Fisher information matrix by

a rollout is given by pγ(τ 0:n) = p(τ 0:n)((cid:80)n

θ log p (τ 0:n) = ∇2

(26)

∇2

= − lim
n→∞

= − lim
n→∞

G(θ) = lim
n→∞

θ log p(τ 0:n)(cid:9) ,
θ log π (ut |xt )(cid:41) ,

(1 − γ)Eτ 0:n(cid:8)∇θ log pγ(τ 0:n)∇θ log pγ(τ 0:n)T(cid:9) ,
(1 − γ)Eτ 0:n(cid:8)∇2
(1 − γ)Eτ 0:n(cid:40) n(cid:88)t=0
γ (x)(cid:90)U
γ (x)(cid:90)U
γ (x) = (1 − γ)(cid:80)∞

= −(cid:90)X
=(cid:90)X

π(u|x)∇θ log π(u|x)∇θ log π(u|x)T dudx,

θ log π(u|x)dudx,

π(u|x)∇2

= F (θ),

dπ

dπ

t=0 γt Pr{xt = x}. Therefore, we can conclude that for
with dπ
both the average reward and the discounted case, the Fisher information and
all-action matrix are the same, i.e., G(θ) = F (θ).

11

3.2 Derivation of the Natural Actor-Critic Algorithm

The algorithm suggested in this section relies on several observation described in
this paper. First, we discussed that policy gradient methods are a rather promis-
ing Reinforcement Learning technique in terms of scaling to high dimensional
continuous control systems. Second, we derived that natural policy gradients are
easier to estimate than regular gradients, which should lead to faster converge
to the nearest local minima in the with respect to the Fisher information met-
ric, such that natural gradients are in general more eﬃcient. Third, Nedic and
Bertsekas[12] provided another important ingredient to our algorithm, showing
that a least-squares policy evaluation method, LSTD(λ), converges with proba-
bility one for function approximation (although it can diﬀer from a supervised
Monte-Carlo solution λ < 1 due to a remaining function approximation error
[30]). Based on these observations, we will develop an algorithm which exploits
the merits of all these techniques.

By rewriting the Bellman equation (c.f. eq.(3)) using the compatible function

approximation (c.f. eq.(14))3 we arrive at

Qπ(x, u) = Aπ(x, u) + V π(x) = r (x, u) + γ(cid:82)Xp(x(cid:48)|x, u)V π(x(cid:48))dx(cid:48).

Inserting Aπ(x, u) = f π
w(x, u) and an appropriate basis functions representation
of the value function as V π(x) = φ(x)T v, we can rewrite the Bellman Equation,
Eq., (27), as a set of linear equations

(27)

∇θ log π(ut|xt)T w + φ(xt)T v =(cid:10)r(xt, ut) + γφ(xt+1)T v(cid:11) .

Using this set of simultaneous linear equations, a solution to Equation (27) can
be obtained by adapting the LSTD(λ) policy evaluation algorithm [5, 7, 12]. For
this purpose, we deﬁne

(28)

(cid:98)φt = [φ(xt)T , ∇θ log π(ut|xt)T ]T , (cid:101)φt = [φ(xt+1)T , 0T ]T ,

as new basis functions, where 0 is the zero vector. This deﬁnition of basis function
is beneﬁcial for a low variance of the value function estimate as the basis functions

(29)

(cid:101)φt do not depend on future actions ut+1 – i.e., the input variables to the LSTD

regression are not noisy due to ut+1; such input noise would violate the standard
regression model that only takes noise in the regression targets into account.
LSTD(λ) with the basis functions in Eq.(29), called LSTD-Q(λ) from now on,
is thus currently the theoretically cleanest way of applying LSTD to state-value
function estimation. It is exact for deterministic or weekly noisy state transitions
and arbitrary stochastic policies, and, as all previous LSTD suggestions, it loses

accuracy with increasing noise in the state transitions since(cid:101)φt becomes a random

variable. The complete LSTD-Q(λ) algorithm is given in the Critic Evaluation
(lines 4.1-4.3) of Table 1.

3 Baird[28] introduced a similar Bellman equation for a greedy algorithm ‘Advantage

Updating’.

12

Table 1. Natural Actor-Critic Algorithm with LSTD-Q(λ) for inﬁnite horizon tasks

Input: Parameterized policy π(u|x) = p(u|x, θ) with initial parameters θ = θ 0,

its derivative ∇θlogπ(u|x)and basis functions φ(x)for state value
function parameterization V π(x).

1: Draw initial state x0 ∼ p(x0), and select parameters At+1 = 0, bt+1 = zt+1 = 0.
2: For t = 0, 1, 2, . . . do
3: Execute: Draw action ut ∼ π(ut|xt), observe next state xt+1∼ p(xt+1|xt, ut),

and reward rt= r(xt, ut).

4: Critic Evaluation (LSTD-Q): Determine state-value function

V π(xt) = φ(xt)T vt and the compatible advantage function approximation
f π
w(xt, ut) = ∇

θ log π(ut|xt)T wt.

4.1: Update basis functions:

T

4.2: Update suﬃcient statistics:

T

; bφt = [φ(xt)T , ∇θ log π(ut|xt)T ]

eφt = [φ(xt+1)T , 0T ]
zt+1 = λzt+bφt; At+1 = At + zt+1(bφt − γeφt)T ; bt+1 = bt + zt+1rt,
[vT

,

4.3: Update critic parameters:
t+1bt+1.

t+1]T = A−1

t+1, wT

5: Actor-Update: When the natural gradient is converged over a window h,

i.e., ∀τ ∈ [0, ..., h] : (cid:93)(wt+1, wt−τ ) ≤ , update the
parameterized policy π(ut|xt) = p(ut|xt, θt+1):

5.1: policy parameters:

5.2:

θt+1 = θt + αwt+1,
forget some of suﬃcient statistics with β ∈ [0, 1]:
zt+1 ← βzt+1, At+1 ← βAt+1, bt+1 ← βbt+1.

6: end.

Once LSTD-Q(λ) converges to an approximation of Aπ(xt, ut) + V π(xt)
(which it does with probability 1 as shown in [12]), we obtain two results: the
value function parameters v, and the natural gradient w. The natural gradient
w serves in updating the policy parameters ∆θt = αwt. After this update, the
critic has to forget at least parts of its accumulated suﬃcient statistics using
a forgetting factor β ∈ [0, 1] (cf. Table 1). For β = 0, i.e., complete resetting,
and appropriate basis functions φ(x), convergence to the true natural gradient
can be guaranteed. The complete Natural Actor Critic algorithm is shown in
Table 1.

This algorithm has rather strong guarantees. The usage of LSTD(λ) for ob-
taining the natural gradient simultaneously with policy evaluation ensures that
the algorithm converges to a natural policy gradient estimate before a policy
update step (Step 3) is performed. If appropriate basis functions are chosen,
LSTD(λ) can be shown to converge with probability one [12]; however, the gra-
dient can diﬀer from the supervised solution for λ < 1 as pointed out in [30],
implying that the manifold on which the gradient descent is being performed dif-

13

fers depending λ). Following the natural gradient guarantees to reach the closest
local minimum w.r.t. to the criterion in Eq.(8) [27].

Nevertheless, there are some critical design issues which inﬂuence the perfor-
mance of this algorithm. First, a suﬃciently good set of basis functions φ(x) has
to be chosen to represent the value function. Second, two open parameters, i.e.,
the eligibility rate λ, and the learning rate α, have to be determined. We have
considered a stochastic policy in all our examples. As the exploration parameter
σ approaches 0, i.e. the policy becomes more deterministic, it becomes harder
to ensure that At+1 remains invertible. Hence, strongly deteministic policies are
complicated to handle. Another issue concerns that the gradient estimate as well
as the value function estimate are reset after every gradient update. In future
work, we hope to use the estimate of the previous gradients to initialize our sub-
sequent rollouts using the results given in [12] – basically, by using LSTD-like
algorithms which can incorporate an initial guess for the parameters and still be
unbiased.

4 Empirical Evalutations

4.1 Example I: Controlling an Unstable Plant

One of the most well-known benchmarks in reinforcement learning is ‘pole bal-
ancing’ [14, 29] – the setup is shown in Figure 2 (a). In this control task, a pole
with a point-mass on its upper end is mounted on a cart or robot arm, and it
has to be stabilized by the motions of the cart/robot arm. This problem is suﬃ-
ciently diﬃcult as an empirical evaluations, while remaining analytically solvable
given some minor assumptions.

System and Rewards. For such regulator tasks, it is common to approximate
the control system by a linearization about a given setpoint, chosen to be the
zero vector in our example. The density function of the start-state is given
by a Gaussian distribution p (x0) = N (x0|µ0, Σ 0) with µ0 = 0, and Σ 0 =
diag(0.1, 0.1, 0.1, 0.1) (using SI units). Near the mean of the start-state dis-
tribution of the pole, the pole dynamics can be described approximately by
p(xt+1|xt, ut) = N (xt+1 |Axt + But, ΣT ), with

xt =

xt
˙xt
α
˙α

 , A =

1 τ 0 0
0 1 0 0
0 0 1 τ
0 0 ντ 1

 , b =

0
τ
0

ντ /g



and ut = F , τ = 1/60s, ν = 13.2s−2, ΣT = 0.01Σ0 as in [31]. The rewards are
given by r (xt, ut) = xT
t Rut with Q = diag(1.25, 1, 12, 0.25), and
R = 0.01 as in [29].

t Qxt + uT

14

Parameterized Policy. The policy is speciﬁed as π(u|x) = N (u|Kx, σ 2). In
order to ensure that the learning algorithm cannot exceed an acceptable param-
eter range, the variance of the policy is deﬁned as σ = 0.1 + 1/(1 + exp(η)).
Thus, the policy parameter vector becomes θ = [K T , η]T and has the analyti-
cally computable optimal solution K ≈ [5.71, 11.3, −82.1, −21.6]T, and σ = 0.1,
corresponding to η → ∞. As η → ∞ is hard to visualize, we show σ in Figure 2
(b) despite the fact that the update takes place over the parameter η.

These experiments required that the function J(θ) = E {(cid:80)∞

t=0 γtrt| θ} ex-
ists for the initial policy with θ0; this is equivalent to requirement of the largest
eigenvalue of a deterministic closed loop system obeys γ −2 > eig(A + BK).
Interestingly, this prerequisite does not require a stabilizing initial policy sta-
bility for γ = 0.95 – however, for γ = 1 a stabilizing policy would be re-
quired. One hundred initial policies are generated by uniformly selecting K from
[10 ± 400, 15 ± 400, −90 ± 400, −25 ± 400]T and σ = 0.5 ± 0.4, while rejecting the
ones where γ −2 ≤ eig(A + BK).

Experiments. For each initial policy, samples (xt, ut, rt+1, xt+1) were generated
using the start-state distribution, transition probabilities, the rewards, and the
policy. The samples arrive at a rate of 60 Hz and are immediately incorporated
by the Natural Actor-Critic module. The policy is updated when (cid:93)(wt+1, wt) ≤
 = π/180. At the time of update, the true ‘vanilla’ policy gradient, which can
be computed analytically4, is used to update a separate policy, thus serving
as a baseline for the comparison. If the pole leaves the acceptable region of
−π/6 ≤ φ ≤ π/6, and −1.5m ≤ x ≤ +1.5m, it is reset to a new starting position
drawn from the start-state distribution.

The additional basis functions for the Natural Actor-Critic are chosen as
4, 1]T . These basis
φ(x) = [x2
functions are suﬃciently rich to represent the quadratic value function for linear
problems.

1, x1x2, x1x3, x1x4, x2

2, x2x3, x2x4, x2

3, x3x4, x2

Results and Discussion. Results are illustrated in Figure 2. In 2 (b), a sample
run is shown: the natural-actor critic algorithms estimates the optimal solution
within less than ten minutes of simulated robot trial time. The analytically
obtained policy gradient for comparison takes over two hours of robot experience
to get to the true solution. In a real world application, a signiﬁcant amount of
time would be added for the vanilla policy gradient as it is more unstable and
leaves the admissible area more often. The policy gradient is clearly outperformed
by the natural actor-critic algorithm. The performance diﬀerence between the
true natural gradient and the natural actor-critic algorithm is negligible and,
therefore, not shown separately. In Figure 2 (c), the expected return over updates
is shown averaged over all hundred initial policies.

In this experiment, we demonstrated that the natural actor critic is compara-
ble with the ideal natural gradient, and outperforms the ‘vanilla’ policy gradient

4 The true natural policy gradient can also be computed analytically. In the following
evaluations, however, it is not shown as the diﬀerence in performance to the Natural
Actor Critic gradient estimate is negligible.

15

Fig. 2. Performance of Natural Actor-Critic in the Cart-Pole Balancing framework.
(a) General setup of the cart-pole system. (b) A typical sample learning run of both
the natural actor-critic (dashed line) and the true policy gradient (solid line). (c) The
expected return of the policy over time. Curves are an average over 100 randomly
picked policies as described in Section 4.1.

signiﬁcantly. Greedy policy improvement methods do not compare easily. Dis-
cretized greedy methods cannot compete due to the fact that the amount of
data required would be signiﬁcantly increased. Model-based dynamic program-
ming based methods as described in the linear quadratic regulation literature
work well, but require the estimation of a model [9] and oﬀ-line iterations to
determine the policy. The only suitable greedy improvement method, to our
knowledge, is Bradtke’s Adaptive Policy Iteration [7]. However, this method is
problematic in real-world application as the policy in Bradtke’s method is de-
terministic: the estimation of the action-value function is an ill-conditioned re-
gression problem with redundant parameters and no explorative noise. For these
reasons, we focused on the comparison of ‘vanilla’ and natural policy gradients.

16

Fig. 3. Episodic natural actor-critic for learning dynamic movement primitives. (a)
Learning curves comparing the episodic Natural Actor Critic to episodic REINFORCE.
(b) Humanoid robot DB which was used for this task. Note that the variance of the
episodic Natural Actor Critic learning is signiﬁcantly lower than the one of episodic
REINFORCE, with about 10 times faster convergence.

4.2 Example II: Optimizing Nonlinear Motor Primitives for

Humanoid Motion Planning

While the previous example demonstrated the feasibility and performance of
the Natural Actor Critic in a classical example of motor control, this section will
turn towards an application of optimizing nonlinear dynamic motor primitives
for a humanoid robot. In [17, 16], a novel form of representing movement plans
(qd, ˙qd) for the degrees of freedom (DOF) of a robotic system was suggested in
terms of the time evolution of the nonlinear dynamical systems

˙qd,k = h(qd,k, zk, gk, τ, θk)

(30)

where (qd,k, ˙qd,k) denote the desired position and velocity of a joint, z k the
internal state of the dynamic system, gk the goal (or point attractor) state of
each DOF, τ the movement duration shared by all DOFs, and θk the open
parameters of the function h. The original work in [17, 16] demonstrated how
the parameters θk can be learned to match a template trajectory by means of
supervised learning – this scenario is, for instance, useful as the ﬁrst step of an
imitation learning system. Here we will add the ability of self-improvement of
the movement primitives in Eq.(30) by means of reinforcement learning, which
is the crucial second step in imitation learning.

The system in Eq.(30) is a point-to-point movement, i.e., an episodic task
from the view of reinforcement learning – continuous (e.g., periodic) movement

17

can be considered, too, with minor modiﬁcations of our framework. In order
to apply the Natural Actor Critic, two issues need to be addressed: what are
appropriate basis functions φ(x) for the value function, and what modiﬁcations
are required for this ﬁnite horizon task. It turns out that a straightforward
simpliﬁcation of the Natural Actor-Critic can deal with both issues elegantly.
For the deterministic dynamics of the movement primitives, we can formulate
the discounted sum of advantages along one roll-out as

γiAπ(xi, ui) =

N(cid:88)i=0

=

N(cid:88)i=0
N(cid:88)i=0

γi(r(xi, ui) + γV π(xi+1) − V π(xi)),

(31)

γir(xi, ui) + γN +1V π(xN +1) − V π(x0),

i.e., for episodic tasks where V π(xN +1) = 0, we can set the additional basis
functions φ(x) to φ(x) = 1 – indeed, only one basis function is needed, as only
V π(x0) is unknown. Thus, after inserting the compatible function approximator
for Aπ(xi, ui), we arrive at a well-deﬁned regression problem for w after multiple
roll-outs, which corresponds to LSTD-Q(1):

γi∇θ log π(ui|xi)T w + v =

N(cid:88)i=0

N(cid:88)i=0

γir(xi, ui).

(32)

In order to yield an unbiased estimated of w, this equation requires a distribution
of start states p(x0) of roll-outs that has its mean at x0, which is diﬀerent
from the general form in Eq.(32) that does not have such a condition. A special
algorithm for this episodic version of the Natural Actor Critic is given in Table 2.
We evaluated this algorithm on a typical problem of motor learning, the ac-
quistion of smooth reaching trajectories for arm movements, using the movement
primitives in Eq.(30). The reward of a trajectory for every DOF is given by

rk(x0:N , u0:N ) =

N(cid:88)i=0

c1 ˙q2

d,k,i + c2(qd,k,N − gk),

(cid:80)N

where c1 = 1, c2 = 1000, and gk is chose appropriately to not violate the
range of motion of each DOF. The reward along a trajectory corresponds to
i=0 γir(xi, ui) in Eq.(32) with a discount factor of γ = 1. Starting from a
zero parameter vector in each DOF, we optimized the parameters (for each
DOF independently) to accomplish a minimal value under the reward criterion.
Ten parameters per DOF were employed. For a comparision, we also tested the
episodic REINFORCE algorithm. Trajectories were executed on the humanoid
robot DB. As can be seen in Figure 3, the episodic Natural Actor-Critic exhib-
ited rather promising results: within less than 100 trials, a fairly low value of
the cost criterion was accomplished, and ﬁnal convergence was reached between
300 to 400 trials. To the best of our knowledge, this algorithm is the fastest pol-
icy gradient method which can be applied on this task – episodic REINFORCE

18

Table 2. Natural Actor-Critic Algorithm adapted for episodic task.

Input: Parameterized policy π(u|x) = p(u|x, θ) with initial parameters θ = θ0,

its derivative ∇θlogπ(u|x)and one basis function φ(x0) = 1 as needed for the start state value
function parameterization V π(x0).

1: Select parameters A0 = 0, b0 = 0.
2: For e = 0, 1, 2, . . . do
3: Draw initial state x0 ∼ p(x0).

For t = 0, 1, 2, . . . , N do

Draw action ut ∼ π(ut|xt), observe next state xt+1∼ p(xt+1|xt, ut),
and reward rt= r(xt, ut).

end;

4: Critic Evaluation (LSTD-Q(1)): Determine state-value function

4.1: Determine

V π(x0) = φ(xo)ve = ve of the initial state xo and the compatible advantage
function approximation f π
bφe =PN
re = PN

t=0 γ t[1, ∇θ log π(ut|xt)T ]
t=0 γ trt,

θ log π(ut|xt)T we.

w(xt, ut) = ∇

T

,

4.2: Update suﬃcient statistics:

Ae+1 = Ae + bφebφ

e ; be+1 = be + bφere,

T

4.3: Update critic parameters:

[ve+1, wT

e+1]T = A−1

e+1be+1.

5: Actor-Update: When the natural gradient is converged over a window h,

i.e., ∀τ ∈ [0, ..., h] : (cid:93)(we+1, we−τ ) ≤ , update the
parameterized policy π(ut|xt) = p(ut|xt, θe+1):

5.1: policy parameters:

5.2:

θe+1 = θe + αwe+1,
forget some of suﬃcient statistics with β ∈ [0, 1]:
Ae+1 ← βAe+1, be+1 ← βbe+1.

6: end.

required about 10 times more trials until a similar level of performance. In com-
plex learning task, humans show similar learning performance. The smoothness
of the reduction of the cost criterion in Figure 3 should be noted, too, indicating
a smooth performance improvement that is desirable for the safety of a physical
system and its environment.

5 Conclusion

In this paper, we reviewed the concepts and problems of traditional and novel
reinforcement learning algorithms with a focus on applicability to humanoid mo-
tor control. We highlighted that greedy policy-improvement algorithms are likely
to fail to scale to high dimensional movement systems as their large changes in

19

the policy during learning makes stable algorithms so far infeasible. Policy gra-
dients, on the other hand, have been successfully applied in humanoid robotics
for both walking and ﬁne manipulation; this success indicates that these meth-
ods could be potentially useful for humanoid robotics. Research of this paper
demonstrated that policy gradient methods can even be taken to a new level of
theory and applicability by using the natural instead of ‘vanilla’ policy gradient.
We derived an algorithm, the Natural Actor-Critic, which uses two essential
components. First, it approximates the natural gradient directly in the policy
evaluation loop using the compatible function approximator. This part is based
on LSTD(λ) and inherits several strong theoretical properties from previous
work. Second, the natural gradient is used in order to improve the policy; under
suitable conditions, this method guarantees convergence with probability one to
the next local minimum of the average reward function. We applied the inﬁnite
horizon version of the Natural Actor-Critic algorithm successfully in a simple
robotic task, i.e., pole balancing, while applying the episodic version of the Nat-
ural Actor-Critic algorithm to the optimization of humanoid motor primitives.
Future work will address the evaluation of the suggested learning framework in
more complex tasks, in particular in conjunction with priming a control policy
from imitation learning and subsequent self-improvement.

References

1. Baird, L. C., & Moore, A. W. (1999). Gradient descent for general reinforcement

learning. Advances in Neural Information Processing Systems 11

2. Bellman, R., Dynamic Programming, Princeton, NJ: Princeton University Press,

1957

3. Benbrahim, H. & Franklin, J., Biped dynamic walking using reinforcement learn-

ing, Robotics and Autonomous Systems Journal, 1997

4. Bertsekas, D. P. & Tsitsiklis, J. N.. Neuro-Dynamic Programming. Athena Scien-

tiﬁc, Belmont, MA, 1996

5. Boyan, J., Least-squares temporal diﬀerence learning. In I. Bratko and S. Dzeroski,
editors, Machine Learning: Proceedings of the Sixteenth International Conference,
pages 49– 56. Morgan Kaufmann, San Francisco, CA, 1999

6. Bradtke, S. and Barto, A.. Linear least-squares algorithms for temporal diﬀerence

learning, Machine Learning, 22, 1996

7. Bradtke, S., Ydstie, E. and Barto, A. Adaptive Linear Quadratic Control Using
Policy Iteration. Technical report UM-CS-1994-049, University of Massachusetts,
1994.

8. Dayan, P.. The convergence of TD(lambda) for general lambda. Machine Learning,

8, 341-362, 1992

9. Dorato, P., Abdallah, C., and Cerone, V. Linear-Quadratic Control: An Introduc-

tion. Prentice Hall, 1998.

10. Kakade, S. A Natural Policy Gradient. Advances in Neural Information Processing

Systems 14, 2002

11. Lagoudakis, M., and Parr, R., Model-Free Least-Squares policy iteration, Technical

Report CS-2000-05, Duke University, 2001

20

12. Nedic, A. and Bertsekas, D. P., Least-Squares Policy Evaluation Algorithms with
Linear Function Approximation, LIDS Report LIDS-P-2537, Dec. 2001; to appear
in J. of Discrete Event Systems, 2002.

13. Gullapalli, V., Learning Control Under Extreme Uncertainty, In Advances in Neu-
ral Information Processing Systems 5 (NIPS 5), SJ Hanson, JD Cowan, CL Giles,
Eds. pp. 327-334, Morgan Kaufmann 1993.

14. Sutton, R.S., and Barto, A.G. Reinforcement Learning, The MIT Press, 1998
15. Ilg, J. Albiez, K. Berns, R. Dillmann. Adaptive Biologically Inspired Control for the
Four-Legged Walking Machine BISAM. In International Conference on Climbing
and Walking Robots (CLAWAR), S. 809-818, Portsmouth, Oktober 1999.

16. Ijspeert, A., Nakanishi, J., Schaal, S. Learning attractor landscapes for learning
motor primitives, in: Becker, S.;Thrun, S.;Obermayer, K. (eds.), Advances in Neu-
ral Information Processing Systems 15, MIT Press, 2003.

17. Ijspeert, J.A.;Nakanishi, J.;Schaal, S. Learning rhythmic movements by demon-
stration using nonlinear oscillators, IEEE International Conference on Intelligent
Robots and Systems (IROS 2002), pp.958-963, Piscataway, NJ: IEEE, 2002.

18. Peters, J., Vijaykumar, S., Schaal, S. Comparing Policy Gradient Methods. In

preparation for ICML 2004.

19. Sutton, R.S., Comparing Policy Gradient Methods, unﬁnished paper draft.
20. Sutton, R.S., McAllester, D., Singh, S., and Mansour, Y. Policy gradient methods
for reinforcement learning with function approximation. In Advances in Neural
Information Processing Systems 12. MIT Press, 2000.

21. Konda, V., and Tsitsiklis, J.N. Actor-Critic Algorithms. In Advances in Neural

Information Processing Systems 12. MIT Press, 2000.

22. Marbach, P. and Tsitsiklis, J.N. Simulation-based optimization of Markov reward
processes: implementation issues, in Proceedings of the 38th IEEE Conference on
Decision and Control, 1999

23. Baxter, J., Bartlett, P., and Weaver, L. Experiments with Inﬁnite-Horizon, Policy-

Gradient Estimation, Journal of Artiﬁcial Intelligence Research 15, 2001.

24. Kimura, H. and Kobayashi, S.: Reinforcement Learning for Continuous Action
using Stochastic Gradient Ascent, The 5th International Conference on Intelligent
Autonomous Systems, 1998.

25. Moon, T., and Stirling, W. Mathematical Methods and Algorithms for Signal Pro-

cessing, Prentice Hall, 2000.

26. Williams, R. J. Simple statistical gradient-following algorithms for connectionist

reinforcement learning. Machine Learning, 8, 1992.

27. Amari, S. Natural Gradient Works Eﬃciently in Learning. Neural Computation

10, 1998

28. Baird, L. C. Advantage Updating. Technical Report WL-TR-93-1146, Wright-

Patterson Air Force Base Ohio: Wright Laboratory, 1993.

29. Schaal, S. Learning from demonstration, in: Mozer, M.C.;Jordan, M.;Petsche, T.
(eds.), Advances in Neural Information Processing Systems 9, pp.1040-1046, MIT
Press, 1997.

30. Schoknecht, R., Optimality of Reinforcement Learning Algorithms with Linear
Function Approximation, in: Becker, S.;Thrun, S.;Obermayer, K. (eds.), Advances
in Neural Information Processing Systems 15, MIT Press, 2003.

31. Mehta, B., Schaal, S. Forward models in visuomotor control, J Neurophysiol, 88,

2, pp.942-53, 2002.

