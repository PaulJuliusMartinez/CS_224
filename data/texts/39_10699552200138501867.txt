From: AAAI Technical Report FS-94-02. Compilation copyright © 1994, AAAI (www.aaai.org). All rights reserved.

Relevant Examples and Relevant Features: Thoughts from Computational Learning Theory
Avrim L. Blum* School of ComputerScience Carnegie Mellon University PittslJurgh PA15213-3891

Introduction
It can be said that nearly all results in machinelearning, whether experimental or theoretical, deal with problems of separating relevant from irrelevant information in some way. In this paper I will attempt to survey someof the results and intuitions developed in the area of computational learning theory. Myfocus will be on two issues in particular: that someexamples maybe more relevant than others, and that within an example, some features may be more relevant than others. This survey is by no meanseven close to comprehensive, and strongly reflects myownpersonal biases as well as issues brought up by results presented at this workshop.
Issues of relevance are fundamental in the theoretical study of machinelearning. In particular, questions regarding the meaningof a "relevant" or "informative" example are key motivations for the most popular and most basic theoretical models. Let mebegin in the traditional mannerof defining the basic models discussed, but do so from the point of view of the motivations from "relevance."
Models and preliminaries
A commonparadigm for concept learning is to have a "training phase" in which the learning procedure studies some set of examples and produces a hypothesis, and then a separate "testing phase" in which that hypothesis is evaluated. The Probably-ApproximatelyCorrect or "PAC"learning model of Valiant [Valiant, 1984], [Kearns et al., 1987] is a modelof concept learning of this form. It is currently the most popular theoretical modelstudied.
The motivation behind the PAC model can be thought of as follows. In order for a learning algorithm to be able to generalize from its training data and produce a hypothesis of goodquality for the testing phase, the training examples need to be "relevant"
*This material is based upon work supported under NSFNational YoungInvestigator grant CCR-9357793 and a Sloan Foundation Research Fellowship. Email: avrim(~cs.cmu.edu

to the final test in someway. For instance, if the goal of a learning program was to distinguish between pencils and pens, and all pencils in the training phase were woodbut all in the testing phase were mechanical, one wouldnot expect to see good performance (and the test would seem a bit unfair). One of the key ideas of the PACmodel is to postulate a fixed (but unknown)distribution on examples, and assume that the algorithm will be trained and tested on this same distribution. Because there is always the possibility that examples
selected for training maynot be representative of the distribution (and therefore not so relevant), this model requires two "fudge" parameters: an error e and a confidence 5. Wesay that an algorithm succeeds in learning a "class" or set of concepts C in the PACmodel if for any distribution 7) on examples and any target concept c E C, the algorithm with probability at least 1 - 5 produces a hypothesis with error at most c with respect to 7). Wegenerally will require an algorithm to run in time polynomial in various parameters such as l/e, 1/5, and the description length of the target concept under some agreed-upon encoding.
Perhaps one of the most important general results in learnability theory is that in the PACmodel, one can effectively say that "learning is data compression". In particular, if one can take a large sample of data and extract the relevant information into a rule significantly smaller than the data set, then this is guaranteed to achieve good generalization [Blumer et al., 1987] [Blumeret al., 1989]. Conversely, any goodlearning algorithm can either be viewed as behaving in this manner or transformed into one that does [Board and Pitt, 1992] [Schapire, 1990].
The mistake-bound model [Littlestone, 1988] is a model for on-line prediction motivated in part by this
samebasic issue. For an on-line prediction scenario (ad infinitum you are given an unlabeled example, asked to predict its classification, and then told the correct answer) we would like to say that a good algorithm will "converge quickly." However if the same example is repeated over and over, we cannot expect this to happen. So, in the mistake-bound model, we just count the number of mistakes made and use that quantity,

rather than the total numberof examples seen, as our measure of time. In particular, in this model, we say that an algorithm succeeds to learn a concept class if the number of mistakes it makes given that examples are classified by someconcept in the class is guaranteed to be at most somepolynomial in certain relevant parameters (the number of features and the description
length of the target concept). In this paper I will use the terms "variable", "fea-
ture", and "attribute" interchangeably. The features will be namedxl, x2,... ,x,~ and an example is an as-
signment of somevalue (usually 0 or 1) to each of them.
Filtering irrelevant examples
Boosting
The PACmodel guarantees that the distribution used for training will be relevant to the success criteria used to test hypotheses. However, as learning progresses, the learner's knowledgeabout certain parts of the input space increases, and examples in the "wellunderstood" portion of the space becomeless useful. Thus, if one has an algorithm for which training is expensive but prediction is cheap, then as its hypotheses improve, it makes sense to try to filter the training data to weed out those less useful examples. As discussed in Freund's paper in this workshop, the boosting technique of Schapire [Schapire, 1990]and Freund [Freund, 1990; Freund, 1992] provides a mechanismfor
doing this.
To get someintuition about the degree of filtering one might hope to achieve, it is helpful to consider the simpler case of conservative algorithms. Aconservative algorithm only pays attention to an example if its current hypothesis predicts incorrectly on it. Since
such an algorithm ignores all the examples on which its hypothesis is correct, it is clear one can filter those out without causing harm. Thus, when the algorithm is predicting with 20%error one can filter out 80%of the examples, and when it achieves 10%error one can filter out 90°£ of the examples and so forth. Learning algorithms in the PACmodel can be assumed to need to roughly double the number of examples seen in order to halve their error rate [Schapire, 1990], [Fre-
und, 1992], [Blumer et al., 1989]. Since the numberof example passing through the filter is proportional to the error rate, however, the number of new examples actually used by the algorithm each time it wishes to halve its error rate remains (roughly) constant. Thus the number of examples actually used is really just
logarithmic in 1/e rather than linear. The boosting techniques enable one to achieve this kind of filtering in muchmore general conditions.
It is interesting to relate this use of boosting to its original motivations. Boosting was developed as an answer to the following puzzling question: Whyare there no classes knownthat are "somewhatlearnable" in the PACmodel in the sense that some algorithm achieves,

say, 40%error under arbitrary distributions but no algorithm can achieve an arbitrarily small error rate? Schapire [1990] proved that no such class could exist
(i.e. weak-learnability implies strong-learnability) providing a general technique to transform any algorithm of the former type into an algorithm of the latter type. The intuitive idea is that since the former
algorithm is supposed to be (weakly) successful over every distribution, you can improve any mediocre hypothesis by applying the weakalgorithm to a modified (filtered) distribution on which your current hypothesis gives you very little information. In other words, filtering to focus on the current "hard cases" is not just a methodfor focusing on the relevant examples, but is also a way of forcing one's algorithm to do something useful with them.
Perhaps the biggest contribution of the boosting technique to computational learning theory is to point out that in the standard PACmodel, the quantity e is "irrelevant" in the same sense that the quantity 6 can
be seen to be "irrelevant" by more elementary methods. Namely, one mayas well assume that e = 6 = 1/3 and attack that case. Boosting will take care of the
rest.
Query by Committee
As described in Freund's paper, the Query by Committee (QBC)algorithm allows one to filter examples in a stronger sense than boosting: examples can be filtered out without even knowingtheir labels. This is useful if the labeling process is expensive. QBCassumes a Bayesian prior distribution on the target concepts. This assumption means there is a natural notion of the information in an unlabeled example: howwell does it split the concepts currently under consideration? The basic idea of QBCis to allow through only the more informative examples, and the assumptions imply that if such examples are rare then randomconsistent hypotheses are likely to be quite good. What QBCrequires, however, is having a muchbetter handle on the space of hypotheses than boosting requires. To use QBCone needs to be able to sample consistent concepts according to the prior, whichcan be quite difficult, although it is also a major topic of algorithmic research, e.g., [Sinclair and Jerrum, 1989], [Dyeret ai.,
1989], [Lov~z and Simonovits, 1992].
Comments
It is useful to keep in mind a distinction between examples that are relevant from the point of view of information, and examples that are relevant or helpful
from the point of view of one's algorithm. In this regard, let us consider the model in which in addition to seeing examples from a distribution, one is allowed to select one's ownunlabeled examples and ask for their labelings. These requests are often called membership queries. This ability to make active queries seems to greatly enlarge the types of concept classes for which

15

one can guarantee polynomial-time learning [Angluin, 1987], [Angluinet al., 1989], [Hancock,1991], [Bshouty, 1993], [Jackson, 1994] .... One very commontechnique used in these algorithms is to take some example that one wants to understand better and slightly tweak it to see howthis wouldaffect its labeling. For instance one might take two examples with different labelings and slowly "walk" one example to the other to see whenthe classification changes. Fromthe perspective of "relevance" the point here is that even though these slight variations may not be the most relevant from an information-theoretic viewpoint, the type of information that one gets is in an especially usable form. This phenomenonhas been noticed for quite some time [Winston, 1975].
Relevant Features
Muchof the work in machine learning theory regarding "relevancy" concerns the issue of relevant features. Given the setup of the basic models, one can define a feature xi to be relevant to a given target concept f if there exists a pair of examples A and B in the input space such that A and B differ only in their assignment to xi and $(A) ~/(B). Notice that in this definition, "relevancy" depends on the target concept, and not the distribution or the set of examplesseen by the learner. For instance, it might be that in all the examples seen by the learner so far, the values of features zl and z2 are exactly the same, but xl could be deemedrelevant and x2 not. A discussion of a useful way to view this definition is given in the commentssection below.
In [Blum and Kannan, 1993] (also presented at this workshop), a generalization of this notion of relevance to the idea of relevant linear combinations of features is addressed.
The question most commonlyaddressed in theoretical workwith respect to the issue of relevant features can be stated roughly as follows:
For a given concept class, is there a polynomialtime algorithm whose performance is especially good when the number of relevant features is small? That is, can one devise an algorithm whose sample size or mistake bound has a low dependence on the numberof irrelevant features?
These sorts of algorithms are termed "attribute efficient" in [Blumet al., 1991]. A similar question, addressed by the work of [Dhagat and Hellerstein, 1994] (presented at this workshop), is whether one can produce a hypothesis that also itself depends only on a small subset of features.
In the framework of computational learning theory, two main techniques have cometo light for achieving performance guarantees of the form described above. In the PACmodel, the technique is "greedy set cover," first used in this context by Haussler [Haussler, 1986]. In the mistake-bound model, the technique is that of

multiplicative weight updating, introduced by Littlestone [Littlestone, 1988].
The greedy set cover algorithm, applied to the case of learning a disjunction of booleanvariables, is as follows. Given a training set, ignore any variable with the property that some negative example sets it to 1.
For each variable remaining, count the number of positive examplesthat do set it to 1. Pick the variable zi whose count is highest and place it into the hypothesis disjunction. Nowthrow away those positive examples with zi = 1 and repeat. The guarantee [John-
son, 1974] is that the numberof variables included will be at most a logarithmic factor (in n) larger than the smMlest possible.* This approach can be applied directly to other situations where the learning algorithm can produce a list of functions with the property that the target concept can be viewed as a disjunction (or conjunction) of some small set of them. Situations of this form include learning intersections of halfspaces in constant-dimensional spaces [Blumer et al., 1989], learning DNFformulas in n°(l°gn) time under the uni-
form distribution [Verbeurgt, 1990], and manyothers.
The greedy set-cover approach is the basis for the results of Dhagat and Hellerstein presented in this workshop. Theyextend this technique in a recursive fashion to apply to other classes of target functions.
In the setting of on-line learning, Littlestone [Lit-
tlestone, 1988] was the first to demonstrate that in interesting cases one could achieve a mistake bound with provably low dependence on the numberof irrelevant features. His Winnowalgorithms apply to learning a variety of concept classes such as conjunctions, k-DNF, and linear threshold functions with good separation between positive and negative examples. For
these, he gives a very elegant proof that the numberof mistakes made has only a logarithmic dependence on
the numberof irrelevant variables. For instance, the numberof mistakes madein learning a disjunction of r out of n variables is O(r log n). His general technique involves attaching weights to each element in a given set of "predictors" (for instance to learn disjunctions one would assign a weight to each variable). These weights represent the perceived importance of each one. The weights are then updated in a multiplicative manner based on the examples seen. This general approach has then been used in other algorithms such as the weighted majority algorithm of Littlestone and Warmuth[1994], and the algorithms of [Vovk, 1990;
Littlestone et al., 1991; Cesa-Bianchi et al., 1993]. Kivinen and Warmuthin this workshop describe relations between these approaches and additive updating methods such as the Widrow-Hoff algorithm [Widrow and I/off, 1960].
*Findingthe smallest consistent disjunction is NP-hard [Gareyand Johnson,1979]; in fact, a polynomial-timealgorithm to find disjunctions only clog n times larger than the smallest for c < 1/4 wouldplace NPinto quasi-polynomial time [Lund and Yannakakis, 1993].

16

One general fact regarding attribute-efficient algorithms is that if membershipqueries are allowed, then any mistake-bound algorithm can be converted into one that has only a logarithmic dependence (in terms of number of mistakes plus queries made) on the number of irrelevant features [Blumet al., 1991].
Comments
It is worth pointing out that in the PACand mistakebound models (without membership queries) the notion of relevance is really being used as a measure of complexity. In other words, the algorithms do not really care what features are relevant and (generally) they are not really searching for a set of relevant ones. Rather, relevance is used to say how"complicated" a target function is, and the goal of the algorithms is to perform well whenthis quantity is low.
Suppose, for instance, we saw the following examples:
111111111100000000000000000000 + 000000000011111111110000000000 + 000000000000000000001111111111 + 000000000000000000000000000000-
According to our definition of relevance, one cannot tell which features are relevant from the above data since that depends on the unknowntarget concept. In a practical sense, if somebodyasks which features are relevant, perhaps all you can say is that they are all somewhatrelevant (see the definition in [Kohavi, 1994]). On the other hand, another useful thing one can say is "3". Namely,3 is the size of the smallest relevant set, assumingwe are learning a class like "disjunctions" where it is possible to be consistent with the data.
One other point: algorithms such as the Winnow and Weighted-Majority algorithm have the following nice property related to their ability to focus on the relevant features. By dropping predictors (or "experts") whose weights become too low, the algorithm can be madeto actually speed up as it learns more. (Dropping bad predictors can be justified under distributional assumptions). This behavior is in contrast to a large number of algorithms in use that slow down as they learn more because their internal representations get increasingly complicated.
Other thoughts
It is my belief that some of the most central open problems in computational learning theory are, at their core, questions about finding relevant variables. In this last section, I will describe one of mypersonal favorite open questions. I believe this is the essence of the difficulty in learning DNFformulas and decision trees (without membership queries) in the PACmodel. The problemis the following:
Does there exists a polynomial time algorithm for learning the class of boolean functions over {0, 1}"

that have log2(n) relevant variables, whenthe example distribution 1) is the uniform distribution?
Afew points regarding this question: First, notice that the class of functions having log2 n relevant variables is a special case of polynomial-size DNFformulas and decision trees. That is because any function which has only logs n relevant variables can, by definition, be written as a truth table having only n entries. Second, this class is easy to learn whenmembershipqueries are allowed (exercise for reader). Indeed, the algorithm Bshouty[Bshouty, 1993] learns the larger class of decision trees with membershipqueries in the exact leaning model, and a recent algorithm of Jackson [Jackson, 1994] learns the even larger class of general DNFformulas using membership queries, with respect to the uniform distribution. Third, randomfunctions in this class, namely functions with randomtruth tables, turn out to be easy to learn. The hard cases seem to be close to, but not exactly, parity functions (see below). Finally, the base "2" in the logarithm is just for concreteness. Anyconstant base greater than 1 will do.
As a practical matter, one difficulty with the above open problemis that since no distribution on the target functions is stated, it is unclear howto experimentally test a proposed algorithm. To handle this issue, the following is a specific distribution on the target functions that seems quite hard (for convenience, the numberof relevant variables will be 2 log2 n).
Select at random two disjoint sets A,B C {1,..., n} each of size logs n. Oninput x, compute the exclusive-or of the bits indexed by A and the majority function of the bits indexed by B, and output the exclusive-or of the two results.
For instance, if A = {1,2,3} and B = {4,5,6} then the classification of the example 011101001010would be positive since the first 3 bits have XORequal to 0, and the majority function applied to the next 3 bits is I, and the XORof those two quantities is 1.
Formally, the associated open question is this. Does there exist a polynomial-time algorithm A, a polynomial p, and a constant c > 0 such that with probability at least 1/2 + e, Apasses the following test: given p(n) uniformly-selected randomexamples classified by a target function drawn from the above distribution, it correctly classifies a newunlabeled randomexample.
One interesting feature about this open question is that in [Blumet al., 1994] it is shownhowto create a pseudorandombit generator with the property that if the answer to this question is "no", then the generator is secure (against polynomial-time adversaries).
Conclusions
Issues of relevant examples and relevant features are central to the theoretical study of machine learning. This paper has attempted to survey just a few of the manyresults related to this topic.

17

References
D. Angluin, L. Hellerstein, and M. Karpinski. Learning read-once formulas with queries. Technical Report UCB/CSD89/528, University of California Berkeley Computer Science Division, 1989.
Dana Angluin. Learning regular sets from queries and counterexamples. Information and Computation, 75:87106, November 1987.
A. Blum and R. Kannan. Learning an intersection of k halfspaces over a uniform distribution. In Proceedings of the 34th Annual IEEE Symposium on Foundations of Computer Science, pages 312-320, November 1993.
A. Blum, L. Hellerstein, and N. Littlestone. Learning in the presence of finitely or infinitely many irrelevant attributes. In Proceedings of the Fourth Annual Workshop on Computational Learning Theory, pages 157-166, Santa Cruz, California, August 1991. Morgan Kaufmann.
A. Blum, M. Furst, M. Kearns, and D. Lipton. Crypto-
~)raphic primitives based on hard learning problems. In ¯ Stinson, editor, Proceedings CRYPTO93. Springer, 1994. Lecture Notes in Computer Science No. 773.
Anselm Blumer, Andrzej Ehrenfeucht, David Haussler, and Manfred K. Warmuth. Occam's razor. Information Processing Letters, 24:377-380, April 1987.
Anselm Blumer, Andrzej Ehrenfeucht, David Haussler, and Manfred K. Warmuth. Learnability and the VapnikChervonenkls dimension. Journal of the ACM,36(4):929965, 1989.
Raymond Board and Leonard Pitt. On the necessity of Occam algorithms. Theoretical Computer Science, 100:157-184, 1992.
N. H. Bshouty. Exact learning via the monotone theory. In Proceedings of the IEEE Syrup. on Foundation of Computer Science, pages 302-311, Palo Alto, CA., 1993.
N. Cesa-Bianchi, Y. Freund, D.P. Helmbold, D. Haussler, R.E. Schapire, and M.K. Warmuth. Howto use expert advice. In Proceedings of the Annual ACMSyrup. on the Theory of Computing, pages 382-391, 1993.
A. Dhagat and L. Hellerstein. PAClearning with irrelevant attributes. In Proceedings of the IEEE Syrup. on Foundation of Computer Science, 1994. To appear.
M. Dyer, A. Frieze, and R. Kannan. A random polynomial time algorithm for approximating the volume of convex bodies. In Proceedings of the Annual ACMSyrup. on the Theory of Computing, pages 375-381, 1989.
Yoav Freund. Boosting a weak learning algorithm by majority. In Proceedings of the Third Annual Workshop on Computational Learning Theory, pages 202-216. Morgan Kaufmann, 1990.
Yoav Freund. An improved boosting algorithm and its implications on learning complexity. In Proceedings of the Fifth Annual A CMWorkshop on Computational Learning Theory, pages 391-398. ACMPress, 1992.
M. Garey and D. Johnson. Computers and Intractability: A Guide to the Theory of NP-Completeness. W. H. Freeman, San Francisco, 1979.
Thomas Hancock. Learning 2tt DNFformulas and k# decision trees. In Proceedings of the Fourth Annual Workshop on Computational Learning Theory, pages 199-209, Santa Cruz, California, August 1991. Morgan Kaufmann.
David Haussler. Quantifying the inductive bias in concept learning. In Proceedings AAAI-86, pages 485-489. American Association for Artificial Intelligence, August 1986.

J. Jackson. An efficient membership-query algorithm for learning DNFwith respect to the uniform distribution. In Proceedings of the IEEE Syrup. on Foundation of Computer ,Science, 1994. To Appear.
D.S. Johnson. Approximation algorithms for combinatorial problems. J. of Computer and System Sciences, 9:256-278, 1974.
Michael Kearns, Ming Li, Leonard Pitt, and Leslie Valiant. On the learnability of boolean formulae. In Proceedings of the Nineteenth Annual ACMSymposium on Theory of Computing, pages 285-295, New York, New York, May 1987.
Ron Kohavi. Feature subset selection as search with probability estimates. This workshop, 1994.
N. Littlestone and M. K. Warmuth. The weighted majority algorithm. Information and Computation, 108(2):212261, 1994.
Nick Littlestone, Philip M. Long, and Manfred K. Warmuth. On-line learning of linear functions. In Proceedings of the Twenty-third Annual ACMSymposium on Theory of Computing, pages 465-475, New Orleans, Louisiana, May 1991. ACM.
Nick Littlestone. Learning quickly when irrelevant attributes abound: A new linear-threshold algorithm. Machine Learning, 2:285-318, 1988.
L. Lov~sz and M. Simonovits. On the randomized complexity of volume and diameter. In Proceedings of the IEEE Syrup. on Foundation of Computer Science, pages 482-491, 1992.
C. Lund and M. Yannakakis. On the hardness of approximating minimization problems. In Proceedings of the Annual ACMSyrup. on the Theory of Computing, pages 286-293, 1993.
Robert E. Schapire. The strength of weak learnability. Machine Learning, 5(2):197-227, 1990.
Alistair Sinclair and Mark Jerrum. Approximate counting, uniform generation and rapidly mixing markov chains. Information and Computation, 82(1):93-133, July 1989.
Leslie G. Valiant. A theory of the learnable. Communications of the ACM,27(11):1134-1142, November 1984.
K. Verbeurgt. Learning DNFunder the uniform distribution in polynomial time. In Proceedings of the Third Annual Workshop on Computational Learning Theory, pages 314-325. Morgan Kaufmann, 1990.
V. Vovk. Aggregating strategies. In Proceedings of the Third Annual Workshop on Computational Learning Theory, pages 371-383. Morgan Kaufmann, 1990.
Bernard Widrow and Marcian E. Hog. Adaptive switching circuits. 1960 IRE WESCONConvention Record, pages 96-104, 1960. Reprinted in Neurocomputing (MIT Press, 1988).
Patrick H. Winston. Learning structural descriptions from examples. In Patrick H. Winston, editor, The Psychology of Computer Vision. McGraw-Hill, New York, 1975.

18

