Optical Reading of Typeset Music
by
Alan Ruttenberg
B.A., Brandeis University (1984) Submitted to the Media Arts and Sciences Section,
Department of Architecture and Planning in partial fulfillment of the requirements for the degree of
Master of Science in Visual Studies at the
MASSACHUSETTS INSTITUTE OF TECHNOLOGY February 1991
c Massachusetts Institute of Technology 1991. All right reserved.
Signature of Author : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : Media Arts and Sciences Section,
Department of Architecture and Planning January 18, 1991
Certified by : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : Marvin Minsky
Toshiba Professor of Media Arts and Sciences Thesis Supervisor
Accepted by : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : Stephen A. Benton
Chairman, Departmental Committee on Graduate Students

Optical Reading of Typeset Music
by Alan Ruttenberg
Submitted to the Media Arts and Sciences Section, Department of Architecture and Planning
on January 18, 1991, in partial fulfillment of the requirements for the degree of
Master of Science in Visual Studies
Abstract
This thesis describes a program which translates a digitized image of a music score into a representation more amenable to computer manipulation of the musical content. I aim for a representation in which the information manifest on a sheet of music is easily accessible, information such as: the key signature, the pitches and durations of notes, and dynamic markings associated with parts of the score. The program is designed to read music printed by a single publisher, in a single musical font. Throughout the thesis I will comment on the issues and feasibility of extending this work to other fonts and publishers. This work is done for the most part using a Connection Machine, a data parallel computer. Thesis Supervisor: Marvin Minsky Title: Toshiba Professor of Media Arts and Sciences
2

Acknowledgments
In no particular order, and undoubtably with omissions.
This work was supported in part by Media Lab Funds, for which I am grateful. Thanks to Sarbina Birner, Jim Davis, Peter Heller, Dave Rosenthal, Jeanne Speckman, for reading and
commenting on drafts of this thesis. The Spirit of 76 formed a supportive household during this work. Thanks Jeanne, Rick, Barry, Liz, Nancy, Mira,
and kitty. Thanks, Dave Rosenthal, for your advise and support in many ways.
Thanks to Sandy Pentland for ideas and space. The people in the Music and Cognition Group at the Media Lab formed the core of my intellectual surroundings.
Thank you. Mike Travers, my officemate, taught me much about programming. For various reasons: Barry Vercoe, Amy Bruckman, Marc Davis, Lori Rosenthal, Linda Peterson, Andrea Akerib, Doug Lenat, Lennart Johnsson, Ken Haase, Dave Sheppard, Stephen Benton, Henry Baird, Nicholas
Negroponte, Gerald Sussman, Harold Abelson, Frank Perkins. Betty Dexter is wonderful!
Thanks to the people at Thinking Machines, Symbolics, and Apple, for building cool machines, and writing inspiring software.
Thanks to Donald Knuth for TEX and his books, which serve as a continuing inspiration.
My parents have always been there when I needed them.
3

Contents

1 Introduction

12

1.1 Goal : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 12

1.2 Why Optical Reading? : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 12

1.3 Comparison to Optical Character Recognition : : : : : : : : : : : : : : : : : : : : : : : : : : : 14

1.4 Considerations in Deciding what a Feature Is : : : : : : : : : : : : : : : : : : : : : : : : : : : 15

1.5 Feature Defined : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 15

1.6 Use of Multiple Methods for Locating Features : : : : : : : : : : : : : : : : : : : : : : : : : : 16

1.7 Handling of Inaccuracy in Feature Location : : : : : : : : : : : : : : : : : : : : : : : : : : : : 18

1.8 Assembling Composite Musical Objects : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 19

1.9 Connection to Society of Mind : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 20

1.10 Influence of Parallel Programming : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 20

1.11 Choice of Serial vs Parallel Algorithms : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 22

1.12 Extending Reader Coverage : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 22

1.13 Speculation: Other Applications of the Technology : : : : : : : : : : : : : : : : : : : : : : : : 23

1.14 How to Read this Thesis : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 24

2 Connection Machine Concepts

25

2.1 Programming Language : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 25

2.2 Image : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 25

2.3 SIMD : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 25

2.4 Subselection : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 27

2.5 Global Operations : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 28

2.6 Virtual Processors Sets : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 28

2.7 Sending : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 28

2.8 Geometry : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 29

2.9 Remapping : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 30

2.10 Movables : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 31

2.11 Slices : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 32

2.12 Pointer Doubling : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 34

2.13 Scans : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 35

3 Locating Fixed Sized Features

36

3.1 Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 36

3.2 Template Elements are Three-Valued : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 38

3.3 Using Portions of Large Features : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 41

3.4 Template Scores and Thresholds : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 42

3.5 Creating the Templates : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 43

3.6 Future Work : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 44

3.7 The Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 44

4

3.7.1 Top level code for finding features : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 44 3.7.2 Top level Convolution of a Feature with a Slice : : : : : : : : : : : : : : : : : : : : : : 45 3.7.3 Convolution - Scanning Method : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 46 3.7.4 Convolution - Packing Method (faster) : : : : : : : : : : : : : : : : : : : : : : : : : : : 47 3.7.5 Finding the Convolution Peaks : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 48 3.7.6 Feature Model Flavor Definition : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 50 3.7.7 Geometry Information for Feature Models : : : : : : : : : : : : : : : : : : : : : : : : : 50 3.7.8 Interface for Feature Models : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 51 3.7.9 Construction of a Feature Model : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 51 3.7.10 Parsing the marked points in a feature : : : : : : : : : : : : : : : : : : : : : : : : : : : 51 3.7.11 Computing the Bounds of Feature : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 52 3.7.12 Creating the Black and White Arrays : : : : : : : : : : : : : : : : : : : : : : : : : : : 53 3.7.13 Handle the Case Where a Full Feature is Specified : : : : : : : : : : : : : : : : : : : : : 53 3.7.14 Bookeeping and Error Checking : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 54 3.7.15 Definition of a Recognized Feature : : : : : : : : : : : : : : : : : : : : : : : : : : : : 54 3.7.16 Definition of a Full Page of Features : : : : : : : : : : : : : : : : : : : : : : : : : : : : 54

4 Locating Beams

56

4.1 Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 56

4.2 Representation : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 58

4.3 Finding the Beams : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 59

4.4 Future Work : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 66

4.5 The Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 66

4.5.1 Top level : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 66

4.5.2 Shape Parameters : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 67

4.6 Filtering Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 67

4.6.1 Computing Neighbor Counts : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 67

4.6.2 Bleeding : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 68

4.6.3 Filter for Beams : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 68

4.6.4 Handle Edges : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 69

4.6.5 Prepare a Single Slice : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 69

4.7 Boundaries Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 69

4.7.1 Boundaries Data Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 69

4.7.2 Define Eight Connectivity : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 70

4.7.3 Connect Boundary Points : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 70

4.7.4 Set Pointer used in bf compute-boundary-neighbors : : : : : : : : : : : : : : : : : : : : 71

4.7.5 Comparing Colors : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 71

4.7.6 Accessors for Nearby Pixels : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 71

4.7.7 Label each Pointer Uniquely : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 71

4.8 Compressed Boundaries Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 72

4.8.1 Definition of Compressed Boundary : : : : : : : : : : : : : : : : : : : : : : : : : : : : 72

4.8.2 Make a Compressed Boundary from an Ordinary Boundary : : : : : : : : : : : : : : : : 72

4.8.3 Pointer Doubling : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 72

4.8.4 Scan Ordered Boundaries : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 73

4.8.5 Make a Compressed Boundary into a Scan Ordered Boundary : : : : : : : : : : : : : : : 73

4.8.6 Compute Lines which Best Fit the Top or Bottom of the Beam : : : : : : : : : : : : : : 74

4.8.7 Remove Short (invalid) Boundaries : : : : : : : : : : : : : : : : : : : : : : : : : : : : 75

4.9 Front End Representation Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 75

4.9.1 Front End Representation for a Single Beam : : : : : : : : : : : : : : : : : : : : : : : : 75

4.9.2 Clean up the Beam Feature on the Front End : : : : : : : : : : : : : : : : : : : : : : : : 76

4.9.3 Compute the Number of Beam Ligatures : : : : : : : : : : : : : : : : : : : : : : : : : 77

5

4.9.4 Beam Geometry : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 77 4.9.5 Object to Hold all the Beams on a Page : : : : : : : : : : : : : : : : : : : : : : : : : : 77 4.10 Code for full page of beams : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 78 4.10.1 Beam boundaries : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 78 4.10.2 Ignore the redundant white border : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 78 4.10.3 Slight modifications for a few methods : : : : : : : : : : : : : : : : : : : : : : : : : : 78 4.10.4 Compute the Height of Beams, in Units of Ligature : : : : : : : : : : : : : : : : : : : : 79 4.10.5 Extract representation from CM : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 80 4.11 Code to deal with slices : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 80 4.11.1 Definition of Seams : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 80 4.11.2 Save away the seams : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 82 4.11.3 Restore the seams : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 82 4.11.4 Details : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 83 4.11.5 Boundaries Which also have Seams : : : : : : : : : : : : : : : : : : : : : : : : : : : : 83 4.11.6 More Details : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 83 4.11.7 Compressed Boundaries with Seams : : : : : : : : : : : : : : : : : : : : : : : : : : : : 83 4.11.8 Compress the Boundary taking Seams into Account : : : : : : : : : : : : : : : : : : : : 84

5 Locating Staff and Measure Lines

85

5.1 Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 85

5.2 Finding Staff Lines : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 86

5.3 Filter, Divide and Conquer : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 88

5.4 Reconstructing Lines From Line Segments : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 89

5.5 Checking and Correcting Errors : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 90

5.6 Grouping Staffs into Systems : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 90

5.7 Finding Measure Lines : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 91

5.8 Robustness : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 92

5.9 Future Work : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 92

5.10 The Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 92

5.10.1 Parameters : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 92

5.10.2 Top level construction of Bars on a Page : : : : : : : : : : : : : : : : : : : : : : : : : : 93

5.10.3 Top Level for Finding Staff Lines : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 93

5.10.4 Top level for Finding Measure Lines : : : : : : : : : : : : : : : : : : : : : : : : : : : : 94

5.10.5 Filtering : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 94

5.10.6 Definition of the Chain Structure : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 94

5.10.7 Secondary Accessors for Chains : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 95

5.10.8 Sending Chains : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 95

5.10.9 Finding the Closest Line Segment : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 96

5.10.10 Create Pointers to the Left and Right : : : : : : : : : : : : : : : : : : : : : : : : : : : : 96

5.10.11 Ensure that Chains are Linear : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 96

5.10.12 Create a Chain : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 97

5.10.13 Extract a List of Chain Extents and Positions : : : : : : : : : : : : : : : : : : : : : : : 97

5.10.14 Reduce each line segment to a point which is at the centroid : : : : : : : : : : : : : : : : 98

5.10.15 Front end Representation of lines : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 98

5.10.16 Reducing Several Line Segments to a Single Line : : : : : : : : : : : : : : : : : : : : : 99

5.10.17 Compute the Median Distance Between Lines : : : : : : : : : : : : : : : : : : : : : : : 99

5.10.18 Generic Algorithm for Removing Lines which don't Make Sense : : : : : : : : : : : : : 100

5.10.19 Draw Lines for Debugging Purposes : : : : : : : : : : : : : : : : : : : : : : : : : : : : 100

5.10.20 Methods to Delete One or More Lines : : : : : : : : : : : : : : : : : : : : : : : : : : : 100

5.10.21 Miscellaneous Functions : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 101

5.10.22 Definition of a Full Page of Staff Lines : : : : : : : : : : : : : : : : : : : : : : : : : : 101

6

5.10.23 Compute the Mode Distance between Lines : : : : : : : : : : : : : : : : : : : : : : : : 102 5.10.24 Decide if the Set of Staff Lines Could Make Sense : : : : : : : : : : : : : : : : : : : : : 102 5.10.25 Ways of Choosing a Bad Line to Remove : : : : : : : : : : : : : : : : : : : : : : : : : 103 5.10.26 Group Each Five Staff Lines into a Staff : : : : : : : : : : : : : : : : : : : : : : : : : 103 5.10.27 Try to Figure Out How Many Staffs in a System : : : : : : : : : : : : : : : : : : : : : : 103 5.10.28 Construct the System Objects : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 104 5.10.29 Definition of a Page of Measure Lines. : : : : : : : : : : : : : : : : : : : : : : : : : : : 104 5.10.30 Definition of a Staff Line : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 105 5.10.31 Simple Functions of Staffs Lines : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 105 5.10.32 Compute Functions for Estimation of Line from Position. : : : : : : : : : : : : : : : : : 105 5.10.33 Conversion between Position and Line Number : : : : : : : : : : : : : : : : : : : : : : 106 5.10.34 Definition of a System : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 106 5.10.35 Draw a System : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 107 5.10.36 Simple Functions of System : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 107 5.10.37 Attach Measure Lines to Systems : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 107 5.10.38 Test for Double Measure Lines. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 108 5.10.39 Definition of a Page of Bars. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 108

6 Locating Stems

109

6.1 Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 109

6.2 Future Work : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 112

6.3 The Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 112

6.3.1 Definition of a stem feature : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 112

6.3.2 Filtering : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 112

6.3.3 Fill in Vertical Gaps : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 113

6.3.4 Label the Stem Regions : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 113

6.3.5 Extract a Representation of the Stems : : : : : : : : : : : : : : : : : : : : : : : : : : : 114

6.3.6 Definition of a Page of Stems. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 114

7 Locating Ties and Slurs

115

7.1 Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 115

7.2 The Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 119

7.2.1 Finding the Ties : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 119

7.2.2 Thinning : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 120

7.2.3 Creating Local Connected Area Maps : : : : : : : : : : : : : : : : : : : : : : : : : : : 121

7.2.4 Line fitting : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 122

8 Assembly

125

8.1 Introduction : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 125

8.2 Surroundings : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 127

8.3 Relations : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 127

8.4 Disambiguation and Propagation of Relations : : : : : : : : : : : : : : : : : : : : : : : : : : : 128

8.5 Related Work : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 129

8.6 Future Work : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 130

8.7 The Code : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 130

8.8 Some Implemented Relations : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 130

8.8.1 Attaching Flags : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 130

8.8.2 Attaching Accidentals : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 131

8.8.3 Relationship Between a Staff and its Constituents : : : : : : : : : : : : : : : : : : : : : 132

8.8.4 Relationship between a Stem and a Note-head : : : : : : : : : : : : : : : : : : : : : : : 132

8.8.5 Measures and their Constituents : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 134

7

8.8.6 Overlap Relations : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 135 8.8.7 Overlap of Sharps : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 136 8.8.8 Current Top Level Test : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 136 8.9 Code Defining Behaviour of Relations : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 137 8.9.1 Definition of a Relation : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 137 8.9.2 Default Methods for Relations : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 137 8.9.3 Pay Special Attention to Ambiguous Relations : : : : : : : : : : : : : : : : : : : : : : 139 8.9.4 Definition of Object which can have Relations : : : : : : : : : : : : : : : : : : : : : : : 139 8.10 Implementation of Surroundings : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 140 8.10.1 Box and binning parameters : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 140 8.10.2 Definition of Boxes : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 140 8.10.3 Definition of Boxes which Keep Track of their Area : : : : : : : : : : : : : : : : : : : : 140 8.10.4 Definition of a Boxes with Contents : : : : : : : : : : : : : : : : : : : : : : : : : : : : 141 8.10.5 Define a Quad Tree Node : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 141 8.10.6 Definition of Quad Tree Root : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 141 8.10.7 Intersection Tests : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 142 8.10.8 The Binning Algorithm : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 142 8.10.9 Routines to Map over a Range of Objects : : : : : : : : : : : : : : : : : : : : : : : : : 143 8.10.10 Routines to Map over all Objects : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 144 8.10.11 Manipulation of the Bitvector : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 144 8.11 Code Implementing Surroundings : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 145 8.11.1 Definition of Surroundings : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 145 8.11.2 Method for Registering Staff in Surroundings : : : : : : : : : : : : : : : : : : : : : : : 145 8.11.3 Method for Registering Systems : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 146 8.11.4 Method for Registering Measures : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 146 8.11.5 Methods for Registering Fixed-sized Features and Beams : : : : : : : : : : : : : : : : : 146 8.11.6 Dispatch Creation of Surroundings by Type : : : : : : : : : : : : : : : : : : : : : : : : 147 8.11.7 Mapping over Portions of Surroundings : : : : : : : : : : : : : : : : : : : : : : : : : : 147 8.11.8 Definition of Objects which can have Surroundings : : : : : : : : : : : : : : : : : : : : 147 8.11.9 Operating on Relations in Surroundings : : : : : : : : : : : : : : : : : : : : : : : : : : 148
8

List of Figures
1-1 A typical system from the Schubert String Quartets published by Dover Press. This one is from
page 97, the third system. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 13
1-2 The first image, representing the curved edges of a note head could have been considered a feature, but wasn't in this work. The last is a composite feature, made up of the stem, the flag, and the
note head. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 16 1-3 Feature are divided into five classes. The greyed staff lines are for reference : : : : : : : : : : : : 17
2-1 Digitization of an image: An imaginary grid is placed over the image. Each square of the grid
gets translated into a 0 or a 1 depending on whether it is more white or black. : : : : : : : : : : : 26
2-2 The connection machine has one copy of the program (= single instruction) and many processors, each of which has different values assigned to its variables (= multiple data). I use an icon of an
integrated circuit to represent a processor. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 26
2-3 Visualization of Selected set. (*when select? (*set c (+!! a b))) gets executed only in processors where select? is t. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 27
2-4 Visualization of a global operation. *sum adds up the value of some variable in all processors. : : 28
2-5 Visualization of Vp Sets. A vpset is a set of processors each of which may contain some variables.
A given variable only resides in the processors of a single vpset. : : : : : : : : : : : : : : : : : : 29
2-6 How to visualize a send operation: A variable in processors from one vpset is copied into another
variable in another vpset. Note that processor 22 gets two messages, one of which is ignored. : : : 30
2-7 When the result of some computation reduces to values in only a few processor in the vpset, and if more processing remains to be done on these results, it often pays to create a smaller vpset in
which the remaining computation can be done. This way, fewer processors remain idle. : : : : : : 31
2-8 An example of a computation which involves surrounding processors. Smoothing an image by
replacing each point by the average of the points around it : : : : : : : : : : : : : : : : : : : : : 32
2-9 Example of a movable copy of a value in a set of processors being moved over an initial copy, in the process of computing the average at the center. The movement of the copy is such that once
done, every processor has had the value of each neighboring processor visit it. : : : : : : : : : : 33
2-10 A page is processed in pieces which I call slices. Slices overlap so that the largest feature is sure to be wholly contained on at least one of them. Blob 1 is contained in slice a but not b. Blob 2 is
completely contained in slice c. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 33
2-11 Using pointer doubling to maximize. In each step all processors share values and compute the maximum. Processors first communicate with their neighbors, then with processors successively
greater powers of two apart. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 34
2-12 A plus scan operation accumulates in each processor the sum of the value in all previous processors.
A segmented scan restarts the summing process wherever the segment start flag is true. : : : : : : 35
3-1 Some examples of fixed sized features. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 36
3-2 Because of quantization noise and printing irregularities, the same feature doesn't always have the
same pixel representation. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 38 3-3 A strictly black template would match many places where the feature is not really located. : : : : 39
9

3-4 Since a black template alone won't do, a template which looks for both white and black might do
better. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 39
3-5 A closer approximation to what the templates should be. The first three images show each part of
the template, the last a composite, with the ignored section in grey. : : : : : : : : : : : : : : : : 40
3-6 Examples of the neighborhood of a note head, showing that the assumption that there is white
surrounding a note head is inadequate. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 41 3-7 On large features, only a unique subportion is used. : : : : : : : : : : : : : : : : : : : : : : : : 42 3-8 The lisp representation of a feature. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 43
4-1 Parts of a beamed set of notes. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 56 4-2 A sampling of beam shapes. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 57
4-3 A closeup of a digitized beam. In order to illustrate the tranformations more clearly, this beam is
not from the score, but instead a more coarsely digitized example. : : : : : : : : : : : : : : : : : 60
4-4 An unsuitable filtering technique: In erosion each pixel which is adjacent to a white pixel also
becomes white. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 61
4-5 The chosen filtering method, neighbor counting: Any pixel which has less than three horizontal
neighbors in a row turns white. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 61 4-6 Beam after the vertical neighbor counting is done. : : : : : : : : : : : : : : : : : : : : : : : : : 62
4-7 Beam after the horizontal neighbor counting is done. At this point different parts of the tuplet are
disconnected. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 62 4-8 In bleeding each pixel which is adjacent to a black pixel also becomes black. : : : : : : : : : : : 63
4-9 Beam after the bleed is applied. Note heads are still visible, but the beam region has been simplified. 63
4-10 Edges of remaining areas. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 64
4-11 This sequence show how the successive beam filters transform the original digitized image. The
image is from the top left corner of page 216 of the Schubert scores. : : : : : : : : : : : : : : : : 65 4-12 Best lines through the points constituting the top and bottom edges of the beam. : : : : : : : : : : 66
5-1 Staff and measure lines. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 85
5-2 The basic way of finding staff lines is to sum pixels horizontally. To the right is a plot of what the
sum looks like as a function of vertical position. : : : : : : : : : : : : : : : : : : : : : : : : : : 86
5-3 Four ways in which digitized printed staff lines differ from the ideal. To the right are the horizontal
sums. The ideal sums are in grey. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 87
5-4 The basic way of finding staff lines is to sum pixels horizontally. To the right is a plot of what the
sum looks like as a function of vertical position. : : : : : : : : : : : : : : : : : : : : : : : : : : 89
5-5 The dot representation is transformed to a chain by having each point search for another which is
nearby. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 90
5-6 This sequence shows the process of finding measure lines. The image is filtered to remove other than thin vertical things. Then it is divided into horizontal slices, each of which is summed downward. The image shows the accumulating sum where the darker it is, the larger the sum.
Finally these sums are thresholded yielding a series of points representing line segments. : : : : : 91
6-1 Some examples of stems. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 109
6-2 Processing stages in locating stems: 1) Original, 2) After filter, 3) after bleed 4) after removing
short things 5) result. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 111
7-1 Some examples of ties and the contexts in which they appear. : : : : : : : : : : : : : : : : : : : 115
7-2 To filter for line like objects, a line is fit in the connected neighborhood of each point. When the line doesn't fit well, as in c the point is not considered part of a line. In b notice that the top grey
line is not part of the fit, since it is not connected : : : : : : : : : : : : : : : : : : : : : : : : : : 117
7-3 Images 1 through 5 show the progress of the skeletonizing algorithm. Image 6 show the final
skeletonized image after points which are not parts of lines are removed. : : : : : : : : : : : : : 118
10

7-4 Line segments need to be reattached in order to reconstruct ties. In order to do this, one searches in a cone which the tangent bisects, for other segments. When the search areas overlap, there is a
potential attachment point. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 118 8-1 Typical relations that exist between features in a music score. : : : : : : : : : : : : : : : : : : : 125
8-2 There are two constraints on the relationship between an accidental and the note it modifies. The pitch-centers need lie on the same line or space, and the the note-head need to be nearby and to
the right. : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : 128
11

Chapter 1
Introduction
1.1 Goal
This thesis describes a program which translates a digitized image of a music score into a representation more amenable to computer manipulation of the musical content. I aim for a representation in which the information manifest on a sheet of music is easily accessible, information such as: the key signature, the pitches and durations of notes, and dynamic markings associated with parts of the score. This kind of encoded score could be used as input to other programs written to analyze musical structure or to translate scores into performances.
The program is designed to read music printed by a single publisher, in a single musical font. As will be seen, there are many difficulties even with this limited goal. I chose The Complete Chamber Music of Schubert, reprinted by Dover Press as my corpus, some 350 pages of mostly string quartet music. A substantial amount of other music is available from the publisher in the same format. I have not done any tests with other scores. Throughout the thesis I will comment on the issues and feasibility of extending this work to other fonts and publishers.
I aim for perfect accuracy in the representation of the written score, since it is my intention to use these representations in scholarly study of Schubert. Where there is a choice to be made between speed and accuracy, the choice in this work is always towards accuracy.
1.2 Why Optical Reading?
One can imagine transcribing the scores by hand, perhaps using some existing or special purpose program to record the information. This would be would be tedious, time consuming, and extremely prone to error. A typical page of string quartet music contains a couple of thousand marks, whose type and position are significant. Further,
12

Figure 1-1: A typical system from the Schubert String Quartets published by Dover Press. This one is from page 97, the third system.
available representations for entering the information are limited [2], either being extremely cumbersome, or in being unable to capture the full range of expression of a printed score.
Attempts to formulate symbolic musical representations often lead to a compromise between conciseness, which demands that unimportant information be left out, and comprehensiveness - the ability of the language to express sufficient information that the score can be reconstructed. By reading the score optically, information can be kept which might justifiably be left out of some representations of the score but which might prove useful. For instance the exact positions of all the marks might be useful for studies of music typography. Thus, the question of which format to use to encode the score can be avoided by recording enough information so that the score can be visually reconstructed without loss. This is more information then one would want to enter by hand, but is easily available using the optical method, and is easy to translate to any desired format.
Another approach would be to write a program that interprets either an acoustic or gestural (e.g. midi) input and translates that to a representation of the score. The problem is that a given score has many interpretations. While the pitches often do not vary in these interpretations, the timing and dynamics do. Even supposing the performer made no mistakes, this variation in timing makes it difficult to determine a unique interpretation of the rhythmic content of the music.
I am skeptical that it is even possible in principle to return to the score from a performance. Often a phrase can be written in many notations which seem roughly equivalent. Compare four alternating eight notes and rests to four quarter notes with staccato markings; these might both legitimately be performed the same way. Examples like this suggest that there are many mappings from scores to performances and vice versa, and thus translating one unambiguously to another is impossible.
13

1.3 Comparison to Optical Character Recognition
It is useful to compare the score reading to text recognition. Superficial similarities between the two problems catch one's attention from the first. A comparison between the two can serve to suggest strategies for tackling the score reading problem, illuminate problems specific to score reading, and help better understand the capabilities and limitations of current character recognition technology.
To optically read text, first the lines of text are identified by searching for the long approximately horizontal space between lines. Each line is then processed in sequence. Within a line characters are handled one at a time. The reason that they can be handled individually is that they are not connected to each other, and so simple region labelling algorithms can segregate characters for individual handling1. The sort of errors character recognition algorithms make show that for the most part characters are individually recognized. Similarly shaped characters are often mistaken for each other, an l (letter L) for a 1 (number one) even in unlikely contexts, such as in the middle of paragraphs of narrative text. Even with the current state of the art, it is imperative to proofread the results of the text reading because errors are quite common.
In examining a page of music, one sees that the first steps towards recognition used by character recognition programs are not applicable. Isolating glyphs on a page of music is difficult because they overlap, and come in many sizes. Staff lines overlap with almost all other features. Shape types range from note heads to beams to ties, each with a different characteristic scale. These features can not be isolated as easily as in the case of character recognition.
The final representation of music is also more complicated than in optical character recognition in which the relevant information is the sequence of characters and the places where the paragraphs break. Though font information would be desirable, commercial optical character readers only supply limited font information - not nearly enough to adequately parse a dictionary definition, for instance. In terms of data structures, this information is typically represented as a ordered sequence of characters with font and size properties attached.
In some forms of media it is an oversimplification to treat text as a stream of propertied characters is much too simplified. On the front page of a newspaper the relative size and position of text carries information which supplements the meaning of the words, information about importance, continuation, and relationship to surrounding information. I am not familiar with research which does text recognition at this level. Certainly what comes under the label of optical character recognition is not this, which might be more appropriately called visual language recognition (after the Media Lab's Visual Language Workshop).
The visual language of music is much more complicated than the common representation of textual information. A beam groups the set of notes attached to it by stems. A key signature is recognized as a cluster of accidentals not beside note heads. An accidental modifies the note to its right, a dot the note to its left. A tie modifies the
1Ligatures are examples of connected characters, but there are only a few of them, and the ligature can be considered a single character by the recognition process.
14

performance of all the notes between the two notes it points to. The point of view taken in character recognition is inadequate for reading music. In order to attack the problem
of music recognition we need to think differently about the sort of recognition primitives to employ and about the architecture of a recognizer which can handle the diversity of visual relations which a musical score exhibits.
1.4 Considerations in Deciding what a Feature Is
Shape can be dealt with at a number of levels of detail. In talking about a character glyph, for instance, one shape-like description might be in terms of corners, edges, lines, and curves. Another might consider the shape of a particular character in a certain font to be a primitive shape. Another, such as Donald Knuth's Metafont descriptions, could deal with descriptions of the shared and unique parts of characters, and how characters are composed from them.
The choice of what to consider a feature is a design decision which involves tradeoffs between the difficulty of the programming task, the processing time, and the reliability of the methods which can be employed to locate that feature. The more complicated the primitive features are, the harder it is to write a specific program to find them. Implicit in complication is variety. There are more types of complicated shapes than there are simple types of shapes. So the more complicated that shape is, the more processing is involved because more methods have to be applied in order to find all the different shapes.
With simpler shape primitives there are also problems. The simpler a shape becomes, the more ubiquitious it is. If the shape primitive were a small curved edge, such as would be part of a note head, that same primitive would be found in many places; as part of a clef, as part of words on the page, and as part of poorly printed beams. Because the feature is found more often, it distinguishes less well between the different types of objects found. So while there is a the potential for a speedup in the feature finding process by virtue of looking for fewer features, there is the additional complexity of using those features effectively.
1.5 Feature Defined
Features are objects such as note heads, staff lines, beams, treble clefs, dynamic markings, and the like. They are the shapes which this program finds as a whole, rather than reconstructing out of smaller parts. A beamed group is an example of an object which is assembled from these primitives, a composite object consisting of a beam feature and several note head features. Features are partitioned into several classes: Fixed-sized, beams, ties and slurs, stems and lines. Each feature class uses a different locating algorithm.
The level of feature type which I chose is not intrinsically primitive. Just as composite structures are built from these features, these features can themselves be considered composed of smaller visual components. Some marks
15

which might be considered single features, such as an eighth notes, are found in two pieces: the note head and the flag. But a note head is found as a single piece, rather than as the coincidence of several curved boundaries.

What is a feature?

Curved edges Note head

not a feature

a feature

23
1
Eighth note
three features

Figure 1-2: The first image, representing the curved edges of a note head could have been considered a feature, but wasn't in this work. The last is a composite feature, made up of the stem, the flag, and the note head.
The principle advantages of these design choices are coverage and accuracy. All features except grace notes (which are rare in this music) are found by one or the other of the methods 2. All the feature finding methods are adequately accurate. Some are virtually error free, whereas others have low enough error rates that the later processing stages can easily detect and correct the errors.

1.6 Use of Multiple Methods for Locating Features
Features come in many forms. Rather than try to create a feature model which could find all kinds of features I wrote a variety of different methods, each able to find a certain class of features. The advantage of a single feature model is uniformity of representation and processing, and perhaps elegence, but as usual there is a tradeoff. Since features come is a large range of shapes, any single model would have to be quite general. Such a model is difficult to design, and it would be difficult to design algorithms which could locate any instance of such a model.
Instead, five distinct feature finding algorithms are used, each designed to find a different class of features. These five classes are illustrated in Figure 1-3.
Fixed sized features are are always the same shape and size (within a single publication). Examples are note heads and accidentals. These are the closest to the features of traditional optical character recognition. Since they are always the same shape and size they can be found by matching the image to a template of the feature in question.
A second class of feature are beams. The length and number of ligatures of a beam varies, as does the angle
2Grace notes would be found using the current scheme if the scanning resolution were greater.
16

Fixed Sized

Division of Score into Feature Types

Stems Ties Beams
Lines
Figure 1-3: Feature are divided into five classes. The greyed staff lines are for reference 17

of the beam, but the thickness of a single ligature hardly varies at all. Beams are found by a method which first isolates them by exploiting the fact that beams are relatively thicker than other features. Once the beams are isolated their shapes can be individually characterized.
To locate staff and measure lines I use a filter to remove other than these "almost" horizontal and vertical lines. The filter is not perfect, and leaves marks which might mistakenly be considered staff or measure lines. A second stage of processing divides the image into pieces to find line segments. These segments are then reconstructed into the desired lines.
Because stems are only a few pixels wide, there is much noise in the marks which represent them. But since stems are usually redundant information, a simple, error prone method can be used to find them. The particular method I use actually works best when the stem information is most needed.
Ties and slurs comprise the last feature class. They have various slopes and length, though have a similar line thickness. The method for finding them focuses on the characteristic of ties and slurs being "thing which look like lines", and uses a variety of filters to isolate and recontruct them.
1.7 Handling of Inaccuracy in Feature Location
The various methods for locating features are not 100 per cent accurate. There are two ways to compensate for this. Either more time could be spent making the feature locaters more accurate or auxillary methods could be used to compensate for their inaccuracies. I chose the latter method because I don't believe that any simple feature recognition algorithm can be perfect, and because I was interested in the general problem of dealing with systems with imperfect information.
In this work, inaccuracies are dealt with in three ways: a) Given that errors in feature location will happen, write algorithms which err toward finding extra features rather than missing some, b) Decide when features contain redundant information since accuracy is less important in these cases, and c) Use constraints on the relationships between objects to rule out impossible combinations.
In locating fixed sized features, the acceptability threshold is a parameter which can be varied to more or less easily accept a feature as matching the template. The template matching process for locating fixed sized features uses a threshold which functions as an acceptibility parameter. When the parameter is lower a pattern more easily matches the template, when higher it is more difficult. These threshold were individually tuned so as to more easily accept features, and thus generate spurious locations, rather than missing a valid feature. It is easier to rule out something as impossible or unlikely than to postulate its existence when it is not in fact present.
Finding stems was difficult because of quantization noise and proximity to other features. But stem information is redundant except in the case where a note lies between two staffs, in which case the stem determines which staff the note belongs to. The method for finding stems works poorly in the presence of other features. But the cases
18

where stem information is useful are precisely when there are not other features nearby. The information derived from the stem locater is used on demand, when other information is insufficient to determine note position. By using the information on demand, the mass of incorrect stem locations do not confuse the score reader.
Once features are found, they are assembled into groups in order to reconstruct the elements of the score. Information about which features are expected to be near others is encoded in the methods which link features together into groups which make sense. Features which are not part of sensible groupings are ruled out, and additional attention is paid to groups which don't make sense, or ambiguous grouping relationships.
1.8 Assembling Composite Musical Objects
The raw positions of the features must be processed further before they can be interpreted as music. Time and pitch need to be computed, the time and key signatures need to be assembled from their components, dynamics and other expressive marks have to be attached to the notes and phrases that they modify. Mistaken features must be discovered and removed, and the score checked for consistency. Where inconsistency still exists the program needs to notify the user. Each of these tasks has in common that their execution depends on the ability to express and manipulate information about the score which is symbolic, rather than exclusively numerical.
I set up an object oriented framework in which the movement between numerical and symbolic representations is relatively uniform. Symbolic relationships are represented as objects which have pointers to each of the features which participate in the relationship. In order to flexibly handle the possibility of mistaken features, relationships may be noted as being ambiguous or missing and thus be accessible as such for further processing. 3 These same objects have methods attached to them which know, given one of the participants, how to find the other potentially related objects and verify whether the relationship in fact holds. Methods exist which can notify other objects that a relationship unambiguously holds and therefore extend to larger scale information which is initially computed locally.
Features are also represented as objects, containing information about their position, geometry, and their relationships to other features. Methods4 on feature classes can be written as necessary in order to enable them to supply information necessary to the computations involved in finding and checking relationships. For example, each fixed sized feature can include in their representation information about their position, bounds, as well as a number of named points on their shape which are necessary for verifying certain types of relationships. An accidental has, for instance, a point called a pitch-center, the position of which can be queried by the assembler/relator. This position is necessary to establish the relationship between a note head and its accidental, namely that the pitch-centers of the head and accidental lie at roughly the same vertical height.
3Relations may be ambiguous because of the presense of spuriously found features, and because not all interpretations can be made without greater knowledge of music. For instance, two flags might be near enough a note head to be both, at first glance, associated with that note.
4I use the term method here in the object oriented sense of a function which is specialized according the type of object it operates on.
19

The initial links between objects are based on the overlap of rectangles which are computed as a function of the features in question. For instance a note head computes a rectangle the same size as its own bounds but displaced to its left as an area to search for an accidental. Features are stored in such a manner as to make efficient the operation of querying their overlap with arbitrary rectangles. Since there are roughly two thousand features per page the efficiency of this operation is of some concern.
Because of the uniform framework it is relatively easy to add new relationships and further methods for handling errors in the feature location. Once all relations are established and verified a subset of the network of relations becomes, with minimal translation, a complete and adequate representation of the page of music.
1.9 Connection to Society of Mind
At the beginning of this work I was uncertain how to relate structural information about music scores to the image processing driven representations of shape and position. Initial steps in making this connection were confusing and complicated and too intertwined with the mechanism used to find the features. I consider it a success of this work that I was able to make a reasonably modular boundary between the geometric and the predicate/relational levels of the recognition process.
In Society of Mind, it is argued that the mind is composed of a large number of agencies, each with a simple function, with limited and specific means of communicating with other agencies. But many questions remain about whether this is true. Where are the boundaries placed? What information needs to be shared short of communicating everything, in order to sustain the functionality of a brain?
Perhaps this work gives a glimmer of what part of such a system might look like. All the feature finding algorithms work on fairly local sections of the image, offering one opportunity for parallelism. A second agency could implement the mechanism for computing overlap quickly. It need only be concerned with communicating information about simple spatial relations. Finally, by being able to move to a symbolic description (still retaining the old when necessary), yet another sort of mental activity can be engaged. The manner of each relation type encapsulating information for finding, verifying, and relaying information about its activities in a controlled way suggests one architecture that a society might have.
1.10 Influence of Parallel Programming
I was fortunate enough to have the use of a Connection Machine in doing this research. A Connection Machine is a data parallel computer with up to 64k processors. Our connection machine was equipped with 16k processors, each with 8k bytes of memory. Peripherals included a 5 Gbyte fast access disk and a 1280 by 1024 by 24 bit framebuffer.
20

Because the machine is very fast, it was possible to implement some of the feature locaters in what would be an inefficient way on a serial machine. This is most true for the fixed-sized feature location method, where the method of convolution was chosen because of its conceptual ease and high accuracy over other algorithms which have the potential of using less computation. The ability to trade off development time against speed made it possible for me to write enough feature locaters to challenge the assembly process and ensure that its architecture could truly deal with the complexity of a real score.
From a computational complexity point of view, a machine with N processors can run N times faster than
a machine with a single processor. This is because the single processor could sequentially execute each of the computations that the larger set of processors execute. But this simple result belies the difficulty and challenge of using a parallel machine. The theoretical speedup of a factor of the number of processors is not easily achieved because it requires recasting of serial algorithms so that the computation can be shared by many processors. Part of the work done in this thesis was exploring algorithms and designing representations which could exploit the machine.
The beam locating code illustrates an example of this process. My method for locating beams employs the equivalent of a labelling of connected regions. The solution, adapted from [cite lim], involves a constant time step (with a processor per pixel) which forms a circular linked list of the the boundary points of the regions. All the information about the regions can be derived from the boundaries of the regions, and since there are typically many fewer boundary than points which cover a plane 5 fewer processors can be used to do the remaining computation on the boundary points. This smaller set of processors communicates label tokens until each point has had the chance to receive a token from any of the other processors, a process which taken a number of steps logarithmic in the size of the list. At this point each point is labelled with a token uniqe to the boundary it is part of. Compare this to the typical raster scanning methods for accomplishing the same thing serially6, and you get some idea of the excitement of developing algorithms for a parallel machine.
In this work, parallelization occured over pixels or features. Algorithms were then best expressed from the point of view of a single feature or pixel. The point of view can be seen most clearly in a cliche which I used several times. To locate a feature I use a two step process: First taking into account properties of the neighborhood of the feature, I would write a filter which disconnects it from or transforms its surroundings. By writing the filter as a function of the surroundings of a pixel it can execute quickly - all surroundings get processed in parallel. Then I would focus identification on the resultant connected fragments. It is reasonable to consider all the fragments which result in the application of the filter by allocating a processor for the task of examining each one.
In this view feature locating can be viewed as an iterative process: Instead of finding a method which locates the feature in question in a single step, repeatedly focus attention on potential features, having them eliminate
5A fractal is an exception 6for instance in [5]
21

themselves when some inspection of the local surroundings makes their existence seem unlikely.
1.11 Choice of Serial vs Parallel Algorithms
A symbolics lisp machine served as a front end to the Connection Machine, and could be used to do serial computation. Given the additional resource, choices needed to be made about which algorithms to implement on the serial front end as opposed to the Connection Machine.
All the algorithms written for this thesis were parallel, except for a portion of the staff finding algorithms, a small deglitching of the beam algorithm and all the score assembly work. My default was to start off with a parallel algorithm. I escaped to a serial algorithm when either the number of objects being dealt with decreased to tens, or when writing a parallel program became difficult.
The former reason accounts for the serial algorithms in the beam and staff line case. In both these cases the computation starts with a processor per pixel, and reduces the image to a small set of complete features. The complexity of writing the parallel program was the factor in the assembly process. In this case there are different sorts of interactions between different sorts of objects, and a data parallel solution did not immediately present itself. The assembling takes a small portion of the total computation time, so it wasn't worth expending more effort to develop a parallel solution, though such an implementation might be interesting in its own right.
1.12 Extending Reader Coverage
The scope of the reader was narrowly restricted to the string quartets of a single publisher in order to make the problem more manageable. However algorithms were designed with the idea of extendability in mind. In this section I will comment the possibility of modifying the reader to be able to read other scores. The reader should note that no experiments were performed to verify the accuracy of these ideas.
How can we asses the difficulty of adapting this program? A program can be viewed as a large function, with the input parameters being whatever global variables and databases are set up before running it. The code can be viewed as a parameter as well, but one which is changed with greater difficulty. The difficulty of changing the parameters so that the program works for a different task is a measure of how difficult it is to perform that task.
I'll characterize the program as three distinct modules. A template driven regular feature finder makes the assumption that instances of the same feature are very similar. It takes as input the set of templates and some variables which define thresholds of acceptance of match.
There are a series of hand coded methods for finding different features which don't fall in the first category. These routines deal with features which are fixed in some ways and vary others. They assume the basic topology of the object and recover the particular parameters of its shape. They take as input some variables related to the
22

scale of the image which define the range of variation permissable. Methods for locating stems, beams, ties, and staff and measure lines fall into this category.
The third module deals with assembling the features into larger groups. This module has no parameters, since the methods for assembling are expressed in code, and are written in terms of relative sizes of features. The code is object oriented with methods for each type of graphical relationships and methods for handling each typical error mode.
I considered extending the reader to handle three successively more general tasks: (1) reading music scores of other publishers and styles, (2) reading arbitrary typeset scores without foreknowledge of the publisher and (3) reading handwritten scores.
Very little work needs to be done to adapt the program to a different publisher of typeset music. The template need to be changed to reflect the different typography standards, and some scale parameters need to be changed. Small conventions, for instance in the placement of dynamics might present the need to rewrite certain of the assembly modules.
To adapt the program to read arbitrary typeset music work of a different sort is needed. The strategy I have considered is to write a program which determines the necessary scale parameters automatically, perhaps by search through the parameter space that defines the operation of the staff line finder. This would give a strong indication of the basic sizes of features, and could be used as a narrower guide for search of other parameters. Since the system has the ability to check for consistency, there is potential for generate and test strategy to determine the parameters once they have been narrowly restricted.
As for the possibility of extending this reader to read handwritten scores, this is fairly remote. Almost all of the feature finding routines would need to be abandoned except, perhaps for the staff locater. Still, the assembly module could still be used with other feature finders substituted, so there is the possibility of some reuse of the ideas presented here.
1.13 Speculation: Other Applications of the Technology
I believe that some of the ideas which were developed in this thesis could be successfully adapted to other recognition tasks. Some initial work has been done is evaluating the possibility of using these methods to read a dictionary, a form of text where font and position information bears information, not only the raw text.
The ideas presented under the name of assembly might be relevant to the task of interpreting diagrams such as blueprints, line drawings, and sketched information input to a computer via a pen and tablet.
I think that in general the questions which are posed here concerning the recognition of visual language, merit further thought, and that the particular solutions used here might shed light on the general question of the nature of people's ability to perceive visually.
23

1.14 How to Read this Thesis
Chapter 2 contains an overview of the connection machine concepts which I use in this thesis. This is necessarily brief, and I urge the reader to consult some of the literature provided by thinking machines. The rest of the chapters are divided into two sections, a prose description of the algorithm and problems, and the code which implements it. The code is provided with few comments, but serves as a definitive definition of the implementation. Most readers will wish to only browse the occasional section.
24

Chapter 2
Connection Machine Concepts

This chapter introduces some concepts which are necessary in order to understand the implementation I describe in my thesis.

2.1 Programming Language
All code for this thesis was written in Symbolics Common Lisp[12], and *lisp[13] both extensions of commonlisp[11]. I assume that the reader is familiar with commonlisp. In addition, I used the object oriented programming system supplied on the lisp machine, called flavors. I wrote an extension of flavors to handle parallel variables which is used in the beam finding code.

2.2 Image

The scanned images I refer to are 1 bit images obtained by digitizing a sheet of music using an Apple scanner

at 300 dots per inch (dpi). They are best imagined as a large array of numbers, in this case 2544 across by 3300

down

for

the

8

1 2

by

11 inch sheets

of music.

Imagine

a fine

grid which is layed over

the original image.

In

each

square of the grid, if the average density (the higher the density, the darker the image) of the square is more than a

certain threshold value, the the corresponding array point is set to one, if it is less a zero. The amount of memory

=occupied

by

such

an

image

is

2544 3300 bits 8 bits per byte

1; 049; 400 bytes, or roughly one megabyte.

2.3 SIMD
The Connection Machine is a parallel single instruction multiple data (SIMD), computer. The CM I that used could be configured to use either 16k or 8k processors, each of which has 64k bits of memory.
25

0000000000000000000000 0000000000000000000000 0000000000000000000000 0000000011110000000000 0000000111111100000000 0000001111111111000000 0000000111111111110000 0000000011111111111000 0000000001111111111000 0000000111111111111100 0000001111111111111100 0000000111111111111100 0000000000111111111100 0000000000011111111000 0000011111111111110000 0000111111111111100000 0000011111111110000000 0000000000000000000000 0000000000000000000000 0000000000000000000000 0000000000000000000000 0000000000000000000000
Figure 2-1: Digitization of an image: An imaginary grid is placed over the image. Each square of the grid gets translated into a 0 or a 1 depending on whether it is more white or black.

One program
(*set c (+!! a b))
Single Instruction

Many Processors
a1 b2 c3
a5 b7 c 12
a0 b9 c9
a6 b4 c 10
Multiple Data

Figure 2-2: The connection machine has one copy of the program (= single instruction) and many processors, each of which has different values assigned to its variables (= multiple data). I use an icon of an integrated circuit to represent a processor.

26

I'll describe the operation of the Connection Machine by starting with analogy with a standard serial machine and adding features until a model of the CM sufficent for understanding of this work is built up.
Start first by imagining a unstructured collection of processors. Each processor is to be imagined as having variables and structures. Each processor has the same set of variables, but each can have different values for those variables.
Instead of each processor having a program memory, however, there is only one program memory(see Figure 2-
2). On a serial machine one would write (setq a (+ b c)) to mean that the variable a should be set to the sum of b and c. For the connection machine one writes (*set a (+!! b c)) to mean that in each processor, the variable a should be set to the sum of b and c. +!! is the parallel equivalent of +, in the sense that it implements the operation
of addition in each processor. Many commonlisp function have a parallel equivalent in this sense. Variables for which there is a copy in each processor are referred to as pvars (abbreviated from parallel variables).

2.4 Subselection

a1 b2 c0 select? nil
a5 b7 c0 select? t
a0 b9 c0 select? t
a6 b4 c0 select? t

a1 b2 c0 select? nil
a5 b7 c 12 select? t
a0 b9 c9 select? t
a6 b4 c 10 select? t

Figure 2-3: Visualization of Selected set. (*when select? (*set c (+!! a b))) gets executed only in processors where select? is t.

A subset of processors can be left out in doing some operations; this is referred to as subselection, the set of
processors which does execute the instruction is called the the selected set. If select? is a boolean pvar, then the
expression
(*when select? (*set a (+!! b c)))
causes a to be set to the sum of b and c only when the variable select? is nonnull. See Figure 2-3.

27

2.5 Global Operations
Operations which accumulate some value as a function of all the processors are called global operations. The
expression (*sum a) would return a single value which is the sum of the variable a in each processor.

1

2
5 9
1 6

7 4
8

3

4 + 5 + 7 + 2 + 1 + 9 + 1 + 8 + 6 + 3 = 46

Figure 2-4: Visualization of a global operation. *sum adds up the value of some variable in all processors.

2.6 Virtual Processors Sets
The Connection Machine software supports the ability to present the illusion that the pool of processors has more than the physical number of processors that the machine has, and the ability to have multiple differently sized pools of processors. A pool of processors is called a vpset(for Virtual Processor Set). The form
(setq vpset1 (create-vp-set (list (expt 2 20))))
creates such a pool of processors with approximately one million processors. At a given moment all operations are done on a single vpset, and forms are supplied that switch the current vpset. The form
(*with-vp-set vpset1 (*set a (+!! b c)) would switch to the earlier created vpset and within it, add b to c. A variable of a given name always belongs to a
particular vpset.
2.7 Sending
Each processor has a unique numerical identifier, which can be used to address that processor. These identifiers
number from 0 to one less than the number of processors in the vpset. The form (self-address!!) returns this
28

previous 20267 next 18976 edge? nil
above 10 below 12 left 38 right 2 inside? t
Figure 2-5: Visualization of Vp Sets. A vpset is a set of processors each of which may contain some variables. A given variable only resides in the processors of a single vpset.
unique integer in each processor. Processors can communicate with each other by sending information between themselves. In order to send
information, the destination processor must be specified. All the sending processors must be in a single vpset and all the receiving processors must be in a single vpset, possibly the same vpset(see Figure 2-6. The syntax for this operation is slightly confusing, but useful to understand. The form
(*with-vp-set this-vpset (*pset :overwrite a processor-address b :vpset other-vpset)) causes each processor in this-vpset to send the value of variable b to the processor in other-vpset with selfaddress processor-address (a variable in this-vpset). The variable c in that processor gets set to the sent value.
Because processors doing the sending can independently specify a destination address, it is possible for more than one processor to send information to a single processor. The Connection Machine software allows one to
specify what happens in this case, which is called combination. In the above *pset form, the :overwrite symbol
specifies that if more than one message is sent to the same processor, earlier ones get overwritten by later ones. Other possibilities are that numbers get added, or that bitstrings get combined using logical operations.
2.8 Geometry
Thus far a vpset has been visualized as an unstructured set of processors. Quite commonly one also defines a geometry on this set. A geomtry introduces a virtual geometric structure on the processors by defining which processors are close to which other processors. Access to close processors is more efficient and the CM software
supplies extra primitives to do these communications. by dimension.
29

destination-processor 5 7 22 5 8 a 3 6 1 23 19

22 7 00
22 7 16

85 00
85 19 3

selfaddress b
selfaddress b

before send
after send

Figure 2-6: How to visualize a send operation: A variable in processors from one vpset is copied into another variable in another vpset. Note that processor 22 gets two messages, one of which is ignored.
The Connection Machine software supplies a limited number of built in geometries. One set of them are grid geometries, optimized so that communication between nearby points on the lattice is fast. A vpset created thusly
(setq two-d-grid (create-vpset (list 1024 1024)))
would create a two dimensional grid with that property. In order to take advantage of the fast nearest neighbor
communication, instead of using *pset, one would use a form such as (*set a (news!! a -1 2)), which would have
each variable a be set to the value of a which is one to the left and 2 below it in the grid. The coordinate functions
are computed using the function self-address-grid!!, which takes a single argument which is the dimension number
of the coordinate desired.
2.9 Remapping
Remapping is the process of taking variables in a set of processors in one vpset and moving to processors in another vpset.
A common application for remapping is compacting. Sometimes many processors are needed to calculate a result which is contained in some subset of those processors. If there is more work to be done on the remaining processors, it is often advantageous to send the values in the subset of processors into a new vpset which has fewer processors. The idea is illustrated in Figure 2-7.
Compacting occurs in beam calculation, for instance, in which a processor per pixel is used to calculate
30

unused processors
Figure 2-7: When the result of some computation reduces to values in only a few processor in the vpset, and if more processing remains to be done on these results, it often pays to create a smaller vpset in which the remaining computation can be done. This way, fewer processors remain idle.
boundary points of the beams, but then a subsequent calculation is done solely on the the beam boundaries. Other times, some aspect of a different geometry is desired in some calculation. For instance, consider a set of points in a plane. For some purpose one might want to think of these as a list of points sorted by their distance from the origin.
2.10 Movables
It is often necessary to compute a value in a single processor which is a function of values in other processors. Suppose that we wish to smooth an image which is represented on the CM by assigning a processor to each pixel. One way to do this is to replace each point value by the sum of itself and its neighboring points(Figure 2-8).
There is a choice of frame of reference here which makes the problem easy to imagine. Focus attention on a
Pprocessor which wants to do this calculation replacing its old value by the value of the sum of itself and its nine Pneighbors. From the point of view of we would write:
(*set P (+!! P (above!! P) (below!! P) (right!! P) (left!! P) (above!! (left!! P)) (above!! (right!! P)) (below!! (left!! P)) (below!! (right!! P))))
The functions left!!, right!!, and so on are function which get the value of a variable passed to it which is one
Pprocessor away in the direction of the name of the function. Since is an arbitrary processor, the computation is
31



1 9

1 15 21 12 43

31 29 8

17 40

12 16 4 8 19

6 9 5 17 23

14 5 6 11 1

????? ? 15 14 19 ? ? 13 13 17 ? ? 9 9 10 ? ?????

Figure 2-8: An example of a computation which involves surrounding processors. Smoothing an image by replacing each point by the average of the points around it

done for each processor. Usually, I implement this computation in a slightly different way. The idea is to first make a copy of variable
being computed on. In the case illustrated above, imagine making a second copy of the image(as in Figure 2-9, in
P P P Pthe variable 0(I call this the movable). Then in each step, 0 is rearranged so that if and 0 are superimposed,
with an offset, so that different values of the image are at the same address (see Figure 2-9). The total set of values which visit a given processor are exactly those you need to do the smoothing.
The advantage of this method is that less communication needs to be done. The connection machine commu-
nicates in either the x or y direction in each step. Using the first strategy 12 communications are needed, using
the latter uses only 8.

2.11 Slices
The size of the images is such that the CM I used did not have sufficient memory to work on the whole image at once. Instead the image was processed in pieces which I refer to as slices. A given slice is rectangular part of the whole image, and the slices are layed out over the image so as to have small amounts of overlap. The overlap is there to avoid the problem of features being divided up between two slices. The overlap is chosen to be bigger than the largest feature. Then, if a feature is positioned on some slice so as to be interrupted by the edge of the slice, some other slice is guaranteed to fully contained the feature.
This strategy worked adequately for most of the reader, with the exception of the beam finder section. In that case beams could be large enough so that no amount of overlap would ensure that there was no beam cut off. The solution to that problem is discussed in the chapter on beam finding.
The macro loop-over-slices, is used in the code wherever it is necessary to iterate over the complete image by

32

1 15 21 12 43 1 31 1529 218 1217 4340 3112 2916 8 4 178 4019 126 169 4 5 8 17 1923 6 14 9 5 5 6 1711 231 14 5 6 11 1
1 15 21 12 43 311 2915 821 1712 4043 1231 1629 48 817 1940 612 916 54 178 2319 146 59 65 1117 123
14 5 6 11 1

1 15 21 12 1 1531 2219 182 4137 31 2912 816 147 480 12 166 49 85 1197 6 9 14 55 167 2131 14 5 6 11 1

43 40 19 23 1

1 151 2115 31 2931 829 12 1612 416 6 96 59 14 514 65

1221 4132 187 4107 84 189 157 2137 161 111

43 40 19 23 1

1 15 21 12 43

31 291 815 1721 4012 12 1631 429 8 8 1917 6 9 12 516 174 238 14 5 6 69 115 1 17

43 40 19 23

14 5 6 11 1

1 15 21 12 43
1 3115 2921 812 1473 40 31 1229 168 417 840 19 12 616 9 4 58 1179 23 6 194 5 5 617 1213 1
14 5 6 11 1

1 15 21 12 43 1 15 21 12 43
31 29 8 17 40 31 29 8 17 40
12 16 4 8 19 12 16 4 8 19
6 9 5 17 23 6 9 5 17 23
14 5 6 11 1 14 5 6 11 1

1 15 21 12 43 31 129 158 2117 1240 43 12 3116 294 8 8 1719 40 6 192 165 4 17 8 23 19 14 65 9 6 5 11 171 23
14 5 6 11 1

Figure 2-9: Example of a movable copy of a value in a set of processors being moved over an initial copy, in the process of computing the average at the center. The movement of the copy is such that once done, every processor has had the value of each neighboring processor visit it.

width

a
height

1

b

2
extra border
c
Figure 2-10: A page is processed in pieces which I call slices. Slices overlap so that the largest feature is sure to be wholly contained on at least one of them. Blob 1 is contained in slice a but not b. Blob 2 is completely contained in slice c.
33

processing each of the slices. The macro arranges for a variable to be set to the current slice, and to have variables bound which describe the width and height of the slice, the coordinate of the top left corner, with respect to the complete image, and other information useful in dealing with a slice.
2.12 Pointer Doubling

a) 1 apart
a h
g
f e

b
c d

b) 2 apart
hb
h
f f

b
d d

c) 4 apart
d h
h
h h

d d
d

d) Result
h hh
hh
hh h

Figure 2-11: Using pointer doubling to maximize. In each step all processors share values and compute the maximum. Processors first communicate with their neighbors, then with processors successively greater powers of two apart.
Sometimes the nature of a calculation is such that the processors in a vpset are logically divided into subgroups, and a calculation needs to be made which is function of all the elements of the group. In the region labelling code, for instance, I construct a linked list of all the boundary points and need to label all the points of a given boundary by a unique number.
Using a movable copy for this calculation would take take n steps for a group of n processors. But for the case
where the computation is binary and associative, the same calculation can be done in a logarithmic number of steps. Each processor communicates with its adjacent processor to share its value. Then each processor communicates
with a processor two away, then four away, and so on, for log2 n steps. Figure 2-11 illustrates this process for a

34

group of eight processors, where the operation is maximization of the alphabetic position of the value.
2.13 Scans

Plus scan

input result

123456789 1 3 6 10 15 21 28 36 45

Segmented plus scan

input segment start
result

123456789 t nil t nil nil nil t nil nil 1 3 3 7 12 18 7 15 24

Figure 2-12: A plus scan operation accumulates in each processor the sum of the value in all previous processors. A segmented scan restarts the summing process wherever the segment start flag is true.
Consider a one dimensional line of processors, each with a value. Take some binary associative operation, like addition. In each processor compute the operation applied to all the processors to the left of it. A scan operation accomplishes this in time proportional to the logarithm of the number of processors, where a serial machine would do this in time proportional to the number of processors.
The connection machine software supplies two versions of this operation. One operates on all the processors in a vpset, the other on segments of the processors, where the beginning of each segment is defined by a boolean in the processor.
Scan operations are used in similar ways to pointer doubling. A scan can be in any situation where a lattice gemotry is used, in which case it is more efficient than using pointer doubling. In the code for locating beams, sets of beam boundary points are placed in segments so that calculations using segmented scan operations are possible.

35

Chapter 3
Locating Fixed Sized Features
3.1 Introduction
Many of the marks on a page of a printed score are always the same size and orientation within a given score. I'll refer to these marks as fixed-sized features. Examples of fixed-sized features are note heads, accidentals, clefs, and the numbers in time signatures. Beams, ties, crescendos, and staff lines are not. A typical page of string quartet music has one to three thousand fixed-sized features on a page, with a vocabulary of thirty to eighty symbols.

Eighth flag Note head Flat sign downward

"8" (part of time
signature)

Piano dynamic

Treble clef

Eighth flag Eighth rest upward
Figure 3-1: Some examples of fixed sized features.
The fact that these features are always the same size and shape makes finding them a simpler problem than if these properties varied. I locate these features by template matching. In this approach one compares an image
36

of the feature with the scanned image. At positions where the image matches this template a feature has been identified. The connection machine proves very useful in this task. By having the template matched at many positions at once, each processor doing a match, the speed of execution is practical 1. Still, this computation is the most time-intensive of all the feature finding, taking about two to three minutes per page on a CM2 with sixteen thousand processors.
Several things complicate finding these features on a sheet of music. Some features overlap others. The shape formed by the overlap of two features is different from the shape of either of them, making it difficult to identify either. Staff lines are a particularly large source of overlap. Staff lines not only overlap features, but connect many features together, a problem best illustrated by comparing the music recognition task to the task of optically reading text.
Programs which read text usually make the assumption that characters are disconnected blobs. This allows them to take a two step approach to their identification. First the programs identify individual blobs, then they can separately determine which character each blob represents. This method cannot be applied to music scores. Staff lines extend across the whole page, making a single connected region out of many features. Furthermore, it is not only staff lines which have this property. Often symbols are printed close enough to each other to have some small amount of overlap; note-heads in a chord touch each other and stems run from note-head to beam.
It is difficult to separate features from one another because staff lines are not printed very uniformly, and because it is hard to differentiate between noise and overlapping features. The problem is exacerbated by staff lines not being the only features which overlap others. Fully disconnecting objects requires designing a separate method for each type of overlap or extended connectivity situation. While this might be possible for staff lines, other cases seem more difficult. The approach in this work is to find features despite the overlap, and without prior disconnection.
A second problem is that features only appear to be exactly the same. When examined closely they are slightly different. The nonuniformity has two causes. Printing quality is not consistent. The exact shape of the impression depends on the thickness of the ink, the quality of the paper and other factors which change slightly from page to page. The scanning process also introduces some quantization noise because its finite resolution. An identically shaped object will have different pixel representations depending on its position relative to the grid because of the need to decide whether a pixel which is partially covered should be interpreted as black or white.
In order to best avoid quantization noise, I scanned the image at 300 dots per inch, the highest resolution available to me. Since quantization noise is always of the same magnitude, roughly a pixel, the smaller a feature is, the more the noise affects the quality of the image. On features which are only a few pixels in size this noise makes it difficult to reliably identify the feature in the crowded environment of a page of music.
1To be precise, the computational complexity of locating the fixed-sized features is proportional to the combined area of all the templates, assuming a processor per pixel, and disregarding machine size effects on the speed of communication. Thus it is advantageous to reduce the number of features, and to limit their size, when possible.
37

Figure 3-2: Because of quantization noise and printing irregularities, the same feature doesn't always have the same pixel representation.
This noise is particularly evident in scanned images of grace notes, which are smaller than usual notes. I decided to ignore grace notes because of this problem. For the Schubert scores this is not too much of a problem, since grace notes are relatively rare, and can easily be entered by hand after the rest of the score has been optically read. Grace notes are the only featurs which are deliberately ignored.
3.2 Template Elements are Three-Valued
Template elements may be one of three values: zero2, meaning look for white, one, meaning look for black, or neither, meaning ignore this point. How well a template matches the image is the sum of how many places a white is found where a white was looked for, plus how places a black is found where a black is desired. The ignored points do not contribute to the match.
There is a reason to include each of the possible template values. The ones are the most obvious. One's attention is drawn to black, and it is the black part which one calls the shape of an object. When a hole (or white space) appears inside a black object, we consider the hole to be part of the containing object. If we didn't consider white space to be a distinct shape, but simply as a lack of black, a solid note head could still be distinguished from a whole note, since the whole note has less black as part of it. When a purely black template is used, features are found in all sorts of incorrect places. Figure 3-3 illustrates some places where a note head might be mistakenly found.
White space doesn't only need to be enclosed to be important. For instance the white space around flags is
2In the images black is represented by one and white by zero.
38

= Black part of note head
Figure 3-3: A strictly black template would match many places where the feature is not really located.

Black template

White template

Figure 3-4: Since a black template alone won't do, a template which looks for both white and black might do better.

39

distinctly shaped, and useful in finding them. In these cases the white space is as distinctive as the black, and so we have a justification for looking at white space. A second approximation to a template is a combination of the black template and a white template which looks like a square with the black template cut out, illustrated in Figure 3-4.
The ignored portions of the template help solve two problems, the problem of overlap, and the problem of nonuniformity of features. Consider a note head with and without a staff line going through it. When a staff line goes through a note head, the part of the note head which is black stays black. But white surroundings and the white area in the head change. The staff line either goes through the center of the note head, or doesn't go through it. By using a template with don't-care values in places where a staff line might overlap, the same template can find a feature whether or not it is covered by a staff line.

Black template White template Don't care

Full template

Figure 3-5: A closer approximation to what the templates should be. The first three images show each part of the template, the last a composite, with the ignored section in grey.
Features are often near each other, with the black of a nearby mark covering an area nearby some other, for instance note heads which form part of a chord. When an occlusion occurs over part of the white space of an object, it is more difficult to use white space information, since any part of the white space might be covered by the nearby black. If features could be in any spatial relationship whatsoever, it might be impossible to use white space information, since you could never count on it being there. This is not the case in music scores.
The positions of marks on the music score have very specific relationships to each other. Staff lines either go through the center of note heads, or appear at the edges. Rests always appear in the same position relative to the staff lines. Note heads appear near each other in chords, but only in certain positions relative to each other. By ignoring the portions of white space where there might be an occluding object, we make the rest of the white space usable in helping to distinguish between features.
It was not obvious how much white space to include in the template. In some cases the choice was limited since other marks were likely to be nearby, forcing the use of ignores. My first (wrong) intuition was to use quite a bit of white space - several times the black area - surrounding each object as part of the template. The reasoning was that the white surroundings would form a large unique template. But doing so overemphasized the importance
40

Figure 3-6: Examples of the neighborhood of a note head, showing that the assumption that there is white surrounding a note head is inadequate.
of the white template. Because how well the template matches is the sum of the white matches and the black matches, the relative importance of the black matches was lessened by the many potential white matches. I found that about a fifty/fifty mixture of white and black was optimal. Many times this ratio was not achieved, as the ignored template values limited the total amount of white space.
3.3 Using Portions of Large Features
In some cases a feature is rather large, as in the case of the word crescendo. When this is the case, a smaller portion of the whole is used as a template, for two reasons. Since the time to do the template matching is proportional to the area of the template, the code runs quicker with a smaller template. Second, the extra border needed at the edge of slices 3 needs to be as large as the largest feature in order that a feature not be missed. By keeping the features smaller, less space is wasted.
When choosing a smaller portion of a feature one must take care not to choose a part which could be mistaken for some other feature, or a part which is duplicated in the feature itself, or false feature positions will be reported. When the feature for the alto clef was chosen to be upper half of the clef, the template sometimes matched twice, once to the lower half and once to the upper half. I replaced it with slightly more than half of the clef, and the problem disappeared.
3slices are defined and discussed in the chapter on connection machine concepts
41

Full feature
Portion used
Figure 3-7: On large features, only a unique subportion is used.
3.4 Template Scores and Thresholds
If the scanned image were perfect, then it would be simple to decide at which points a feature occurred. They would simply be the points where the surroundings of that point exactly matched the template, pixel for pixel. Since the image is never perfect, the criterion for matching has to be something other than an exact match.
The template score is the number template elements which matched the scanned image, excluding ignores. Ignored points do not affect the score at all. Instead of asking that the score be perfect, a threshold is used to decide if a point matches a feature. Places with a score greater than the threshold are accepted as matching.
There are two issues associated with use of a threshold. First, threshold values need to be chosen. If the threshold is too low, then many places where there is no feature are matched. If the threshold is too high then some features are missed. Second, if the threshold is less than perfect, then slightly shifting the template yields a score which also might exceed the threshold.
After some experimentation with choice of threshold, I found that a threshold which was eighty five percent of the total possible score of a template was a reasonable choice. The fact that this threshold percentage was adequate for most of the features was a surprise to me, and undoubtably had something to do with how I adjusted the templates. I think that there is something interesting in this fact, but have not investigated it in detail.
When this threshold is applied to the result of the matching, a small cluster of points around where the feature was located scored high enough to pass the threshold. This is because most shapes, when only shifted slightly in position, look a lot like themselves. In order that the program didn't think that there were many note heads in a small area, each of these clusters had to be reduced to a single point representative of the position of the feature.
I experimented with several different methods for doing this. One method is to average of the positions of
42

all the points in the cluster, weighted by score. Another is to choose the point in the cluster with maximum score. The major problem with these two methods is that they are both functions defined on a connected region, and computing a connected region is time consuming. Instead of these I chose a slightly less accurate, but local method, in which a point was considered a representative position if it was a local maxima. While this method occasionally allowed for superfluous points, these are easily removed at a later processing stage.

3.5 Creating the Templates
I created the feature templates by hand. I inspected displayed images of the score using a bitmap editor and selected portions which defined typical features. Then I edited the templates to remove noise and to specify don't care pixels. I used the resultant template to find features and see where it failed. After analysis of failures I was adjusted the feature until it worked well enough.

(make-instance 'feature-model :documentation "from 97" :threshold NIL :points '((1 :pitch-center "*")) :pretty-name "half note" :string-description '("================********========" "==============***********=======" "============**************======" "----------*********-----***-----" "-----...-********-------***-----" "-----..********---------***-----" "-----,********----------***-----" "-----********----------****-----" ".....*******..........*****....." "=====*****===========*****======" "====*****=======1===******======" ".....****==========******=======" "-----***----------*******-------" "-----***---------*******--------" "-----***-------********---------" "......****...*********.........." "======**************============" "=======***********==============" "================================") )

x
pitch-center

Figure 3-8: The lisp representation of a feature.

I was not able to adjust the template and threshold so that all and only features of the desired shape were found. Either some would be missed, or others found where there were in fact not any. When I could, I adjusted the feature until it tended to find all features of the desired type, and as few extras as possible. I did this since it seemed likely that I could rule out a feature which was in a place it shouldn't be more easily than hypothesizing it

43

to be in a place where it might be. Though features are indivisible objects from the point of view of the finding algorithm, they have parts, and
these parts are necessary in later attempts to assemble the score. For a note head, the center point the head is important, since it is the position of the center on the staff that determines the pitch of a note. On a clef there is typically a spot whose placement determines what transposition to use. In such cases templates were augmented by giving symbolic names to whatever points would be useful in later computation. Figure 3-8 shows the representation of a half note.
3.6 Future Work
Though these methods work well in finding features, despite overlap and connection between them, they seems unsatisfying from a cognitive point of view. Were this same algorithm implemented in the brain its time or space requirements would be proportional to the number of features we know. The older we became, the longer it would take to recognize objects. Further, this algorithm is sensitive to the size of a feature, yet we seem able to recognize features despite their size. It would be worthwhile to do some work in making a more cognitively plausible implementation.
On a more mundane level some automation of the template acquisition would be beneficial, and also might make it possible to more easily use this work for scores printed by other publishers. One idea is to start with a rough shape of the object and refine it with search, first through size space, and later through shape space. This might be a time consuming process but only needs to be once for each publisher, after which the templates can be used for a large corpus of music.
3.7 The Code
3.7.1 Top level code for finding features
This is the top level code for finding all of the features on a given page. It is complicated by the fact that the page is divided into a number of slices. After each of the slices is processed the coordinates of the found features need to be adjusted to be in the coordinate system of the full page.
(de(fuun((nfcleomcsrshm:ae(atccttkmat-c:hi"af)-~tts%(ac*cFachotoetrldged)or-btbrotaoointa)etdt(asc(ehtcqm-c-amimtt-aaimcgheaingimge a(aginmed)a*gceo-ltdo--bcomotiimnga"g)e cm-image))
(an(dsetmqoivmieapge(u*nlalessts-i*m8a-gbeit--tdoi-spcmlay-*im(aingiet*ia))lize-display))))
44

(de(fwu(hnseecntoq(enrfuecalelt-ufteroae-tsuf(ereaasct)cuerpets-'(lissetqu(efenacteurfeesa)ture-model) :prompt "Find which features?")))
(wh(seentq(ofrea(tsutrreinsg(p fneda-tfueraetsu)re(kfeeyawtuorredsp)))features)) f(ewa(htuseernetqs()afteoamturfeesat(ulirsets)features)))

(defun (and

local-positions-to-recognized
local-positions

(featupreer-croolwumhnei-gshttarwt irdotwh-lsotcaarlt-ppeors-itcioolnusm) n

(loop fffwfoooohrrrrerrrcneeooaawlull(--mbarcnoeoniwdlnubgm(=e<itnn(hrg+e=owtra(hor+erwpaecayrror--orlewrauolyme-w-msn)etelaec(nrmot<t)lseucnomotflsnu(-mossefntca(orpnte)rdsr-tlcolooclcaualm-l-pnpo)ossititioionns)s)

(< real-row height) (< real-column width))

collect (make-instance 'ba:::smrrieecddy--uurccfeeeecaddot--guyxnreizrreeefeaadall---tfrcueooraweltu)u)m))ren

(defun nd-features-on-sheet (&opti(&&s(olvikaimncpeuaey-xalssg((eeftr(ee(c(aspmuptvulv-tarasiremr-s-(gavm*egpatae-flkls-*ceefml-taehas-cattmi-sumhir-mea-ismgta*aeg)abe:gli-eme))t))oa-gtoce)mt)a)*l-)to-do (progress 0)
(((ssceehtteqqckft-eoaitfta-uls-rcetaost-t(decroober(ra*cine(-el(dteionf((c-gsmalftleepihnc-apegtiflmsuteyharae't*gssul-eri(celii*essm)sat)rarfgeaeay)t-udriems)e)nsions cm-image))))) (*w(ti(vth:len-toat(lil(n-vgva-plip-drs-oexgt-rvelipsms--istaelt(t-era(bcaler-*ncouterre(n"t"-)cm-con guration*) (pvar-getf cm-image :extra-border)))
(loo;;p(g-veoatvlierdir-d-yso-liflcimseosimt((sel-incoe(icscaemdfr-oi*rmcnuaorgwree)nt-cm-con guration*) (pvar-getf cm-image :extra-border)))) (wh((fleoonor-p(vsiflsiocurea-fl-mintyefpmeeabsteu(rrimeslsiacwgesei)t-htop-afrbtiasllicdeo)) (((ttsnvv(e::t-ilfnqoo"crpto~mealAu-ratmpti~-ranAopl-gr(eobrlenoygsdcrs~eascA(l-soi,-npluntcoomfosptipnteirl-oeosnfgttsra-e(rstt~so)a)-,~rrteooacw)toa"-gl-sn(ttipaozrre-etddtctoyfo)-lcvunoamalluimdnm--eysnt-f-)alsritm(t)a-rittriormowwa-g-eens-tdahrertoigwvha-tlsiditma-rxat-)gleim-witidth (setf (gethash (f rnesdu-lbtsa)sic(-nmcoondcepl asrlitciaelf)())gethash f results)))))) (make-instance 'page-of-features :result-table results :image image)))))

3.7.2 Top level Convolution of a Feature with a Slice
(de"favpaprr*oxciomnavtoelvraed-ipuesaikn-pmixaexlsimofuamc-ornavdoiulust*io2n peak")

45

(de"(flFeuitnnd((nacoldln-ovbc-acsuscirocar-nemc-esosizdeoef(lfi(ensatletiucgereerm-oloenndsgellti)che"(send model :total-bits))))
(*(l((e*wctoth((y(nee((pvxnnsmeotcdlr(oa(v-a*rtsemcecoc-thor-af(eerxsm!esa!iinmtacn0ugtoi)arllc)nee!h!msv)e)s-msals)itccaceothrcmeehs-oesssdi)cz)eo)e)lr))me (*amctcoahntecvshoelsvsceot-r))pe)eak-maximum-radius*)
3.7.3 Convolution - Scanning Method
The first method method described is implemented in the function convolve-feature-slower. Slice is a portion of the input image, model a feature model object, matches is a boolean which, upon exit from the routine will be t
wherever the convolution has scored above threshold. Score is a variable to be used to accumulate the convolution.
The feature model contains a number of pieces of information about the feature being looked for. model-zeros and model-ones are two bit arrays which are positive where the feature model expects a zero or a one respectively. The model also supplies width and height.
PThe loop is best understood from the point of view a single processor at a pixel . The pixels which contribute
to a match at itself, lie downward and to the right. Imagine a sheet onto which the values of all the pixels have
been copied (the variable movable-slice). In order to have all those pixels pass by P one first pulls the sheet to
the left, as far as necessary to complete on row, then slides it upward a row, and pulls it in the opposite direction
until the end of that row, and so on. In the code moving-left keeps track of which direction the sheet is currently
going.
At each step of loop, one gets the value of looking-for from the feature model, compares it to the pixel which currently lies on top of P, and increments score accordingly. The functions left!! and right!! move the sheet.
Finally after all the accumulating is done, the model is asked for a threshold, which is a number of matches necessary to have the pixel considered likely to have the feature nearby.
POf course nothing changes if, instead of imagining a single processor , there was a processor at every pixel,
which is case on the connection machine. So the convolution gets done in time proportional to the area of the feature model.
46

(de(f*ulonccaollny-vtoylpvee-(f:efaasttu(r(es-lsicloewmeartc(hsleics)e tm)o(dseclormea:tcehled)s)score)

(*l(((e***ttss(y(eelo(pttmoesmpco(oavmwfrtoaeciorbthhv(lreeao!s-!wbwsnl0ieldi)if-l)ctr!ehos!)lmis=cleic0(ets))re))enpdeamt ohdeeigl h:wt idth) and height = (send model :height)

(loopwwwdwoiiiiffttttoohhhhrr for

mmmmoooaxvddcieenoll--gl -zo=enlerewfostsid===tht((sseenndd mmooddeell::ozneerso)s) column from 0 repeat width clooolukmingn--tfoor-d=o(=co(nidf m((opvluinsgp-(leafrtecfomluomdenl-(o-nmesarxocwol

ccoolulummnn-t1o))-do))

'ones)

((plusp (aref model-zeros row column-to-do)) 'zeros)

((*i((f(scwimefa((((t(hmsozo***emeednvssnworoeeeiloonvohttslvsigooenmma(-onk(g*blki*oo-enlsmiesvvflengete-aatag-ftsbbtt-mflcllmiofeechora--eaertsstsc(llciihbcc(heeee*eslsso((emwlr(teing!ofs!tohvc!tatmo!!!br!!moel(emvmot-(avo1osnbalv+viliblecaa)!)-e!lbbe)s)lls-eelcis--colsesirc)lle)iie)cc))e))e)))))))))

(se((t**qsseemtt ommvioonvvgaa-bbllleeef--tss(lliinccoeet((mrleigfothv!ti!n!!mg-molveoafvtb)a)l)be)l-es-lsicliec))e)))

((*fosre-tvmisuaatcl-hteysp(es>!(!rsacinobreow(!-!sic(asleen-dtom-fobdseclo:rtehr(essehnodld)m)))o))del :threshold)))

3.7.4 Convolution - Packing Method (faster)
The faster method for convolving incorporates a number of optimizations. In order to minimize communication time, the bits are first compacted upwards so that a feature is represented in a line of 30 or so bit fields, instead of an area of 1 bit fields. The communications speeds up because there is a constant overhead for each communications
+cycle which is greater than the time spent communicating a single bit. Using this method we make length height
communications, instead of length height. The compacted bit patterns are precomputed on the front end and are stored in the feature model.
A second optimization is to write the inner part of the loop in paris, a lower level language for the connection machine.
A third optimization is to periodically check if the number of template elements can't possibly be enough to cross the threshold in any of the processors. When this happens we can cease computing. This is most useful when looking for sparse features such as clefs and dynamics.

47

(de("fmTuhnuilstcioptinlmev-eovlapvlaeuc-ek-febhaiontrduizro(enwt(iadslltihcbeiltosmoiokn-dtoemlaamsskaintccgahlreees-mescldao,srkeant&odatatuhlx-ebnloitgist)weriadtteh olovgetrohteailgbhitts")

((ss(eeftteqqatlloouggretw-oitpdaatlhcbki(t-sipn(ateirnagtmeerge-etleer-rnslgetmnhgotwdhiedlt)toht)a)l-bits))

(*l(o*cl(ae*tlltyy(-(((ptppteyeaapm(cc(ekkppee(add(:c--f!ak!esee0tdll)-dd)()-s(lsei!ucl!dem0t1)e))(m!!(pm0)))awtcidhtehs)t)(p(ascckoerde-loegltdo-tsaulbmitsl)o)gwidth))

(w(i(((t**ldhosso(-oeectlpttiom(mc+spf:acoeagpotsrceiarkotl(eco-enikdof(s(er-k!od1(!m--bp0eae)l-w)dicennklidgdesew-ltdithcl-sho)e)-e)caealilwdr1ra)apyyas(--c+ek1leelpdma-cekneetldds--osfeullmdo-olskoc-comrie)ast0kem:up)pward 1))

for for

cbaitrse-bsoe-infgart=he0atrhraeyn-(e+lembietsn-tssoo-ffacrar(el-omgcaosuknt

care))

(andwdfo((oirztwheihtreoceranpnf(r(tom>mmi(os-ds1

= (- total-bits (scl:send model :threshold)) itbeitrs4-)s)o-;;faerve(rcym4:gsleoebmals-un-omt taox-im1lpsocsoeret-olooclalroggetoataplebnitasl)t)y

cantmiss)

(go si:end-loop)))

(((cccmmm:::luloo-gglaeoqngvdc-o-cucoonnnt-sstt2aa-nn2ttl--p32a--c11kllettdee-mmppe-l-dllo-ocscupcmaa-rcekloewcdi-dtetmeh)ldp--lloocc

look width) logwidth width)

((*fosre-t((vccmimmsscua::oatgurcl-e-eht-ate-yldsofpdrc(eo-s>m3s!c(-!-or3snarlceieno-wbrloeso-cw(ap!-l!wasc(caaktyhelsede---1tloxep-nlafdubc-mksseucd(mo-src-ele:lo(sldescn-clldl:oosgcmetnopodtadacmelklboei:tdtdsh-erlleoe:sgtlhodtoot-altldoal)-)lc)bb))ii1ttss:))ul)o)p)g)w)wairddthw))i)dth)

3.7.5 Finding the Convolution Peaks
A point is considered to be part of the peak if it is a local maxima. This method was chosen to be fast, and involves
communication over a small number of processors. spiral-deltas computes a series of incremental moves by 1
in either the x or y direction which taken in sequence can move a copy of the data nearby a processor over the
center one. extract-singles gets a representation of the points where the feature was found. Initially the points
are scattered on a 2d surface. The routine sends them so that they are adjacent in a 1d geometry and then uses a
starlisp function to copy them to an array on the front end.
(defvar *convolve-max-blobs-per-slice* 500
"oAnrbaitsrianrgylempaaxgime.uImf mnuomrebtehranoftfheiasttuhreersefoisupnrdobably an error")
(defvar *convolve-max-blobs-length* (integer-length *convolve-max-blobs-per-slice*))

48

(de"fhscpaavicreahleeddaecslhtpapisrraorlec-tedusersnoltsraaisnl(ia(strbaoodfxiuloiss)f)tsw(iddtxh

d2yr)+w1hibche

when used brought to

with news instructions the central processor"

(fl(eltet(((d((lsuop(ollipocaoftoper-fioerbleermloferwonmtti(m1eeletsomcreoanldlteicuttisminges)element)))

nnncwocccitooollhennnccccdti(((r(edddacuuurtpppeiofllliiincccdaaasirttte=eeec---(teeeivllloeeeenmmmcsteeeo3nnnr)ttt'((((1aaarrr0eee)fff

'(0 1) '(-1 0) '(0 -1))

directions ddiirreeccttiioonnss

102)))

(((**1-rr

(22*))))r

2)))

s))) nconc (duplicate-element (aref directions 3) (* r 2)))))

(defun nd-maxima (places score &optional (radius 2) &aux (conv-score-size (pvar-length score)))

(*l(ole(ct*a*llley(t-((td(yidpie-s(i(z:fiefa!s(!t*p(wlpahlceaencseps(l1at)+c!e(!ss(c(-oin!r!etescgcoeonrr-evl-e(sn!c!got(rh*e-m(s1iizn+e)s()c-or(e*)))m)a(x!!sc0o))r)e) (*min score)))))))

;(;*itsyonpleaeitg(eh(pbnoeoisrg)shibbloerpdeiak)s di -size))

((*fo(ar*l-lsveitsunaeli-gthybpoers

(image-to-fb di )

places))

(loop fdoor(((**dssxeettdpyn)leaicignehsb((soparnir(dan!l-e!wdpeslal!t!caensseri(ag>dh=ibu!os!)rddi x dnye)i)ghbor))))

;; a typical error mode is that two adjacent pixels are selected. Clean this up here

(*when (or!! (above!! places) (left!! places)) (*set places nil!!))

(for-visual-types (image-to-fb (not!! places)))

)))))

(de"fpuunlleoxuttratchte-xsianngdletsh(epylaccoeso)rdinated of each selected processor, and return
;;ansoawliostnloyfotnweopvreoccteosrsso,ropneerobfloxbcoisosredliencatteeds and one of y" (*l(o*cw(a*hlll((yee*ln-tettty(py(cp(ploe(aeenhoc(euro(des(mwnpsmule(amna!c!nte-*ys0cbc))tool)o)onbrvdso)lv(e*-smumax(-!b!lo1b))s))-length*) ((coord sent-coord) :cube))
(cond ((((>pluhsopwhmoawnmybalnoybbslo*bcso)nvolve-max-blobs-per-slice*) (break)) ((*le(st*ewt(((yietx-nh-vu-vemxec-ctato(onrerdn(-u(mymma(eakrxkeae-ty-ae)ar!rr!)ar)ayyhhoowwmmaannyybblolobbs)s)))) ((**psestetco:noord-cxo)llisions coord sent-coord enum) (pvar-to-array sent-coord x-vector :cube-address-end howmanyblobs) (((**ppsveaster-tcto:ono-orad-rcryoa)yllissieonnts-ccoooorrdd ys-envte-cctooror:dcuebneu-mad)dress-end howmanyblobs) (list x-vector y-vector)
)))))))))

49

3.7.6 Feature Model Flavor Definition
The feature model is an object which contains all information pertinant to a feature, including dimensions, geometry annotations and cached values for bit strings needed in the convolution routines.
(defparameter *feature-white-character* #\-) (defparameter *feature-black-character* #\*)
(defparameter *feature-content-characters* (list *feature-black-character* *feature-white-character*))
(defvar *all-features* nil) (de avo(rthfreeashtuorlde-dmocoudmelentation pretty-name
;o;nceosozredrionsatleooakreingw-rtfotrolotookp-lemftacsokrncaerrex-mrigashkt (ytdootawl-nb. its 0) points width height black-top black-left black-bottom black-right (full-feature nil) full-feature-o set) (((::sg:::eiriennetttiiqtttaau-abbibkrlleeleee-y(d--)wi-ininniosnssrttitdataa-snnnkcc:ceeseety---rwvvivnaoaagrrrriid-aiaasdbbbell:elessescsts)rriitpnhptgrri-oeetdsnth)eyos-cldnriapdmtoioecnup)moiennttsatfiuolnl-feature full-feature-o set)
3.7.7 Geometry Information for Feature Models
These routines supply information about the shape, size and annotated point in a feature.
(de(fdmeceltahroed(v(aplouienstx-pyo))sition-maybe feature-model) (point-label)
(l(etva(l(ufeosun(cdd(darsfsooucnpd)oin(tc-aldarbefol upnodi)n))t)s)))
(defmethod (some-point-position feature-model) (&rest point-labels)
(loop ffwoohrrelfnoinufnopduoni=dnt(d-aolsasb(orecelstluprnoi(nvtsa)lues (cddr found) (cadr found)))))
(de((fdcmaesceeltahproeodi(nv(ta-pllouaiebnsetlx-pyo))sition feature-model) (point-label)
(((:::rlteiogfptht((vv(aavllauuleeussesb(l/balca(k+c-klb-elrfaitgc(hk-/t l(e(f/+t (bb+llaabcckkla--ctrkoig-phtotb)pla2bc.kl0a-)cbkbo-ltabtcooktm-to)tom2p).))0)2)).0))) ((::cbeonttteorm(v(avlauleuses(/(/(+(+blbalcakc-k-lelfetftblbalcakc-k-rirgihgth)t)2.20.)0)(/bla(c+k-blbaoctkt-otmo)p) black-bottom) 2.0))) (ot(hl(e(etavrwas(sl(iuesfreeotsufn(odcudn(ddars(fsopouocninpdt)osin(ptco-aildnartb-eflolaubpneodli))n))t")s)))c)o)uldn't nd label ~A in ~A" point-label pretty-name)
(de(fdmeceltahroed(v(ablluaecskt-obpoluenftdsboftetaotmurreig-hmt)o)del) ()
(values black-top black-left black-bottom black-right))
50

(de(fvmaleutehsowdi(dftehaltouorke--mpaacskk-cpaarer-ammaestkertsotfaela-tbuitrse))-model) ()

3.7.8 Interface for Feature Models
(de(funnd-infd(-fe(af)tu(rsetr(innga-meqeu&aalux(p(rneattmy-en(asmtreinfg) nnaammee))):end1 (length name))) *all-features*)) (de((fiwfuin(thsst-hrrioonwogmp-f-ietf)aotr(-usgreertaq(pitiht&ic(ospn(tdsiot-rnfeaeaalmt(usr(terseeiant)md))i*ts:thaenigdhart)d)-output*) location)
(itp))resent it 'feature-model :stream stream :location location)
(de(fdmraewth-oimd a(gderafuwll-fefeaattuurree:o-(pm+aqoxude(ecl)nairl(:xfaulylul-&afoeluap)tt)uiorne-alo(aselut)):d(ra+wy))(second full-feature-o set)) (defmethod (pretty-name feature-model) () pretty-name) (defmethod (sys:print-self feature-model) (stream &rest ignore)
(if(((dfomrramewma-btimesrtar:gedearmaown"-e:ts#1r<a-0nFbsiet0fa-ot:rrusmatrserte`e(mar1mo(0dsseet0nlrdef-ao1smrt0~reaa,>hm"eigp:whreth)t)itcyh--noapmerea))t)ions))
(de`(fmnedt-hfoedat(u:rfeas'd,p-rfeottrym-nfaemateu))re-model) ()
3.7.9 Construction of a Feature Model

The magic 85 percent threshold is supplied here, if one is not supplied in the feature definition.

(defmethod (make-instance feature-model :after) (&key string-description &allow-other-keys)

((mchuelct(kicp-olienn-titevsnatlsu-eebl-fobsuitnnriddnsg(-sedrlesftss-ctrrrioipnwtgio-lands)ets-crroipwtiorns)t-column last-column)

(((gsseerttoqqk-whpeiodigitnhhtts((1s1e++lf((s--trlialnasgstt---dcroeoslwucmripnrtsito-rnsrot-wrc)s)ot)-lurmown)))rst-column)

(if(fcuollm-fpeuatteu-rbelack-bounds self full-feature

(compute-black-bounds self((--strirrnssgtt---rcdooewlsucmr(ispnetci(oocnnadr rffsuutll-ll--cffoeelaauttmuurrnee--oorstss-eertt)o)))w)))

(((((uuchrnpa(llensl-daeedaistntltesqe-e--(a-atfrafhrurenrralaaeldy-tyssufshterhoseaserle-tdelluflsfi)rh(ssetrtoorlssiduneenlgl(ffd)-)>))d(te*hscr(eroisphrtotiolhdnre1s)h)rsotl-dro.8w5)

rst-column last-column) total-bits))))

3.7.10 Parsing the marked points in a feature
The annotated points are represented by an association list pairing character to name and replacement character. When character appears in the representation, the coordinate is noted, and the replacement character is put into the representation (so as not to leave a blank).

51

(de(ffmletet(h(ot(odc-o(cnghdraor((k(n-tuphmoinibgn)etrsp

feature-model) (string-description rst-column rst-row
thing) (coerce (format nil "~A" thing) 'character))

&aux

result)

((((((nssyturmlilnbgtohplipntght)ihningn)igl))(c(oceorecreceth(isntgrin'cghathraincgt)er)')character))

(setq

p(looionpts((fc(otocrl(hle(eacorrtrraioincgrtgine"ra(cplloisutttohldki(nnetg'not)-rcetghhpuailnarrcgeo)e)oriugitninwaplho)ainttotsckheanra(cttoe-rc~haSr

should be" replace))))

thing)))))

(flet

((g(leoto-ppofffiooonrrrtsplsi-tnorfesirniotfgmirooin-nms=ts0rti(rni(spngtogrs(is-n(ictdg)si)etosr(nicsn-regiitpf-qtdiowenshcaritp(ticoanr

o set-x o set-y &aux what) (member c points :test 'char=

:key

'car))))

when position

do ((wsheetfn((atrheifrdstwrinhgat)position) (third what)))

((sweh(tqseentpqfouirnlel-tssfueln(ataaatn(pluldgypreeec(tno-rdleplteoruceirtnsnut(slcrt-eofs(nrugoslemt()t)-s)-)epsctooriinnndtgss-wffhruoall((mt-)--f-e(sactrrtrossuittnnr--esgrcsoo(w-lsutmrl(iinnsneegc-(oodnerdsssetcftruf-iuplyllt)-li-fo(efnea-attupurrosertse--i-tociooonsluseemot)t)))n))s)etr-sxt)-))roiwn)t)o))))result

3.7.11 Computing the Bounds of Feature

(de(flemt*eth((odrs(tc-oronwten(tp-obsoituionnd-siffe(at(us)re(-hmaso-dseolm) e(-sctroinntge-ndtesscerlfipst))ions)tring-description))
((larsstt--rcoowlu(mpnos(itaipopnl-yif'm(in(s()m(ahpacsa-rso(m(es-)co(ncotennttenste-lfstsa))rtssterilnfgs-))desstcrirnipgt-idoensc:frriopmtio-ne))n)d t)) (valu(elsastr-sct-olruomwnla(sat-pprolyw'mrastx-(comluampcnarla(st-(cs)ol(ucmonn)t))ent-end self s)) string-description))))

(defmethod (c(ostmripnugt-ed-ebslcarcipkt-iboonulnedfts tfoepat&uareu-xm(ocd(elli)st *feature-black-character*)))

(setq b(-lac(kp-otsoitpion-if ( (s) (has-some-content self s c)) string-description) top))

(setq (setq

bb(-llaacc(kkp--oblseoiftttitoonm-if

(

(s)

(has-some-content

self

s

c))

string-description

:from-end

t)

top))

(setq

b((--lac((kaa-pprppigllyyht''mmainx

(mapcar (mapcar

( (

(s) (s)

(content-start (content-end

self s c)) string-description)) self s c)) string-description))

left)) left)))

(defmethod ( nd-if (

((h(csa)tsr-(insmogme&meo-bpcetorioncntaeclnotn(ctfeoenanttt-uecnreht--amrcahocatdreaerlc)ste:trses*t f'ecahtaurr=e)-)csotnrtinegn)t)-characters*))

(defmethod (c(ostnrtienngt-&sotpatritonfeaalt(ucroe-nmtenotd-ecl)haracters *feature-content-characters*)) (or (position-if ( (c) (member c content-characters :test 'char=)) string) most-positive- xnum))

(de(fomr e(mtphooosstdi-tin(oce(nogs-tnairfttiienv(nget--(&ceo)xnpndt(uimomfene)aa)mtlub(rceeo-rnmcteocndoten-lt)cehnat-racchtaerrasct*efresat:uterest-c'ochnater=n)t)-cshtrairnagct:efrros*m))-end t)

52

3.7.12 Creating the Black and White Arrays

This is where the compacted bit strings are created for the fast version of the convolution.

(de(flemte(t(hwoiddt(hc3r2ea(t*e-3a2rr(acyesilifnegawtuidreth-m32o))d))el) ()
(((ssseeetttqqq lzooenoreokssin((gmm-afaokkree-(-amarrrarakayey-((alilrsirstatyhhe(eigilgihshttthwweiidigdththht33w22)i)d:t:ehelel3em2m)een:nitnt--itttyiyapple-ee'l'bebimtit:e:innintititniaiiall-l)-)e)elelemmeenntt00)))) (setq look-mask (make-array height)) (setq care-mask (make-array height)))

(defmethod ( ll-in-arrays feature-model) (string-description rst-row rst-column last-column)

(loop

for for

si tbrienlogwinh(eingthhtcdr

rst-row string-description)

(loopffdooofrroclroacorekbe==in00g the array-elements of string from rst-column to last-column

for j from 0

(conddo((((csseehttaffr=((aacrree*ff foleoanotekusirnei g-j)-bfl1oa)rcki-j)ch1a)racter*)

(((sisneecttqfq tclooatoraekl-((blloiotggs)iioorr cloaorek ((aasshh 11 jj)))))))

((sseettff ((aarr(ee((((ffcsisncleehoacttaoqffrrek=t(-c-oaammctrraeea*alf-ssf(klekbolaoioiit)t)gsku)iicrolnoearg-orc-ewk)a)f)hor)eirtei(-aj)cshh0a)1rajc))t)e))r)*) (setf (aref zeros i j) 1)

3.7.13 Handle the Case Where a Full Feature is Specified

When a portion of a feature is used, the full bitmap of the feature can also be specified. This is useful for two

reasons: 1) For debugging purposes the full feature can be plotted, and 2) Because some of the annotated points

may be outside the bounds of the portion.

(de(fifm((fspeuetr(lthols-qogeftndefqua(ltflhu-uarflelen-adfteluaert-eufru(emllo-anfkeeeas-)tfuurlle-ffeeaattuureres-emlf ofudlel-l)fe(a)ture))
(setq full-feature-o set '(0 0)))))

(de(fl(emtlo*eot((h(phf(uoewfldilog-irdh(ftemtshat(rtai(lunke*rgneeg-3i(tfn2hum(sllsatc-trkerifeniieln-iganga-tg-rdurdea(reseylseccnrf(rieglpiiapstthtttioiuohn(rnece)ia)-grmhtsotwrdiniedglt)-hd)(es:stecrlirenimpgt-eiodnnet)-s)ctry3ipp2et))i)o'bni)t :initial-element 0 )))

(loopfdoofroir

from 0 c being

the

array-elements

of

string

for j from 0

(whedno(char= c *feature-black-character*) (setf (aref full-feature i j) 1))))

full-feature))

53

3.7.14 Bookeeping and Error Checking
(defmethod (check-inits feature-model) (string-description)
(assert ("athpeplsytr#in'=gs(minatphcearst'rliennggtdhessctrriipntgi-ondesshcroiupltdioan)l)lbe()the same length") (check-type threshold (or null (number 0 *))) )
(defmethod (update-feature-list feature-model) ()
(setq *all-features* (delete-if ( (f) (string= (pretty-name f) pretty-name)) *all-features*)) (push self *all-features*) (setq *all-features* (sort *:kaelyl-(fea(tfu)re(sp*re#t'tsyt-rninagm<e f)))))
3.7.15 Definition of a Recognized Feature

A recognized feature is an instance of a feature found on the score. As such it keeps a pointer to the feature model,

and information about where the feature is found. We redefine methods for getting geometry information which

translate the positions to the coordinate system of the page.

(de:::signeeittatttavaabobblrlelee-b(--iuainintnssisisltct-taa-amnnnrcecicexece-i-no-vvvgahaanrarriiiasiaza-bbebrlldeleees-lssa)fteioantus rheas(-(msuyrr-ofueantduinregsnisl)ys(:prerodpuecretdy--xlisnti-l)m(ixreind)uced-y nil))

(defmethod (sys:print-self basic-recognized-feature) (stream &rest ignore)
(format stream "#<~A at (~A,~A)>" (pretty-name my-feature) ( oor reduced-x) ( oor reduced-y)))

(defmethod (draw basic-recognized-feature) (&rest args)
(apply 'draw my-feature reduced-x reduced-y args))

(de(fmmueltthipoled-(vpalouien-tb-ipnods(itxioyn) basic-recognized-feature) (point)
(v(apluoeinst(-+porseidtiuocnedm-yx-xf)ea(t+urreedpuocinetd)-y y))))

(de(fmm(uealtt(nhiapdopledpx-l(yvysa'olsumoem-ebe-i-pnpodoini(ntxt--ypp)oossiittiioonn

basic-recognized-feature)
my-feature points)

(&rest

points)

(values (+ reduced-x x) (+ reduced-y y)))))

(defmethod (point-position-maybe basic-recognized-feature) (point)
(mu(alt(nippdoleixn-tvy-apluoes-itbioinnd-m(xayyb)e my-feature point) (values (+ reduced-x x) (+ reduced-y y)))))

(de(f+m(estehnodd m(tyo-pfeabtausriec-:brelaccokg-ntoizpe)dr-efdeuacteudr-ey)))()

(de(f+m(estehnodd m(byo-ftetaotmureba:bsliacc-kr-ebcootgtnomiz)edr-edfeuacteudr-ey)))()

3.7.16 Definition of a Full Page of Features
This object contains a list of all the features of a given type which occured on a single page of the score. The draw
method here and elsewhere are used for debugging.

54

(de:::gsineeittatttavaabobblrlelee-p(--iuainintngsissltet-ta-aamnnonccifcex-ee-i-fn-ve)vvaaaartrriiauiaabrbbellelesesss()result-table image elements)

(de((fsmmetaeqpthheaolesdmh(e(mnt(asikg0en)-oirnesdt)an(cinecpf aegleem-oenf-tsfe(aletungreths)d())&)reresstuilgtn-otareb)le))

(de(ffmoremthaot dst(((rihefsaay(smszh:e-pr"troa#ipnb<tlFee-le-esacmetolufeurnnpettasN)greee"ts-wunolootf"r--ktfeaewlbeailmtteuh)ern~e(trhss))afes(ehasl-teturtmeraeabe~mnlept-,s&)c)~roeAusntitnigsrtneasonurcelt)e-~tpabfoleu)nd>"

(de(fwmiteht-hroodom(d-rfaowr-ipmaaggee-of-features) (&key (reduce-by 6))

(image :r:leadbuecle(-fboyrmreadtunciel-"b~yV features from ~A~ " '(:eurex :italic :huge) (send image :name))

(ma(ph(aigs:nhloarbeela-)object self)

(mapc ( nil))result-table)

(n)

(dw:(wdirtahw-onu))t)pua)t)-as-presentation

(:object

n

:type

'sys:expression)

55

Chapter 4
Locating Beams

Stems Beam

Note Heads
Secondary Ligatures Primary Ligature

Beam length

Slope Beam heights

Figure 4-1: Parts of a beamed set of notes.

4.1 Introduction
Beams connect the stems of a set of notes signifying that they are to be played as s single group. In most cases a beam defines the duration of the notes which it attaches. I'll call the whole object a beam. Each of the separate lines of which it is made will be called a ligature1. By length of a beam, I mean the distance between its leftmost and rightmost pixel, and by height, I mean the height at some particular point along the length of the beam (since
1This differs slightly with [8], who calls the complete object a beam, but also calls the individual lines primary and secondary beams, which doesn't adequately make the distinction between whole and part.
56

i ii iii

iv v
vi vii

viii

Figure 4-2: A sampling of beam shapes.

57

beams may have different numbers of ligatures at different points). At least one of the top and bottom edges of the beam is flat. At times I'll talk about the slope of the beam, and I'll mean the slope of the flat edge.
What is interesting about recognizing beams is that while their shapes do exhibit a regularity, that regularity is not obviously parametrizable. The task of recognizing them has two fundamental parts to it. First a representation of a beam needs to be designed - we need a precise way of describing and talking about it, and second, a method needs to be designed to recover this representation from the bit images.
Visually, beam shapes vary in their length, in their slope, and in the number of ligatures at various positions along the length of the beam. In terms of their surroundings they overlap staff lines but not measure lines, they have stems connecting them to note heads, and group together a number of note heads which typically lie at varying distances either above or below the beam, and occasionally on both sides.
In recovering beams from the score, we should keep in mind the tasks that need to be accomplished. These are threefold: Each beam must be associated with the set of note heads which it groups. Each note head needs to be assigned a duration which depends on the number of ligatures above or below it. Finally we need to check whether the beam has been correctly located, and resolve cases which are uncertain.
4.2 Representation
The representation which I chose is an intermediate representation, a compromise between a form which is reasonably well suited for creation from some transformation of the image, and a form which would anticipate all uses of the beam information. The hope is that it represents the visual information completely enough, but is in a form which is easy enough to manipulate so that representations can be easily built on top of it.
I considered several choices of representation before settling on one. For instance a representation as a series of boxes or parallelograms might have worked. Whenever I thought of the representation in terms of boxes, though, it seemed that this was too general a representation. All the boxes of the beam would have an edge which would be aligned with the others (along the top edge), but this fact would have to be grafted on to the box representation as an extra constraint, and would have to be explicitly checked for in any found beam. Also, any box representation would be ambiguous - there are several ways that a series of boxes could cover a beam, and any method for finding a beam would have to deal with this ambiguity.
My representation relies on beams having at least one flat top or bottom edge. The representation of the beam will root itself with respect to this line. The height of the beam at a given point can then be measured with respect to that line. This representation makes the assumption that one of the edges is in fact flat. While I believe that this is true of beams in general, and certainly is true of beams in the Schubert scores, I am not sure that this is true of all beams in common music notation. If beams are more complicated in other score then the algorithm will need to be rewritten.
58

There are two natural units for the representing the heights of the ligatures. One is height in pixels and the other is the number of ligatures. The latter is more interesting information, but is potentially harder to calculate. This is because one is not a priori sure that that the height of a single ligature is stable enough in the printed scores to rely on it, and because the slope of a beam is variable, the height of a ligature might vary as the slope changes.
Why might the height change? It depends on how the beams are produced. If we imagine a rectangular piece of metal which is tilted to produce the varying slope, then the height would increase as the absolute value of the slope increased. If on the other hand the production of a beam were considered a skewing of parallelogram, initially a rectangle, then the height would not change.
Fortunately it seems that in the Schubert scores we needn't worry about such intricacies. The beam height tends to be stable across pages, and the maximal slope of a beam is small enough that height changes due to angle shifts are not noticable, if present. So changing from units of pixels to ligatures is a matter of rounding to the nearest multiple of the standard beam height.
I said that the representation records the height along the length of the beam, and once again we have the issue of what unit of measure to use. In this case, however, no obvious unit presents itself. Beams for even the same type of tuplet can have radically varying lengths, since the material is typeset in reference to all the other staffs in a system. If there are few notes in other staffs then the beam will be short, if there are many the beam will be long.
The most desirable representation would be one which assigned a beam height to each head modified by it. But in order to do that we need to have interpreted much of the score by the time we interpret beams, and that hasn't been done yet. So instead the pixel scale was chosen, with the idea that at a later stage of interpretation it could be transformed to something else.
It doesn't make sense to record the beam height at each pixel along the vertical length of the beam, since it changes so slowly on a pixel scale. So, in order to conserve space, I chose to run-length encode the beam height along its length.
In summary, the representation of a beam will start with a line representing either the top or bottom edge. We'll record the slope and horizontal limits of this line, and an indication of whether it is the top or bottom of the beam. The heights of the beam are stored as a list of the height of the beam (in ligatures) and its horizontal extent (in pixels).
4.3 Finding the Beams
Given a more precise description of what is being looked for, we are ready to start discussing how to find the beams. The strategy is to disconnect the beam from other parts of the score, transform the beam into a single connected region, find the edges of that shape, and then do calculations with the edge points in order to compute the necessary parameters.
59

A fundamental idea used over and over again in this work is the idea of connectivity. Often a feature-finding algorithm starts by disconnecting the feature in question from other features. Then each connected region is labelled, and finally computations on these labelled regions work on distinguishing the features we are looking for from those that we don't care about.
Why is labelling important? Because while people can look at a blob of ink and identify it as a single object quite readily, that information is not explicit in a pixel representation. The process of labelling gives each connected object a unique identification, and gives each pixel, by access to that label, a method of determining which object it is part of. Once a unique label is given, we can collect all the points in a region, sort the points by region, and do other operations which facilitate computation on the feature.
Figure 4-3: A closeup of a digitized beam. In order to illustrate the tranformations more clearly, this beam is not from the score, but instead a more coarsely digitized example.
To disconnect the beams from the rest of the score I exploit a fact about the relative sizes of beam parts and their surrounding. Looked at with a squinted eye, beams look like large ink blobs, with other thin ink streaks running in and out of them. The strategy for disconnecting the beams is to erase the thin streaks, without disturbing the beam shape.
There are a couple of standard image processing methods for doing this. One idea for getting rid of the thin lines would be to conceptually erode the image at the edges, just to the point where the thin lines disappear (Figure 4-4. The problem with this is that in an erosion, the beam changes shape, since its own edges erode as well.
Or we could consider the frequency space representation of the image, and realize that the thin lines are the high frequency component of that image. By using a spatial filter, we might hope to filter out all the thin lines,
60

Figure 4-4: An unsuitable filtering technique: In erosion each pixel which is adjacent to a white pixel also becomes white. but not the beam shapes. But this method suffers from the same problem that the erosion method has; low pass filtering will remove important detail from the actual beam shapes as well.
Instead I use a filtering technique which envisions each pixel in the context of the consecutive attached vertical or horizontal run of which it is part of, and take the measure of its thickness as being the number of pixels in that consecutive run. So a pixel which is at the end of a run has the same measure as a pixel which is in the middle of a run, shown in Figure 4-5. By removing pixels which have a small measure, thin sections are removed without at all changing thicker sections.
Figure 4-5: The chosen filtering method, neighbor counting: Any pixel which has less than three horizontal neighbors in a row turns white.
The disconnection of beams from their surroundings is a matter executing this filter twice, first with a vertical 61

measure(Figure 4-6), and then with a horizontal one(Figure 4-7). As a side effect this filter also removes small objects of all sorts from the image. After this process, the only marks visible on the page are the beams, remnants of solid note heads, and remnants of treble clefs.
Figure 4-6: Beam after the vertical neighbor counting is done.
Figure 4-7: Beam after the horizontal neighbor counting is done. At this point different parts of the tuplet are disconnected.
The remnants do not cause a problem because they are easily distinguished from beams. Clefs are always in a position where beams are not possible, and there are not notes above or below a clef. Notes are easily removed
62

because note heads are always shorter than beams, since a beam covers at least two notes. As printed, the individual ligatures are often visible in the beam. Since we want each beam object to be a single
connected region, we need to do something to reconnect these segments. In this case, we can tolerate a small distortion of the beam. In order to reconnect the segments, each pixels blackens its white neighbors, a process called bleeding (see Figure 4-8). In this way, after a few iterations of this process the thin white space between ligatures is filled in, with the slight cost of broadening the beam slightly (Figure 4-9).
Figure 4-8: In bleeding each pixel which is adjacent to a black pixel also becomes black.
Figure 4-9: Beam after the bleed is applied. Note heads are still visible, but the beam region has been simplified. What remains is to calculate the edges(see Figure 4-10). The reason edges are calculated at all is that the 63

parameters which we want are easily expressable as functions on the edge points, and any function on edges will
be faster than functions on the whole area. Think of the edge points ordered by their x coordinate. Then for each x coordinate, we have at least two edge points - the top and the bottom. The set of points with maximal y for each x are the points on the top edge. The points with minimal y for each x are the bottom edge points, and height in pixels is the difference between these two, for each x.
Figure 4-11 illustrates the complete sequence. From the top are illustrated: a) The original score, b) the score after horizontal neighbor counting, c) the score after vertical neighbor counting, d) the score after the bleeding is done, and e) the edges of beams (before remnants are removed).
Figure 4-10: Edges of remaining areas. The details of the computation of the edges will be explained in later sections along with the code. The algorithm I use is adapted from a parallel region labelling based on that described originated by Willie Lim of Thinking Machines. Roughly, a linked list of the edge points is computed, then the points are identified as being part of the same edge by a marker spreading algorithm. The beauty of the algorithm is that it is very parallel. Creating the linked list (on a parallel machine), takes a constant number of steps, with the number of processors on the order of the number of points contained in the regions. The marker propagation step takes order of log the length of the longest border, with as many processors as there are edge points. Last of all the flat edge of the beam must be determined. To calculate this, the boundary points are sorted by
their x coordinate. For each x coordinate, the maximum and minimum y coordinate is calculated. Then a line is
fit to each of these sets. The set with the line that has the better goodness of fit (in 2 sense) is considered the flat edge.
64

a.
b.
c.
d.
e.
Figure 4-11: This sequence show how the successive beam filters transform the original digitized image. The image is from the top left corner of page 216 of the Schubert scores.
65

Top Best Fit Line

Bottom Best Fit Line

Figure 4-12: Best lines through the points constituting the top and bottom edges of the beam.
4.4 Future Work
The main weakness of this method of finding beams is its dependence on several variables which express the scale of the image - numbers which measure how thin something can be without being a beam and the thickness of a single ligature. I think that a method could be designed which computed some scale statistics on a new image in order to automatically calibrate these sizes.
Other than this dependence, I think that this approach should be transportable to other music scripts. Of course the challenge to undertake would be recognition of beams in handwritten scores. In handwritten scores the width of beams is somewhat more variable, and the beams themselves are often curved somewhat in the haste of writing. Still, I think that some of the ideas here might be a help, particularly the methods used to disconnect beams from their surroundings.
4.5 The Code
4.5.1 Top level
After writing the code for chains, I got frustrated with *defstruct, so I wrote an analog of de avor for *lisp, called *de avor. * avors act like regular avors, using *defmethod to defined methods. One extension to the flavors analogy is *leti, which allocates a *instance with dynamic extent.

66

(de(((f**uuw(wnn*laietl(rsehmlstno-od-ac((pml-bl--bo-lovoetipvemta)e-rmears-dgess-tel-i(im(co&edfaosvgcp-(metisimo-cnmaimlagt-leeair(-mgectedoma--g-iecm)im)maga2eg))ere*alal-sst)-image-to-cm*) &aux (boundary-points 0))
((binecafmb-oulntdera-rysl-icpeoirnetasl-(s*)when real-s (count-boundary-points real-s)))) (*l(e*tl(iel(to((i*os(lpee(-atcimobv(s(be::tpbreb::o-itcpacotomsmtaultbuilan-c-serldei-eab-msa-cmdbrova(rdi-pmeygsrbs--eyp-ops-rsleuopeteltenitsoanersd*imetenracseddtrsud-s-i-ber-ibrfobmsioeomuonr:aunu-stagnedn-sgedaladv)iemarcapyrer-ys-sysp-seeopta*ionmitnsst)s):)s)eams seams))
(((nccooewmm-ppsruleitcsese--bsboeoauumnnddsaacrrioyelsubmbppnc-sb)s)tart row-start column-end row-end) (for-visual-types (show-boundaries cb (send cb :next))) (*w(s)i)pthre-aadll--lvapb-eslectb)(send cb :vp-set) (*leti ((scan-bdry be:vapmsest-s(csaenn-dbcobun:dvpar-yse:tp)icture-vp-set *osr-image-set* :seams seams ((ibnliatniakl-izoeu-tf-roremgi-ocno:stm-owtparitel-hsbs-edwdri-yd-btpho-ouilnnedstass-r(ytshseacnnadns-ccbbadn:r-tyobtdcarbly)-b*dbreya-mpo-iwntids)t))h-minimum*) (((sfleootrr-t(-v(bitsyhu-ea-xl-bstecyaapmne-ssb((dserhxyo)trwa-cbt-obuenadmarsiesscascna-nb-dbryd)r))y))
((mmaapken-iiln'sctlaenacne-u'ppagthee--obf-eabmeasm) s :image (pvar-getf cm-image :image) :beams the-beams))
)))))))
4.5.2 Shape Parameters
(defvar *beam-basic-height* 15 "height in pixels of one beam width") (defvar *beam-width-minimum* 25) 4.6 Filtering Code
4.6.1 Computing Neighbor Counts
(de`(fmletac(r(o(hv-w-lelietnnhgg-tthnhe((i1g1+h+b((oinirnt-tecegogeeurr-n-ltelesnng(g(tthshli,c,hevrravanrnaggnee)g))))e))hrange) &body body)
(f,usnliccaell,-vwraitnhg-en,ehigrahnbgoer-counts ( ((*alobcoavlely--ctoyupnet (b:efaloswt -((caobuonvtel-ecfto-ucnotubnteloriwgh-tc-ocuonut)nt)v-length) ((left-count right-count) h-length)) ,(@igbnoodrye))a))b)ove-count below-count left-count right-count)
67

(defun funcall-with-neighbor-counts (sl(&icvae-ulxvenr(aghnt-ghlee(nh1gr+tahn(gi(ne1t+efug(neircn-ttileoegnnegrt-hlevnrgatnhgeh)r))a)nge)))
(*l(o*claetlly(-((((((((((((tfabrlssfffsseyrrrrittttbegoooofpiiiiltllllohmmmmolllle-----vtwc--e---cccc(o--oooocarlb:euficocnnnnbegafonounnnnltohsoutuneeeetvtswnnccccte(l(sitttttt!c(lseeeess!iell(ddddl!(ci)ii!0cc!ec!----!))!eee0rabl)))ei)00begt)f))))lto)h))o?vtw?es??lsiclssiellc)iicec)ee)) (*type ((((((safrabovomev-e-s-lleiccfoteuffnrrotommb-e-lroaigwbho-tvcesotufilrnlo-t)mco-vn-bnleeelncotwgetdhs-)tillelf-tc?onstniellc-tceodn-naebcotevde?-rsigtihllt-?c)ont)nected-below?) t) (((lfl((((o(o(u******oonwwwswsppceeahhhhttffleeeeool(fsfsfsfsnnnnrr(rrrrfttttoouooliiiiiiessssllllmmnmmllllttttfbb----ctiiiieellll----cccc-tllllll---o-oooilarbcoooeinnnnccccboewwgfnoooonnnnltouhonnnneeeevnat(((wccccnnnnetb11l(tttteeeeeo++ee(ee(rrfccccivtddiddbattttgghv!e----eeeebe!hhrr-ddddlrlbaoaatotefic----b!envg-nrfwo!orblaltoeghcgeoiu?!bm!efvgoetef!w!nr)lt?)oehuoo(-?tf??fvtnwmarrld(d?eobeton(((ao?)o?f-mem*daa(ntlr)s!hn(*on(d-i-!eg*-d*wds!bath!ess!ls!-ebe!t!ettelsl)neciottotlssrfolgviwti-ttbalguteili-)cleb-l)hhnllcol)--octto)onoc-cvwulnoonecen-en-onnftcctncune-tooce(neecutcuc1tdoetntn+-de(uett!ldd-1n!e(-(-+rtfl1it1bae!gr?+!f+ebihtg!l!roft-o!!ihr?vgwcobtaeoh-m?fe?butrclo-oo-noffvcmrwrtluoe)eoo)n-f-m-)umttcr)cn)-oi)-ogt)u)b)auh)n)ebn)tlt)oto))))v)w)))e)))
4.6.2 Bleeding
(de(f*uloncballleye(d*-tvyepreti:cfaalst ((sslliiccee &t)o)ptional (radius 1))
(*l(eltoo((pmfoorvar bbleeloslwicer)a)dius (a((n**dsseemttdoossllviiccieeep(((ooirrm!!!!a((gnneee-wwtoss---fbbboorrsddlieecrre!!))!!)))sslliiccee nniill!!!! 00 -1)1)slsicliec)e))))
(defun bleed-horizontal (slice &optional (radius 1))
(*l(o*cl(aeltlolyo((p(m*fotoyrvparebbl:eefalosslwtic(er)sa)ldicieust)) (a((n**dsseemttdoossllviiccieeep(((ooirrm!!!!a((gnneee-wwtoss---fbbboorrsddlieecrre!!))!!)))sslliiccee nniill!!!! -110)0)slsicliec)e))))
4.6.3 Filter for Beams
Aim for multiple tiered beams to be one region
68

(de(f*ul(onfcoar-llltvyei-srtu-yaoplu-ett(-y:pofeatshste(r(im-stliahcgeaen-t)-)tbo-efabmsslic(es))lice &key (min-height 7) (min-width 13) (bleed 4))
((wfoi(rt-*hvs-einstuesaiglli-hctebyo(prae-nscdo(!ui!mnstalsigc(ee-s(lti>coe!-!fmb(+isn!li!-ch(e)e!)!ig1h)t a0)bove-count below-count) (!!i min-height))))) ((((fbfwooli(errt--*ehdvvs-eii-nsstvuueesaaigrlllit--hcicttebyyao(pplraee-snssclidoc((!ueii!mmnbstaallsieggce(eeed--s)(ltti>cooe!--!ff0bb(+mss!llii!iccn(ee-))!))w!))i1d)thl)eft-count right-count) (!!i min-width)))))

4.6.4 Handle Edges

We don't want spurious connected regions on the wrapparound, so clobber a couple of pixels around the edges.

(de(f*ul(on*ca((ian**lllltwwye-ihrtterhyun-ppx(et-o-(arr:n!ef!dag(-sit<yo!n(!(ssxxl-icya(e)t!!-ti)e)eddggees-w(isdlitche))&o(p<t!i!oyna(l!!(ieeddggee--wwididtthh)2)))

(*set

slice

ni((l!>>!)!!))!!))xy)

((!!!!ii

((-

((cseacro(nvdp-(svept--sdeitm-denimsieonnssio*ncsur*rceunrtr-evnpt--svept-*s))et*e)d)gee-dwgeid-twh)i)d)th))))

4.6.5 Prepare a Single Slice
(de((((fffinuooltntrre--errbvvr-iieussoapuuumtaat-ll----roettyytghlppitoeeeernssr-s-((t-shiiammlaitcn-aae-eggdbee(ge--sa)ettsoom--ssff)bbs)ss)))))
4.7 Boundaries Code
4.7.1 Boundaries Data Structure
Adapted from
(*de avor boundaries (processor used labels (vp-set *current-vp-set*)
(pointer-length (1- (integer-length (apply '* (vp-set-dimensions vp-set))))) total-bdr (:pvars(()processor (@ 4 pointer-length)) (used (@ 4 t)) (labels (@ 4 pointer-length))) ((:g::ioenttithtaaebrb-lleed--eiicnnlssattraaanntcicoeen--svvaa(rrdiiaaebsbtlleienssatvipo-nsepto)inter-length) (slice t) :fast) :settable-instance-variables)
(de(f:gdeonceurmicesnhtaotwio-nb"oPunutdaarireespr(ebseonutnadtaiorny &ofopthtieonbaoludnidsparlayyo-nvatrhiaebFler)amebu er.
If display-variable is speci ed, the image is colored with that value"))

69

(*d(*ef(((am*idlflso(((eed*tritmtaiihssmieospnatldelgbiacsseoy(el-(wi-sctinhv-eoi4aosl-)!(rcw!fio)aab-rlbe!bsl!-eloit(couae-)nr)e)fd)bfa!!r(iiuefs!s!edbsloi(cu!e!niddi)ia)srpislealisyc)-e)v())a&roiapbtiloen(a!l!

display-variable 0)))

&aux!!

slice)

(*d((cceoofmmmepptuuhttoeed--bp(rocouocnmedsapsoruyrt--elpa-obbienoltussnssdeelafl)friselsiceb)oundaries) (slice)
((cfoorm-vpiusutea-l-btoyupnedsa(rysh-onwei-gbhobuonrsdasreilefssslieclef))))

4.7.2 Define Eight Connectivity
(defvar *boundary-neighbors*
(apply 'vector '((0 . -1) (-1 . -1) (-1 . 0) (-1 . 1) (0 . 1) (1 . 1) (1 . 0) (1 . -1))))
(de(fcuanr (baoruefnd*abroyu-nddxar(yd-inreeicgthiobno)rs* direction))) (de(fcudnr b(aoruenf d*abroyu-nddyar(yd-inreecigthiobno)rs* direction)))

4.7.3 Connect Boundary Points

(de(fmun(a*ccrloooclueantllty(-(-b&(tyo&2p1u(enn(d()n(a)s`r(ly`im(c-mepotood))din(+(ts+2(1,snl,i)nc)e8)8&))a))ux (count 0))
(colo(u*onipft(()-*i)fn)noif(cor-f*tnn-icf(oes-oiitanusg-macnhsfmtbaecom-e(orc-*euocsi-nnlouoctlmro'o((lrso0*(lsris!cl2!uiseclm14ienc))ee()6(i)&!g(!2&hd1b1on)o)e)nr)i)eg))ihgbhobro)r)

(*d;(((*leo*famoalllple(t(f*ho*sorednltle((uicgcsaohesdbmto!np!riului!nt!s)ee)'-d(b04o)2u(n4!d!6a)0r)y)d)-opoints boundaries) (slice)

(*if((-**nisfoe-ttnf-os(taa-mrseaefm-!!ceou-lsocerodlso(lri!c!seilin(ce/eig(nh&eb1igohnrbeiogrh2b)o))r)t!!)

(*if(-*ssaemtfe(-acroelfo!r!

slice used

((&!2!i

n(e/ig(h&b2orn)eighbor)

2)))

t!!))))))

(*defmethod (compute-boundary-neighbors boundaries) (slice)
(l(o*oipf(-*fnoifor-tsn-aesmiagmeh-beco-orclooinlrosr'(lis0cleic2e(4&n2e6i)ngehdibgoohrbor) (*if((-ssneetto--tpp-oosaiinnmtteeerr-cssoeelllffornnseeliiiggchhebb(oo&rr1'(s&ne2elfign(he&bi2gohrn)beoigr)hbnoeri)g))hbor) (*if(-sseat-mpeo-incotelorrssellifce(&(2&2nenigeihgbhobro)r)(&2 neighbor) neighbor))))))

70

4.7.4 Set Pointer used in bf compute-boundary-neighbors
(*defmethod (set-pointer boundaries) (direction-pointer processor-pointed-to direction-in-pointed-to-processor)
(let* (((ddiirreeccttiioonn--pino-ipntoeinr t(e/d-dtiore-cptrioocne-spsoorin(te/r d2i)r)ection-in-pointed-to-processor 2))) (if((*esqetpfr((oaacrreeesffs!!o!!rpl-arpbooecilenssts(eo!d!r-i (tdo!i!ri'esdcetilrifoe)cnt-ioinn--ppooiinntteedr)-)to-processor))) (*setf ((anreewf!s!!!p((roabcroeeufsn!s!doarlar(by!-e!ldisxd(ipr!e!ricotdciieorsnesc-otprio-onpin-otiiennr-t))epdo-intot)ed-to-processor)) (boundary-dy processor-pointed-to))))))
4.7.5 Comparing Colors

The algorithm is designed for used in an image with more than just black and white, hence the plural colors. For our purposes there are only two colors, and in practive we are interested only in the black boundaries.

(de(f*ulonciafl-lys-atmypee-c(o:flaosrt-f(upnvcaral:l (edldi)r)ection if-continuation else-continuation pvar &optional (same? t))

(*l(((e**utitnfy(l(eptstheshee(msmtahm(e(fmeu=?n!!tc())a(*lnsleeitwf-tsch!o!enmptvina(urnao(ttbi!oo!nut)nhde(amfur)yn))-cdaxll

direction) (boundary-dy else-continuation)))))

direction))

pvar)))

(de`((fdmief-caslcaarrmoe e*(-izfcw-oenloio:ritn--dfuseannmctaaetlli-o,cdnoir2leocr2t)i()opnva(r

direction () ,if) (

if &body else) () ,@else) ,pvar

nil))

(defmacro *if-same-color (pvar direction if &body else)
`((dief-cslaarme e(-zcwoeloi:rin-dfuennctaatllio,dnir2ec2t)i)on ( () ,if) ( () ,@else) ,pvar))

4.7.6 Accessors for Nearby Pixels
(de`(fmmaocdro(-+in2-,na)vo8)r)(&2 boundaries) (n) (de`(fmmaocdro(-+in1-,na)vo8)r)(&1 boundaries) (n)
4.7.7 Label each Pointer Uniquely
This needs to be done as precursor to compression. The algorithm creates four pointers in each processor. Since
we are going to compress just the active links, each needs to be assigned a consecutive number. The *lisp function enumerate!! assigns each active processor with a unique number between 0 and the total number of selected
processors.
(*d;;ecfmometphuotde (acnoemwppurtoec-epssroorcelasbseolr-folarbeevlesrybousuenddparoiienst)er()
((*lo(*olwlplhafweobinrtehln(seao(irg!eh!sfeb!0!to))ru=sbe0edldo(ow!!i4neighbor)) ((*sesteqtfo(asreetf!(!+laobelsset(!(!*i snuemigh(b!!or1))))))()+!! (enumerate!!) (!!i o set))) nally (return (setq total-bdry-points o set))))
71

4.8 Compressed Boundaries Code
4.8.1 Definition of Compressed Boundary
A compressed boundary is a set of only active boundary pointers.
(*de avor compressed-boundary (id (valtiodtanli-l!b!)drnye-xptoxinytspicture-vp-set
(vp-set (vpset-to- t total-bdry-points)) (((pxylloeeinnnggtetthhr-((leccneegiilltiinnhgg(((clelooilggin((gse(rcslotogn(dvtop(t-vasple--tb-seddtri-ymd-eipmnosieinontnssiso2np))si)ctpuicrteu-rvep--vspe-t)s)et2)))))2)))) (:pvars(()id pointer-length) (next pointer-length) (x xlength) (y ylength) (valid t)) :((g::ioenttithtaaebrb-lleed--eiincnlssattraaanntcicoeen--svvaa(rrpiiaaobbinlleetsesrppicotiunrtee-r-vlpe-nsgetth)vp:-fassett)total-bdry-points) :settable-instance-variables)
(*d(*eflemt-etinh-ovdp(-sshetowpi-ctbuorue-nvdpa-rsieest (c(obmdrpyre(s!s!e0d))-)boundary) (&optional display-variable)
((**tw(yihfpeedni(spvbaldalriydy-v%aridia))ble ((**pnsoewta:rnno(-*cposlleistio:(nncosu-bidceo-blfldrisoriymon(-scvudpbi-segp-rlaifdryo--mavda-drvirapeb-slsge!r!ibdpd-ircaytdudrree-svsp!!-pseicttuxrye)-v))p-set x y) )))
(*w(riathin-baollw--vpsc-asleet-tpoic-tfubre-(mvpo-ds!e!tbdry (!! 255))))))
4.8.2 Make a Compressed Boundary from an Ordinary Boundary
(*d((sseeefmttqqetschmboa(dl*le(mra(-al&lskoaeecut-ax(ctoves-pmmscapeolrtmle-estrps-ore-sedes-tstebcdtobo-u)tbnaodl-uanbryddar:yrpi-iecpstoubirnoetu-s)nv)pd-arsieets)*current-vp-set* :vp-set smaller-set (*with-all-vp-set smaller-set (allocate-pvars:t-ootna-l-hbedarpy-cpb)o)ints total-bdry-points)) (ma(kde(o-*tivwmisheiebsnle((n(aecriogemfh!b!poruresse4sd)ed(-!b!ionuenidgahrbyorc))b next x y valid) (le((t**wp(s(ietdhte-s:nxti-ona-anctiodo-lnliysi((oaxnlhisaes(r!ea!rye(fha!er!erefp)!r!olcaebsesolsr ((!!!!ii nneeiigghhbboorr)))))))next destination :notify valid) cb) ((**ppsseett ::nnoo--ccoolllliissiioonnss xyhheerree xy ddeessttiinnaattiioonn)))))))
4.8.3 Pointer Doubling
Label all of the points of a single boundary with single color, by pointer doubling.
72

(*d(*ef((w(m**lhosseeoeetnptthopivdddaoolinin(destxeptrr)enaedxt-)label compressed-boundary) (&aux!! pointer (lastid pointer-length))

((((****spsseeestttetpliado:snitno(idt-meciriodn)(l!lpi!sriieodfn!(s!piprdeofii!nd!tepidroippnooteiinnr)tteerr

:collision-mode :collision-mode

:no-collisions))) :no-collisions))

(for-unvitsiul a(l*-atnypde(s=(!s!hloawst-idboidu))n))d)aries self))

4.8.4 Scan Ordered Boundaries
Yet another ordering for boundaries, a linear ordering in which points on the same boundary are in contionuous segments. These are useful for computations on complete boundaries, which can used segmented scan operations.
(*de avor scan-ordered-boundary (x y dpxictduyreb-dvrpy--ssettarvtpbsdetryt-oetnadl-b(vdaryli-dpnoiiln!!t)s
((xculebneg-tlhen(gctehili(ncgm(il:o:vgp(-serstt-a(dvdpr-essest--lednimgtehnsviposnest)p)icture-vp-set)) 2))) (ylength (ceiling (log (second (vp-set-dimensions picture-vp-set)) 2)))) ((::optvhaersr-(()dxecxllaernagttioh)ns((yyymleinngytlhe)ng(tdhx) -(2y)m(adxyy-le2n)gt(hb)dr(yc-osmtamrtotn)x(xblednrgy-the)nd(cto)m(mvaolindyty))length) (slope ^) (intercept ^) :fast (:g:ientittaabbllee--iinnssttaannccee--vvaarriiaabblleess vpset picture-vp-set) :settable-instance-variables)
(*d(*ef(amlilf((ed**tihsnsoepotdwlaiay(dr-sn(hvsao(cr*waiasn-eb!btl!eoi(duifnd!d!isabprdliaeryys--vssatcarairantb-(loe!)r!)d1e)re(d!!-b0)o)u'n+d!!ar:dy)im(e&nospiotnio0n)a))l display-variable &aux!! (id :cube))
(*w(*hleent-vina-livdp-set picture-vp-set ((bdry (!! 0)) (slice nil!!)) (*type (bdry %id) (slice t)) ((**wpsietht-:anlol--vcpo-llisseito-nosfidbdbrdyry(*(sceutbbed-rfyro(m!!-0v)p))-grid-address!! picture-vp-set x y) :notify slice) (*w(riathin-baollw--vpsc-asleet-tpoic-tfubre(-mvpo-ds!!etbdry (!! 256)) 256))))))

4.8.5 Make a Compressed Boundary into a Scan Ordered Boundary
Compute a mapping between compressed-boundary and scan ordered boundaries. Once each compressed boundary
is labelled, a rank!! computes the mapping. This is because of the fact that if two nodes have the same id they
are guaranteed to be contiguous after a rank, since no larger or smaller node can intercede.

73

(*d((cseeofmtm-expt-uhytoe-d-dmx(-iandpiyt-itcaobli-zxsec-yafndr-oxomrddy-e)croedmcpbremssaepda-dbdoreusnsdbadrryy-ssctaanrt-obrddreyr-eedn-d)boundary) (cb &aux!! (mapaddress :cube))
(*w(*hb(e*intpcs(aettth-el:entboo(-obclouelnalicnsh-iop(nvxsarbyu(dnsxcehnddyb))cubnc:hvamlida)p)address) (((*fsoewrt-hq(ve*tinsoautl(laa<(ll--!*!tbey(dxpsrteeyrsla-fc-p(taos-dhixndotwrxse)-s(sb(*-o*wguehrxniedtdnr!aa!rc(i(ett!-sh!yes0ey)b)l)fo))o(()l!*e!eiaxntto-rtapacvlta--rbdd(xrsyed-nxpd)oc(inb*tes:x)v)tarl(aid*c)ts)-etd(y*vsadulyimd))))t(!!!)!)1))))
(*defmethod (co(mmappuated-dmreassp-btoou-nsdcaarny--osrtdaerrtedbocuonmdaprrye-sseendd-b&oauunxd!!ar(ym)appedid :cube))
((((****(w(stsyee**hpttpseeesbmnteo(tamvumpa:nnapaldipoepdaad-ardicyddod-dlrsr(leeti!ssas!issro0tn():)cnscuui(lb!b1!ee+)-b!fo!(ru(oidbnm)do-aumrgnyrda-ipaderp-nyead-ddeidndnridlem!s!)bsa!op!ua(ndrddaarnrekys!-s!)s)tidar't<)=t!)!)):)safe) (*w((**hsseeentt b(b<oo!uu!nn(ddsaaerrlyyf---esatndaddrrt(es(/s/=-=!g!!r!(id(n!pe!rxe(tv!!!!iom0u)s)a!p!(pm!!eidatipdop)teadml-idab)pdprmye-dapipdop))ie)n)dtisd))))
(*d((**efw((tmy**hpppeeesstneeh(ttovxda::nnnlei(oodws--ecc:too-llellxiilssd-ii)ooynn-(ssdyxnxy-exywdnnyee:wwceolnnmdee)xxptt(r))(edsxseddy-)b-o2u))ndary) (xnew ynew dx dy)
(*set dx (-!! x xnew) dy (-!! y ynew) xnew x ynew y)))

4.8.6 Compute Lines which Best Fit the Top or Bottom of the Beam

(*defmethod (sort-by-x scan-ordered-boundary) (x-seg-start x-seg-end &aux!! (rank :cube)

(*(w*hneonwvaarnlid"rank!! doesn't compile"

&type ((x-seg-end x-seg-start) t))

((*fobri-tcvaistu-alel-t(t*(ypbseuetsnrc(ahsnh(koxw(yr-abdnoxku!d!nydx))a'r<ie=s!!sel:fdirmanekn)s)ion 0 :segment-pvar bdry-start)))

(*pset :(ncou(-+bc!eo!-lrflirasonimokn-(sgsbrciuadnn-c!a!hd(dbsrueelnsfc-s!ha!ddress-grid!! (!! 0)) 'copy!! :segment-pvar bdry-start :dimension 0))))

((**ss(ee*ttalxxl--(ss*eeeggx--tesrtnaadcrtt-((oxor!xr!)!!b(bd*dreyrxy-t-ersnatdcatr-(ty/(=y/!)!=!((!*n(eepxxrtter!a!vcixot)u-sdx!)x!)))dx))x)x)())*extract-dy dy)))

(*d(*efsmetecthoomdm(ocnoxm(psucatne!-!a(nsdc-a'csnou!p!byxt!r!'am:cdtiin-m!c!eon:mdsiiommneon0ns-:iosmengo0md:eesnestgc-mapnvea-nrot-rbpddverayrre-debn-ddbryo:-udsintraedrcatt)riyo)n

(commonx commony) :backwards)

xco(m-m!! oxncyo(mscmano!n!x)(scan!! y 'min!! :dimension 0 :segment-pvar bdry-start)

y

(-!!

y

'copy!! commony)))

:dimension

0

:segment-pvar

bdry-end

:direction

:backwards)

74

(*defmethod (compute-lines scan-ordered-boundary) (lines&taaurxt!!x((sysxxxsl^^o))pe((ssiynyyt^e)^rc)(esp(xtnyg:^co)uobden))ess

(((***tssyeeptt essxy:f((assscctaa(nn(!!x!!

y xy

slope intercept ''++!!!! ::ddiimmeennssiioonn

g00o::ossdeenggemmssee)nntt^--)ppvv(aalirrnelliisnnteeassrtttaarrt)tt)))))

(((((*****l(sssseeeee*tttttty(sssnpdxxyeyx(yens((((codsssamcccenaaan)!nnn!o!!!m(!!!!(((!^***1))!!!)!!! 'xxy+yxy!!))):'''d+++im!!!!!! e:::ndddsiiimmmioeeennnn0sssiiiooo:snnneg000m:::ssseeeengggtmmm-peeevnnnatttr---ppplivvvnaaaerrrstlllaiiinnnrteee)sss)tttaaarrrttt))))))

(*w((**hsseeentt dsbledonrpyoe-me(n/(d!-!!(! -(!*!!!(*n!!sxnx)sx(y*)!!(*s!x! ssxx)))sy)) denom))

(;w*hseot(k*gnsooeotwdisnnewtsehsrce(er/ep!t!i (f(o/+u!!!n!d((-*((t!**h!!!!!is!!(n*s(foil!!no!!rtpms2eex)ruxcsleielnsopytpt)eeric(nse*txpe!x!rt)csesxlpotsp)xey)s)x)denom))))

((--!!!! ((**!!!! ((!!!! 22)) sinloteprecespxty))sy))

syy) n)))

(*defmethod (line-shift-coordinates scan-ordered-boundary) (commonx commony slope intercept)
(*incf intercept (+!! commony (-!! (*!! commonx slope)))))

4.8.7 Remove Short (invalid) Boundaries
(*d(*ef(wm*hseeetnthov(vdaascllii(addbn!la! n(k>-!!o(uatb-sr!e!g(io-n!!s-((wsscciaatnnh!!-!!wxxid''mmthian-x!l!!e!s::dsd-iimmtheeannsnsiioosncna00n:-:ssoeerggdmmeerenentdt---ppbvvoaaurrnbbdddarryryy--)sstt(aarmrtt))i)n)-width)
'copy(!!!!i:dmimine-nwsiiodnth0)):segment-pvar bdry-end :direction :backwards))))

4.9 Front End Representation Code

4.9.1 Front End Representation for a Single Beam
This flavor is called new-beam-feature, because it was the second attempt at the problem. (de(:coanvostrrun(chetawosr--brmeelaaaktmeio--nbfseeaahmatus--rfeseua(rtrlueorfuetnr(disginlhogtpsesuloitnpitle-ermicneitxpeitnrc)pepotinptso-inutpsw-aurpdwsagrdosodhneeigssh-tsofg-oot)d)ness-of- t)
::sgeettttaabbllee--iinnssttaannccee--vvaarriiaabblleess)

75

(de(ffm(leltoeto(h(podfdroar(wd(-rxsaelwgenm-gfeetnhattru(ar&werhenesitegwphot-)lbyie-naphmoein-igtfshe)tas(tudrrae)w-(p&oolpytgioonnapl o(layl-up:odirnatws):) lled t :alu alu)))

for ffoorr

hrleiegfithgsthisdtied=e=(=x*(r+awxhleeingghtth)*beam-basic-height*

(if

points-upwards

-1

1))

ffoorr for

ttbooopptrlteiogfmtht=ri=g(ht(tot-o=y-(ys+esletfolflperrfiitggshhidttes)hideei)ght)

ifformpobaioxntitmtso-imzueplew(fmtar=adxs(+totpolepfltefttohperiigghhtt)) into lower

elsamenadximmiinziem(imzea(xmbionttboomttroigmhrtigbhotttboomttloemft)leifnt)toinlotoweurpper

(drawdno-aasnleldygmmeinnitmlreiigzftehsti(sdmiedietno(tp+oleptflotepfrtrigigthohtptsriihdgeehigtt)hotpi)nritgloehfttuspidpeer(+ topleft height))

(bug-wo(rdkwa:rwouitnhd-o"uNtpouotp-oasp-tipornesteontdartaiown

rectangle (:object

scealuf s:etyspeera'sseyst:eoxpprrienstseior"n)

(un;;lemssak((edtyrtaphweep-sr*eensctstaiatnnivdgealerrde(-g1oi-ountlpeafutt)b*o(x'1lg-bpeu:c:palgpupes2re)-pp(oa1lg+yeg-roibgnuhste)enr(sini1tg-iz-alsottwiroeenarm)is):mlleesdsetd:aulpu

:noop)) in Genera

7.2

(dw:with-output-as-presentation (:object self :type 'sys:expression)

(draw-rectangle (1- left) (1- upper) (1+ right) (1- lower) : lled t :alu :noop)))))))

(defmethod (pretty-name new-beam-feature) ()
"Beam")

(de(f+m(e*thxodslo(pteo)-yintneerwce-pbt)e)am-feature) (x)

4.9.2 Clean up the Beam Feature on the Front End

Here, very short ligatures are removed and merged with their neighbors.

(de((fgcmoetme-tprhiuodt-deo-(flc-elfhete-aigannh-dtu--pgrilgnithecthwes-seblsfe)e)alfm) -feature) ()

(de((fslemetteq(t(hlleoafdstt(((cccaoaamrr (phlueaitsgteh-htlsee)i)fgth-tas)n))d)-right new-beam-feature) ()
(setq right (+ ( rst last) (second last)))))

(defmethod (get-rid-of-height-glitches new-beam-feature) (&aux (glitch-threshold 5))

(loop

wfoirthsecgamrreyn=t

0 in

heights

for (x length height) = segment

if (< length glitch-threshold)

elsdceooll(eicntcsfecgamrreynlteningttoh)deglitched and

do ((idneccff((sceacronsdegsmegemnt)enct)arcrya)rry)

nally(s(esteqtqcahreryigh0)ts deglitched)))

76

4.9.3 Compute the Number of Beam Ligatures
(defmethod (beam-height-at-x= new-beam-feature) (x)
(if(0(looorp(>fwohxrdeo(rnilg(e(hfrte<t)tlu(e(rn-n<g-xtxfhlreolhefmtfe)ti)g)blheenta)gmtinh-)hheeiigghhtt-sat-x= (* height *beam-basic-height*)))))
4.9.4 Beam Geometry

For use in establishing relationships.

(de(flemte(ut(hpoopndeer-(lltoiomwpeit-r)a(ntod--ybosetltfoxm)) new-beam-feature) (x)

(if((pssoeettinqqtsluo-pwuppeerwr oaornndees--lliimmiittulopwpeerr

((+

oonnee--lliimmiitt

((bbeeaamm--hheeiigghhtt--aatt--xx==

self self

xx)))))))

(values upper lower)))

(de(famndet(h>odx(lepfot)in(t<-inx-rbigehat)m? new-beam-feature) (x y)
(mult(iapnled-v(a>luye-upbpinedr)((u<ppyerlolwowere))r))))(top-and-bottom self x)

(de(flomoepthfwooidrth((lbuefpotpu-enprodaiinnntgdw-lboidowtxeh)rnienwh-ebigehatms -feature) ()
dmoin(immiuzletipulpep-evraliunet-osteotpq (upper lower) (top-and-bottom self left-point)) dmmoainx(iimmmiuizzleteipulolpewp-eevrraliiunnetto-osbteootpqtt(oumpper lower) (top-and-bottom self (+ left-point width -1))) mnaaxlliym(izreetluorwner(vinatlouebsottotpomleft bottom right))))

(defmethod (place-relative-to new-beam-feature) (thing)
"(mth(uinmltgiupsllthei-opvuleal-dluvaea-clucbeein-pdbt itn(hdxe y(:)tpoi(tpcphbo-ioncttet-onpmteo)rsip(titoooinnpt-t-hapinnodgs-itb:ipoointttcohmm-ecsessnealtgfeerx)") (cond ((< y top) :above) (((t>:oyvebrolattpos)m))))) :below)

4.9.5 Object to Hold all the Beams on a Page
(de::gseettattvaaobbrlleep(--uaiintngisslet-t-aamnoncifcx-eei-bn-)vevaaarrmiiaabsblle(esbs)eams image) (de(fwmiteht-hroodom(d-rfaowr-ipmaaggee-o(ifm-baegaem:res)du(c&ek-ebyy(rreedduuccee--bbyy 3) (coloring-function ( (ignore) :draw)))
::llaabbeell-(ofbojremctatsenlifl)"Beams from ~A" (send image :name)) (map nil ( (f) (draw-feature f (funcall coloring-function f))) beams)))

77

4.10 Code for full page of beams

4.10.1 Beam boundaries
(*de::gineitattavaboblrele-b-ieninassmttaan-ncbceoe--uvvnaadrriaaiarbbileelesss() (boundaries-with-seams)
:settable-instance-variables)

(*de avor beams-compressed-boundary () (compressed-boundary-with-seams))

(*de avor beams-scan-boundary (x-seg-start x-seg-end seams) (scan-ordered-boundary)
:::(sgi:nepeitttvttaaaabrbbsllelee(---xiini-nnsssstettaagann-nccsceete-a--vrvvtaaartrri)iaiaabb(bllxelee-ssss)eg-end t))

(*defwhopper (allocate-pvars-on-heap beams-compressed-boundary) ()
(*with-vp-set vp-set (continue-whopper)))

(*d(*efwwithho-pvppe-rs(eat lvlopc-asette-(pcovnatrisn-uoen--wshtoapcpkebr))e)ams-compressed-boundary) ()

(*defmethod (show-boundaries beams-scan-boundary) (&optional display-variable &aux!! (id :cube)

(*(ailfl((d**isnsepotwlaiaydr-n(vsa(cr*aiasneb!tl!ei(difd!!isbpdlaryy--vsatariratb(le!)!)1)

(!!

0))

'+!!

&aux (reduction :dimension 0)))

(reduction

seams)))

(*(w*hleent-vina-livdp-set picture-vp-set ((bdry (!! 0)))

(*type (bdry %id))

((**wpsietht -:(ancloul--bvcepo--lflrissoeimto-n-osvfipdb-dgbrrdyirdy(-*asdedtrbesdsr!y!

(!! 0))) picture-vp-set

(

oor!!

x

(!!i

reduction))

(*with-all-vp-set picture-vp-set ( oor!! y (!!i reduction))))

(rainbow-scale-to-fb (mod!! bdry (!! 256)) 256))))))

4.10.2 Ignore the redundant white border

Modify compute-boundaries, so that only the black border is bothered with
(*d(*efwwhheonppsleicre((ccoomntpinuutee--wbohuopnpdearriselsiceb))e)am-boundaries) (slice)

4.10.3 Slight modifications for a few methods

(de(fmmueltt(hiepoxledtr-a(v-maaludaedk-reeb-siinsn-dslet(anxgn-tcahedsdbsreeeaassmm-ses)x-tsrcaayn--abdodurnesdsa-reyxt:raaf)ter) (&rest ignore)

((iinnccff

xlength ylength

yx--aaddddrreessss--eexxttrraa))))

(*d(ceofwnhtionpupee-rw(hsooprpte-rbyx--sxegb-esatmarst-xs-csaeng--benodu))ndary) ()

78

4.10.4 Compute the Height of Beams, in Units of Ligature
(*defmethod (compute-height beams-scan-boundary) (ymin ymax beams which-beam
&&aoupxtio(nnaulm(bbears-ico-f-hebiegahmt s*b(eleanmgt-hbabseica-mhse))ight*) (*set height (round!! (-!! ymax ymin) (!!f basic-height))) &aux!! ((hceoiguhntt 3:)cu(bhee)ig&htty-pbed(ryw-hsitcahr-tbte)a(mhe:icguhbte-)b)dry-end t) (((***ssseeettt hhheeeiiiggghhhttt--(bbsddcrrayyn--!se!tnahdreti(g(ohort!r!!'!cbobdpdryyr!y-!-e:snstdeagr(mt/(e=/n!=!t-!h!pevhigaerhigtxh-(tsne(egpx-rte!e!vnidhoeu:isdg!ih!mth)e)e)n)igsihotn)))0) :direction :backward)) (*((l(e**wtts(iye(t*(phtw(s-ectlthooa(eeoursmntpntxapthfr(-ote(saxri-cgr!parxh!anlteyx-!n!xb(gsnxdthtuarhe'myr)ic)tg-oxhe)bp)ntye-di!nr!lge:dtnihmuemen*bspeiroro-ncoe0fs-s:boseerasgmmdose)nt-pvar height-bdry-start)))
(loo(ppfuosrhb((blairesetinf(ghpetriehgfehstat-rarrrlateyx-(pep)lreem(f1ew+nht(iscphore-ffbbceeoaamumntsp)p)))))) (pref height p)) for i from 0 do (send b :set-heights (sort (aref height-rle i) #'< :key #'car))))))
79

4.10.5 Extract representation from CM

(*defmethod (extract-beams beams-scan-boundary) (&aux!! (slope ^) (goodness ^)

(y(misnttainerrtycbmeitpatt)x^c)o(mpmoionntsx-cuopmwamrdonty)

(*((w*chol(eem*nttpy(vupxatepleid-(y(apx)npd-yspu)b^tr))act-common-mode

self

commonx

&aux beams) commony)

;; make a bit which is t in the rst end of a x segment

((**sseett xstparxtbpioti(nstcs-anu!p!wbadrdry-nislt!a!)rt 'copy!! :dimension 0 :segment-pvar x-seg-start))

((**sw(echtoemynmpxui-ntse(e-gslc-inaeenns!d!syelf'msti;ancr!ot!bm:idtpiumxtpeenytsphioesnltoo0ppe:sliienngtemerceenpt-tpgvoaordxn-essesg)-start) yp ymin)

(*s(elitney-msahxift(-sccoaonr!d!inya'tmesaxs!e!lf:dciommemnsoionnx 0co:msemgmoneynts-loppvearinxt-esrecge-pst)t)art) yp ymax)

(*l((e**twty(hpbeeont(t(xob-mosestgtloo-pmeensdbloopt;etcobomomitnptotuemtrecinebptoettrtcboeonptttloibnmoegttooomdgnoesosd)ness) ^))

; s((etclionsmelo-ppsuhetif(et-t-hlcienoeorsersdsuienlltfatsseltosaprstee)blifttcoxoptmhyempsoblnooxptetcoowmmitsmhlooptnheyebbbooettttttooemrmignsoltoeoprdceneebpstostbtooofmttoitnmtegrocoepdtn))ess)

(*w(*hseent

s(l<o!p!ebbootttotommgsoloodpneess goodness) goodness bottomgoodness

intercept bottomintercept

((**sleett (y(mwihnic(h+p-!ob!iencatomsm-um(p1ow-na!y!rdy(mstc!i!an))n)))!!ym(caaxst(!+! !b!dyrmy-asxtacrotm1)m'o+n!y!):dxim(+e!n!sixonco0m)))m) onx) y (+!! y commony))

; (*(w*thyepne((=w!!hiwchh-icbhe-abmea:mcu(b!e!)i)*beam-to-debug*))

; (print((*lw(olhooeponpfobfrodrpryp-beenixndngumtheb*eipnrgoctehseso*rpsrococlelsescotrs(cons (pref x p) (pref y p)))))

wfoirthbfth=em(m=ak(em-baekaem-a-rrfeaayt(u1re+(p((rp*erfmefpaosxlionwptshe-icuph)p-w(baperrademfp)i))n)t(eprrceefptgopo)dness p))

(compuntdea-ollhy(esi(gesthefttq(saebrlefefaymtmhseinmthyem(mpar))xe)fbweahmichs -wbheiacmh-bp)e)ambf)))

beams))

4.11 Code to deal with slices

4.11.1 Definition of Seams
Unfortunately we don't have enough memory to do a page at a time. Instead, the boundaries for each slice are computed. Since a beam can straddle a slice boundary, there needs to be a mechanism for hooking up the boundary in one slice to the boundary in the next. To do this, an object called a seam is created, which holds the results of the boundary labelling algorithm on the edges of slices. When the boundary points are moved to compressed boundary vpset, the links are restored.

80

(*de avor boundaries-seams-for-slices (cm-imt(oimatagale-gbed(rpyv-apro-ignetstf cm-image :image))

((npuicmtub(r1eer---vv(pe*-rastreirctaayl(--psdveiamarm-evnspsi-osnetcmcm--imimagaege1)))))

(numb(1er--h(*orairzroanyt-adli-mseeanmsiosn cm-image 0)))

((ptootia(nl+t-esnre-ualmemnbsgetrh-vertical-seams number-horizontal-seams))

(t(hahelal--v(se(pe1-moa-simnae(aktsi(eemnra-btsspade-prgrlreyleayn-ry-gp'*lt(oehlini(nsg(vttt?*phn-(4usbmepdtbo-ryiedn-ritm-pehoreo-innrlsietzinsoo-gnnststoha)-p)l-ficastreua0rm)e-svp-set)))))

((selxictrea--wbiodrtdher( (rpsvta(rv-pg-entsufemtc-mbdei-mri-mevnaesrgiteoicn:aeslx-ptsriecaat-umbroes)-r)d)vepr-))set)))

((toshlpaicllfee--fbthoebridogethtrto(m(/serecixgothnrtda-l(ebfvotp?r-dtseoertp-2?)d)bimotetnosmio?nsripgihctt?ure-vp-set)))

((iimmaaggee--wheidigthht ((sseenndd imimaaggee::whieditghh))t))

((sseeaamms--levnpg-tshet(m(vapxseitm-atog-e-wt i(d*th2imseaagme--lheeniggthht)))))

xslice yslice)

((::ipnviatarsb(l(e)t-hine-stsaenacme-sv(a@riatbolteasl-ismeaamgestaoltl-alp-obidnrtye-rsp-oleinntgst)h)) (bdry-point? (@ total-seams t)))

(:((ouptashereadrl-l4ed)l-ecaldadraretisosn:s

(labels all-pointers-length) eld) (perp-address : eld)

;

labels

passed

from

the

boundary

(which-seam 2) ; layout is boundary then overlap seam in ascending cube addresses

(()::gseettttaabbllee--iinnssttaannccee--vvaarriiaabblleess)))

(*defwhopper (allocate-pvars-on-stack boundaries-seams-for-slices) (&rest ignore)
(*with-vp-set seams-vp-set (continue-whopper) (*all (* ll bdry-point? nil!!))))

(*d(*efwwithho-pvppe-rs(etalsloeacmatse--vppv-aserst-(ocno-nhtienaupe-bwohuonpdpaerr)ies(-*saella(m*s-llfobrd-rys-lipceosin)t(?&rneislt!!)i)g))nore)

(*d(+efm(ifet(hpoldus(psedaimme-nisniodne)xnbuomubnedra-rhioersi-zsoenataml-ss-efaomr-ss0li)cews)hi(chd)i)mension which)

(*d(1ef+m(emthaoxdn(urmedbuerc-tvioenrtibcaolu-snedaamrisesn-usmeabmer-s-hoforirz-osnlitcael-s)se(a)ms)))

(*d(leeftm((e(xtxlhismotdaitrt(v((aiifflirldeig-fths?tli?c0esh-liaclilemf--wibtoisdrbtdheoru)()n-dsalirciee-s-wsidetahmhsa-lffo-rb-osrldicere))s)) ()
(va((lyyusleitmsarliettf((tiitffobtpooptxt?sotma0rt?hysasllitfc-aerb-tohrxedliiegmrh))itt (y-limsliitc))e)-height half-border ))))

(*d(vefamlueetsh(ocdei(lienxgtr(alo-gad(d*raersrasy--lewnigdtthhscmbo-uimndagaer)ie2s)-)se(acemilisn-gfo(rl-osgli(c*eas)rr(a)y-height cm-image) 2))))

81

4.11.2 Save away the seams
(*defmethod (cache-seam boundaries-seams-for-slices) (parallel-address perp-address
(*w(*hwenhe(nor(!a!n(d=!!!!(p>e=r!p!-paadrdarlelesls-a(d!!diroesvser(la!!pi-(siefaimnc))lud(=e-!!expterrepm-ae?d&&d(il((aa0anrbosuuebcehvoxxsleaause!ulm!(rlsdnfl(le-awde-u!-pbn!aishine-groeixydcbdsrtt-dhheeorasxed-uee(rmismn)mss(ai)efdll)smaiiee(ccae(m?nee1arzy(--s)m+e-i-hwro-sboenileidpoiengatnuwdhmdhgnehti)td)mx)i)h)caehsrhyneasl-sftilsofade-nraibt)mmoer))ndseiron1))which)) (*set which-se(a<m=!!(-p!a!raplelerpl--aaddddrreessss((!!!!ii(b-oulenndgatrhy-hsaelaf-mb)o))rder)))) (*w(*hl(ee*ntty(((ppaeldu(dsaprde!!sdsrue(ssecsdu):bs(ce+eua-!bm!ferp)so)a-mrva-plv-lepsle--tagdriddr-easdsd(r!e!siss!t!art) (*!! which-seam (!!i seam-length)))))) (*pset :no-collisions labels (alias!! (aref!! the-seams (!!i seam-index))) :andodtriefyss(alias!! (aref!! bdry-point? (!!i seam-index)))))))))
(*d(*efw(muitnehlte-hsxos-dab(nocdtta-ocymh(e?x-(syce)aacmhes-bseoaumndsaerlfiexs-ysleaabmelss-ufsoerd-s0licyselsi)ce(lleafbtellesftu?s)e)d)
(unless right? (cache-seam self y x labels used 1 xslice top top?))))

4.11.3 Restore the seams

(*defmethod (restore-seam boundaries-seams-for-slices)
(*w(*itw(h*h-seleinnt ew(-<ha!id!cdhlir-nesesesa(m(!!liin((e*)o2ors!e!almine-l(en!!gitshe))a)m-length)))

(label&&saaduuixxm!!(e(snwseesahaiomimcnh---wiinsnhdediaecexmhx

beginning end self dimension

which)))

(*set line (mod!! line (!!i seam-length)))

(*w(*hw(einhf e((nzaen(rdaor!pe!fd(!!i>m=be!d!nryslii-nopeno)(in!!ti?b(e!g!iinsneinamg))-i(n<d=ex!)!)line (!!i end)))

(*pset (*pset

::((nnccoo(pup(u--++ibibcccc!!eettoo!!--uull((ffrrlliirree-!ssoo!--ii!immoo!vvnn(ppl--1ssi--nvv-ss((eppeeaa--htt(llggaii!aarrl!fiiiss-dd!!b!!--beaao((gddraaidddrrneeerrnrffee)i!!)ssn!!ssg!!twt)!!)hh)heei--csshee-aasmmeassm(()!!)!!ii)sseeaamm--iinnddeexx))))))

labels labels

((++!!!! ((!-!!i!(l1in-eh(a!l!fi-bbeogridnenr)i)ngw)))h))i)c))h))-)seam)

(*d(*efa((mululnnellteehssossdlteo(fprte??s((trroeerssett-oosrreee--assmeeaasmmbosseeullnff dllaaabbreieellsss-10se((a11m-- xyss-sllfiicoceer))-stlleoifcpte((s)11--(l((a++betlleso)fpt sslliiccee--wheidigthh)t)))))))))

82

4.11.4 Details

(*d(seefmtqetxhsloicde((n/ewxs-tsalritce(-bsoluicned-awriidetsh-seexatrma-sb-ofordre-rs))l)ices) (xstart ystart xend yend)
((((sssseeeettttqqqq yllteeosfflpttic??xes((t(zza/eerrrtooysprpitgaxyhrssttlliicc(xee-e))n))sdlicteo-pwyidsttahrtexbtortat-obmorydeenr)d))) ((sseettqq rbiogthtto?m(?>=(>x=enydenidmaimgea-gwe-idhtehi)g)ht)))

(*defmethod (subselect-to-protect-seam-labels
(*a((**llsw(euittnhrle-essxst-oatronepdd?--yse(axmys)nil!!)

boundaries-seams-for-slices)

(conti&nauuaxt!i!on(restored-seams

t))

(*w(fhu(enuncn((a**l(lelssnseeosctttol!rr((ne!eefoo((tsstrirr==nt?te!!oo!!!s!u!!rrtar((eeoyyetdd==riseo-(-(!!t!!dn!!sso!!-)eexxrii)aae)sh(((edmm1aa!!-!!ssl-msiife-h(shab)1aamol-lfrfs--dhbbearoo)l)rfr)-dd))beerro))))r))d))e))r)))

4.11.5 Boundaries Which also have Seams
(*de:::gisneeittatttavaabobblrlel(ee-bb--iooininnuussstnnttaaddannanacrccreieiee-e--svs)vva-aarwrriiaiaiabtbbhllele-essss)eams (seams o set) (*d(le(eftrme(se(tt*ohuroesd-esd(e*caomsmeslfp)s)ueatme-sbloaubnelds)a))ries boundaries-with-seams :before) (&rest ignore) (*defmethod (compute-boundaries boundaries-with-seams :after) (&rest ignore)
((cleatch((e*-useseadm*ssseelaf))ms labels used)))

4.11.6 More Details
(d(efinmceftbhdordy-(pmooinrtes--bsoo-ufnadrahroyw-pmoainnyt)s) boundaries-seams-for-slices) (howmany)
(*d(seufwbsheolpecpte-rto(-coprmotpeuctt-es-eparmoc-elasbsoelrs-lsaebamelss (bo(u)nd(caorinetsin-uwei-twh-hsoepapmer)s))))() (*defmethod (compute-processor-labels boundaries-with-seams :after) (&rest(&o(aigsu:enxsbnoeddtrreys-eapmoinsts-so-far)))
((dm(oo*trismee-tebfso((uainre4df)a!r!yl-apboeilnst(s!s!ieai))ms(+t!o!ta(la-rbedf!r!y-lapboeilnsts())!!i i)) (!!i o set))))

4.11.7 Compressed Boundaries with Seams
(*de avor compressed-boundary-with-seams (seams) (compressed-boundary))

83

(d(efmmueltt(hiepoxledtr-a(v-maaludaedk-reeb-siinsn-dslet(anxgn-tcahedsdcsroeemassm-pser)extsrsaedy--badodurnedssa-reyx-twrai)th-seams :after) (&rest ignore)

((iinnccff

xlength ylength

yx--aaddddrreessss--eexxttrraa))))

(*defmethod (show-boundaries compressed-boundary-with-seams) (&optional display-variable

(*with-all-vp-set vp-set

&aux (reduction (reduction seams)))

(*let-in-vp-set picture-vp-set ((bdry (!! 0)))

((**ta(ylilfp(ed*in(s(*pobwpldasrayeyr-tnv%:anriodia)-)bcloellisions display-variable bdry

(*pset

(cube-from-vp-grid-address!! :no-collisions id bdry

p(icotuorr!e!-yvp(-!s!ei tre(duocotiro!!n)x))))(!!i

reduction))

(cube-from-vp-grid-address!! (*with-all-vp-set picture-vp-set

p(icotuorr!e!-vyp(-!s!ei tre(duocotiro!!n)x))))(!!i

reduction))

(rainbow-scale-to-fb (mod!! bdry (!! 255))))))))

4.11.8 Compress the Boundary taking Seams into Account

Compress boundary is more complicated since we compress from a number of slices, instead of only one.
(*defmethod (compress-boundary boundaries-with-seams) (compresse&da-ubxo(uvnpdsar*ycurrent-vp-set*))
(ma(*kew(-*itvlehist-iba((llelr-e(vcpcipo-imseenpttrsvepsns-iels!de!-)t)boundary-with-seams compressed-boundary next x y valid vp-set) ((*mtuyplteip(ler-evciapluieen-tbsint)d) (xo set yo set xstart ystart xlimit ylimit) (valid-slice-limits seams) (*w(*itw(h*i-twhah-lle-xn-vpa(-nadsne-dty!!v(p(xs<h=e!r!e (y!h!ierxes)tart) xhere (!!i xlimit)) (<=!! (!!i ystart) yhere (!!i ylimit))) (dotimes (neighbor 4) (*w(lh(ete*np(s((edaters:entfio!n!-auctiosoelnldis(i(oa!n!liisans(!ea!irge(hfab!r!eofrp)!)r!olcaebsesolsr ((!!!!ii nneeiigghhbboorr)))))))next destination ((**ppsseett :::nnnooo--ticcfyoollrlliiessciiooipnnissen((t++s)!!!! yxhheerree ((!!!!ii yxoo sseett)))) yx ddeessttiinnaattiioonn))))))))) (*set valid (or!! valid recipients))))))

84

Chapter 5
Locating Staff and Measure Lines

System

Staff Lines

Measure Lines
Figure 5-1: Staff and measure lines.
5.1 Introduction
Staff and measure lines impose a grid on a page of music forming a coordinate system by which time and pitch are measured. Of the various features found on a sheet of music, they are the most obviously structured. Each staff line is composed of exactly five horizontal lines which stretch across almost the whole page. Each measure line is a thin vertical line which extends across a group of staffs called a system. There are as many staffs in a system as there are instruments in the orchestration. In the Schubert string music which I worked on that meant between three and five staffs per system.
85

The lines which compose the staff and measure boundaries are intended to be exactly horizontal and vertical. This observation inspired my first attempts to identify them on the score. Finding staff lines and finding measure lines are very similar. In the rest of this discussion I'll mainly focus on finding staff lines, adding a few remarks at the end on the differences between finding these and measure lines.
5.2 Finding Staff Lines
Professor Sandy Pentland, of the Media Lab's Vision group, pointed out that if one considered the horizontal sum of pixels across each row of the image then most rows would not add up to much, but that lines which were part of a staff line would have a sum which was comparable to the width of the image. The horizontal sums could be viewed as a function of the vertical position on the page. Identifying the staff lines would then be a matter of finding the locations of the peaks of this function, illustrated in Figure 5-2.
Horizontal Sum

Figure 5-2: The basic way of finding staff lines is to sum pixels horizontally. To the right is a plot of what the sum looks like as a function of vertical position.
Unfortunately lines are not always horizontal. Figure 5-3 shows some typical cases. In the first place, if the image is not perfectly registered when scanned then the lines have a slope. Think of what happens to the peaks as a line is tilted. When the line is flat at 0 the peak exists at a single point. But at 45 there is absolutely no peak. So any tilting of the page results in a rapid diminution of the peaks. The images were scanned at 300 dots per inch, and since the staff lines are only a few pixels wide, the necessary level of precision in scanning was difficult to maintain.
To make this even worse, imperfections in printing introduced a hardly perceptible bowing of the line which amounted to tens of pixels. This imperfection appeared on the horizontal sum function in the form of peaks which were significantly smaller, and were hence more difficult to positively identify. Moreover, this imperfection in the
86

Noise Bowing

Tilt Interference

Figure 5-3: Four ways in which digitized printed staff lines differ from the ideal. To the right are the horizontal sums. The ideal sums are in grey.

87

printing process could not be corrected by any amount of care in placement of the sheet while scanning. Another problem is that where there is a long tie, beam, or dynamic, or where many beams are at the same
height on the page, the horizontal sum of pixels for that row is comparable to the sum produced by a staff line. It is difficult to distinguish between peaks which are due to staff lines and peaks which are due to beams and ties.
5.3 Filter, Divide and Conquer
The work leading to overcoming these problems was done by Bill Jarrold a student who worked with me on this phase of the project. This approach was three pronged: filter the image to reduce extraneous features, divide the page into vertical segments so that within each segment the lines were more consistently flat, and make a final pass over the found lines applying heuristics to remove unlikely lines. The next few paragraphs discuss these methods in more detail.
In order to reduce the influence of ties, beams and other features on the horizontal sums, the image is first filtered to remove image portions which are not part of somewhat longer horizontal runs(see Figure 5-6). The filter acts like a low pass horizontal filter, but is not implemented in frequency space. Instead each point looks in its horizontal neighborhood, counting how many neighbors it has within a certain radius. Points with less than some threshold were ignored in future processing. The subsequent processing is not extremely sensitive to the exact value of the radius, so not too much care was necessary in its choice. Larger radius values result in stronger filters, but take longer to compute. When the radius is too low too much of the image other than staff lines remain. When the radius gets too large, the bowing of the line results in the staff lines being filter out. Between these two extremes there is roughly an order of magnitude to choose from. For the staff lines I used a radius of about one third of an inch, for measures about a tenth of an inch.
The second strategy was to divide the page into a series of vertical segments. The idea is that although the staff lines are bowed, they are less so over smaller lengths. Segment lengths were empirically chosen to be the largest which gave sufficient accuracy so that the algorithm didn't fail in some fifty pages of testing. The segments were about an inch wide for staff lines, and about one fifth of an inch for measure lines.
The larger the segments were, the less likely that some long non staff line feature such as a tie would give a significant peak, but also the more the chance was that bowing of the line would contribute to degradation of the ability to find the peak. As with the filter, there was, despite these constraints, a large range of segment size which gave adequate results. I chose segment sizes which led to a power of two number of segments in order to simplify allocation of processors.
This step uses one processor per pixel, with the sums being accomplished by scan operations. With these operations the time to sum is proportional to the log of the width of a page. At the end of each segment, peaks are found. As with the original algorithm, it is possible that a string of beams or a tie would cause a spurious peak. At
88

Sum on Segments




Peak Dots

Figure 5-4: The basic way of finding staff lines is to sum pixels horizontally. To the right is a plot of what the sum looks like as a function of vertical position.
this stage of processing such fictitious staff line segments are tolerated. These spurious line segments will have a chance to be removed when the line segments are put back together. If they still persist, they are removed using heuristics to suggest which lines are incorrect.
5.4 Reconstructing Lines From Line Segments
What is taken apart, must also be put together. In dividing the page into a number of vertical segments the algorithm finds portions of staff lines, rather than complete staff lines. To reconstruct the full line, I construct a list of segments which might connect to each other.
After the horizontal sum is completed there are relatively few processors which have interesting information in them, specifically those processors at the end of a segment in which a peak was found. Imagine, then, removing all the processors which are allocated to points not at the end of a segment. In this new topology peaks which are near other peaks represent line segments which end near the same vertical position. I call this the dot representation (see Figure 5-5).
Each dot searches for another dot in a small neighborhood to its right. If a dot is found then a link is constructed. Once all the links have been made1 a pointer doubling algorithm is used to uniquely label each chain of dots, i.e. line segments2. Finally, a representation of the chain is extracted from the connection machine. In this extraction, chains with a single member are excluded, since they are obviously too short.
1All processors search in parallel, so the time is proportional to the search area. 2This takes time logarithmic in the number of segments.
89

Distance Metric

Dot Representation
Typical line
Typical noise

Search Range

0 > >>

3 2 1 0 1 2 3

Linked Chain

}

} Pixel Sum Length

Figure 5-5: The dot representation is transformed to a chain by having each point search for another which is nearby.
5.5 Checking and Correcting Errors
Despite the removal of the smallest line segments, occasionally a longer chain is mistaken for a staff line. In order to remove these the program repeatedly checks the set of potential staff lines seeing if they make sense. A set of staff lines makes sense if there are a multiple of five of them, and if each appears to be part of a group. A line is judged to be part of a group if its vertical distance to one of its neighbors is almost the same as the mode distance between lines.
If the set of staff lines is judged not to make sense, then a candidate for removal is computed. A line is most likely to be mistaken if it is short, less than one third the average line length3. If no such line is found, then a line which is relatively shorter than both the lines surrounding it is searched for. These heuristics have never failed.

5.6 Grouping Staffs into Systems
Systems are groups of several staffs, one staff for each of the instruments in the orchestration. The program does its best to determine how many staffs are to be grouped into a system using the heuristic that the spacing between staffs within a system is usually less than the spacing between systems. This heuristic only sometimes works, so when the program can't rely on this it asks me how many staffs there are in a system. Unfortunately this
still happens regularly. Since the number of staffs per system is the same over a complete piece it is no chore
3The algorithm is not very sensitive to the exact value.
90

to tell the program once and for all what the answer is, and so I decided to put no more work in making this part of the program more accurate.

5.7 Finding Measure Lines
Very little changes in finding measure lines. The choice of several of the length scales changes as does the direction of application of the algorithm. Filtering tries to preserve long vertical things. The filter radius is reduced, as measure lines are shorter than staff lines. The segment size is likewise reduced so that the chances of a line only partly overlying a segment are lessened.

Original

Filtered

Summed

Thresholded

Figure 5-6: This sequence shows the process of finding measure lines. The image is filtered to remove other than thin vertical things. Then it is divided into horizontal slices, each of which is summed downward. The image shows the accumulating sum where the darker it is, the larger the sum. Finally these sums are thresholded yielding a series of points representing line segments.
The measure locater uses a couple of heuristics, one of which is applied in this phase of computation and one later. Measure lines span a single system. Vertical lines which are found to lie substantially outside a system are removed from consideration as measure lines.
To test whether measures make sense the number of notes in the measure can be added up and should equal
91

the amount in the time signature. Later this constraint will be used to help rule out incorrect measure lines.
5.8 Robustness
There are several choices of parameters in the staff finding algorithm: the number of sections in a division, the length over which filters are to operate, the threshold for considering peaks, the length ratios for choosing most likely wrong staff lines. In all cases the parameters have the property that changing them slightly has little effect on the performance of the algorithm. Consider this in the light of the attempts with the first(naive) algorithm. Experimenting with that method showed it was extremely sensitive to parameter changes. It is this insensitivity to parameter shifts which I believe gives robustness to the modified version of the algorithm.
5.9 Future Work
Several parameters are hand tuned. It would be better to have the program derive these parameters. Also, people can read a fairly tilted sheet of music and my program can't. This discrepancy should be fixed.
The tilt problem can be handled in a general way, I think. First the orientation of the page needs to be determined. This can be done in a variety of ways, using a Radon, Hough, or Fourier transform. Then the image can be rotated so that the lines are relatively horizontal. At this point the current algorithm can be used.
5.10 The Code
5.10.1 Parameters
(defvar *long-emphasis* 100 "was originally 70, but 5% would fail. at 100 none fail") (defvar *vertical-slice-width* 256) (defvar *measure-emphasis* 32) (defvar *measure-squelch* .5) (defvar *slack-sta -line-spacing-percentage* .30) (de"fcvlaorse*rdtohuabnleth-ims aenadsutrhee-ylianree-ctohnresisdheoreldd*a(d*o(usbelnedba(r nlidn-e"fe)ature "solid") :width) 2)
92

5.10.2 Top level construction of Bars on a Page
(defun grid-page ()
(le((tsv*pelri(itf(((-ymsp-stbtaaeana(sd-msu-lirasnetkxe-aes-l-iin(f-in-elssinnnteda(ec-sne)scnstesdaa-'rpmy-alegsinateaes-uso)r)-fe-l-ibnliaenrse)ss):)sta -lines sta -lines :measure-lines measure-lines))) ((pmsbe))agkmee-nstysptbe)ms sta -lines)
(de((fcmmleaeaptr-h-momdeeaa(sssuuerrgeem--lliiennneetss m(pstaeaga((eswu-u-(nlhroislneiefoc-es-hmslsb)inetaeor((spss)eb((n(osgd&ytratsasotubtemx-ampd)po-eotllieesnntietetis-ioatn:lhs)-yemssteee)amsus)r)e-line system top bottom position))
((dmealeptce-'ilginneosrem-deaosuubrlee--lsitnaes(-dpleiunlseehtsew-(sthheincehsde)dstealet-el-intheses:es)y))s)tems)))

5.10.3 Top Level for Finding Staff Lines

(defun nd-sta -lines (&key (cm-image *last-image-to-cm*)

(*locally (*type :fast) ((cwuidtoth *.8v)er(tricaanlg-esli8c)e-width*) &aux (sum-size (integer-length width)))

(*w(lietth-((asllm-vapll-esr-ets-etof(cslmic-e-imseatgcem-image 0 width)))

(*(w*itl((eh*lto-toya((pplll-e-inov(epvl-e-insrs-uee-smtessgsummm(a!es!lnlse0tur)e)-md)s--estsliizcee)s)(slice width 0 cm-image)

(((*emllel-tpihn((a-hsnisozueism-elos(nlsigcc-ea)nth!!in(gcsasslti!c!es*lilceeft1-)rig'+h!t!*:d:eimmepnhsaiosins-*flaecftto-rri*ghlotn*g:-seemgmpheansti-sp*)var segment-start)))

(((**fotwry-hpveeins(ushaeslg-ummtyepnseuts-me(-ngsdriezye-))scale-to-fb hsum))

(*w(*itl(((eh*lt(e(-tntmsay(de(pl(a-nlc(-epdles(iv-n(ntcpsatecth-toe-eaasr-nm-iesntslt-iemi--nndrlciioespanlos!fole!mtl))eisl))nirpnt:uehsse-tslteusi-n-umiesmme-lgssianumgeme-enss(utpcsmvua(tsr)oc)-o))gnecstetfrnuctcemtr-s-)cimhaaingse

centers 1 :image))

range)

width

'page-sta

-lines)))

sta -lines)))))))))

93

5.10.4 Top level for Finding Measure Lines
(defun ((&nckdue-ytmo(ecam.8s)-uirm(er-aalgniengee*sl8a)st-image-to-cm*)
(*loca(llwy i(d*thtyp*em:efaassut)re-slice-width*) &aux (sum-size (integer-length width))) (*with-all-vp-set-of cm-image (let ((smaller-set (slice-set cm-image *up-down* width))) (*(w*itl((eh*lto-toya((pplll-e-inov(epvl-e-insrs-uee-smtessgsummm(a!es!lnlse0tur)e)-md)s--estsliizcee)s)(slice width *up-down* cm-image) (((*eml(lel*-tptihny((a-phsneisoz(ueishm-esluos(mnlsigcc-eas)utnhm!!in-(:gdscsiiazmes*s)ltem)i!cn!eessaio*lsinucuepr*e-1-ud)peom-'w+dpn!oh!*wan:sei*sm*:ps:ehsgqamsuiesel-ncfhta--cpftavocartrosre*gmmeenast-urseta-rstq))u)elch*) (for-visual-types (grey-scale-to-fb hsum)) (*wi(t*hw(-mahleal-npv-spte-ogs-mestme-noatfl-leleirnndeh-susummlsine-sums)))) (*l(e*tty((pcee(ncteernstenrisl!!t)))) ((lentd(-(lm(inceeha-asmiunir-decp-oolmiinneptsustlein-ese-gsummenstcsuto centers) (mseeansdu(rmceo-enalissntuerrsu)e)c-))tl)-i)n)c))ehsai:nsest-ceimntaegrse (1prvaanrg-eg)etwf icdmth-i'mpaaggee-m:imeaasguer))e-lines)))
5.10.5 Filtering
(defun emphasize-long-things (slice direction &key
(*locally (*type :fast (slice 1)) (&eamuxph(asusims--fsaiczteor(1*+lo(nign-teegmepr-hlaesnigs*t)h (esmqpuhelacshis--fafaccttoorr).)7))0) (*let (((spuremvio(u!!s 0s)l)ice) ((*dtoyt(pimneee(xs(tn(seklxicteem)p)rpehvaiosiuss-)fa1c)to(rs)um sum-size)) (if(((**zsseeerttoppprreedvviriiooecuutssio((nla)ebfto!v!ep!!repvrieovuiso)usn)exntex(trig(bhte!l!owne!!xtn))ext))) (*l((o**cssaeelttlysslu(icm*ety((p+aen!!(dss!!luicmselicpte)r)e(v>io!!ussunmex(t)*))!! (reduce-and-spread!! sum 'max!! (other-direction direction)) (for-visual-types (image-to-fb slice)))))(!!f squelch-factor))))))
5.10.6 Definition of the Chain Structure
A problem with *defstruct is illustrated here, and worked around. A chain is defined in part by the size of the
vpset which it is in. However the definition is vpset independant. So I use some special variables and a form which dynamically binds them.
(defvar .chain-row-length.)
94

(defvar .chain-column-length.) (defvar .chain-pointer-length.) (de`(fmletac(r(o((.c..ccwhhhaiaatiniihnn----rccpohowoali-unimnlteesnnr-g--itlnlehe-nn.cgg(ottihhnn..ttee((gxiinentrtt--eeoglgefeenrr(g--vtllpehesnneg(gtsttheh&cbo((oandpdryspt(lbyv(opv'd-*pys-)(esvte-ptd--isdmeimte-nedsniimosinoesnnss,vio,pvnspseste,))vt))p)))s)et)))))
(,@dbecoldayr)e)(special .chain-pointer-length. .chain-column-length. .chain-row-length.))
(*d((rceoofswlturm0ucn:tty0cph:etay(ipnuens(iugnnseidg-nbeydt-eby.cteha.icnh-arionw--colelnugmtnh-.)le:ncgmth-.u)n:icnmiti-aulinzeindi-tipalti)zed-p t)
((rleigftht0 0:t:ytpyepe(u(nusnisgingende-db-ybtyete.c.hcahiani-np-opionitnetre-rl-elnegntght.h).):c:mcm-u-nuinniintiitailaizliezde-dp-pt)t) ((rleigfth?t?ninl i:lty:tpyepebobooloelaena)n))
5.10.7 Secondary Accessors for Chains
The slots of the chain are used a second time, with different meaning. I define the accessors here.
(de`(fmchaacinro-lcehfta!!in,-chinadine))x!! (chain) (de`(fmchaacinro-lcehfta?i!n!-,cshtaain-))line?!! (chain) (de`(fmchaacinro-rcighhati!n!-,cclhoasien)s)t!! (chain) (de`(fmchaacinro-rcighhati?n!-!c,lcohsaeisn)t)?!! (chain)
5.10.8 Sending Chains
This is shorthand for sending to one of the processors pointed to by one of the pointers the chain structure.
(d`e(fmpraocgrno(*igchnoarien-cphsaeint-f s(ept)lac(e*pvsaeltue:)no-collisions ,value (alias!! (,place chain)) chain-address :vp-set chain-set))) (d(ef*ulonccaullyb-iftyy-pceh(a:ifna-stpo(cinhtaeinrs$(cchhaainin)))
(*w(*it(wh*h-seaenltlf-((vcpchh-aasineint---leloeffftt?c!!h!!accihnhaaiinn)) (cube-from-grid-address!! (chain-left!! chain)))) (*w(*hseentf((cchhaainin--rrigighhtt?!!!! cchhaaiinn)) (cube-from-grid-address!! (chain-right!! chain)))))))
95

5.10.9 Finding the Closest Line Segment

(defun nd-closest-to-sta -line (chain index
(*locally-type (:fast (index : eld) (column :

eclodlh)uom(rirnzoowrnotw:ale-sltrdaa)ng(-eclihnhaeainm$ocuhnatinv)er(tisctaal--ralinngee)t))

(*let

((d(acislttotasanecschteed(-mtoos-ts-opmoesitthivineg-?

nil!!) xnum!!

row))

((*lotoyapptetfoa(rcahtcetoaduc-nhtteo)db-etloow-sohmoreiztohnintgal?-rta)n(g(edidsotance closest) %row) (attached-to %index))

((**walhl e(n*s(entocth!!aiantt(ancehweds!-!toch-asoinmheatmhinogu?n)t 0)))

(d(ollno(((isa***otlwas(((ply(e***lhltvfdsss(eon(aeeeod*nr*amtttiaffflsscl(loteyolacaaatulutt(nno(nttcn*d*csaathtsee!cacae'!shhlb(titl(neese-a(tcdddl1oba*h(--iswssna1ttt!e-ooie)a!n)tvw-lni((encsc(s-rcohe!enth!!)maie!c(aicwnaeci(hntlhsc-a-h(!ha!irniiniannanecindg-nw0hge?-sasxetvri!t!anoa!!!w!m)c(c-!h*ho!laiaun-ciinnenh1t?)a))0)!)hi)!no()cr*ihzra-ooiw1nn))t)va)el(-r<tri!ac!nadgl-iesrtahanangmceeovucalnomts)eosu0t)n))))t))))))))

(*setf (chain-closest!! chain) attached-to (chain-closest?!! chain) attached-to-something?)

)))

5.10.10 Create Pointers to the Left and Right
(de(f*uloncsaellty--lteyfpte-r(ig:fhats-t p(ostinate-rlisne(stt)a ((-clihnaeinc-hoariingicnhaalinch-aoirnig)in$aclhhaainm)o(ucnhtaicnh-aaind-draedsdsre:sseldc)h)ain-set)
(*w(*hwenhesnta(c-hlainine-closest?!! chain-original) (w(h(**encchh(aapiinnlu--spppsseehttaff mcchhoaauiinnnt--)rriigghhtt!?!!!((chchaainin--clcolosessets!t!?!c!hachina-ino-riogriingainl))al))) (when (minusp hamount) ((**cchhaaiinn--ppsseettff cchhaaiinn--lleefftt?!!!!((chchaainin--clcolosessets!t!?!c!hachina-ino-riogriingainl))al)))))))

5.10.11 Ensure that Chains are Linear

Because the links between elements of the chain are determined by search, there is no guarantee that two chain elements don't point to an identical element. This routine removes such cases.
(de(fcuo(n*ma(dp*lleilloteacr-calhlely-t-e(tn(yd*pupeso(ei-:nfatalssw-taa(ytcs-h-vaineinsrttr$icucechtsaioi(nnc))sh*ainn)il))
(*let (((irnigdhetx?((scehlfa-iand-drirgehsts?!!!)!) chain)) ((**wtyh(peleenf(t(i?nad(necdxh!!a:icrniug-bhleet)f?t?(!(!ricghhati?n)l)e)ft?) t)) (*setf (chain-((rpnigrohetft!!?!!!(!l=ecf!ht!?a(i(np)crehfna!ii!ln!!-())crihgahitn!-!lecfhta!!inc))hain) (chain-right!! chain)) index))) (*when (and!! le((fpntro?etf!!!!(r=ig!!ht(?pr(ecfh!!ai(nc-hleafitn!-!rcighhatin!!))chain) (chain-left!! chain)) index))) (*setf (chain-left?!! chain) nil!!)))))))

96

5.10.12 Create a Chain
(de;;funrscthdaisinco-ncnoemctpusetgem-seengtms wehnitcsh(acrheaninotwcidotnhtiguaovours).
(w(it*hw(;-;dcictehhota-apicanyh-lsl---spievnrnp-ed-acpsdoeontitn-etoxsft--cahot-af iv(nesrlticicee-ssecth*ailna)st-image-to-cm* 0 width) (*l(ole(ct*all(ley(t-it(te(yrppaeotiion(nt:fesars(t(cce(hiclaihniangi-n(ril$gochght!a(!i*ncm))haaxin)()chain-column!! chain)) 2)))) ((*dto(y*t((piwmvvehaae(ellsuipnde(o-viip(naisottleieeidnlrrf-ta-e.ptacriodoh(idnancirstn)hee-sarspin!o!-)i)n)ritgehrt-?le!!ngcthha.i)n))(valid-pointer t) (value :cube)) (((***spseesttetpvao:nliinodt--ecproo(lilnpisrtieeofrn!s!(pvpraoelifun!et!evvraaplluiodei-nppteoorii)nn))tt)eerr)pointer)) (extract-chain-extents chain value width avor)))))))

5.10.13 Extract a List of Chain Extents and Positions

(d(ef*u(an*lll(eo*xcltaertllay(c-(ttl-eyfcpthe(a(ain:nf-ades!!txt((eccnhhatasiinn(-$crihcghahaitni?n!i)d!

width avor) (cihdai:n)el(d)n)ot!!

(chain-left?!!

chain))))

(((rraeingcyhipt(ieo(nra!tn!sd(n!c!ihl!(a!c)ihna-ilnef-tl?e!f!t?c!h!acihn)ain()ch(anino-t!r!ig(hcth?a!!inc-hraiginh)t))?!! chain))))

(*ty((pcseehg(a(minleefcnthtr-aiigpnhv)atr)a)ny recipients segment-pvar) t))

(let ((((rtilogetfhatt-l--pppoooiniinntttsss(((***wwwhhheeennnlaerifngtyh(t(**(s*suusmumm((!!!(!!1!1)))1))))))))))

(assert (*when

"(a=Dnyilefetr-epnot inntusmrbigehrto-fpoenindtps)oin()ts

on

the

left

~A,

on

the

right

~A"

left-points

right-points)

(*l((e**ttpy(s(pereta:n(nkroa-(ncrkaon:lclkius!ib!oeni)d)s

'<=!!))) chain chain

rank

:notify

recipients)

(*wh((*e*nspesrteescteip:gnimeon-etncsot-llpisvioarns(/id=!i!d

rank))) (next!!

id)

id))

(ma(:k:arrsevaao-owwrirtn--!s!yxtac((hnppacvvieaanrr--'<ttoo=--!!aarr:rkraaeyyy

'chain-column!! :segment-pvar segment-pvar)) ((*ch!!ai(nc-hraoiwn-!!coclhuaminn)!!niclh:aciunb)e(-!a!di dwriedstsh-))end total-points)

::sraliwce--idwi(dpthvnailwr-:icdtuotbh-ea-rraadydridesns-ile:ncdubteo-taadl-dproesins-tse)nd total-points)

))))))

97

5.10.14 Reduce each line segment to a point which is at the centroid
(defun nd-line-midpoints (line-sums cut-o centers)
(*w(*itleht-a((lls-ivgpm-as-ets-uomf-lixne(-!!su0m))s ((smigumltiap-limcaunltdip(li!c!a0n)d) (!! 0)))
(*type :fast ((sigma-sum-x multiplicand sigma-multiplicand) ^) (line-sums %line-sums) (centers t)) (*((w**itl((sehe**t-tts*yxemp-t(((((eausacccnlit(geeebdi(nnnmpo-atttlvybiarrrceooo-oa-(iiivmdddnwteh--duh-(reslite!ttnch!(saihdphr*r0-elto!)i(ss)!cl)(hladaivacon?neenlddrd(d!tv?!>i(!ce!=saacrca!tbela!-ibnocnplotavi!ronvle!o-see-impi--dttohsit-uohusrslneirmtttesiaiplhsosrilhnotni(co)elcd*a-lde?!ns!n?du(t((mr(n!ro'n!oes+if)oddt)!!ctu-!!!uce!:(tens-(-bedaoga)eblmno)otdw)ev-n!es(!t!pc-!arepebanvabotadrovro!ev!ic-ede-ltinhn%tthrerevr-oseesihsrduhto-miolcsdlastd?al)?-')rm))pt)))o)a:dsxii!tm!io*ennu))spi-odno*wunp*-))d))own*))
(((***wss((ee**httspeescsnteiegtnccmtee:eonnarvtt-srresoornuwiiiddmlr!-i!(-t)eerxnodt(u!sn!cdac!en!n!s!tieglrimnsea(--csumubmuels-tif'pr+ol!imc!a:-nsgedrgismdig-emandtad--rpsevusasmr!!-cxwe)n)htircohi-ds-lsicteartce:ndtirmoeidn))s)ion *up-down*))
)))))
5.10.15 Front end Representation of lines
(de:::sgineeittatttavaabobblrlelee-p(--iuainintnrsiassltt-tlaalamnennclci-cexeel-i-in-nv)vvaeaarsrriiaia(abbrbla((lelewelssisesn-)gexms renaniwl)t--(ypsoresagwmn-ile)ind(tspmoneiindl)tias(n(s-liimwceiad-gtwehidnntiilhl)) n(iml)a(xdimeleutmed-nnuilm) ber-of-lines-to-remove 30)) (de(fsmeteqthpoodin(tsm(alekneg-tihnsrtaawn-cye))parallel-lines :after) (&rest ignore)
(((accoossmnesrpttruu("rtcae=Stw-o-(m-milnyeedendrtigiavhatwiidnhn-u-grxaw'aslwi-rdaws-twerhygo-)mnside(g)ell.fen))nTtsghtesheselrf)aswho-ux)ld(alellnbgeththraews-aimd))e l(e)ngth - ~A,~A,~A"
(de(ffmoremthaotdst(resayms:p"r#in<t~-Asellifnepsafroarllepla-glein~eAs), (~srtrseeagmmeingtnso~rAe >ig"nore)
(((ismftrodinneligek-teedrdoswe(lnff)ocramseat(sn(elinel nd"g,itm~hradg~eeAle:tnreeadmm)oev))edli"nes (if (> (length deleted) 1) "were" "was")) "")))
(defmethod (moniker parallel-lines) ()
"parallel")
(de(fcm(a(isoemetthhaveogarderwia`i(s(b:eoflearns(idl)c)-o)floorr:mn-do-fimpaargaelle,(l-selinndesi)m(avgaeri:anbalme)e)) (to-image ,(send image :name))))
98

5.10.16 Reducing Several Line Segments to a Single Line
(defmethod (construct-individual-segments parallel-lines) ()
((sseettqq lsiengems e(ncotsun(tm-asekgem-aernratsy slienlef)s) : ll-pointer t)) ((lloo(((wpsooeupp(htsieqwffdfnhnooooclirrra(tf(hscieinctolbfoolnraebeutosslle)nmot(i(tnwe)aa)gq0nrl(edtlflheacnresoagtwauternh-rl)tax)sy=ei-)ge-m(l1eaemrneetfsn)rtaswo-fyrai)w)-(iadref segments count))) ((scoormt-psdueotgem(-sseeentgftms(seaenreltff)-asevgermagene-tspoi)si(timonapscealfn))( (a) (list (car a) (cdr a))) (sort (aref segments i) '< :key 'car))))
(de(fsmeteqthsoegdm(ecnotm-ppouste(-msaekgem-aernraty-a(vleenrgatghe-sepgomsietniotns)p:arlla-lpleoli-nltienrest)))()
(loop for s being the array-elements of segments (setfdfo((ora/rce((ofl/uosno(etplgemfnfroogermtnh(t-x0(payor)esfocnsoeu(gnamtr)eefntssegcmouenntt)s) c2o.u0)n))t))) by #'cddr summing y)
(d(efsmeteqthsoegdm(esnotrst-(sseogrtmseegnmtsepnatsra'<lle:lk-elyin'esse)co(n)d))) (defmethod (compute-left-and-right parallel-lines) (left right
&&aoupxtio(nsaegl m(secnatlse sseligcme-ewnitds)t)h) (l((etldoe(oc(pllaerffeotrl(essfytb)se:ai(nrrgriagythh-terreiaggrihrsatt)ey)r-eleleftmreignhtst osefgsmegemntesn))ts
((sseettfffdo((oraarrceeoffulrneigtfthftrcoocmuonu0tn)t)((oooror(c(alor os)p sfocral(e)x)y) on s by #'cddr nally (return x)) scale)))))

5.10.17 Compute the Median Distance Between Lines

(de(fsmtaectkh-oldet((c(olemftp(umtea-kme-eadrriaayn-(wleindgtthh pseagramlleenl-tsl)i)n)es) ()

(declare (((srwyisgi:dhattrhra((ymm-araekkgee-is-atarerrrarayleyf(t(lelrenignghgttht)h)sseeggmmeenntst)s))))))

((clooomppffuootrrel-r lbbeeeftiinn-gganttdhh-eeriaagrrhrratayys--eeellfleelmmefeetnnrttisgshootff)lreifgtht

((ss(eostreqttwfmfdoi(oderadtrchieoafnu'<w-n)twidiftdrhothmco(u0anret)f

(abs (width (

l r)))) oor (length

width)

2)))))

99

5.10.18 Generic Algorithm for Removing Lines which don't Make Sense

(defmethod (verify-and- x-if-necessary parallel-lines) ()
((lcooomppuunttei-lm(cooduelds-ellifn)es-make-sense? self) (rne(amwllfdh(((yoooldeevrirnkrerace-oow(-wru=no"nsercetCwsoltfobu)-suenlellitldonf)wnem'tsamexvlafie)mxriiufmymua-mnnd-unmuxbme~brA-eo"r-f-(oslfie-nnleidns-eistmo--atogre-emr:enomavome)vee)))))

(de((fdlermretasew)(t)(hrsoeedslf)((a(:adcfsoeckfre-ampuutalstt'en0rn(u)-mi)ml)foo"brnC-eihrklioen:rpoerssoeepmlafa)r)pastullpeel-r liunoeus)s

()
~A

line

by

pointing

at

it"

5.10.19 Draw Lines for Debugging Purposes

(de(ffmletet(h(od(dlro(ad(owdwp-r:tfawhoweirtmhsp-ba(ore)uaintlplgeultt-h-leiansae-rspr)arey(s-&eeknleetaymt(ieornnetds(uo:cofeb-sjebegcymt6ce))onutsntfo:rtycpoeun'stysfr:oexmpr0esdsioon)
(loop fwoirth(xlays)txoannsdblays'tcyddr (unlewsisthnnoot-t-yyeett(=drtawdo-a-segment self lastx lasty x y ))
(with-room((-ssfeeottrqq-inlmaostat-xgyexetlansitl)y)))y))) ((dimraawg-et:hr::lleeaamdbbu)ee)c)ll)-e(-ofbboyjrem'c(ret:aedtsuuenrcleifel)x-"b:~iytValic~:Ahulignee)s (fmroomni~kAer~se"lf) (send image :name))

(de(fifm((caaeopptlhppoollryy:dc''o(ddldorraarraw-wws--cll-riinenaeee-nsxxe00gyym00exxn11t

parallel-lines)
y1 :thickness 2 y1 args)) )

(x0 y0 x1 y1 &rest :scale-thickness nil

args) args)

5.10.20 Methods to Delete One or More Lines

The lines are stored in an array, so this requires moving the lines after the one to be deleted so that they fill the space. Keep track of the deleted lines so that they can be restored, for debugging.

100

(d(effmletet(h(od((ddloo(eis(tocedpf(tewfa(fwlroe(dhrir)atltoelhern-ie(-pbcfi(loneoi/anlicuonr=fenrwttecicproowl=aiuunarhn0rneairtcst)l)))dl)h)e))ol(-alrinefesa)rr(iw))hich)
((((pdddueoocsiittfhssliweengghemmsic)eehnndtt-se)pleotse)d)))

(de(ffmletet(h(oddoi(td(ealrert&ea-ulixne(slepngatrhall(ecla-rli(naersr)ay(-tdhiemme)nsions arr))))

(st(((aslcoceooktpf-pyl(-efaotlrrl(r-a(epylno-ebiwpneoitnre(gtrmioatanhrkre)ea-ra0rar)rr0aray(y-1el-:elenl(mlg-teplhln-otip:sneotloeienfmrtne(eernwtlal--rrtp)y)opiennet(wearr0raar(yr)1-))-e)le(mlel-npt-otiynpteer

arr) arr)))

fuondrleocsos(uv(nemtctfeormor-mbpeur0scho-uenxttetnhdemel :atrers))t)))#'=)

((ddooiitt sseeggmmeenntt-s)pos)

((dseetcqf dlineleest)ed (append deleted them))))

5.10.21 Miscellaneous Functions
like-new is a routine which restores the state of the lines to what they were before any lines were deleted. This
was useful for debugging.
(de(fsmenedth(osden(dpaseglef :pimaraaglele)l-:nlianmese)))() (d(eflo(mwoephthewfdnoooidrt(hen(lolcabtoseut(inneagqtn-ldtslhaecesgotaumernrle)ta)ny=t-(sei0nlpecmaf rceaonlultesnlt-o))lfinraews)-(id)
(sneatlqlyla(srteteul)rn-from count-segments count)))
(de(((fcscmeootmneqstpthdruoeutdlceet-t(-emlidinkedendi-iivla)nidneu-wawli-pdsatehrgamsleleelfnl)-)tlsinseeslf)) ()

5.10.22 Definition of a Full Page of Staff Lines
The :fasd-form method here and elsewhere instructs the lisp machine how to save a representation of the object
to a file.

101

(de::sgeettattvaaobbrlleep(--paiinangsrseatt-alalnsentclc-aeel--invv-eaalsrir)niiaaebbsllee(ss(mode(mnial)xim(sutam-snnuiml)b(esry-sotfe-mlisnensi-l)to-remove 30))
:initable-instance-variables)
(d"efsmtaet"h)od (moniker page-sta -lines) () (de`(fw(lefhtleo(tp((pit(esr,e(t(le-:xfsaptasr-dc--oflinontreimnsu(ept-ahwignhego-)pst(paseern-adlrignthse)isn))g)(:&seret-ststaarg-s)lines it)))
i(tl)o)((ommpaappfoccraarrs ##in''ss(eetts--enssttdaait--:llsiinnyeessste((mssees)nndddoiitt(::rsseytsasettes-m))s)ts)a)ves s))

5.10.23 Compute the Mode Distance between Lines

(defmethod (compute-mode page-sta -lines) ()

(let ((max-spacing

(loop

ffoorr for

inroebwxetl-o=wro(ws(e1c=-on((dsleenc(oganrtehdf

s(seeaggrmemfeesnnettgss)m)i)e)nts

(1+

i)))

(stack-let (m(baixnims (izme a(kaeb-sa(rr-ayro(w+ nmeaxtx--rsopwa)c))i)n)g 10) :initial-element 0 :element-type ' xnum)))

(loop

for ffoorr

irnoebwxetl-o=wro(wa(r1e=-f

(s(ealegrenmfgetsnhetg-smepgeomnstei-)nptos)s)(1+

i))

(l(oionpcffdo(orarsefbebiinngs t(haebsar(rraoyu-nedlem(-enntesxot-frboiwnsrow))))))

wfwoihrtehcnomu(na>txsf=rmo0maxa)n0ddow(hseerteq where count max s)

nally (return (setq mode where))))))

5.10.24 Decide if the Set of Staff Lines Could Make Sense

A set of staff lines makes sense when there are a multiple of five of them, and each has a neighbor whose distance is approximately the mode distance between lines.
(defmethod (could-lines-make-sense? page-sta -lines) ()
(and ((zloeoroppww(iittmhhoctdoolu(enlreatnng=cteh0=se(g*m*esnlatsc)k-5s))ta -line-spacing-percentage* mode) ((lso(esoteqpdwwtqolihfatoihcslretociu((obla<duerllecd(ofoaw=usnend4tgtmacd(onoeluednnltdlg-atps(ht<oss(ecagobmusne(nt)-t)-mpoosd))e (- (aref segment-pos (incf count)) last))) tolerance))) (in(sceftncqaollulaynstt()r(eatruerfnsecgomulde)n))t)-pos count)))

102

(de(flemte(t(hloinde

((roerm((loisnuvere-p-srwhisoionrrtgseltry---ltsihnhaeonr-tp-nlaeingigeeh-sbseotlrfa)s

-lines)
self)

()

(delete-line (saeslfk-linues)e))r-for-line self))))

5.10.25 Ways of Choosing a Bad Line to Remove

(defmethod (line-shorter-than-neighbors page-sta -lines) ()

(stack-let (declare

((((slryeisgf:thatr(rma(yma-kareek-gea-isratrraerryayl(elf(etlnergnigtghhtths))esgemgmenetnst))s)))))

((clooomppwutiteh-lseefgt-maenndt-sri=gh(tlesneglfthlesftegrmighent)t-pos)

fwfooirrthiabbboeigvlogewe=stsm-egdomiste-=npt2sosaitnivdew- hxenreum= nthilen middle

fffwooonhrrrdaeobmdlnlieyi(l(dos(>d=werlteedq(t=iui=fbr(ni((ibgf<-igwg(ea(gh=sbaeetros(-retev1df-)e)+i)dr)ibiig)deh)lisotewg0w))mh((ee-anrertaes)ifb)omlveeoftsmt0-)i)dpdotlshei)etinv(eb--ebloxewnlouwmm(-idd(laer))ef right (1+ i)) (aref left (1+ i))))

(de(fsmtaectkh-oldet((s(ulerfptri(sminagklye--asrhroaryt-(lleinnegtphasgeeg-msteants-)))lines) (&aux (segments segments))

(((dclooeocmplaprwuetite(h(-srylseisgef:gtha-mtrara(enynmd-t-asrreki=gge-ih(sattleresrnraeglylfethf(ltelesfrtenigggrhmitgth)he)nts)et-gmpoesn)tsa))n))d where = nil

for i below segments

wfoirthwsidhtohrt=es(t-=(maroesftr-ipgohstiti)ive(-arexfnluemft i))

wnhaelnly((<rewtuidrtnh(sihf o(r<tessht)ordteost(s(e/tqmsohdoert3e)s)t

width where

where nil)))))

i)

5.10.26 Group Each Five Staff Lines into a Staff

(defmethod (split-sta s page-sta -lines) ()

(setq

sta s (loop

for i below lines by 5 for count collecting (make-instance

from

0

:':toyh-nepe--olssintitaeiosn(m(makaek-ea-rarraryay55:d:idsipslpalcaecde-dt-otosesgemgmenetnst-:dpiospsl:adciesdp-laincedde-x-inodesxe-toi)set i)

:::msfrtoaomd-e--ltisnopepasccsoienulgfntmode))))

5.10.27 Try to Figure Out How Many Staffs in a System

(defmethod (intersta s page-sta -lines) ()

(loop

fwohre(ns r.ersetsct)olloenctsintag

s
(-

(top

(

rst

rest))

(bottom

s))))

(defmethod (intersta -larger-than-neighbors page-sta -lines) ()
(loop fwohre(nla(satntdhitshnisexnte)xto)nc(oilnletecrtsintag (sasnedlf)(> this last) (> this next))))

103

(de(flemte(t(h(polodosos(pidbiefloittreierpsmosisnieb-lenf-rtoemt

page-sta
2 to 6

-lines) ()

(if (= (lengwwthhitehpnoin(stspeiobrssilstiatibielys-)-bni1g-)gteert?se=lf(iinntteerrssttaa --blairgggeerr-?thpaons-sinbeleig)hcboolrlescsteplf)ossible)))

((acaskr-puossesri-btiloit-icehs)oose-arrangement self possibilities))))

(defmethod (possibly-n-tet page-sta -lines) (intersta -bigger? n)
(loop faolwr ai yfsrom(n(th- inin2t)erbsytan -bbeliogwger(?l)e))ngth intersta -bigger?)

(d((efdlemrtaew(t(hnsoeadlmf)(eass(kv-eucsteorr-:tsoo-loch:douoeste:-tarirora:nqugaermteetn:tqupiantgeet-:ssteaxte-t)l)i)nes) (possibilities)
(1(+position (dw:accept-values nam`((e:(spm)r))o)emmpbter"I,@c(alno'otp gfourrepoinutpwoshsaibt isliotrietsocfoalrleractnignmg e(natretfhnisamis.esW(h1a-t pis)))i)t?")))

5.10.28 Construct the System Objects
(defmethod (make-systems page-sta -lines) (&optional (n-tet (determine-n-tet self)))
(le(tse(t(qsts(aylostosep(mcucsoonpltlyiel-c(ltiinsntuglslt(samtaas)k)s)e)-ifnosrtcaonucnet:'tohfrneoe-m-sstay0svteesm(loop repeat n-tet collect (pop sta s)) ::sfrtoam--ltinoepscsoeulfnt
)))))

5.10.29 Definition of a Page of Measure Lines.

Mostly, I fool the staff lines into being vertical. For instance in the draw method I just modifies the usual method
by switching the x and y arguments.

(de avor page-measure-lines ()
:::sgineeitttttaaabbbllelee-(--ipininanssrstattaalanlnencclce-ee-l--ivnvvaeaarsrri)iaiaabbblleleess)s

(defmethod (moniker page-measure-lines) ()
"measure")

(defmethod (map-measure-lines page-measure-lines) (function)

((sdteacclakr-ele(tv(a((lulreiegfstht((wm(mhaikcaehk-eat-orarprarybayo(tl(etolnemgntghpthossesigtemigomne)n)e)tnst))s)))))

(declare (sys:array-register left right))

((lcooomppffuootrrelr-lbbeeeftiinn-gganttdhh-eeriaagrrhrratayys--eeellfleelmmefeetnnrttisgs hootff

1le)ft right

ffoorr cpoousnbtefinrogmth0e array-elements of segment-pos

(funcdaoll function count l r pos))))

104

(defmethod (sort-segments page-measure-lines) (&rest ignore) nil) (defwhopper (draw page-measure-lines) (&rest args)
(unwi(npdr-opgrnot((erlecoxttpart-ecfornawtin-uxer-awwh-oyp)per args)) (rotatef raw-x raw-y)))
(defmethod (draw-a-segment page-measure-lines) (x0 y0 x1 y1 &rest args)
(apply 'draw-line y0 x0 y1 x1 args))
5.10.30 Definition of a Staff Line
(de avor one-sta (the-lines from-top sta -lines mode-spacing
:::sgineeitttttaaabbbllelee-(--hiininansssstt-taaarnnenclccaeee-t--ivovvanaarrsriiaiaaubbbtylliele-les-sp)smosixitiino)n roughly-one-line line-functions )
(de(fomnee-thlionde (semlf)a)ke-instance one-sta ) (&rest ignore) (defmethod (sys:print-self one-sta ) (stream print-depth slashify-p)
((figonrmoraetpsrtirneta-mde"pt#h<~s:lar sshtiafy-opn) page ~a>" (1+ from-top) (send (send sta -lines :image) :name)))
(defmethod (:fasd-form-of one-sta ) (symbol)
(eq symbol 'sta -lines))
5.10.31 Simple Functions of Staffs Lines
(de(fsmeteqthrooudg(holyn-eo-nlein-elinoen(e/-s(t-a ()bo(t)tom self) (top self)) 5))) (defmethod (relative-position one-sta ) (position &aux (x (car position))) ; position is cons x y
(cond (((((t<>:ixxns((id-+e)(())tboopttsoemlf)serolf)ugrholuyg-holnye--olninee-))lin:ea)b)o:vbee)low)
(de(fsmenedth(osden(dpa(gseendonsee-lfs:tsata)-(l)ines) :image) :name)) (de(famreeftyh-opdo(stitoiopno0n))e-sta )() (de(famreeftyh-opdo(sbitoiotnto4m)) one-sta )() (de(fmmaepthnoild((d(rya)w(-dcrlaipwp-ead--sesgemlf eonntes-tsata-li)ne(slelfetftriyghrti)ght y)) y-position))
5.10.32 Compute Functions for Estimation of Line from Position.
I take the x and y positions of each of the segment and do linear regression, fitting line number against the x and y. Output are the coefficients which are used to convert back and forth between line number and position.
105

(de(flemte((t(chpoooedin(stcs(om(m/apk(uele-tneag-rrtlahinye(3-a)r)f)eufntchteio-nlinseosn0e))-s2t)a) ) ()

(stack-let ((((srluhusm((msma(akmeka-ek-aera-rrarayaryr'a(3y3':3(in)3)i)t3ia)l-:einleitmiael-netle0ms0e))nt 0s0))

(m(ascerotqletl(in((ple(os-inof(pc`um(fn-sfcaoectktroifeoes-n(easagrcrmreiaefeynnst3ut)(m)b)iesjlo,viw),j)(1(-inpcof i(natsr)ef sums ,j ,i) ,v))))

(lo(loo((pdfiionnoopffdrccooofffd(rr--osoccllrtiioonna(eereext-xbnycce)usiiieetnmaonngrnttbtety00(hrnee10fntrhado((crxm**rdarexxy2n-(yxd*be))))yly)esme-og1enmnt(esanrtoeff2)tthhleien--elli)innebessy

0) by 'cddr

'cddr for count

below

2

(ma(((((((tiiiiiiihnnnnnnn:cccccccdfffffff---e-(((cccccaaaooooorrrmeeeeeeefffprrrocccchhhiiiiseeeesssennnn210tttts)))u0112ml((i2122**nse(((1lll-uii)***nnneepuxyy--s))m)))nny)uub)mmer)bb))eerr yx))))

(mathco:slolelcvte (lulisptsstrahrstxcoeendsx) coe s)))))))

5.10.33 Conversion between Position and Line Number

(de(fwmh(ecetonhmo(dpnuo(ttpe(-itvlcianhrei-a-pbfuolens-cibttiiooounnnsdospneellfi-)n)set-afu)nc(txiony)s)) ;; compute it on demand

(loop

fuonnrtai(lllsy(ta<(r=rtetseutnardnrtc(xoreoeunsnd))d

in line-functions (+ (* (aref coe

s 0) x) (* (aref

coe

s

1)

y) (aref coe

s 2)) .5))))

(d(efwmheetnho(dno(tn(ovramriaalbilzee-db-oyu-ncdopolridnien-afutencotinoen-s)s)ta;; )co(mxpyu)te it on demand
(lo(ocpomfuonnr(ptalui(le(lltstyre(te-(<at(lur=itlnrinnseete-na(fdr(vut+ancxlcou(teee*iosn(nsd()a)s+riesn(efallfcir)no)eefe-yfs-upn0)ocstxiiot)ino(sn*2()ar(e/f lcinoee (sar1e)f yc)oe(asre1f))c)oelinse))2)))))))

5.10.34 Definition of a System

(de avor one-system (the-staves from-top sta -lines half-sta (measure-lines nil) roughly-one-line)
:settable(-hinasst-arnelcaet-iovnarsiaubtliel-sm:gixeitnt)able-instance-variables :initable-instance-variables)

(de(fwmhee(tnsheo(tqdneh(qamlsfat-akseta--liinn(setsaotno)cr;e(; -on(eb-ostytosmtemsel:f)af(tteor)p

(&rest ignore) self)) 2)))

(one-line self))

106

(De((fifgmonremotrhaeotpdsrti(rnestay-msd:epp"rt#inh<t~s-:lsaresshlyfisfotyen-mep)-osnysptaegme)~(as>t"re(a1m+

print-depth slashify-p) from-top) (send (send

sta

-lines

:image) :name)))

(de(fsmeteqthtohed-(srteavseest-(sltoaovpefsoronweh-icshysitnemth)e-(s)taves collecting (nth which (send sta -lines :sta s))))
(setq half-sta ( oor (- (bottom self) (top self)) 2)) (one-line self))

(defmethod (:fasd-form-of one-system) (symbol)
(c(a(ssthteaes-y-smtliabnveoesls t`)(list ,@(loop for s in the-staves collecting (send s :from-top))))))

5.10.35 Draw a System
(defmethod (draw-self one-system) ()
(let ((((britogothptto(m(troe(pdbusoceteltf)o)(m(saelbf))) (min a (car b))) measure-lines :initial-value most-positive- xnum)) (lo(olpeffto(rr(epdouscietio(n)(ainb)me(amsuaxre-alin(ecsardbo))) measure-lines :initial-value 0))) ((mdraapwc-a(-s(esgtmaf)en(tdsrtaaw--clliinpepsepdo-ssietlifonstatof plepftosriigtihotn))btohtet-osmta))ves)))

5.10.36 Simple Functions of System

(de(fum(nsleeetsthsqo(drno(uuomgnhbelye--rlpoinn(eec-aolrinnteeh-e(s-/ysst(ta+evme(s)o))n(e;)-; liinneca(steopw-estaarveemsealkf)i)ng(oinnset-alnincee

from fasd le (bottom-stave

self)))

2))))

(de(fcmaretthhoe-ds(tatvoeps-))stave one-system) ()

(de(fcmaret(hlaosdt (thbeo-tsttoamve-s)s))tave one-system) ()

(defmethod (relative-position one-system) (position &aux (x (car position))) ; position is cons x y
(cond (((((t<>:ixxns((id-+e)(())tboopttsoemlf)serolf)ugrholuyg-holnye--olninee-))lin:ea)b)o:vbee)low)

(de(fsmenedth(osden(dpa(gseendonsee-lfs:yssttaem-l)in(e)s) :image) :name))

(defmethod (top one-system)()
(top (car the-staves)))

(de(fbmotettohmod((cbarot(tlaosmt tohne-es-tsayvsetse))m)))()

5.10.37 Attach Measure Lines to Systems

Each system decides which measure lines are part of it. This help rule out potential measure lines, since a line is ignored if it doesn't significantly overlap the system.

107

(de(flemt*eth(((oiodnus(tidsgiedrae(bs(-e-lpf-obitonetttneortmsiaeclt-toimopneinassseiuldfrete))o-)plinbeototonme-))system) (top bottom position)
((iufn((pleausnssdh(((v>alirsiitnabspilodese-itboioouuntns(iddcpeo)nms(e>taosipnusrbeid-oetlitnhoeamsl)f)-)(smtsaeetqa))smureea-sliunrees-)lines nil)) nil)))

(defmethod (self-intersection one-system) (top bottom &aux (my-top (top self)) (my-bottom (bottom self)))

(cond

((((((oaarnndd(<((><b==ottttoooppmmmmyyy---ttootopp))p)(((<>>==

tbbooopttttmoommy-mmboyyt--tbbomoott)tt)oomm0)))));

no
((-

intersection bmoyt-tobmotttoomp))m;yc-otmopp))le;tesluyrcroounntadisned

(((t<(-tomp ym-yb-ottotop)m(t-opb)o)))ttom my-top)) ; bottom is between

5.10.38 Test for Double Measure Lines.
This is a standin, I never got to the stage where it mattered.
(de(flomoepthfwoohdrdeo(n(t)i)hg(inasnotdrheot-thdhooetruh)ebrolen(-<mst(ea-as(-uclriaenr-eltsihnioess)ne(-csayrsttheomth)e(r))) *double-measure-line-threshold*))

5.10.39 Definition of a Page of Bars.
(de:::gsineeittatttavaabobblrlelee-p(--iuainintngsissltet-ta-aamnnonccifcex-ee-i-bn-v)vavaaarrrsriiaiaa(bbbslletleeasss)-lines measure-lines) (de(fsmenedth(osden(dpa(gseendpasgelef-:ostfa-b-alrisn)es()):image) :name)) (de(fwmiteht-hroodom(d-rfaowr-ipmaaggee-o((fs-ebn:aldarbss)etla((&f-oolprinmteioasnt:('ani(smli:ele(nau"rdger~eedV)(xusc:e:reinMte-addbeluiyascctsea7:u-h.rb9ue-)ysg)lienfr)reeodsmu:cime~-Aabg~ye)":name))
(mapc 'draw-self (send s:tlaabe-ll-inoebsje:cstyssteelmf)s))))

108

Chapter 6
Locating Stems
Stems
Figure 6-1: Some examples of stems.
6.1 Introduction
Stems are the small lines which lead vertically from a note head head. From the point of view of optical recognition of music, stems serve several purposes. When the note is part of a beamed group the stem leads from the note head to the beam. Since a stem or any of the flags can be attached to a solid note-head, the stem distinguishes a solid note head as being a quarter note. When several notes are played as a chord, a stem attaches them. A stem is also part of the shape of half note head. Perhaps most importantly for this work, when a note is either above or below a staff, the stem points in the direction of the staff, sometimes being the decisive factor in deciding whether a note is part of the staff above it ot the staff below.
109

In fact, in all the of the cases of stem use but the last, the stem represents information which is recoverable from other sources. Flags are found by the same method that note heads are found. The stem on a half-note gives no additional information. The shape of a half note, though similar to a whole note, is distinct.
The stems which attach a note to a beam are also redundant information. In fact all the notes which belong to the staff that the beam is in lie either above or below the beam, and their horizontal positions are bounded by the horizontal extent of the beam.
The only stems which are of any use at all are those stems which are attached to notes which lie between staffs. I would like to write that given that only these stems are interesting, these are the only steams that will be set about to be found. Unfortunately, the reality of the development of this module unfortunately disturbs the flow of the prose.
In fact I first made attempts to write algorithms to find all stems, and found this very difficult to do. There are several reasons for this. Stems are thin so any noise (dirt, nonuniformity) in the printing easily affects their shapes. The length of stems is not uniform. If a note is close to a beam then the stem will be short - sometimes of length smaller than the note itself. Stems are hard to disconnnect from their environment. They touch the note heads, cross several staff lines, and are perilously close to accidentals and the like.
During these experiments I noticed that all the algorithms worked the best when the stem was isolated from its surroundings, i.e. when it was attached to a note which was outside of a staff. Elsewhere, the algorithms found stems where they didn't belong and didn't find them where they did belong.
It was after this experimentation that I realized that finding stems didn't matter that much, except in certain places, and those places were exactly the places where they were easiest to find. So the strategy changed: instead of looking for all stems, use an algorithm which does well for stems which are isolated. Later, only use the stem information on demand, when the stem can supply some information that can't be derived in any other way.
To find stems I use the following series of steps, illustrated in Figure 6-2. First remove points which are part of a horizontal run wider than the average stem thickness. This leaves the greater part of stems untouched, and almost everything else in the score disappears, since most things are wider than a stem. A side effect of this is that where a staff line crosses a stem, a small gap in the stem is produced, since that part of the stem is also part of the long horizontal staff line.
These gaps need to be repaired. The gap repair method has each white point looking to see if there is a black point nearby above and nearby below it. If there are then it turns itself black.
Finally the stems need to be extracted from the connection machine. In order to do this, they need to be uniquely labelled. The labelling algorithm is not at all general, it exploits the fact that the stem regions are essentially rectangular. To label a stem we first spread a unique marker horizontally, and then vertically. I call this the peanut butter region labelling algorithm, since it resembled the spreading of peanut butter on bread. The front end representation records the coordinates of the top of the stem, and its height.
110

1 23 45
Figure 6-2: Processing stages in locating stems: 1) Original, 2) After filter, 3) after bleed 4) after removing short things 5) result.
111

6.2 Future Work
Some experiments have been done to see whether the stem information in its current form is in fact adequate to disambiguate which staff notes belong to which staffs. The results look promising, but a final assessment will only be available once more work on assembling a complete score is done.
6.3 The Code
6.3.1 Definition of a stem feature
(d(:ei:ncioatanvbostlrer-ustcinetsomtra-mnfceaeak-tevu-arsretiae(mbtleo(sptolepftlehfteihgehitg)h(t)b)asic-recognized-feature sys:property-list-mixin)
:gettable-instance-variables)
(defmethod (make-instance stem-feature) (&rest ignore)
(setq reduced-x left reduced-y top my-feature self))
(defmethod (pretty-name stem-feature) () "a stem") (defmethod (:my-feature stem-feature) () self) (de(fdmraewth-olidne(dlerfatwtosptelemft-(f+eattoupreh)ei(g&hkt)ey:a(laulual:ud))raw)) (de(f+mteotphohdeig(bhto))ttom stem-feature) () (defmethod (top stem-feature) ()
top)
6.3.2 Filtering
Filter out stuff which isn't a good stem candidate
(defun nd-stems (&option(vael r(tmicaalx-igmaupm1-0w)i(dmthin4i)m(uhmor-ihzoeingthatl-2b0l)ee&da1u)x them)
(*locally-type (:fast) (lo(wopi(t-*hos-evnteersi-glishcliebcoe(rsa-n(cdsol!ui!cnestlsi*cl(eass(lti<c-e!i!m0(a+mg!e!a-x(ti!om!-u1c)mml-*e)wfti-dctoh)unt right-count) (!!i maximum-width))))) ((((wbfolli(elrt--*ehidvsn-ei--nsthuveosaeiglrrli-ihtczitebcoyoan(prlta-e-ansgcldoa(s!puil!misncsteaslsilgcihc(eeoe-sr(ltiivz>coeoe!-r!nftmbti(ca+iasln!-lli!i-bcmg(ele)au!)e!pmd)1)-)haebigohvte0-)count below-count) (!!i minimum-height))))) (for-visual-types (image-to-fb slice))
(ma(kpe-usinhst(aqnucieck'-plaagbee-l-osf-tesmtesmssli:ctehecmolu(mapnp-lsyta'rntcoronwc-tshteamrt)) :itmheamge)))(pvar-getf *last-image-to-cm* :image)))
112

6.3.3 Fill in Vertical Gaps
(defun ll-in-vertical-gaps (slice &optional (radius 1))
(*l(o*claetlly(-(thyapseup(n(esliigchebto)r :sfaliscte)) ((*lotoy(pphefao(sr(dhroawbsendlnooewwignrhnabediogiruhsbsloicre)h)asupneighbor) t)) ((**sseettdohhaassduopwneningehibgohrbo(ror(!!orh!!ashuapsndeoiwghnbnoerig(hnbeowr s(-nbeowrds-erb!o!rhdaers!u!phnaesigdhobwonrnneiigl!h!b0or1))n)il!! 0 -1))) (and mnoavlileyp((*ismetagseli-cteo(-ofbr!!slsicliec)e))))(and!! hasupneighbor hasdownneighbor))))
6.3.4 Label the Stem Regions

This is a quick and dirty region labelling. Since stems are pretty much rectangles, I can get away with token spread

horizontally and then vertically.

(de(f*ul(en*ttqy(u(plieacbk:fe-allsa(tb!(!ell0a-)b)setlteo:mcpusbbo(e)tstlio(c(metoclpoelfubtmortingt-ohmst)tasrlticreowle-ftstraigrtht&)aut)x) smaller-set smaller-size)

(((((;c*****awssss(;(;(l;;eeee*csshtttteelsuwaemttllrbtnbahqqeioogoteefpsetsstlhnoltmmits((obc(haaaaem(oannllaulnlladdeenn(dbrr!!dda!--!!e!!anssl!ssriedtlluziisiote!ccepl!spiee(/c(svedl(l(1epioxcx+f(swteooex)(rrtno(!!*-(r,!!xm!t*o!l((oesrala-(efe!xtb!rtf/itotg(ll!rava!hbisgbebmtes!hee!ll!!olitla)c),wsls)(elllu)eie!ic!crpne-se/us))lsildmicizscoseleeel)wii)))rcc))anees)t)))el))i!c!e))))))

(*set label (scan!! label 'max!! :dimension 1 :segment-pvar top))

(((***ssseeettt

label llaabbeell

(((ssscccaaannn!!!!!!

label llaabbeell

'copy!! ''cmoapxy!!!!

:dimension ::ddiimmeennssiioonn

1 00

:::ssseeegggmmmeeennnttt---pppvvvaaarrr

lrbeifogttht)t)om:dir:edcirteiocntio:nba:cbkawckarwdasr))ds))

(;e*xw((((t***frioatsslehreec-t-ttt-vxlli(iaa-nsxbuba-aeenv(llldpy-((--t(ssysy!ccep!aa(tenn0xss)!!p)m!!(o*all(saaalhlbbyleelpeeri(gll-orhss''a)mcetiotna(pbx!y!o!!!w!0:)-:)ddsiimc(maveleaennl-issdtiiooonn-nifl1!b1!):)(:ssieefg!g!mm(eeznnettr--opppv!v!aarrlatbbooeptl)))tolmabe:dl i(re1c+t!i!on(m:boadc!k!wlaabrdesl))(!!i 254))))))))

(*type (x %xpos) ((y height) %ypos) (valid t))

(*w((**hppessneett(a::mmndiinn!!xytppooopss

lxeftl)abel :notify y label))

valid)

(*when (and!! bottom right)

(*(w(**itpshes-tetahle:l-migvahpxt-sy(ep-to!!ssmhheaeiilgglehhrtt-syl)ea)tbel))

(extract-stems x y height valid smaller-size column-start row-start)

)))))

113

6.3.5 Extract a Representation of the Stems
(defun extract-stems (x y height valid howmany column-start row-start)
(*l(osctaalclky--tleytpe(((x(ax(:mealdk)e-(ayrr:ayelhdo)w(mheaingyh))t : eld) (valid t)) (((yhvaaeilgi(dhmataa(km(em-aakarekr-aeay-rarhraoryawyhmohawonwmym)a)nayny:)e)lement-type 'boolean)))
(((pppvvvaaarrr---tttooo---aaarrrrrraaayyy hxyexyigaah::tccuuhbbeeeig--haatddaddrr:ecesusssb--eee-nnaddddhhrooewwssmm-eaannndyy))howmany) ((plovoapr-fftooorr-tlaeorfprtabybeeviinnaglgidtthhveealaaidrrarraay:yc--ueeblleeemm-aeednndttsrseoossff-xyeaand howmany)
ffoorr vhaeliigdhtbebienigngthteheararrarya-ye-leelmemenetnstsofovfahleidigahta when valid collecting (make-stem (+ top row-start) (+ left column-start) height)))))
(defmethod (probably-not-a-stem stem-feature) ()
(> height #.(* 10 (send ( nd-feature :solid) :height))))
6.3.6 Definition of a Page of Stems.
(de::gineitattavaboblrele-p-ianingssteta-anoncfce-e-s-vtvaearmriaiasbbl(elestsh)em image positions) (util-mixin) (de(fwmiteht-hroodom(d-rfaowr-ipmaaggee-of-stems) (&key (reduce-by 4) (coloring-function ( (ignore) :draw)))
(image :r::lleaadbbueeclle-(-opbbryjeetcrtetyd-suneclafe)m-bey(car them)) (map nil ( (f) (dw(d:wraiwth-f o:aultupu(tf-uansc-apllrecsoelnotriantgio-nfu(n:cotbiojenctf))f)):type 'sys:expression)
them)))
114

Chapter 7
Locating Ties and Slurs

a tie

Figure 7-1: Some examples of ties and the contexts in which they appear.
7.1 Introduction
Ties and slurs are curved lines which connect one note to another. Ties connect notes of the same pitch signifying that the notes are to be played as one longer note. Slurs connect notes with different pitches and indicate that the notes should be played with each leading smoothly into the next. In the rest of this section I'll use the word ties to mean both, since they are graphically equivalent.
Ties are of variable length, and of variable curvature. Their start and end points need not be at the same height. Occasionally, a tie is broken across two systems, when a group of notes which it refers to cannot fit on a
115

single system The thickness of a tie varies across its length, being thicker in the middle, and tapering to a point at the ends. Ties begin and end at specific notes, and modify the interpretation of all the notes between these. In searching for a representation to be used in the later interpretation of the score this extent is the only semantic information which is carried by the tie, and so the only information which is necessary to represent eventually are these endpoints.
Finding ties is hard because their shape varies a lot, and they intersect many things, at least staff lines and measure lines, and often stems, heads and accidentals. Because of the size variability the template matching approach won't work in general, though it might be useful for finding the class of short slurs which may be more fixed in their shape. An approach of trying to distinguish ties from other objects, rather than directly identifying them might have worked if ties didn't intersect all sorts of other things.
I have not yet completed the work on finding ties, but have done what I hope is a promising start. After looking at ties for while, I decided that the most salient feature of ties was that they were long "line-like" things. The question then became, how do you find line-like things on a scanned image. Here is the strategy I used.
I tried to develop a filter which removes the parts of the image which are not ties. In this way subsequent passes can more easily focus on candidate for tieness. Consider a neighborhood around each point on the score. The black points in this neighborhood are fit to line. When the goodness of fit is better than some threshold the pixel is considered to be part of some line-like thing.
When I first tried this, I found was almost every point had a poor goodness of fit. The problem was twofold. First, even line-like things in the image had a thickness of more than one pixel. Because of this I was fitting a line to a rectangle yielding a poor fit. Second, using every point in a neighborhood was a bad idea. Consider a white point which is sandwiched by two parallel black lines. Any neighborhood of the white point contains some black, and yet the point, being white, is most certainly not part of any line. Consider a point on one of the black lines. Most neighborhoods of the line the point is on also contain the other line. Even though the the point is certainly part of a line, the presence of the points on the other line will disturb the fit.
Each of these problems has a separate solution. To attack the problem of thick lines, I used a thinning or skeletonizing algorithm invented by Zhang and Suen [3]. This image transform erodes the black areas in an image in such a way as to preserve the topological properties of regions, while leaving no more than a couple of pixels in a row black. With a processor per pixel, this algorithm takes time proportional to lesser of the width or the height of the area a pixel is part of. The transform substantially distorts other parts of the image. Note-heads, for example, are usually turned into crosses. The algorithm works well, however, in the case of ties where it leaves a line a pixel wide where ties used to be.
To address the problem of undesired fit points in the neighborhood, I decided to use only a locally connected area surrounding each point in the image(as in Figure 7-2). The parallel implementation is interesting. Each processor goes through a step where it communicates with its neighbors to assemble a bitmap of the image in its
116

a

b

Fit Range Connected points Best Line

c

Figure 7-2: To filter for line like objects, a line is fit in the connected neighborhood of each point. When the line doesn't fit well, as in c the point is not considered part of a line. In b notice that the top grey line is not part of the fit, since it is not connected

neighborhood. The line is fit only to processors which are connected to the central point. Actually, I use an approximation to connectivity which I call local spiral connectivity, since testing for true
connectivity would take much more time. It is local in that points are not considered connected if there is no connecting path which goes completely through the neighborhood. It is spiral because the algorithm for deciding connectivity proceeds by looping through a spiral starting at the center of the bitmap. At each step it encounters a new point which needs to be classified as being connected to the center point. A new point is considered to be connected if one of its neighbors has already been noted as being connected.
In practice, this version of connectivity serves my purpose well. Fits to the points chosen this way have a goodness of fit which distinguishes well between points which are not line-like and points which are. To tighten the filter, a further test is made to see whether the line which is fit passes within a small distance of the target point. If it is too far away, the point is not considered part of as line.
Running the filter has the effect of disconnecting line segments, since vertices don't fit a line well. It also has the serendipitous effect of removing some other line-like things which we are not interested in - measure lines. Measure lines are vertical and the standard least squares fit can not fit nearly vertical lines. This is because it computes its parameters in terms of slope and intercepts, and a vertical line has an infinite slope.
This is the point at which my work on ties stops. The image in this state looks like a bunch of disconnected line segments(see Figure 7-3), with other smaller scattered noise. Staff lines are still prominent, since they too are line-like, but they no longer connect features together. We already know, from the staff line work where they are,

117

12
34
56
Figure 7-3: Images 1 through 5 show the progress of the skeletonizing algorithm. Image 6 show the final skeletonized image after points which are not parts of lines are removed.
Figure 7-4: Line segments need to be reattached in order to reconstruct ties. In order to do this, one searches in a cone which the tangent bisects, for other segments. When the search areas overlap, there is a potential attachment point.
118

so they can easily be eliminated. Longer ties are interrupted at vertices. What needs to be done is to put these interrupted segments back together, and then determine which represent ties. Line segments can be reconnected by searching in a neighborhood around their endpoints(Figure 7-4). The slope of a tangent of a line continuation should be close to the tangent line at the endpoint being searched from. This search can be done in parallel. Where there are more than a single potential continuation, both should be accepted as potential lines.
Thes lines can then be checked for other constraints. The strongest constraints are that a tie starts and ends near notes(except at the end of a system line), and that the slope of the tangents to the line at each end are of opposite sign. The tie slopes upward at one end and downward at the other, or vice versa.
7.2 The Code
7.2.1 Finding the Ties
The code here is for debugging and exploration. Explore lines lets me experiment with changing various parameters and viewing the results on the framebuffer.
(defun test-thin-lines (&optional (radius 4) (acceptable 1) (slice '(0 0)))
(*n((**owwwaaitrrhnm--vpb-osoett) *osr-image-set* (*a(*lllet ((places (plusp!! (aref!! *last-image-to-cm* (!!i (car slice)) (!!i (second slice))))) ((*imtya(pgteeh-(in(tnope-ladfcbenpsill!at!h)c)iensn)ed) t)) (((*itmhleiantg-(ei(m-litnaoge--efpbplaltahcceienssnnetidhl)!i!n)ned) (((igsnlootoeprdecne(ep!s!ts0(()!)!!! 00))))) ((*lintyep-eth(r(opulgahce-scolinnnee-cptleadc-esr)egti)on((tshloinpneedgoroaddniuessslininet-eprclaecpet)s s^l)o)pe (explore-line places line-places slopinetgerocoedpntegsso))o))d))n)ess acceptable)
119

(defun explore-line (places line-places slope goodness)

(format t "~#%=s(loI)pme athgreeGsh(ooloddBne(sasd) lSin(elsopoeu)t)L(Ci(noeloprleadcelsi)neos)r "E)(xit)

(lo(*ol(pe*tfwwdtoy(oiir)ptthheinnts(h(turrsmueloscbhpteioeorlsndgo===o'd2((n#se\csl0s:)s#e\^n)1d

#*\q2ue#ry\-3io#*\4:ty#i)\5 #\6 #\7 ((places line-places) t))

#\8

#\9)

(wh(seentq(mthermesbheorldin(stprouscittiioonn ninusmtrbuecrtsio)n numbers)))

(c(a(#s#e\\iein((sitrmreutaucgtreino--ntfor-omfb pexlapcloesr)e)-line nil))

(((###\\\gsl (((igmgrreaeyyg--es-scctaaoll-ee-f-bttool-i-nffebb-(pgaloabocsed!s!n))esslosp(e*)

threshold 10))) threshold))

((##\\bc ((*iml((ernatao*girnem(-b(toat(owhlci-zeo-femlsbo-crc(a(o<l(<elc!o!-!o!rtlsgogoo-olri-ofnobbdedl-nnocpeeobslslsasoscrt()(eh)!)s!e)!!)m)c1)1o)..)l00)o)))r))))color)

7.2.2 Thinning
This is an implementation of the thinning algorithm of Zhang and Suen [1984], as described in Digital Image Processing, by Gonzalez and Wintz, pages 398 to 402. The transform takes an image and thins it by eroding the edges of blobs, such that connectivity, number of holes, and edges of lines are preserved.

120

(defun thin-image
(*a(*lllet (neigbors

(t&haiucxk

thinned ('(n(e0ig-h1b)or(-1o-s1e)ts(1

0)

(1

1)

(0

1)

(-1

1)

(-1

0)

(-1

number-of-neigbors number-of-transitions old-thinned)

-1))))

((*mtaycpreol:(efnates(itg((bnooo`(lrtdns--oa(ttl@hl!!i(n8(naeetnl)dd)d!t(&)!(rt,e(@hs(ti(nclukbomiottsphb)ienfron-reodbf)-itntr)a)bnitssiticoonllsecntuinmgb`e(ra-roeff-!n! e,igebldor(s)!!

4) ,b))))))

(flet ((c((o*l((ouposoenrnpottep--nfdesotuotrrrmu-a((snb*idszesix(etre)-itdo(foy)nf)(--'aon(irnnae(elifn<nyg!d=e!b(!!io!ng)!reh(ns'ib>g(u(o==bmcr!!o-o!!bruosennnruu(-tsmm!!oe!!tfibbs-tcee!noar!re--nunioogdneffbti--)cgo)tnobrreus(oainnrng(stesb)!)iw!oftrirs6oos!)n)m!)()st!h0!(i!2n!)n)1e)d)))dx dy)))

((*l(os*oewpt hnfeounrmc(boaeunrn-dto!!fb-(etnlrooawtn!s!8it(idoaonresf!(!!!ne0i)g)bors (!!i count)))

((*l(((os**coeowspteuhttdnheotoni-nl(dsn(*t-eauitdnnhdc)itfn!h!nnice(ukdp(m)rntobohpeti(e-rn-aran-roleelsfdfi-n)z!t!eer)iangneb(isoogirtnbsieoo-0rnstsr2))(a))!n4)!)siit(iloong-aonndly()1+ count) 7))))

(not-all neigbors 2 4 6))

((*cow(u*hnseetnt-s(tthauinnd)n!e!d(nprilo!!p))er-size) (one-transition-only)

(an(*dsumenttoitlvhi(ien*pnae(ndidmn(((ainnegl!ooqe!)tt!-)!--taaoolll-lldfnn-beetiihtgghibbninoonnrressedd00)t)h42in66n)))ed))))))))

7.2.3 Creating Local Connected Area Maps

The nearest neighbor array is calculated outside the main loop, avoiding the repeated costs of checking for
boundary points. The *with-local-grid sets up an bitmap in each processor containing a neighborhood of the
specified radius.

(de(feu(cna:esniegehcitgonh'(nb(eo0crt-.ivo-it1y)se(t1s

(connectivity) . -1) (1 . 0) (1

.

1)

(0

.

1)

(-1

.

1)

(-1

.

0)

(-1

.

-1)))

(:four '((0 . -1) (1 . 0) (0 . 1) (-1 . 0)))))

(de(flectac(h(eadrranyea(rmesatk-en-earigrabyo(rsli-starwraidyth((hweiidgthht))h))eight connectivity))
(l(oloo(ploopfoopfrocfroorrlo(bwneelboiegwlhobwwoidrh-tehoigdhsotetd-ocol . neighbor-o set-row) in (neighbor-o sets connectivity) wffoohrrennneeii(ggahhnbbdoorr(--nrcoootwlu(m=mn(in+=usr(op+wncenoieglihgnbheoibgroh-rbc-ooorlu-msoent-s))erto(-wnc)oolt)(minusp neighbor-row))
array)) do (push ((<connesignhebigorh-bcoorl-ucmolnumwnidtnhe)ig(h<bonre-irgohwb)or(-arroewf ahreriagyhtc))ol row)))))

121

(de`(fm(leitganc((roo((arccer*eercannweyttin-eettrrdh--ei-rmrc-olooerwloucnwams,irlo-ancndge,inrr(uiatd1sed)+ri(-u((csg*)o)rli2udm,rrana)ddiiuuss))&)optional (type 'boolean) (initially 'nil!!)) &body body)
(*l((eddte(o(cdtl,ioamgtrrieeimds)(e(tsyi p((ej1+((1p(+v*a(r2*(,2arar,rdraiauydsi),u)t)ys)p))e (array-dimension array-dimension))) ,grid)) ,@bo(d*y)s))etf (aref!! ,grid (!!i i) (!!i j)) ,initially)))
(de(f*ul(oncchcaeolclymk-(pt*uytptyeep-ecloo(ncpnalaellccyet-sesdtp?))i-rgarli-dco(npnvaerct(eadrr-aryegbiooonlesa(np)))lace&sauraxd(i(ug*sraidrcr-oandyni-medceitmnesdeion?ns-igornidconnected?-grid 0)))
(*a(*lll((e**ttsy(e((ptfnmee(o:(iasgvcraheoefbdfne!o-n!(rpe(icclnnaotgecen-iedngcs?eho-cpbntglonearredciidcne?tsg-)(e)-gd@cr?iodgnnrn(iidle!!-!!c)idteriamdd?eiunmss)ioov(ne!d!gi-rripdal-dadicueimss)))entp)sliaocnest)))) (l((o(*ssoeesptteqqtfwdwwwoomciiiirttttcuhhhhu(orrrdvnccdereeuueeindlanarrtt-mrrart-eeep--rnneslcortatttoowe---cwlrenrcuo(soe=mdw+il(guen(nbmlc1=teuo(a+nwrr+r-rsa(sce=dc!*on=!uilrtuu2ram-(srmdnrerooineanuvwatd)se-rideucdisn-soet)p)ll-utl(naams-ecpinergiosrbwdadoel)-e)rltsldta-ea-al-tcrcaroaoslyulurmamddinani)u)msd)eetletar-drioawm))eter :eight) ((**w(allhol eo(n*psmfeotornv(eendige-higpbhlaobcroienrsg--cocolunmnenct.ende?ignhibl!o!)r)-row) in (aref nearest-neigbors current-column current-row) (*setdoneighboring-connected? (*setf ((aorerf!!!(!naceroiegnfh!n!becocotreinndng?e--ccgtoerniddn?e-(cg!t!reiiddc?u(r!r!einnte-icgohlbuomr-n)co(lu!!mi nc)urr(e!n!it-nreoigwh))bonre-irgohwb))o))r)ing-connected?))
)))))
7.2.4 Line fitting
Calculate a line through the locally connected region, and throw away points which aren't line-like.
122

(defun line-through-connected-region (places((&&aaoarrruapeedxtaaiio-u((nlsde*ainlalidgnm(iteaahe-mctpc(eeleriatnpec(ttree1asg+dbeilsae(rl-o-m*pldee2einstgetrinaart)nthd)eciruaecsre)e1)p)a.t)0)))goodness

((*se(at*lqll(o*aclcaectlelyp((t(as*xbtly(ep!-!ed0i:s)s)taaf(nescy(e((s(!lo!op0ae))tina(tcsecxrexcpe(tpa!t!b)l0e)^)-)d(i(ss(txpaylna(cce!e!)s)0l)i)ne(-spylyac(e!s!)0)t)))

(*ty(pne (((!!sx0)s))y sxx sxy syy goodness) ^) (n area-length))

(*(w*hw((elcnio(tolohmo(pp-*olpalw(poffdcuooachoetffdrrcaseeoooclcc-nrr-uoolgrrmo(lloouurcawwuimmadrle-lalnn=f(yit!n-ec-!=(di-osncepns(doxouinernameaxobntclaes-etb(tleccose-dto(xwleo?n-rdswond?yrcweaioadcs(d-lmtixu!iiaeun!xmmedisdt)-scneeeyroxtr-yeleiugrnrsamidxodyennixus-nsir)pn)acldodaelciuuxe)mss))(nra!!rdioiurwos)w)c-oinnndeecxt))ed?)

(*l((e**ttw(y(sh(ploedenpe(en)(-)do)>)eam!nn!od(nm-!i!(n^0!t!))e)i)r)c1)e)pt sx sy sxx syy sxy n denom slope intercept))

(*(if*(lsainevtee-rliapngleae-c-pecslhaic-essqu(aarnedd!!g(o>o!d! nnes(s!!six1)s)y

(<!! sxx

(abs!! syy sxy

intercept) (!!f acceptable-distance))))) n slope intercept)

(*w(*hsee(nt*(swlnohopetne!!((l!ni!nofet*-!!npollaitncheei-ns)pgl*a)c))es) (*set goodness (!!f (*all (*when line-places (*max goodness))))))))

)))

(defun accumulate-sums (sx sy sxx syy sxy n xcoord ycoord)

(*locally (*type ((sx sy sxx syy sxy) ^) (n %n))

((((((******sssssseeeeeetttttt

snssssyxxyx(yyx((1(((++++++!!!!!!!!!!!!ssnxysss))yxx((yyx!!!!(((ff!!!!!!xyfffccoo(((***oorryxdxd))ccc))o)o)oooorrrddd

yxccoooorrdd)))))))) ycoord))))))

(de(figunnosrleospyey-)and-intercept (sx sy sxx syy sxy n denom slope intercept)
(*locally (*type :fast ((sx sy sxx syy sxy denom slope intercept) ^) (n %n)) (((***sdifee(t(cppfd(rlo*edugnsesneonptmo!!msld(oe*(pn!*e!o!!m(n*s)s!x!xxsn)x)))sxy)) (((***sdseeettcfisnlsotleporpecee(p/(t*!!!(!s*ls!ox!pssexyx)d)esnyo))m)) ((**sdeetcfinitnetrecrecpetpt(/(*!!!!instxerscxeyp))t denom))) (p((ro**gssneett sinloteprece(pmto(s!t!-0p)o)sitive- oat!! slope))))))

123

(defun average-chi-squared (goodness sx sy sxx syy sxy n slope intercept)
(*(lo*caalllly(*(s*ettypgoeod:snaefses(((!s!x0s))y)sxx syy sxy slope intercept goodness) ^) (n %n)) (*if((p/r=og!!nslope (most-positive- oat!! slope)) (((***iisnnecctffgggoooooodddnnneeessssss(((***!!!!!!in(slt!o!epr2ce)espsltolopipneetesirxncxte)e)prtcenp))t sx)) (*incf goodness (*!! (!! -2) intercept sy)) (((***isinnecctffgggoooooodddnnneeessssss(s(/y*!y!!)!g(o!o! d-n2e)ssslno)p))e sxy)) (p(ro*gsnet goodness (!!f (*all (*max goodness))))))))
124

Chapter 8
Assembly

has-accidental

has-stem has-stacatto

overlaps

tie-start-note tie-end-note

has-beam inverse: has-note

Figure 8-1: Typical relations that exist between features in a music score.

8.1 Introduction
Assembly is the process of taking the locations and types of features and translating them into a representation in which the relationships between different features are explicit. This representation should not be viewed as an
125

ultimate "music representation" language, but as one representation in a series which enables a performer to go from looking at a score to playing it:
The representation arrived at thus far, namely in terms of position and shape.
A representation of the performers understanding of what the music score is communicating.
A representation of how the performer intends to play the music.
The motor control script which directs the performer's muscles to play the music.
This chapter's work aims at recovering something like the second representation. Some examples of things which are explicit at this level are: The pitch, duration type, and beat number of a note, the grouping of the note (whether it is part of a beamed group or is simply flagged), the starting point, and sometimes the extent of score to which a dynamic marking refers, the key signature, the time signature, what part of a score the repeat sign signifies should be repeated. Examples of things which are not explicit at this level: How loud to play each note, exactly how long to play the note, where to breath (when using a wind instrument) how to bow (for stringed instruments), how a fermata should be played.
Consider what information needs to be used in order to make explicit the aforementioned relationships. To compute what the pitch of a note is we need the clef, the key signature, whether an accidental modifies the note-head, and need to know which line or space of the staff line the note lies on. To know the duration of a note, we need the shape of the head, whether or not there is a flag (information which is determined separately this far), or whether the note is part of a beam, and whether there is a dot beside it. For each dynamic we need to know whether the dynamic operates on music below it as a trill does, or above it as a forte does, and whether it has a known extent, as a tie does and the word crescendo doesn't. How does one take the positions of features and turn in to the symbolic links which describe these relationships?
The problem is further complicated because not all features are found with 100 per cent reliability, a byproduct of the ambiguity of some shapes, and the difficulty of writing perfect feature finders. These errors are obvious to a person skilled in reading music. A sharp is found on top of a beam, a note is found at the intersection of a staff and measure line. How does one recognize and rule out these "obvious" mistakes?
In working with the various score structures, I categorize them by specifying the objects which form their parts, and the relationships between the parts and the whole. For example, a beamed group of notes has as components note heads and beam. The relationship between them is that the height of the beam above the note helps define the duration of the note. The that beam is above the notes (or below), defines a positional constraint which can be used to check for correctness.
Some visual relationships merit the status of being recognized, even though they do not form part of some musical structure. For instance, the sharp feature locator commonly makes the mistake of finding a sharp on top
126

of where a beam is located. The consequence of this visual relationship is that either the sharp, the beam, or both have been mistakenly found.
I designed two data structures to help facilitate the recognition and representation of relationships such as these. The first I call surroundings, a structure which enables efficient queries by objects about others in some prescribed area. The second is the relation data structure. A relation is an object which records the participants in, and type of, functional or visual relationship.
8.2 Surroundings
A note has an accidental if one of five accidental shapes is not to far to the left of it, and the center line of the accidental is aligned with the center of the head, as in Figure 8-2. To determine whether or not this accidental exists, the note head needs to check its surroundings for a list of features which satisfy the type and positional constraints.
A simple strategy for satisfying this query would be to have a list of all objects, and upon a query, loop through this list, testing the type and position of each to see if it satisfies the request. But there are thousands of features on a single page of music, each of which may make many queries in the process of creating relationships. Were this implementation strategy chosen the result would be a very slow process.
Instead surroundings are implemented as a set of quad trees, one for each type of object. A quad tree is a data structure which allows the efficient computation of which of a set of rectangles intersects a given rectangle. Surroundings serve the role of responding to queries asking for specified kinds of object which occur in a given area.
8.3 Relations
A relation is an object(in the sense of object oriented programming) in which the a relationship between two features is stored. Relations are designed to handle a number of specific issues involving the reconstruction of the score from its parts. The relation stores information about the participants in the relationship, methods for checking whether the relationship exists given one of the participants. A relation can be noted as being ambiguous, for example in the case where a spurious note head is found, and a single accidental is near two note heads. Relations have procedures attached to them which take effect when the relationship is created. Relations can have inverses defined, which are automatically created. Whenever we note that a beam modifies a note head, the note is notified that it is part of the beamed group.
127

pitch center

search area

overlap

bounds

pitch-center staff-line

bounds

Figure 8-2: There are two constraints on the relationship between an accidental and the note it modifies. The pitch-centers need lie on the same line or space, and the the note-head need to be nearby and to the right.
8.4 Disambiguation and Propagation of Relations
A specific method may be used to attempt to disambiguate an ambiguous relation. The method may ask for other information in the surroundings, or for information about other relations which have been established with the idea of figuring out which of a set of relatees may be considered invalid.
This can not automatically be done when a relationship is initially determined to ambiguous because at that time the information necessary to disambiguate the relationship may not be available. Take, for example, the the problem of deciding which notes belong to a given measure.
There are two problems that occur in this part of the reconstruction. First, some notes may lie between staffs, but may not have stem information. When a note is asked to establish a my-staff relation there may be two staffs which are sufficiently close to it to be considered. But one and only one measure may consider a note to be part of it.
A second problem is spuriously found note-heads. One way of deciding that such a note-head doesn't make sense is to add up all the notes in a measure and see if they add up to the time signature. If there are too many notes then the note may be removed from consideration. A good note to remove from consideration is one which may belong to some other measure.
The point that I want to make is that the computation of which measure a note may belong to proceeds along different paths. One path needs to be done first. The disambiguate method might find that it doesn't have enough information to decide now, but might have enough information later. Conceptually, we imagine that the disambiguate method is retried repeatedly throughout the calculation of other score properties, until the point it succeeds in disambiguating the relation.
Another way in which relations may affect their surroundings is by a propagate method. Suppose at some

128

point a note is removed from consideration for some reason. Then we know that any relationships which depends on it being really part of the score should now be notified that this is no longer the case. An example is in the case of stems. If it is decided that a note has a stem, and if until that point it is uncertain which staff a note belongs to, then the the direction of the stem is used to make the decision. The propagate method for the stem relation encapsulates this knowledge.
Whenever there is some computation to be done, there is the question of what needs to be done first, what needs to be done before something else is done, and so on. I am trying to stay away from any order of evaluation dependency in this work on relations, since it makes it simpler to conceptualize. I want to be able to specify the relationships between objects, be able to write code to express these specifications, but to not have to worry as much about which relation is done first, particularly in the light of the fact that the process of disambiguating all relations may have to be iterative.
What is aimed for is a state of affairs in which demands for information from the score trigger off demands for the necessary establishment of positional relationships, the establishment of which which gives information which can satisfy the demands of the query. To this end, relations are established on demand and cached. A primitive called force-relation causes a relation to be computed the first time, and a provision is made for cases where this demand cannot be satisfied in that a function cant-force-relation is called. This method can take into account that fact that a portion of computation is not possible at a given time, and define a strategy for proceeding.
8.5 Related Work
This work was heavily inspired by David Waltz's[14] work on interpreting line drawings of polyhedra. That work focussed on computing several properties of lines in the drawings - whether or not both of the faces joined by the line were visible in the image, whether the line was part of a shadow a crack, or a polyhedra, and whether the line was at a concave or convex joinder of the faces. To do this he categorized all the various shapes of vertices of lines which can occur and the constraints which each vertex had on what types of lines could have formed it.
In a fully interpreted image, each of the lines had to have a single interpretation. The constraints are used to limit the possibilities for the pairs of interpretations of vertices on either side of the line. Impossible combinations are removed. When a vertex is removed from consideration by the constraints on one line, any interpretations of adjacent lines which used it would also need to be removed. Thus the constraints at one vertex propagate to others. At the end of this process either a single interpretation of the image is left, in which case it is accepted, or several interpretations are possible, as with an optical illusion, or none wass possible, in which case the drawing does not representation a physical object.
There are similarities and differences between his work and mine. In his case there were only three types of things in the world - lines vertices, and line labelings. In the music score there are many types of objects, with
129

many type of relations. What is similar is that there may be ambiguity in the interpretation of some position of the score, which can be cleared up by constraints imposed on the interpretation of objects elsewhere in the score. Though there are more type of objects in the music score, the degree of ambiguity is less than in the line drawing world.
Waltz's work did not deal with the problem of noise and incorrectly found features. In personal discussion with Waltz, we talked about what happened if the constraints were not completely satisfiable, even though a labelling of the vertices existed. In that case each of the labeling of vertices needed to be changed to other plausible candidates and the constraint propagation run from the start to see if a consistent labeling could be found.
In this work the problem noise is considered just another potential labeling of an object. Thus the consequence of some constraint propagation might be that an object is considered noise, and this labeling might have consequences for the surroundings of the object.
8.6 Future Work
The work described in this chapter is not yet completed. I believe the basic mechanism which I outline here is adequate for the task, and illustrate the solution of several grouping problems using the mechanism. Still, the work should be viewed as work in progress - it represents new ground, and more than other methods described in this thesis, could very much use a second pass at the both framework and the implementation.
At the time that I developed the implementation of the relation data structures, I had little experience with knowledge representation systems. Given that I have an better understanding of the inference requirements of the score relationships, it might make more sense to implement these in an existing knowledge representation system.
8.7 The Code
8.8 Some Implemented Relations
8.8.1 Attaching Flags
(de avor ag-relation () (relation)) (de avor agged-by () (relation)) (defmethod (inverse ag-relation) () ' agged-by) (de avor ags-downward () ( ag-relation)) (de avor ags-upward () ( ag-relation))
130

(de(fmmraeeptl-ahtbooodru(nsdesa-ro;cvmhe-rylfaofper-a-ttruyeprleaetheads

ag-relation)
surroundings

()

##(se..((l(f onnbdd)--(ffee;eaasgtttiuuavrrbeeeliss::ehshlofasllaiefd)l)fbooub)n);dscamneatthtoadch(wtohiscohliddeoprenhdalsf on relator)

t) )

(de(fdmeceltahroed(v(atlouleesrenacge-sto-ahge-ardelnaetairo-nh)ea(d) x-tolerence))
(values ###...(((**se4n.5d((s(seennnddd-((fenandtdu--rfefeeaa:tstuourlreied):s:so:ohliledidi)g)h:h:tw)eiigdhtht))))))

(de(fmmueltthipoled-(vbalouuen-dbisnd a(gxsy-)downward) ()
(point-position relator : ag-tip) (mu(vltaiplulee-sv(a-luye-baingd-t(o-ahgea-dt)o-(h-eaxdxa-btoovleer-ehnecae)d (x+-tyolaebreonvcee-)h(eatod)ler(e+ncxesx-setolf)lerence)))))

(de(fmmueltt(hippooledin-(tv-baplououesn-itdbioisnndra(eglxasty-o)urp:waagrd-)tip())
(mu(vltaiplulee-sv(a+luye-bbeilnodw-(heaagd-)to(--hexadx-btoelloewre-nhcee)ad(+x-ytolearge-ntcoe-)h(etaodl)er(e+ncxesx-setolf)lerence)))))

8.8.2 Attaching Accidentals

An accidental is related to a note if it is in bounds, and if it is on the same line
(de avor accidental-relation () (relation)) (de avor modi ed-by-accidental () (relation)) (defmethod (inverse accidental-relation) () 'modi ed-by-accidental) (d(e(ffmmoraecpte-h-boroedlua(ntsdioesna-rorcvehela-rtlfaooprr--'tmryepyla-etsetad )accide;nmtaalk-eresularteioI nh)av(e) a sta relation
###(rsee...l(((la(ftonnnobdddr)---(fffeee;raaaegltttaiuuu;vtrrremeeee-sy:::teshwolfofa-ehllaaisofd)ttl)aueb)roeusnhedalfssomsbu)e)rtrohuondd(inwghsich depends on relator) t) )
(de(fle(mtme(tu(hlstotipdale(r-rve(alfaolutreec-e--btrione-ldastt(iaomny-aoxbccm'imdyey-n-yt)sata(l-sro))e)mlaet-ipoon)int(-opbo)sition relator :pitch-center)
(mu(mltiasptplae--cvrrao(lsusen--dpb-oirsnesdliabt(ilioiotbnie-srxeloabto-ry)'m(py-osintat-p)osition ob :pitch-center) ( ((oanbdsta((e=qm(opybitsscttaha-)pmosyitsitoan )mysta my-x my-y) (pitch-position obsta ob-x ob-y)) (establish self ob))))))))

131

(de(fmmueltthipoled-(vbalouuen-dbisndac(ctiodpenigtnaol-rereblaottitoonm) r(i)ght)
(v(abluoeusndtbosoptrteroliamgthot(r)+ right #.(send ( nd-feature :solid) :width)))))

8.8.3 Relationship Between a Staff and its Constituents

(de avor my-sta () (relation))

(de(fmmueltthipoled-(vsaeluaer-cbhi-nfdor(-troeplaitgendorme byo-tsttoam)ig(n)ore)
(c(a(btft(loce)mh)ut))n#:rra'(sdeed(p'tllscoc(-aaahnhlttbre(eooeeeo-ticlrrcfuaik((k(nint(penod(sirsurntoss)iaesd-tgianbeondc?lveie)s(e?)herlx(ascapelnlu-fdstsyiv(tpea<e=s)e))tl)of)pst(abo)tt(othmroswta'd))on(e>t=))bottom (top sta )))))

(de(fwm(hepetnrhoo(pdaomg(apbtriegou(pofoougrsca?et-seerelmfl)ayti-osntarel)at(o)r 'has-stem-upwards))))

(de(fwmh(eieftnh(o(sdyamn(dbdoi(sl=pam(wlebhniicgghut-hastrteealyamst)eye-)st2a)) ) (which-stays)

(le(tle((t(p(po(os(rs2ew1m(h((otcetovna(opes:pu(e(pn(wspeceqheacrirocp(nhroid-efsls1a(rttea<pelyaoeps)ts)oe)2es))1)))pos2) (car relatee) (second relatee)))

t()u))n(ewst(hauebnnliesrshetmas(be:olllfivosew(hesnred(lfifwre(hm<icohpv-oess)t1aty)p)s)osre2)lat(eseec:otensdt

relatee) 'neq))

(car

relatee)))))))

8.8.4 Relationship between a Stem and a Note-head

Propogating this relationship involves resolving any ambiguity about which staff a note is associated with
(de avor has-stem () (relation)) (de avor has-stem-upwards () (has-stem)) (de avor has-stem-downwards () (has-stem)) (de avor stem-of () (relation)) (defmethod (inverse has-stem) () 'stem-of)

132

(de(fmmaept-hboodu(nsdesa-rocvhe-rlfaopr--tryeplaeted has-stem) ()

relator ; my feature has surroundings

t)

self :(ste(mob))

(;esgtiavbelissehl-f iaf-bdoiruencdtisonm-eotkhosdelf(wobh)i)ch

depends

on

relator)

(de(fwm(heeetsnhtao(bddliir(sehecststieoalnbf-loiosbkh))?)-isfe-ldf ioreb)ction-ok has-stem) (ob)

(defmethod (direction-ok? has-stem-upwards) (stem)
(< (bottom stem) (bottom relator)))

(de(f<m(ettohpodre(ladtiorre)ct(itoonp-sotke?m)h))as-stem-downwards) (stem)

(de("(fdvamaemcleuoltaeuhrsnoe#td(.t(v(o*aolou.5essse(etsteahtngahd-set-(obs-otnhxedem(-a1)fde/a(n2)teudarirem-h:esenoasldiido)nx-s:ht)oe"liegrhetn))ce))
#.(* .5 (send ( nd-feature :solid) :width))))

(d"efambeotxhoddis(pblaocuedndtso huapsp-esrtreigmh-tuopfwhaeradds") ()
(m(umltiupllt(eiv-pavlelau-leuvsea-l(ub-ein-tdboipn(dtoo(psoeletysf)tetby(o+ottleosfmettoxr)igs(heott)x)s(eb(to-suebnlofd)tstoremlaotors)ety) (+ right o setx)))))

(de"fambeotxhoddis(pblaocuedndtso hloawse-rstleefmt o-fdohweandw"ards) ()
(m(umltiu(pllleteit-pvl((e(ao-oluvsease-leutbyteixn-(db(-i-n(ydtxot(olpexpfl)te)y)))f)t (bpoottinotm-proigsihtti)on(breoluantodrs :rceelnatteorr)) (values (+ top o sety) (- left o setx) (+ bottom o sety) (- right o setx))))))

(defmethod (propogate has-stem) ()

(le(tw(h((le(esnttc*ao(na(-d(((mroome(bpp(leiappga-toonuidossdoeiinuttmeesn(-?ee(fdod-fseort?dcareecn(-eed-n-rdereer?eldealnla?(atetidtdoi(ioeo?nnnno)nsrteeerleldoafl)?pat)optooroprs'pmi(toeoys-p-idtpseeto))as)nit)ee)d)-?d))irection-stem self)))

(((((tdadnniissidlaa))mm)())nb)boiiggtuumaatteee-dsstteaa

n--errdee?ll)aattoiioopnnpo((sssitttaae---deeemmnppehhdaa?ss)iizzeedd

self))) opposite)))

(d'ehfmase-tshtoemd -(doopwpnowsiatred-sd)irection-stem has-stem-upwards) ()

(de'hfmase-tshtoemd -(ouppwpaorsdits)e-direction-stem has-stem-downwards) ()

(de:lfomweetr)hod (sta -emphasized has-stem-upwards) ()

(de:ufmppeetrh)od (sta -emphasized has-stem-downwards) ()

(de(fvmaleutehsotdop(bleofutn(d+stsotpemhe-igfehat)tu(r+e)le(f)t 4)))

133

(de((ffamlsesteut(rh(eoc-dhste(ecsmkt--esmpeon-ssiietnifo(onerxsmpseaecltft)iosntepmag&ere-sotf-igsntoerme)s) (head &optional (htolerance 5) (vtolerance 5) &aux (direction :none))

(w(hiefn((s(eeqetqqdd(iricerdecrctitositonenm:ne)oxnpeexe)cpte)ct)

;(mlefu('mtlts(iapi&pdlr-eee-os(vv(teaeuxalrnup-rlgeeeo-scsb)tscjae(d(claleotpqsw-pndil)nyir-e#rca'tcnihogeneckep-xospseeitncisto)ens:(dsoewtqn

direction args))

:both))))))

; righhtotlseirdaence vtolerance (point-position head :left))

(multiple-value-call

'map-over-objects-in-range positions

(hto(l&erraesntcearvgtso)le(raapnpcley direction)

(#p'ochinetc-kp-osseintsioen:uhpeaadrg:sr)i)ght)))

8.8.5 Measures and their Constituents
The current propogation of measure is that if you consider the box containing all unambiguous heads, then any
heads still contained in that box are likewise contained, and we can disambiguate them. Possibly there are more
propogations to be done. Disambiguating involves removing any extraneous measure relations
(de avor measure-contains () (relation)) (de avor in-measure () (relation)) (defmethod (inverse measure-contains) () 'in-measure) (defmethod (ambiguous? measure-contains) ()
(un(sleosms e(u(nd(eobn)ed(?amseblifg)uous? ( nd-relation ob 'my-sta ))) relatee)))
(d(efamppeltyho'md a(ps-ebaorcuhn-dfso-ro-vreerllaatpe-dtympeeasure-contains) ()
relator ; my feature has surroundings t) *(sehle(faodbs)*)(;esgtiavbelissehl-f iaf-bsoamuned-sstmaethseoldf o(bw))hich depends on relator)
(d(efinmeutehnocde-(bboouunnddssremlaetaosr)u)re-contains) () (de(fwmheetnho(drel(aetsetda?b(lifsohr-ceif--rsealamtieo-nsotab 'mmye-astsaur)e-(csotantarienlsa)to(r)o)b)
(establish self ob)))
(defmethod (propogate measure-contains) ()
(resolve-ambiguous-head-sta s self))

134

(de;;fmmeatkheoda b(roexsaorlovuen-damalbl itghueouunsa-mhebaigdu-osutsanostme ehaeasdusre-contains) ()
;; then disambiguate any ambiguous note heads which are inside that box (un(mlesuslt((ibpuolnexd--eveannlcueleod-s?binisnged-lfu)(neanmclboisgeusoaums bseiglfu)ous)
(loop fwoirthhetaodp ianndambboitgtuoomusand left and right do (multiple-value-setq (top left bottom right) (bounds head)) if d(ob(odxis-aomvebrilgaupast-eresgeilofnh-epade))n))c)loses left top right bottom)

(d;e;fmwhetahto-dsta(ydsisiasma bfoigrmuaetrelymsteaasuamreb-icgounotuasinhes)ad(wwhhaicth-swtaeysd)ecied belongs with us

;; in order to disambiguate, we need to

;(;le1t)(T(melleaostuhreersm(eansdu-rreeslaittiomnaywhbaet-pastratyosf'tinh-amt ietansuorwe))i)sn't part of them

(map(-p((muosneslaeibssisulirt(eie)eqs

measures measure relator)

(;;d2is)amTebllighue(aautdenet(shtaantbdl-iitsrhehlaa(stionands-iwnreghllaaett-isotsnatamysneo'amwsuyr-est'ma e)as(usrtea-corenltaationrs))))what-stays)))))

(de(flomoepthfoord h(ebaodx-inenrecllaotseieng-unambiguous measure-contains) ()
fwoirthsttaop=an(dnbdo-trteolmatiaonndhleeaftd a'mndy-risgthat ) if c(oalmlebctighueoauds?insttoa a)mbiguous else do(multiple-value-setq (top left bottom right) (bounds head))
and minimize top into top! and maximize bottom into bottom! nally (return (va(lmueaske-instance 'box :top top! :left (from relator) :bottom bottom! :right (to relator))
ambiguous))))

8.8.6 Overlap Relations
These are in order to compensate for features of more than one type which are found at a single place. We are going to first collect the set of selfs which overlap me. Then, Any features which are considered to be superlfluous by virtue of being overlapped, will get the overlapped-by-self relation, and be put on self-overlaps of the overlapper. This means that the computation for the set occurs the first time that the relation gets forced on one of them. So in establishing the relation, we won't look at anything which has either of these relations already on it. I really don't want to have this information around on each of the features : too much junk. Oh well. keep it for now.
(de avor overlapped-by () (relation)) (de avor overlaps () (relation)) (de avor self-overlaps () (overlaps)) (de avor overlapped-by-self () (overlapped-by))

135

(de(fumn(lleeettshs(o((doov(res(relaanprdcp-hinr-egfl-oasrt-ieotrne(-laloistfte-dtryeplsaeetlofr-re)l)oa)vtoerrl'aopvse)rl(a)pped-by-self))
(mraepl-atboorunds-o; vmerylafpe-attyupree has surroundings relator ; bounds of my relator
(wh(((sesene(tno-(dbuc)pdre-r(lraaoetnvloaedrtril(:oamn(nppospyut-isnsf(ehgelnf-antes(duew-tr)nero)de)bl-adtooivomenrilnaoapbtpo(inrtygsp-eelsf-etoo))fv)esrellaf)p))pin; gb-esceatu)seovtehrelareppminigg-htsebt)e)))specializations of this relation t)
(de;;(;;fl(emstmoe(taw(hpdeocodcm(o(m-s(reeoet)li-antuiwpon-itrh(eelaasnttaioebmnlissphts-yerlesfle-aloft-ivooenvreldarolpamsp)sin(aadntoodmr n(iontyaoptvoeer-roalafllp)speelfd))-))by
(un((eelesssttsaabb(lleiissqhhd(doeomsmtian-barletiolsahrt-ioor)enlaot)ion o 'overlapped-by-self) dominator))) all)))

8.8.7 Overlap of Sharps
First pass at sharp, a common error mode
(de avor self-overlaps-sharp () (self-overlaps)) (de((fblo(mrwoeeap(htkhsef)wfdenooootidrrtq(hst<(uomippntnopi=nsdpehr-=(mamdtrmoopoinpsms)otssi)stn)-aptoosritsiveelf--oxvneurmlapasn-dshuaprppe)rm(sohsatrps)
na(lslyet(qremtuinrntoupp))permost)))

8.8.8 Current Top Level Test

(defvar

*sharps*

(list

( (

nndd--ffeeaattuurree

::snhaatrupr)al)()) nd-feature

:

at)

(defvar

*heads*

(list

( (

nndd--ffeeaattuurree

::shoallifd)))) (

nd-feature

:whole)

(defvar

*upward-

ags* (list

( (

nndd--ffeeaattuurree

""esiixgthetehnthag augpwuaprwda"r)d")))

(defvar *downward- ags* (list ( nd-feature "eighth ag downward")
( nd-feature "sixteenth ag downward")))

136

(de(fsuentqte*ssut-rrroeulantdiionngss*()(make-instance 'surroundings :page 215 :book schubert))
((((ttttrrrriiiiggggggggeeeerrrr----rrrreeeellllaaaattttiiiioooonnnn ****ssssuuuurrrrrrrroooouuuunnnnddddiiiinnnnggggssss**** ''''macaaycgg-issds--etdunaoptawwl*an-hrwrdeeaalar*ddtusio*p*)wndao*rwsdhn-awraaprgsds*-*))ags*) (((ptprrrioogppgooeggr-aartteeel--arrteeiollaanttii*oosnnur**rssouuurrnrrooduuinnngddsii*nngg'ssm**e''ammsuyera-ess-utcaroe-n*ctaohinenatsadi(sn*lsi)st(l:imste:amsueraes)u)re))) 8.9 Code Defining Behaviour of Relations

8.9.1 Definition of a Relation
(de avor relation ((relatee *unde ned*) relator) () :settable-instance-variables) (de(fl(emtlee(tt(h(so(td*apt(ursisnyt(s-c:cpoarnsidne*t(-(:sudenoldfwernecnlaaestdei)?o)ns)elf()st"r(eaumnde&rensetd)ig"n)or(e()ambiguous? self) "(ambiguous)") (t nil))))
(if(sftoartmusat stream "#<~A ~A>" (type-of self) status) (format stream "#<~A => ~A>" (type-of self) (car relatee))))))

8.9.2 Default Methods for Relations

(defm"Reethtuordns(ttyhpeetyrpeelaotfiorne)lat(i)on"
(type-of self))

(d"efTmheethinovder(sienvoefrtsheisrerelalattiioonn). B()y default it is also established, if extant. Default nil"
nil)

(de(fifm(((pseeetuqthsqohrdnerelea(lwateetseenteea*wb(u-llniirssdethela-nte1neweerd-e*rrle)eallataittoeenee))))))(new-relatee)

R(dee"lafSmtpoeertcihisotedhse(tehosabttjaerbcetlliasothneerweshlaaitctihsiotneh)set(hrneeelawrte-iloarnetliaostintese(.T&Dhaeeufaxrueillntavtmeioresnte)hisodbejtuwsteepnusrheleastoitr
((wes(hteeasnbtlai(sbihnl-ivs1ehr-ss1eelf(sesneleft)wq-irnevlaertseee)(establish-relation new-relatee (inverse self)))

oanndrerlealtaeteese") relator)

((pwrh(opepnroogipnaovtgeearssteeelfi)nverse))))

(de"(fsSmepteeqtchireoeldast(etuhena(tedsretelaleabtteleieswhhdiorceehlsanrt'eitloasnta)etei)(s))wehitchhe) relation. Default method just removes it from relatees"

(d(e"feRmqeet*utuhrnnodsdet(uinfnetddh*ee rrneelelaadtte?ioe)n)reilsateimonp)ty(")

(de"fRmeetuthrnosd t(uifntdhee rneeladt?ionreilsateimonp)ty(")
(eq *unde ned* relatee))

(defmethod (ambiguous? relation) ()

(a"nRdet(ucronnsstp

is the relation relatee) (cdr

rieslaatmeeb))i)guous"

137

(d(e"fiWfm(hecetohnnoasdpr(eralearlatbitioetnre)airsya?mrebligautioouns), r(e)turns some object which satis es the relation."
r(eclaarteree)l)atee)

(Tdheofumgeht"hHinoadmve(odtsihtseacamreselbasitgitouhnaetddeiisaramemlbabitgiigouuana)ttioe(n&itrisseesldtfo,inngefivo,)eint mthaeyinnfootrmbeatfioornswomhiechreiasspoanssed as info.

which the relation chooses. (error "Don't know how

tRoedtuisranmtbiifgtuhaetree~wAasacacodridsainmgbtigou~aAti"ons,elafnidnfno)i)l otherwise"

(defmethod (propogate relation) ()
w"Hhiacvheitthhearseilnatioorndedrotowhaatecitt konthoewrsrehloawtiotnos.doThinistgeermtsscoaflleudsinagftetrheesitnafbolrimshatrieolantion by default, and should be called after any change to the relation. Default method does nothing" nil)

(de(fsmeteqthreoldat(edeis(adlelolewte-1whreiclhatrieolna)te(e)w))hich)

(de((fdwmi(hseale(etlntlhaono((wd(din-invi(1nvedvesriesersesrlafseles-lw-eorlherwfe)liaclarhteti)oiloannt(io(ndn)idsa-(lrwleohlwaict-ih1o)ninwvehrisceh-(reinlavteiorsne rseellaf)t)o))r)))))

(de("(fueSmsn(ptmleeaetcbsahislpoise(cdhsu((nsteehd(lxaefrct)wlnur(heesddilicai?vhstea)e)selelrolesfw)laattsisieolfens)r))t(hwreehlraiectlhea)et)i)on, and further is the sole relatee (throws away other possibilities)"

(d(efemrreotrh"oIdt w(eaxspaescstuemde-dthtahta-trtehlaerteioins-adleeanstedonreelraeltaiotene), (b)ut there is not"))

(odbej"efHcmtasevtewhohthdiceh(rsesealaattrisicofhyn-tlfhooeor-krreaelatlatiitto'ensdscurreritrleaorutiiano.dniR)neg(ts)uranndt

establish relations with if succesfull. Default returns

nil."

nil)

(de"fCmheetchkoidf (orbejelacttsedis?orneelaotfiotnh)e (rewlahtaetd) to objects of relation"
(un(mlesesm(buenrdwe hnaetdr?elasetelfe))))

(de"(fuFmn(olleroetseohsapoc(dhfoo(rrpm(aruiarinnpcd-oreecnlrsanoitesseidtse?i-ndpgsooeolsff)siob(niuleintdpieeossnsrieebdlial?ittyiootfnhr)oerm())ortehleartifounncatniodno)ne from other-relation, call function on the pair"
(lo(foupncfoarll rf1uninct(iosnenrdro1)t)h))e)r :relatee) do

(de("fummn(alle(oeptsfohusfpoun(dncfuoac(nrtllmidorfenuainnpnoc-ervtedpeilo?roantsesesaerei)clb)f)h)d)iloiotfietshereplaotsisoibnl)e (refulantceteios"n)

138

8.9.3 Pay Special Attention to Ambiguous Relations

(defmethod (trigger-relation-on-ambiguous surroundings) (relation-type ambiguous-relation object-types)

(lo(loept

for type ((area (

inndo-bajreecat-steylpf etsypdeo)))

(map-all ar(ea((ow)hen (ambiguous? (force-relation o ambiguous-relation))

(force-relation o relation-type)))))))

(de(fdmeceltahroed(v(amluaeps-oobvjeecr-t armelabtiigoun)o)us-relations surroundings) (function relation-type &rest relator-types)
(lo(mopapfo-raltly(penidn-raerleaatosre-ltfytpyepse)do ( (o) (let ((r ( nd-relation o relation-type))) (and r (ambiguous? r) (funcall function o r)))))))

8.9.4 Definition of Object which can have Relations

Things which may have a relation get the has-relations mixin.
(de avor h()as:-sertetlaabtlieo-ninss(t(arneclaet-ivoanrsianbill)e)s) (d(e"fsSmeetteqsthrteohldeatr(ieoslneastt-io(rdneeloalefttietoyntpyehpeatysrp-eerlaettloaiotrnieoslan:tksi)eoyn("t'ytyppee-reolaf))tion)
(push relation relations))
(d(efomr e(thnodd-r(eelasttiaobnlissehl-f rteylpaet)ion has-relations) (type)
(l(reetslea(tt(-iroreenlla)a)t)tiioonn (smelfaktey-preelraetlaiotnio-nt)ype self type)))
(de(fm"ndentdhtysopdree(lraetlniaodtni-oronefslaw:tkhieooyns'tthyyappsee--sroaeft)l)iastieosn(s)ty(pteypper)elation type)" (de"fmnedtshroedla(tionndo-frewlahotisotny-poef-satytipseehs a(st-yrpeelpatrieolantsi)on(ttyyppee))"
( nd-if ( (ob) (typep ob type)) relations))
(d"e(flMe((imttas)a)ees(ktns(ehedisorttdia(t(nm(:tsmyiaenpktsae-etkpa-reeniinl-tcasret'teoraoleranlfacstsetieopiloftne)nyc-)pitey()e))pd)e"tTyhpahese-orfearlvaeoltaritoiinnosnst)"an(ttiyaptee)d is not a relation") (de"fImf tehtehordela(tfioorncee-xirsetlsa,trieotnurhnassi-t,reoltahteiorwniss)e (ttryiepse)its best to estabish it, eg. by search-for-related"
(or ((le(nntoedwr(-()(()rn)sceeealawantrtic-o(hnfe-osfrtsocaerebl-f-lrirtseeyhllpaa-ettr)eieodlantniseoewnlf)steylpfet)y)pe)))
(d"e(feAmrrfeootrrhc"oeTd-rri(eecldaatntiootn-ffoworcracesert-errliaeedtlai,otbnioubntenthwoaesme-neret~hlaAotdiaosnnudsc)c~eA(et,dyebpdue")t couldn't" self type))

139

(d(efle((mtswee((htt(hlqe(ornodor(deip(slaa(anfnlktodlidoiro-lwlnrrr-eesrr(lleaa(nrttldoeaioelittanlniet(o)t()usne)senelthdfnyeadptsyen-rperre:ee)dr)ell)?aalattrit)io)eo)nen)ss):dko(etyyp'tey)pe-of)))) (de(fsmeteqthreoldat(ioknilsl-naill)l)-relations has-relations) ()

8.10 Implementation of Surroundings

8.10.1 Box and binning parameters

(defvar *osr-box-area* (make-area :name '*osr-box-area* :gc :ephemeral :n-levels 3 :capacity-ratio 2))

(spdae"cfBveianpr eh*rearerenetairf-yotghbojreeecssthuaoprle,da-asdleeysfosautuhlinta*cnre.t2ah5sise,mparonbyatbimiliteys

bin area. As you decrease of collision increases")

this,

8.10.2 Definition of Boxes

(de avor box (left top right bottom) ()
(::wi:norirtitdaaebbrleele-d--iniinsnststatanancncece-e--vvavarariraiiabablbellesess left top right bottom) ((::dcoefnasutrltu-citnoirt-mplaiskte-:abroexa (*loefstr-tboopxr-iagrheta*b)ottom)))

(defun boxes-overlap-p (box-1 box-2)
(let (((lteofpt ((mmaaxx ((bbooxx--lteofpt bbooxx--11)) ((bbooxx--lteofpt bbooxx--22)))))) (right (min (box-right box-1) (box-right box-2)))
(wh(ebno(ttaonmd ((>mrinigh(bt olexf-t)bo(t>tobmotbtoomx-1t)op())box-bottom box-2)))) (values t left top right bottom))))

(de(famndet(hloedt (((binotxe-rosevcetriolanp-st-orpeg(iiof no-thperb-otxo)p ((omthaexr-tolepftooththere-r-totop)p tootph)e)r-right other-bottom)

(> i(nitnetresrescetciotino-nb-obtottotmomin(teifrsoetchteior-nb-otottpo))m (min bottom other-bottom) bottom)))

(let
(>

(i((niitnnettreesrressceetcciottiinoo-nnr--iglreihgftthti(ni(tfeiforstohetcehtrei-orl-nerf-itgleh(fmtt))()a)mx ilneftrigohthteor-thleefrt-)rilgehftt)))

right)))

(de(fvmaleutehsotdop(bleofutnbdosttboomx)ri(g)ht))

(de(ffmoremthaotdni(l p"oxs:~itai,o~na-ys:t~rAin,g~Ab"ox(-wooitrhl-efatr)ea() o(o)r right) ( oor top) ( oor bottom)))

8.10.3 Definition of Boxes which Keep Track of their Area
(de(:daefvaourltb-oinxi-tw-pitlihst-a:arreeaa (*boosxr--abroexa-)ar(ebao*x))) (de(fsmeteqthboodx-(amreaak(e*-i(n-straignhctelbefot)x-(w-itbho-ttaormea)to(p&))r))est ignore) (defmethod (area box-with-area) () box-area)

140

(de(fmmueltt(hibpooledx-e(vsia-nloutveeer-rsbleaincpdt-ipn(gvs-aelalfidroeltaehfebtro)txo-pwriigthht-abroetat)om(o)ther)

(if valid 0()*))(-

left

right)

(-

top

bottom))

(de(fmma(ecatrnhodoledt(((>b(m(omxin-i1no1v(eabrolbat)tpos`m(-irfeo(gt>hioe,nra--b,pbo)tbt,oobxm-,)aw))(itm(hma-xaa1rxe1tao)(pa(oobt)thhe`er(r-i-ftloe(pf>t)),oath,be)r-,taop,b)o))ther-right other-bottom)
(> (min1 right other-right) (max1 left other-left)))))

8.10.4 Definition of a Boxes with Contents

(de:(s:ectoatnvaosbtrlreuo(-cbbitnojoesxrtc-atown-bicit-nehi--n-vb-aaborreoxiaax)b((l(eoosbbjjeecctt

nil) top

id) left

bottom

right

id)))

(de(ffmoremthaotdst((roesraym(sa:pn"rd#in<(t~i-nAssetialnfncaoebbpjoeoxcbt~j-eAicn>t)-"b(ooxr)((psrtertetaym-na&mreestoibgjneocrt)e)(send-if-handles object :name)))
object) (position-string self)))

8.10.5 Define a Quad Tree Node

(de avor area-quad

(a(((lertodfeobotap-jm-elrecitigfnhtthsaretntn-soiihlcr)l)oe:nl(ndttoeonrper;)toiogbph;j-fetrbcanto;cissltt)otiaoolte(nmbtoooh-btficjsteeaocnlremttevelfeoreo)lbfrtjeancliltl)l;osch(waboecuorhltedltedovtmeablkirssiege:chnttotoinnnbgeiel)ilfsinaeevmsedp;ttahyt,e

subquadrants :tehxipsalenvdeeld if there

are

(:s:ectotna(sbtblreou-xci-tnowsrtiatmhn-caeak-reev-aas)ruibabqlueas;dan(dtoopf

course it is a box left bottom right)))

(de((fssmeetteqqthlaeorfedta--(rimtghhraetk-sehc-oeinlndtse(tra*(n**cae.r5eaa(r-e+tahl-erqeftsuhraoigdldh:-t)ad))fetfearu)lt(*&rbeosxt-iagrneoar)e))
(setq top-bottom-center (* .5 (+ top bottom))))

(defmethod (sys:print-self area-quad) (stream &rest ignore)
(l(etfo(r(mbactoustnrtea(mbo"x-#c<oaurenat-sqeulfa))d) ~A (~A instance~p)>" (position-string self) bcount bcount)))

8.10.6 Definition of Quad Tree Root

The top quad node is special, as it contains global information about the tree.

(def

avor

top-level-area-quad
(area-quad)

((coun(((gdbt rii0stov)pwela(tchctbeo-vdrfleabnncvigtl)ontrhil)26))4)

((::cseotntsatbrulec-tionrstmanackee--vaareriaa-bqleusa))d (top left bottom right))

(de(famdjeutshto-dbi(tvmecatkoer-sienlsf)t)ance top-level-area-quad) (&rest ignore)

141

(de(fl(emtife(((t((ffhoozboerrcmmdroouaa(pt(tnspbytssosctt(rr:ospbeeiutaaroniimmoxnt-)nt-c""-os##stue<<rnlittnftoogtppso--esplaaef)rrl-)fee))l)aae--vqqeuul-aaaddre~~aAA-q((ue~maAdp)itnys()ts>atn"recaem~p,&rreesdtuingdneonrcey) ~,2f)>"
(position-string self) bcount bcount ( oat (/ bcount count))))))

(defmethod (box-count area-quad) ()

(+

(((liieff nbtgootpthlteoofmtbj(reibgcothsxt)-(c(boiofuxn(-tscytomoupbnlotelfpbt)odt0ot)omminraigthotr))

0 1) 0)

((iiff tbooptrtiogmhtle(ftbo(xb-ocxo-ucnotuntotpbroigthtot)m0le))f)t) 0)

8.10.7 Intersection Tests
(defmethod (intersects-bottomright? area-quad) (box)
(if((bwbooth(t)xs)et)eeonstm-q(orbbivogoexhrt-tltaoopvm-erprilgabhpotst-(tromemgairkoiegn-h-stpubbboqoxux)aldeftto-pri-gbhot-ttcoemnt-ecretnotpe-r bleofttt-ormig-hct-encteenrterrigbhottbtoomttormig)ht))
(d(efifmteotphloedft (intersects-topleft? area-quad) (box)
((abnodxe((s-bseootvxqe-rotloavpperl-elapftpts(o-mprelaegkfiteo-nbs-oupxb)qbuoaxdletfotptolepftletfotp--ribgohttt-ocmen-tceernttoepr -lebfott-troigmh-t-cecnentetre)r)) t)))
(de(fifm(bbeotohtxtoeodsm-(oleivnfettrelarpse-cptsb-obttootmtolemftlebfotx?)area-quad) (box)
(wh(seentq(bbooxt-toovmelrelaftps(-mreagkieo-ns-upbqbuoaxdletfotp-tboopt-tboomtt-ocmen-tceernlteefrt lbeoftt-torimghlte-fct-enritgehrt-bcoetntotemr))) t)))
(defmethod (intersects-topright? area-quad) (box)
(if((twboohpxereingsh-(tobvoexr-laopv-eprlatposp-rrigeghitobno-xp)box left-right-center top right top-bottom-center) (setq topright (make-subquad top left-right-center top-bottom-center right)) t)))

8.10.8 The Binning Algorithm

(de((fwwm(h(hebbeetnniihnno11((diinnbtott(oeepbtrrltisseoneefm-tccttiolnsse-b--f)ttbs)oouoptbblt)eqo)fumt?aldesfsetl?farsoeebal)f-oqbu)ad) (ob)

((ww(hhbeennin1((iinntotteeprrrssigeecchtttss--otbbo)o)ptrtiogmhtr?igshetl?f

ob) self

ob)

(bin1 bottomright ob)))

142

(de(fifm;;(e<tthh(iosadroe(babjeoicnbt1)isaarrseemaa-a-tlqlheurreatsdhh)aonl(do)rbe)asonable size for this quad

(ca(s:neodnoem(isneattqordominator ob)) ; there are no sublevels keep object here for now

((:ol((tohsbweeientrrwq-i(indsbe-oinmsu-ibinnqa-ut;soauordbts:qhloueswerawldefris)sdeosemtlhfienor;abetm))oisra)rak

cu;rt;rhepneurteshdaordmeoimlnoawinteoarrtolervdeolswbnin this the node as having subquads

lower

down

;;

obj(ebcitn-isins-imsuiblaqrusaizdes,

sseolfboinb))a)t

; and this level

bin

self

(add-to-objects self ob)

))

(de(fl(emta*edtjh(u(osotd-b(b(bitoivnbe-ctitnoo-prb-soleexlvf)oebl-jeacrteato-pquleafdt)b(oottbojmectritgohpt l(eifntcbfoctotuonmt))r))ight)
(bin1 self ob)))

(d(e"flt(omhmoienptughlfstooitprdoloe(bb-bivininanl-suthmeho-iauncnlgadsyll-st'tuboopi-pnpb-osilrneetlvfdtehoole-bab(robeuoanu-dnqsdusmadoe)bs)s)()a)tghein"gs-to-bin)

(de(fumnleetshso(dm(eamddb-ertoo-boobbjejeccttss a:treesat-'qbuoax-d)eq(uoabl))
(setq objects (cons-in-area ob objects *osr-box-area*))))

8.10.9 Routines to Map over a Range of Objects

Given a rectangular area, we want to call some function on each object which intersects that range.
(de(fpmreeptahroed-b(imtveacpt-oor vseerlf-)objects-in-rectangle top-level-area-quad) (function in-box? top left bottom right)
(map-over-objects-in-rectangle-internal self function in-box? top left bottom right bitvector))
(defmethod (map-over-objects-in-rectangle-internal area-quad) (function in-box? top left bottom right seenv &aux (se
((mdeacclarorele(t s(y(sa:acrcreasys-(reogbijsetcetr)seen)) `(if in-box? ,object (send ,object :object))))
(when (and (not (symbolp dominator)) (box-overlaps-region-p dominator left top right bottom)) (le(tun((lecsosu(nptlu(sspen(dardeofmseinenatocor u:indt)))))
(wh(le(onwo((pohfsbeufejnonterfcc(tao(bslaloirnxfeu-fonosbcvej;teeeirnocclthanscepo(csduka-onicrnectg)gesio1s)nr)ds)-)topmisoinalaewtftoinrt))op right bottom) (wh(wenhe((nele(q(tuadn(((nofs(leudecmsntosfticunoa((naplpatltlrleoufe(frufstsnpe:s(lcneob(tdewiaonoerxoner-c)f:oo(isdvuae)enc)e)rctnl)easpc1sos))-ou)))rn))e)tg))ion-p topleft left top right bottom))
((ww(h((hmmmeennaaappp((a-a--nnoooddvvveeetbrrro---opoootrtbbbiogjjjeeemhcccttlttesss(f---tbiiinnno(---xb-rrroeeeoxcccv-ttteaaaornnnvlageggprllleeelsa----piiirnnnse-tttgeeerirerronnngnaaai-olllpnttb-ootopopptrpltbeiorgfoimtghthttfleoutffmnutlecnlfftecutiftontitnocolntepiinfotir-nnitbg-oiohbnpxto-?xrbbi?ogotoxhtttp?otopbtlmeoolf)ep)ttfttbloeombftto)t)tbotomotmtroimgrihgthritgsehseetne)sn)e))en )) (w(hmenap(a-nodvebr-oottbojemcrtisg-hint-(rbeocxta-nogvleer-lainptse-rrneagliobno-tptobmortitgohmt rfiugnhcttiloenft itno-pborixg?httobpotletoftmb))ottom right seen)))))

143

(de(fmmaepf(tu--hnooccvdeteinor(t-nmeorib-anjyp-e-bcytoorsavx-?neingr--eor)ebcj(te-acntcgsel-neitnes-er-lrfaxnxgreantgoep)-(le+vceel-ntaerre-ay-qyruaandg)e

(function in-box? xrange ) (+ center-x xrange)))

yrange

center-x

center-y)

8.10.10 Routines to Map over all Objects
(d(efpmreeptahroed-b(imtveacpt-oar lsletlof)p-level-area-quad) (function &optional in-box?)
(map-all-1 self function in-box? bitvector))
(defmethod (map-all-1 area-quad) (function in-box? seenv &aux (seen seenv))
((mdeacclarorele(ts(y(sa:acrc`r(eaisfys-in(r-eogbbiojsextce?tr),soebejne)c)t (send ,object :object)))) (wh(deno(uliosnbtlej(escost(sopbljuescpts)(aref seen (send o :id))) (if (sym((bfsuoentlpfca(dlaolrmfeufinnscaetetionorn)(s(eancdceoss:iod)))) 1)))) (wh((aaennndd(ebbqoottdttooommmirlneigfathtot(rm(:malopaw-pea-rl)al-ll1-1bobtottotmomlerfitgfhutnfcutniocntioinn-ibno-xb?oxse?esneve))nv)) (un((laaennssdd (ttpoolppurlseipgfth(t(am(remafpas-pea-elnal-ll1-(1steotnpodlperfditgohfmutninfcuatnitoocntrio:iinnd-))ib)no-xb?oxs?eesneve))n)v)) ((fsuentfca(lalrfeufnsceteinon(s(eancdcedssomdoinmatinoart:oidr)))) 1)))))
(d(effmletet(h(oa(dcifc(einms-sab(poox-b?ajelolcbta)jreecat-(qsuenadd)o(bfjuecntct:ioobnje&cot)p))t)ional in-box?)
((wif(h((wdesn(oh(yflmaeiuonsnnbbtdcj(o(eaeblcoplqotlsotdfdtubooonjmmmeccitrintinisoga)anthtoto(rr)(a:mclcoaewpses-r)aol)l)))bottomright function in-box?)) (((aaannnddd bttooopptrlteiogfmthtl(em(ftma(pam-pa-alapll-tloatplollpebrfoitgthtfuotnmfcultenifoctntifouinnn-cibtnio-oxbn?o)i)xn)?-))box?))
(funcall function (access dominator)))))
8.10.11 Manipulation of the Bitvector
I use a bitvector to keep track of already mapped objects, since an object may be binned in more than one place.
(de"(fasmentdetad(hllioseldplnlda(tricpsieerpdeslabptcvaoerde0b-v(bui0tn)v)s)eeecnt)o"r top-level-area-quad) ()

144

(de"(fwrmehseeiztnheo(tdohre((ab>ditjvcueoscuttn-otbr ibitfvvlneeecnctgeotshrs)atro(ypn"-ulllevbeitlv-eacrteoar)-)quad) ()

(setq(bifv(lbaeindtgvjuetshctt-o(ar*rr(acyeibliintvgec(tifor(>bvcloenugntth)bvlength) (* bvlength growth-factor) bvlength) 32) 32))

(setq bitvector (setq displacedbv

(make-array (make-array

bvlength :adjustable t (/ :bevlelmenegntth-t3y2p)e :e'bleitm:eandtj-utsytapbele'

txn:aurmea:d*iossprl-abceodx--taoreba*it)v))ector))))

8.11 Code Implementing Surroundings
8.11.1 Definition of Surroundings
(defvar *surroundings*) (de avor surroundings (page book (areas nil) sta s systems image)
:settable(-)instance-variables)
(de(flemte(t(hdoadta(m(gaekte--diantsatabnoocek spuargreo))u)ndings) (&rest ignore)
(((ssseeetttqqq issmytasatgesme((ssse(ensndedn(ddsae(tnsaden:(idmse(ansgdeen)d)datdaat:agr:igd)rid:)st:asta-lin-elisn)es:)st:asyss)t)ems))))
(de(ffmoremthaotdst(resayms:p"r#in<ts-usrerolfunsudirnrogsunodf ipnaggse) ~(Astrferaomm &~rAe>st"igpnagoree)(pretty-name book))) (de(fomr e(tsheocodn(d (nads-saorcetaypseurarroeuansd:tinesgts)'m(etympbe)er))
(maybe-compute-area self type)))
(de(fsmeteqthaoredas(k(idlle-laetreea(assusrorcoutynpdeinagrse)as(t:tyepset)'member) areas)))
8.11.2 Method for Registering Staff in Surroundings
(d(eflomoepthfffwfoooooirdrrrthstnt(hoseplipaxoslstan=t=c=se((t(-ocassraetr(scaaossnn)-ddinlsass)ute(nbcoettsoumrrolausnt))din0)gs) (sta s area image)
((bseintqfdwaoolriratehsabtorttithghtiohissmt))t)=o=p((s0eonbrdo(taitmnodmagnereigx:wthti()dttohp) next)) (send image :height))

145

8.11.3 Method for Registering Systems

(defmethod (place-system-in uence surroundings) (systems area image)

(loop

for ss on systems fffwoooirrrthtnthoelipaxsst=t==(((ocsraer(caossnn)dd

ss) last

(bottom

last))

0)

((bseintqfdwaoolriratehsabtorttithghtiohissmt))t)=o=p((s0eonbrdo(taitmnodmagnereigx:wthti()dttohp) next)) (send image :height))

8.11.4 Method for Registering Measures
(de(flemte(t(hvomde(apsluarcee--armeaea(smuarek-e-ininsutaennccee 'stouprr-oleuvnedl-inargesa)-(qpuaagde:timopag0e:l&eaftux0 (image-height (send image :height)))
(measure-area (make-instance 'top-:rlie:grvhiegtlh-(tasr(eesnaed-nqdimuiamadgae:gt:eowp:iwd0tidh:)tlehf):tb:o0btotottmom(s(ensedndimimagaeg:ehe:higehigt)h))t)))) (f((lemmt aa((ppp(--llvm(eamtbceeiae((n-(asbauasa((((e-ubrrlofotoeermroorrosewavse((mmepmaaa(paesnn(cmaegauddcaagesraerseuebaar(ur(bes((er(bulo)emo(a)er)vw(mb)elee)o)moa)w((vs)tueb(mor(opmepptleatlaaebaocsareecmeusl-eaour-a)ewar)a-e)b)))-m)))o)mveimeae)as)ausgur0eer)-emhmeimgvhemta)seuarseu-rea-reaar)e))a)))) ((ppuusshh ``((((::vmmeaeasusurer)e),m,vemaesuarseu-rea-reaar)eaa)reaares)as)))

8.11.5 Methods for Registering Fixed-sized Features and Beams

(d(efgmetehtahsohd((fneda-tuferaetsu-roef-tytpyep)e(ssuernrdou(nsednidng(sg)e(t-tydpaet)a book page) :features) :result-table)))

(de(flo(mmoeptuhlftooipdr lfe(-ipnvlaaflceuaeet--ufcreaeaslltud'borien

surroundings)
area f (bounds

(features f))))

area)

(de(fl(ommoeptuhlftooiprdlbe(-epavlmaalcuebe-e-bicneaglalmt'hbe-inianrbreauayem-nec-leeamreseaunrbtrsoeauomnf d((isnbegonusd)nbd(eibnaegma-msbo:sbxbeabeamemasm)-)a)d)roea)
(push `((:beam) ,beam-area) areas))

146

8.11.6 Dispatch Creation of Surroundings by Type

(defmethod (maybe-compute-area surroundings) (type)

(let* (((iamreaag(em(saekned-i(ngsteatn-cdeat'atobpo-olekvepla-gaer)ea:-imquaagde)):top 0 :left 0

(cond (((epqlactyep-esta:st-ain-iunenuceen:crsiege)lhfts(tasensdarimeaaigmea:gwei)dth) :bottom (send image :height))))

((((pepuqlsahctye(p-leissyt:sst'ye(sm:tset-main--iuninenuuceeenncsceee)l)f

area) areas)) systems area

image)

((((ppequlascthyep-(efleisa:tsttu'e(rme:s)yssetlfem(s-einnd

uence) (send

area) areas)) (get-data book

page)

:stems)

:them)

area)

(((tpyupsehp(tlyispte'('f:estaetmur)e-amreoa)deal)reas))

(place-feature self (gethash type (send (send (get-data book page) :features) :result-table)) area)

(push (list (list type) area) areas))

(((peqlactyep-em:emaseuarseu-rien) uence self (make-measures book page) image))

(((((peeqqlacttyyepp-eem::evbamesauemrae)s-uirne)uence self (make-measures book page) image))

area)) ((tp(laecrreo-rb"eadmidn-'int kuneonwcehosewlft(osecnodm(pguetet-adraetaafboroo~kA"patgyep)e):))beams) area))

8.11.7 Mapping over Portions of Surroundings

(de(flo(mloeeptth(foo(drarte(yampe(apinn-dbt-yoapureensaddsso-elofvteyrplea)p))-type surroundings) (object-with-bounds function &rest types)
(multiple-value-call 'map-over-objects-in-rectangle area function nil (bounds object-with-bounds)))))

(de(flo(mloe(eptmth(fuoo(ldratirtpe(ylampe-e(avpiann-ldupt-eyo-apicreneastal-ldos'omevlefarptly-apopev-))et)ry-poebjseucrtrso-uovnedrilnagpps)in(gx-pyofinutncatrieoan

&rest types) function nil x

y))))

(de(flomoepthfoodr t(ympeapin-oobvjeerc-to-btyjpecestsd-oof-type surroundings) (function object-types)
(le(tm(a(pa-reaall (arenad-fuanrecatiosne)l)f))type)))

(defmethod (map-over-areas surroundings) (f)
(loop for (types area) in areas do (funcall f area)))

8.11.8 Definition of Objects which can have Surroundings
(de avor has-surroundings () ()) (defmethod (surroundings has-surroundings) () *surroundings*) (de(famppeltyho'md a(pm-abpou-nbdosu-nodvse-rloavpe-rtlyappe-(tysuprerohuansd-insgusrrsoeulfn)doinbgjesc)t-(wobitjhe-ctb-owuintdhs-bfuonucntdiosnfutnycpteiso))n &rest types) (de(famppeltyho'md a(pm-appoi-npt-ooinvte-rloavpe-rtlyappe-(tysuprerohuansd-insugrsroseulnf)dxinygsf)un(cxtiyonfutnycpteios)n) &rest types)

147

8.11.9 Operating on Relations in Surroundings
(defmethod (kill-all-relations surroundings) ()
(l(omopapfo-ral(ltayrpeeas 'akriella-)aliln-raerleaatisondso)))
(de(fmmaept-hoovder(-toribgjgecetrs--roefl-attyiopen sseulfrroundings) (relation-type object-types)
( (o) (force-relation o relation-type)) object-types))
(de(fmma(oepbt-j((heooloce()vdttae-nr((t-d(yproprrboe(js(pe)p)oncrtdgos-ap-rtooeegfl--aatrttiyeeoplnare)t)o)is)oernleflasutirorno-utnydpein)))gs) (relation-type object-types) (de(flomoepthfoodr t(ykpiell-inreolabtjeioctn-tsyuprersoudnodings) (relation-type object-types)
(le(tm(a(pa-reaall (arenad-(ar(eoa)s(eklfiltl-ypreel)a))tion o relation-type))))))
(defmethod (map-over-relations-of-type surroundings) (f type)
(m(ap-(oarveear)-a(rmeaasps-ealfll area ( (ob) (let ((r ( nd-relation ob type))) (and r (funcall f r))))))))
148

Bibliography
[1] Harold Abelson and Gerald Jay Sussman. Structure and Interpretation of Computer Programs. MIT Press, Cambridge MA, 1985.
[2] Raymond Erickson. Darms, a reference manual. 1976. [3] R.C. Gonzalez and P. Wintz. Digital Image Processing. Addison Wesley, Reading MA, 1987. [4] Daniel W. Hillis. The Connection Machine. MIT Press, Cambridge, 1985. [5] Berthold K. P. Horn. Robot Vision. MIT Press, Cambridge, MA, 1986. [6] Marvin Minsky. Society of Mind. Simon & Schuster, New York, 1987. [7] David Prerau. Computer Pattern Recognition of Standard Engraved Music Notation. PhD thesis, Mas-
sachusetts Institute of Technology, 1970. [8] Gardner Read. Music Notation. Crescendo Publishers, Boston, 1969. [9] Franz Schubert. The Complete Chamberworks (Breitkopf & Hardel Edition). Dover Press, New York, 1973. [10] Guy L. Steele. The definition and implementation of a computer programming language based on constraints.
Technical Report AI-TR-595, Massachusetts Institute of Technology Artificial Intelligence Laboratory, 1980. [11] Guy L. Steele. Common Lisp: The Language (2nd Edition). Digital Press, 1990. [12] Symbolics, Inc. Symbolics Common Lisp-- Language Concepts, 1988. [13] Thinking Machines. Starlisp Reference Manual Version 5.2, 1988. [14] David Waltz. Waltz filtering. In S. C. Shapiro, editor, Encylopedia of Artificial Intelligence, Vol. 2. John
Wiley & Sons, 1987. [15] Patrick Winston. Artifical Intelligence. Addison Wesley, Reading, MA, 1984.
149

