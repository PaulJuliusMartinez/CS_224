Efficient Algorithms for Constructing Testing Sets, Covering Paths, and Minimum Flows

Alfred V. Aho
David Lee
AT&T Bell Laboratories Murray Hill, New Jersey

ABSTRACT
Although testing is an essential part of program and circuit design, the area is still more an art than a science. This paper considers several fundamental problems arising in program and circuit testing, and abstracts them in terms of path-covering problems on graphs. These problems are representative of important classes of graph-optimization problems, and we introduce a technique called ``balancing'' to solve these problems. This technique yields algorithms that are faster, simpler, and easier to implement than those obtained by applying existing methods. Included in the classes of problems are minimum network-flow problems and the Chinese-postman problem.

1. Testing Sets, Covering Paths, and Minimum Flows

Testing is an important part of the process of constructing reliable programs and circuits. To test a program one would like to construct a set of inputs that exercises, if possible, each edge (and/or node) in the program flow graph at least once. Furthermore, one would like to minimize the cost of the test, such as the size of the test suite or the time required to execute the test. Many good programmers have attested to the difficulty of constructing comprehensive test suites [Knuth, 1984].

To test a logic circuit, one can sensitize a set of paths such that each node is on at least one path. A node can be a logic element (combinational or sequential) or a block of such elements. To reduce the cost of testing, one would like to minimize the number of paths sensitized. One may also want to minimize the total length of the paths to reduce the complexity of the test [Seth and Agrawal, 1985; Uyar and Dahbura, 1986].

To simplify the problem, we will represent a program flow graph or logic circuit as a directed graph,
G = [V  { s, t }, E], with n vertices and m edges. The distinguished vertex s is called a source; it has
in-degree zero and corresponds to a unique entry point. The distinguished vertex t is called a sink; it has
out-degree zero and corresponds to a unique exit point. The vertices in V are called intermediate vertices.
Each edge e in E has a lower and an upper capacity bound l(e) and u(e), respectively, where 0  l(e)  u(e), and also has an associated nonnegative cost, cost(e).

A modification of the techniques presented here can also provide algorithms with the same time bounds for problems in which a cost and/or capacity lower and upper bound is assigned to each vertex. For simplicity, however, we will consider directed graphs where only edges have associated costs and capacity bounds.

A v 0 - v r path p in G is a sequence of vertices v 0 , . . . , v r such that there is a sequence of edges

e0, . . . ,

e

r

-

1,
r

where
-1

ei

=

(vi ,

v i + 1 ),

for

i

=

0, . . . ,

r

-

1.

For such a v 0 - v r

path p, we define

cost(p) to be  cost(e i ). A set of covering paths for G is a set of s - t paths such that each edge e is tra-

i=0

versed at least once and no more than u(e) times, where u(e)  1. The basic versions of the testing

-2-

problems can be couched as covering-paths problems:

Problem

CP

(1) 1

.

Minimum-cardinality covering paths.

Find a set of covering paths for G such that the number of paths is minimum.

Problem

CP

(1) 2

.

Minimum-cost minimum-cardinality covering paths.

Among the sets of minimum-cardinality covering paths, find one with minimum cost.

Problem

CP

(1) 3

.

Minimum-cost covering paths.

Find a minimum-cost set of covering paths for G.

Throughout this paper, three forms of each problem will be considered. These forms will be distin-

guished by a subscript, where a value of one denotes a minimum-cardinality problem, a value of two a

minimum-cost minimum-cardinality problem, and a value of three a minimum-cost problem. In addition,

we will consider several versions of each problem form depending on what constraints, if any, are placed

upon the edge capacity bounds. The version in which, for every edge e, l(e) = 1 and u(e)   will be denoted by the superscript ( 1). For the purpose of program or logic circuit testing, we can let l(e) = 1 and

u(e) = . This version will be denoted by the superscript ( 2). A third version, denoted by the superscript (0), where 0  l(e)  u(e)   will be considered later.

Problem

CP

(2) 1

was

studied

by

Ntafos

and

Hakimi

[1979]

in

the

context

of

program

testing,

but

if

one

wants

to

minimize

the

cost

of

the

test,

then

solutions

to

Problems

CP

(2) 2

and CP3(2)

are also needed.

Special

cases of these problems have been considered by Krause, Smith, and Goodwin [1973], Gabow, Mahesh-

wari, and Osterweil [1976], and Ntafos and Hakimi [1979].

Here we consider the more general covering-paths problems on directed graphs with arbitrary capac-

ity upper bounds. In Section 4 we show that these covering-paths problems are equivalent to positive-flow

problems, which are special cases of minimum-flow problems [Even, 1979]. One way to solve these

minimum-flow problems is to reduce them to a sequence of maximum-flow problems as in Ford and Fulk-

erson [1962], Lawler [1976], or Even [1979]. Following this approach, we can find an algorithm for Prob-

lem

CP

(1) 1

with

cost

O(mn log n),

and

algorithms

for

Problems

CP

(1) 2

and

CP

(1) 3

with

cost

O(n 2 (m + n log n) log n) using the methods of Tarjan [1983] and Galil and Tardos [1986].

Instead, we use balancing to solve these minimum-flow problems. We first reduce the minimumflow problems to minimum-cost maximum-flow problems, but the reductions are different from those previously used [Ford and Fulkerson, 1962; Lawler, 1976; Even, 1979]. Using balancing, the reduced flow problem has an obvious bound on the flow value, and efficient algorithms can be devised, such as minimum-cost augmentation and scaling. Furthermore, our approach is intuitive and easy to implement. To our knowledge, there has been no formal presentation of this approach. We feel it is worthwhile to explore this method and to apply it to practical problems, since the ideas involved are simple.

We also present methods for minimizing both the flow value and the cost, which have not been well studied. Balancing can also be used for circulation problems. As special cases, we present algorithms for covering-paths and postman-tour problems. For example, we obtain an O(n(m + n log n) log(m/n)) algorithm for the Chinese-postman problem. For this problem, the best previously published algorithm was O(n 5 ) [Papadimitriou, 1976], and an O(mn log n) algorithm can be obtained by reducing the problem to a minimum-cost flow problem using balancing and solving the reduced problem by scaling [Gabow and Tarjan, 1987]. Our algorithm is faster than either of these methods. Several versions of the covering-paths problems and the postman-tour problems can also be solved with the same run time.

We also study these problems on mixed graphs.

For

example,

we

show

that

Problem

CP

(j 1

)

remains

polynomial,

but

Problems

CP

( i

j),

i

=

2,

3, and j

=

1,

2, become NP-complete.

We begin by providing algorithms for the minimum-flow problems using balancing. Then we spe-

cialize the algorithms to positive-flow problems, which are equivalent to the covering-paths problems.

Finally, we consider several versions of minimum-circulation and postman-tour problems.

-3-

2. Minimum-Flow Problems

A preflow f on a directed graph G = [V  { s, t }, E] is a function from E to nonnegative integers. We define cost( f ) as  f (e) cost(e). The balancing index of a vertex v in G with a preflow f is
eE

(v, f ) =  f(v, w) -  f(u, v)

(v,w) E

(u,v) E

We define value( f ) to be (s, f ).

A flow on G is a preflow f such that l(e)  f (e)  u(e) for all e in E and such that the balancing index (v, f ) is zero for all intermediate vertices v in V.

We can now consider the following minimum-flow problems:

Problem

F

(0) 1

.

Minimum flow.

Find a flow for G with the minimum flow value.

Problem

F

(0) 2

.

Minimum-cost minimum flow.

Among the minimum flows for G, find one with minimum cost.

Problem

F

(0) 3

.

Minimum-cost flow.

Find a flow for G with minimum cost.

The superscript ( 0) indicates that there are no constraints on the capacity bounds on the edges; that is, for each edge e, 0  l(e)  u(e)  .
In the next section, we provide algorithms for these minimum-flow problems using balancing whenever they have a feasible solution [Lawler, 1976; Even, 1979]. The conventional approach has been to reduce a minimum-flow problem to a maximum-flow problem, then to a second maximum-flow problem, and if this has a feasible solution, optimize it by solving a third maximum-flow problem. On the other hand, with balancing we can find an optimal solution directly by solving a maximum-flow problem on a modified graph.

3. Algorithms for Minimum-Flow Problems
We first show that the minimum-flow problems are equivalent to preflow-minimization problems, which can be reduced to maximum-flow problems on a so-called balancing graph with only capacity upper bounds on the edges. Balancing-preflow problems are introduced to make the reduction conceptually clear. For practical purposes, one can construct the balancing graphs by a simple modification of the original graph, and then solve the final maximum-flow problems directly.

3.1. Balancing-Preflow Problems
A preflow f 0 is basic if for every e in E, f 0 (e) = l(e), where l(e) is the capacity lower bound on edge e. We partition the set of intermediate vertices V into three sets: S (surplus), B (balanced), and D (deficient). An intermediate vertex v is in S, B, or D depending on whether (v, f 0 ) is less than, equal to, or greater than zero, respectively. A preflow f b is balancing if f b (e)  u(e) - l(e) for all edges e in E, and (v, f b ) = - (v, f 0 ) for all intermediate vertices v in V. Note that a balancing preflow may not exist because of the capacity bounds on the edges.
Theorem 3.1. (Decomposition of a feasible flow). f is a flow on G if and only if f = f 0 + f b, where f 0 is the basic preflow and f b is a balancing preflow on G.
Proof. Let f b be a balancing preflow. Since l(e)  f 0 (e) + f b (e)  u(e) for all e in E, and (v, f 0 + f b ) = (v, f 0 ) + (v, f b ) = 0 for all intermediate vertices v, f 0 + f b is a feasible flow.
On the other hand, given a flow f on G, let f b = f - f 0, where f 0 is the basic preflow. Since l(e)  f (e)  u(e) for all e in E, f b is a preflow. For all intermediate vertices v, (v, f b ) = (v, f ) - (v, f 0 ) = 0 - (v, f 0 ) and therefore f b is balancing.
Since the basic preflow depends only on G and has fixed cost and flow value, we have:

-4-

Theorem 3.2. The minimum-flow problems F(i0), for i = 1, 2, 3, are equivalent to the following corresponding balancing-preflow problems:
Problem BF 1. Minimum balancing preflow. Find a balancing preflow for G with minimum value.
Problem BF 2. Minimum-cost minimum balancing preflow. Among the minimum balancing preflows, find one with minimum cost.
Problem BF 3. Minimum-cost balancing preflow. Find a balancing preflow for G with minimum cost.

3.2. Balancing Graphs

__

From the directed graph G, we construct a balancing graph G__, and the balan__cing-preflow problems

on G can be reduced to corresponding maximum-flow problems on G. To construct G, we add a new source

vertex s and a new sink vertex t to G. The following edges are also added to G:

i) Add the edges (s, s) and (t, t).

ii)

For each v in S, add the edge (s,

v)

with

capacity

upper

bound

_ u(

s



,

v)

=

- (v,

f 0 ).

iii)

For each w in D, add the edge (w,

t



)

with

capacity

upper

bound

_ u(

w

,

t)

=

(w,

f 0 ).

The cost of each edge in G remain__s what it was, and the cost of each added edge is zero. The capacity

l_ower u__( e )

bound = u(e)

of -

all the edges in G is zero. For l(e). The capacity upper bounds

each edge e in G, the capacity upper bound becomes of (s, s) and (t, t) will be specified later. Obviously,

G has O(m) edges and O(n) vertices. __

Given a flow F on G, the induced preflow f on G is defined as f (e) = F(e) for all e  E. We now

reduce the balancing-preflow problems to maximum-flow problems on balancing graphs.

3.3. Minimum flow

To present the algorithms, we use the concept of a residual graph of a flow. Let f be a flow on G
wucs_ea(itpvthVa, c,cwisatyo)puau=rcpcipteuye(srvl,ob,swiownuek)rndtb,-oua_un(fndw(dva,,znvewe)rod).=gaenIffd((v(uv,vp, ,wpwew)r)o).bfioTscuhainepndarcEeuis.tiybdTuuu_tha(el(vwg,rre,waspvi)dh),uwiRashl(encfroae)tp,fu_art(ochvmiet,nyaw(auf)dlpodp>wearn0f b.ieosTdutghhneeed)c(gwoorasf,pt(shvvo),wftwiotthh)eGivneedwrEgtieetixhss in R( f ) are defined as (v, w) = cost(v, w) if (v, w)  E, and (v, w) = - cost(w, v) if (w, v)  E. We need the following well-known lemma, see, for example, [Tarjan, 1983].

Lemma 3.1. Let f be any flow and f * a maximum flow on G. If R( f ) is the residual graph from f, then the

value of a maximum flow on R( f ) is value( f *) - value( f ).

__

To find a minimum flow, we use the following step-wise balancing on G. When finding the maxi-

mum flows, we use the Sleator-Tarjan algorithm [Tarjan, 1983]. The induced preflow on G is a minimum

balancing preflow.

Algorithm 1. Minimum flow.

1.

Construct

the balancing

graph

__ G

and

set

_ u

(

s

,

s)

=

_ u(t,

t)

=

0.

__

2. 3.

Find a maximum flow

Set

_ u

(

s

,

s)

=

 and

F1 _ u(v

on G, , s_)

and let = 0, v

R 

1 be the residual S, in R 1, and let

graph. _ R 1 be

the

modified

graph.

4. Find a maximum flow f 2 on R 1. Let R 2 be the residual graph, and let F 2 = F 1 + f 2.

5. If value(F 2 ) <

(w, f 0 ), then abort. There is no feasible flow on G.

6.

Set µ

=

u_ ( s  ,

wD
s) = F2(s,

_ s) and u(t, _

t)

=

_  in R 2, and let R 2 be the modified graph.

7. Find a maximum flow f 3 on R 2, and let F 3 = F 2 + f 3.

-5-

8. If value(F 3 ) < µ + [ - (v, f 0 )], then abort. There is no feasible flow on G. vS
9. Let f b be the induced preflow of F 3 on G, and let f = f b + f 0, where f 0 is the basic preflow; f is a minimum flow on G.

Intuitively, the minimum balancing preflow is constructed from three-stage balancing. Steps 1 and 2 balance vertices in S and D as much as possible without using flow from s or t. Steps 3 to 5 balance the remaining vertices in D using flow from s only, and Steps 6 to 8 balance the remaining vertices in S using flow from t only. To analyze Algorithm 1, we need the following lemma.

Lemma 3.2. Let f b * be a
i) there exists a flow

minimum balancing preflow on G with

F1*

on

__ G

with

_ u(s

,

s)

=

_ u(t,

t)

=

value µ*. Then 0 such that value(F 1

*)

=

(w, f0)

wD

- µ*;

ii)

there

exists

a

flow

F2*

on

__ G

with

_ u(s

,

s)

=

and

_ u(t,

t)

=

0,

such

that

value(F 2 *)

=  (w, f 0 ); and

iii)

wD
there exists

a

flow

F3*

on

__ G

with

u_ ( s  ,

s)

=

µ*

and

_ u(t,

t)

=



such

that

value(F 3 *)

=

µ*

+  [ - (v, f 0 )].

Proof.

vS
We define

a

flow

F3*

on

__ G

with

_ u

(

s

,

s)

=

µ*

and

_ u(t,

t)

=  as follows. Let F 3 *(e)

= f b *(e) for e  and F 3 *(w, t) =

E, and - (w,

let fb

F3 * ),

*( w

s, s) __D.

= µ*, Then

F3 *(s F 3 * is

, a

v) = (v flow on

,__f G

b *), with

v_ u

 (s



S, F , s)

3* =

(t, µ*

t) =_ - and u(t

(t, , t)

f b *), = .

We call F the derived flow on G from f b *. Since f b * is balancing, value(F 3 *) = F 3 *(s, s)

+  F 3 *(s, v) = µ* +  (v, f b *) = µ* +  [ - (v, f 0 )]. Part (iii) has now been proved.

vS

vS

vS

We successively re_duce the min_imum balancing preflow f b * along v - t paths, where_ v  S__, such

tu_h(astt,hse)re=ducedanpdreu_fl(otw, tfb)

* has = 0.

(t, fb Since

*) = fb*

0. is

Similarly, balancing,

let F 2 * be the derived flow from f b a_nd only the balancing indices of

* v

on in

G S

with were

changed during the reduction of f b *, F 2 *(w, t) = - (w, f b *) = - (w, f b *) = (w, f 0 ), w  D. Now,

value(F 2 *) =  F 2 *(w, t) =  (w, f 0 ), and Part (ii) has been established.

wD

wD

_

__

(s,

__We further reduce f b *) = 0. Let F 1 *

f b * along s - be the derived

w paths, w__here w__ D, flow from f b * on G with

such

_ u(s



,

that s)

the

=

_ u

reduced (t, t) =

preflow f b * has 0. Similarly, we

have value(F 1 *) = (w, f 0 ) - µ*, and Part (i) has been proved.

wD

Theorem 3.3. Algorithm 1 determines the existence of a flow on G and constructs a minimum flow f in

time O(mn log n).

Proof. We first show that if the algorithm aborts at Steps 5 or 8, there is no feasible flow on G. We then

show that the preflow f b constructed in Step 9 is a minimum balancing preflow and, therefore, f is a mini-

mum flow on G.

Since paths

In Step 4, we construct t is not reachable from in R 2, F 2 is a maximum

a maximum flow on

s in flow

oRn2G,__awndithseu_tt(isng,

__

gu_sr()avp=,hsR )1abanafdcteku_r(tsote, Fttti1n)(gs=u,

(v, v) 0.

s) to zero for each v  S. does not provide any s - t

Assume that Algorithm 1 aborts at Step 5 and that there exist balancing preflows on G. Let f b__* be a

mu_(isni,msu)m=balanancidnug_(ptr,etflo) w=w0i,thwvitahluvealµu*e.(

Then F2 *)

by =

(ii)

of Lemma (w, f 0 ).

3.2, there exists a flow On the other hand, the

F 2 * on G maximum

with flow

F 2

on

__ G

with

u_ ( s  ,

s)

=



and u_(t,

t)

=

wD
0 has value(F 2 ) <

(w, f 0 ) = value(F 2 *). This is a

wD

contradiction. Therefore, if Algorithm 1 aborts at Step 5, there is no balancing preflow on G, and by Theo-

rem 3.2, there is no feasible flow on G.

Assume that Algorithm 1 aborts at Step 8 and that there exist balancing preflows on G. Let f b__* be a minimum balancing preflow with value µ*. Then by (i) of Lemma 3.2, there exists a flow F 1 * on G with

-6-

_
u(s

,

s)

=

_ u(t,

t)

=

0,

with

value(F 1 *)

=

(w, f 0 ) - µ*. Since Algorithm 1 did not abort at

Step 5, value(F 2 ) =

(w,

f 0 ).

Since

w
F1

D
is a

maximum

flow

on

__ G

with

_ u(s

,

s)

=

_ u(t,

t)

=

0,

wD

 value(F 1 ) = value(F 2 ) - µ =

(w, f 0 ) - µ  value(F 1 *) = (w, f 0 ) - µ*. Thus µ  µ*.

 _
u(s

,

{µ +

Since F 3 s) = µ*

iasnadmu_ax(tim, tum)

w  D __ flow on G
=  has

with

_ u(s

,

value no

s) = more

µ and than

[ - (v, f 0 )] } = µ* + [ - (v, f 0 )]. That is, a

wD

_ u(t,

t)

=

(µ* - µ)

maximum

__

, a maximum flow on G with

+ value_(_F 3 ) <_ flow on G with u

(µ (s

* ,

- s)

µ) + = µ*

and

_ u

v
(t


,

S
t

)

=



has value

less

vS
than µ*

+

[ - (v, f 0 )]. This contradicts Part (iii) of Lemma 3.2.

vS

Therefore, if Algorithm 1 aborts at Step 8, there is no balancing preflow on G, and by Theorem 3.2, there is

no feasible flow on G.

From Steps 5 and 8, F 3 saturates all the edges (s, v) and (w, t), v  S and w  D. Therefore, the induced preflow f b constructed in Step 9 is balancing. From the arguments in the previous paragraph, value( f b ) = µ  µ*, where µ* is the value of a minimum balancing preflow. Therefore, f b is a minimum balancing preflow.

It takes time O(mn log n) to construct a maximum flow using the Sleator-Tarjan algorithm in Steps 2, 4, and 7. The other steps take time O(m).

3.4. Minimum-cost minimum flow

The algorithm for finding a minimum-cost minimum flow for G is based on the output of Algorithm

1, which computes the value of a minimum balancing preflow µ, if it exists. Since for any balancing pre-

flow f b, (s, f 0 ) + (s, f b ) = - [(t, __f 0 ) + (t, f b )], let  = - (t, f b ) = µ + (s, f 0 ) + (t, f 0 ). From G we construct a balancing graph G, _i_n which the capacities of edges (s, s) and (t, t) are µ and , respectively. Let F be the derived flow on G from__a minimum balancing preflow. Then F saturates all the edges incident to s or t. Therefore, a flow F on G is maximum if and only if all the edges incident to s or

t are saturated. This is the case if and only if the induced preflow f b of F is balancing and has the mini-

mum value µ. Since cost(F) = cost( f b ), we have:

__

Lemma 3.3. If there exists a balancing preflow on G, then a flow F on G is a minimum-cost maximum

flow if and only if the induced preflow f b on G is a minimum-cost minimum balancing preflow.

__ To construct the minimum-cost maximum flows on__G, different techniques can be used. Note that
from the capacity constraints of the edges incident to s in G, the flow values are bounded by L =  l(e). eE
Algorithm 2. Minimum-cost minimum flow.

1. Use Algorithm 1 to determine the existence of balancing preflows on G. If there exist such flows,

2.

compute

the __

value

µ

of

the

Construct G, the balancing

minimum-balancing preflows, and  as well.

graph

for

G,

sett_i_ng

_ u(

s

,

s)

=

µ

and

_ u(t,

t

)

=

.

3. Find a minimum-cost maximum flow F on G.

4. From F construct the induced balancing preflow f b on G.
5. Let f = f b + f 0, where f 0 is the basic preflow; f is a minimum-cost minimum flow for G.
All steps except 3 take total time O(mn log n). Different algorithms for Step 3 yield different costs for Algorithm 2. We shall use algorithms for finding the shortest paths frequently. Recall that single source shortest paths can be obtained in time O(n 2 ), O(m log m/n + 2 n), and O(m + n log n), using Dijkstra's algorithm [Aho, Hopcroft, and Ullman, 1974; Tarjan, 1983], implicit heaps [Johnson, 1977; Tarjan, 1983], and Fibonacci heaps [Fredman and Tarjan, 1984], respectively. The first two algorithms are relatively easy to implement, and the last one yields the best-known time bound. The time bounds reported here are from using Fibonacci heaps, and practitioners might want to choose the other two alternatives.

If we use minimum-cost augmentation for finding a minimum-cost maximum flow in Step 3, since

-7-

the flow value is bounded by L and each augmentation takes time O(m + n log n), the total cost is O((m + n log n) L).
Since the flow value is bounded by L, we can set the capacity upper bounds to L for the edges with capacity upper bounds exceeding L, and then use scaling on capacities [Edmonds and Karp, 1972]. A minimum-cost maximum flow can be found in time O(m(m + n log n) log L).
Theorem 3.4. Algorithm 2 constructs a minimum-cost minimum flow f in time O(mn log n + (m + n log n) L) if minimum-cost augmentation is used in Step 3, and in time
O(m(m + n log n) log L)) if scaling is used, where L =  l(e). eE
Proof. The correctness of the algorithm follows from Lemma 3.3 and Theorem 3.2.

3.5. Minimum-cost flow

We first reduce the minimum-cost balancing preflow problem on G to a problem on an augmented graph, and then further reduce this problem to a minimum-cost maximum-flow problem on a balancing graph. Essentially, we reduce the problem to a circulation problem (see Section 6). Because of practical applications in programming and circuit testing, we prefer to present solutions in this order. We identify the problems in the reduction only for the purpose of making the reduction conceptually clear. For practical purposes, one can construct the balancing graphs by a simple modification of the original graph, and then solve the final maximum-flow problems directly.

To construct the augmented graph G* from G, we add an edge (t, s) with cost zero, and capacity
bounds l(t, s) = 0, u(t, s) = . Given a balancing preflow f b on G, we define a preflow f b * on G* as follows. Let f b *(e) = f b (e) for e  E, and let f b *(t, s) = (s, f 0 ) + (s, f b ). Let * be the balancing index of vertices in G*. Obviously, the balancing index of f 0 for all vertices in G* remains the same as it was in G, and *(v, f b *) = (v, f b ) for v  S  D. On the other hand, since (s, f b ) + (s, f 0 ) = - [(t, f b ) + (t, f 0 )], we have *(t, f b *) = (t, f b ) + f b *(t, s) = (t, f b ) + [(s, f 0 ) + (s, f b )] = - (t, f 0 ), and *(s, f b *) = (s, f b ) - f b *(t, s) = (s, f b ) - [(s, f 0 ) + (s, f b )] = - (s, f 0 ). Therefore, if f b is a balancing preflow on G then f b * is a balancing preflow on G*, where s and t are considered as intermediate vertices, and the restriction of f b * to G is f b. On the other hand, the restriction of a balancing preflow on G* to G is a balancing preflow. Since cost( f b *) = cost( f b ), we only have to find a minimum-cost balancing preflow on G*.

__ Note that t is a surplus vertex and s is a deficient vertex in G* now. To construct the balancing graph G*, we add a new source vertex s and a new sink vertex t to G*. The following edges are also added to

G *:

i)

For each v in S



{t}, add the edge (s,

v)

with

_ u(s

,

v) = -(v,

f 0 ).

ii) For each w in D  {s}, add the edge (w, t) with u_(w, t) = (w, f 0 ).

The cost of each edge in G rem__ains what is was, and the cost of each added edges is zero. The capacity

l_ower u(e)

bound = u(e)

of -

each l ( e ).

edge in G* __is zero, and for each edge e Obviously, G* has O(m) edges and O(n)
__

in G, the vertices.

capacity

upper

bound

becomes

Given a flow F on G*, the induced preflow f b * is balancing if and only if all the edges incident to s

or t are saturated, and in this case, F is a maximum flow. Thus

Lemma 3.4. There__exists a balancing preflow on G* if and only if there exists a balancing preflow on G. In this case, F on G* is a minimum-cost maximum flow if and only if the induced preflow f b * on G* is a
minimum-cost balancing preflow, and this is the case if and only if f b, the restriction of f b * to G, is a
minimum-cost balancing preflow on G.

Algorithm 3. Minimum-cost flow.
1. From G construct the augmented graph G*. __
2. From G* construct the balancing graph G*.__ 3. Find a minimum-cost maximum flow F on G*. If not all the edges incident to the source s or sink t
are saturated, then abort. There is no feasible flow on G.

-8-

4. Compute the induced balancing preflow f b * from F on G*.
5. Let f b be the restriction of f b * to G. 6. Let f = f b + f 0, where f 0 is the basic preflow; f is a minimum-cost flow for G.
We can now prove the following analog of Theorem 3.4:
Theorem 3.5. Algorithm 3 constructs a minimum-cost flow f in time O(mn log n + (m + n log n) L) if minimum-cost augmentation is used in Step 3, and in time O(m(m + n log n) log L)) if scaling is used,
where L =  l(e). eE

4. Positive Flow and Path-Covering Problems on Graphs with Capacity Upper Bounds
A flow f is positive if l(e) = 1 for all edges e. We now specialize results obtained for the minimum-flow problems to the following positive- flow problems:

Problem

F

(1) 1

.

Minimum positive flow.

Find a positive flow for G with a minimum flow value.

Problem

F

(1) 2

.

Minimum-cost minimum positive flow.

Among the minimum positive flows for G, find one with minimum cost.

Problem

F

(1) 3

.

Minimum-cost positive flow.

Find a positive flow for G with minimum cost.

Given a set of covering s - t paths P, let f (e) be the number of times e appears in P (if e appears more than once on the same path, each occurrence of e is counted). Then f is a positive flow on G, called the derived flow from P. Obviously, the cardinality of P is value( f ), and cost( f ) = cost(P).

Conversely, given a positive flow f on G, one can successively reduce the flow along s - t paths and cycles, constructing s - t paths and cycles. When f  0, we have constructed a set of s - t paths and cycles P such that the derived flow from P is f. Since f (e)  1 for all e in E, we can append the cycles to s - t paths, such that there are only s - t paths in P.

On the other hand, the flow value is bounded by L =  l(e) = m, and each flow augmentation in eE
Algorithms 1-3 is taken along a path of no more than n edges. Therefore, the value of  F(e) for the eE
constructed flow F is O(mn), and that for the corresponding balancing preflow  f b (e) is O(mn). The eE
flows f computed by Algorithm 1-3 have the property:  f (e) = O(mn). Therefore, from such a positive eE
flow, the corresponding covering paths can be constructed in time O(mn). We summarize:

Theorem 4.1. The covering-paths problems CPi(1) are equivalent to the corresponding positive-flow prob-

lems

F

( i

1)

,

i

=

1,

2,

3, respectively.

An optimal solution of a positive-flow problem can be transformed to

an optimal solution of the corresponding covering-paths problem, and vice versa, in time O(mn).

We can use Algorithms 1 - 3 for the positive-flow problems F(i1), i = 1, 2, 3, and then obtain solu-

tions of the covering-paths problems.

__

Since the flow value on the balancing graph G is bounded by m, instead of using the Sleator-Tarjan

algorithm, we can use Dinic's algorithm for finding maximum flows. One can easily check that it takes

time O(mn) [Gabow, 1985]. We summarize:

Theorem

4.2.

The

positive-flow

problem

F

(1) 1

and

the

covering-paths

problem

CP1(1)

can

be

solved

in

time

O ( mn ).

The

positive-flow

problems

F

( i

1)

and the covering-paths problems CP(i1), i

=

2,

3, can be solved

in time O(m(m + n log n)).

-9-

5. Positive-Flow and Covering-Paths Problems on Graphs without Capacity Upper Bounds

For the purpose of constructing testing sets, there is no a priori capacity upper bound on the edges. Therefore, we can set u(e) =  for all e in E, and denote the corresponding positive-flow and coveringpaths problems by F(i2) and CP(i2), i = 1, 2, 3, respectively. As special cases, we can apply Algorithms 1-3 for these problems. However, since there is no capacity upper bound, it is easy to determine the exis-
tence of flows on G:

Lemma 5.1. For a directed graph G without capacity upper bounds, the positive-flow and covering-paths problems have a solution if and only if for every vertex v in V, there is an s - v and a v - t path in G.

After checking the existence of feasible solutions, Algorithms 1 - 3 can be applied to these problems:

Theorem

4.2.

The

positive-flow

problem

F

(2) 1

and

the

covering-paths

problem

CP

(2) 1

can

be

solved

in

time

O ( mn ).

The

positive-flow

problems

F

( i

2)

and the covering-paths problems CP(i2), i

=

2,

3, can be solved

in time O(m(m + n log n)).

By taking advantage of the fact that the capacity upper bounds are infinite for all the edges in the bal-

ancing graphs except those incident to the source s or sink t, we can further reduce the time bounds for

Problems Fi(2)

and

CP

(2) i

,

i

=

2,

3.

5.1. O(mn log n) Algorithms

Since the sum of capacity bounds of edges incident to the source or sink in a balancing graph is bounded by m, and the rest of the edges have infinite capacity upper bound, we can use capacity scaling [Edmonds and Karp, 1972; Gabow and Tarjan, 1987]. It provides an O(n(m + n log n) log n) algorithm for finding a minimum-cost maximum flow on a balancing graph.

If m  n log n, then this bound is O(mn log n). Otherwise, we can use minimum-cost augmentation for finding a minimum-cost maximum flow with cost O(m(m + n log n)), which is O(mn log n) when m < nlogn. We summarize:

Theorem

5.1.

The

positive-flow

problems

F

( i

2)

and

the

covering-paths

problems

CP

( i

2)

,

i

=

2,

3,

can

be

solved in time O(mn log n).

Next, we use partial scaling to further improve the efficiency of the algorithms.

5.2. Partial Scaling: O(n(m + n log n) log(m/n)) Algorithms

In Algorithms 2 and 3, the positive-flow problems F(i2), i = 2, 3, are reduced to minimum-cost maximum-flow problems on balancing graphs, where the edges incident to the source or sink have bounded

capacities and the rest of the edges have an infinite capacity upper bound. Instead of scaling all the edges

after setting the capacity bounds of some of the edges to m, as was done in the previous subsection, we now

use partial scaling to further improve the efficiency of the algorithms. We only scale the edges incident to

the source or sink. Our approach is a generalization of scaling used by Edmonds and Karp [1972] for the

transportation problem, and we adopt their terminology. The interested readers are referred to the original

paper.

__ _

_

We construct a minimum-cost maximum flow on a__ balancing graph G = (V  {s, t}, E). _A

labeling function is a mapping from the set of verti__ces of G to the real numbers. Note that for v, w  V,

the capacity of edge (v, w) is infinity. A flow f on G is extreme if and only if there is a labeling function 

such that for every edge ( v, w) in the residual graph R( f ), (v) - (w) + (v, w)  0, where __ is the cost function on the edges in the residual graph as defined in Section 3.3. A flow f is extreme on G if and

only if there exists  such that the following six conditions hold: __

(i) For v, w  V and (v, w)  E, (v) - (w) + cost(v, w)  0; __

(ii) For v, w _ V and (v, w)  E, (v) - (w) + cost(v, w) > 0 implies f (v, w) = 0;

(iii) (iv)

For

v



S, _

(s)

For v  S__, (s)

> <

(v) implies f (s, v) (v) implies f (s, v)

= =

0;

_ u(s

,

v );

(v) For w  D, (w) > (t) implies f (w, t) = 0;

(vi)

For w



__ D, (w)

<

(t) implies f (w,

t)

=

_ u(w,

t  ).

- 10 -

A flow is pseudo-extreme if there exists a labeling function satisfying conditions__(i) and (ii). As in Edmonds and Karp [1972], it can be shown that a pseudo-extreme maximum flow on G is extreme, i.e., a
min__imum-cost maximum flow. The problem is now reduced to finding a pseudo-extreme maximum flow on G.

Choose a positive integer l such that the capacity upper bounds of the edges incident to the source s

or sink t have at most l digits in

function. capacity

uF_o( wr

Problem , t)/2p

p, where , where v

their binary expansions. Obviously, l 0 _ p  l, edg__e (s, v) has capacity  S and w  D. The capacity of the

u_

log m, where (s, v)/2p and

. is the edge (w,

other edges remains infinite.

ceiling t) has

Then the scaling method computes maximum pseudo-extreme flows successively for Problems
l, l - 1, . . . , 0. It can be easily shown that if f is a maximum pseudo-extreme flow computed in Problem p and  is the associated labeling function, then 2 f can be taken as its initial pseudo-extreme flow in Problem p - 1 with  as its associated labeling function.

The detailed implementation is similar to that of Edmonds and Karp [1972], and we omit it. How-

ever, to guarantee the correctness of the algorithm, we have to prove that each minimum-cost augmentation

over a pseudo-extreme flow still gives a pseudo-extreme flow. _
Sin_ce f k is a pseudo-extreme flow and k is the associated labeling function, for (v, w)  E, v, w  V, k (v, w)_ = k (v) - _k (w) + (v, w) = k (v) - k (w) + cost(v, w)  0. On the other hand, for v, w  V, (v, w)  E, and (w, v)  R( f k ), k (w, v) = k (w) - k (v) + (w, v) = - [k (v) - k (w) + cost(v, w)]. If k (w, v) < 0, then k (v) - k (w) + cost(v, w) > 0; that is, f k (v, w) = 0, since f k is a pseudo-extreme flow. Thus, (w, v_) cannot be in R( f k ), a contradiction. Therefore, k (v, w)  0 for all (v, w)  R( f k ), where v, w  V.

Starting with 0  0 and f 0  0, we do the following minimum-cost augmentations. Given a pseudo-extreme flow f k with its associated labeling function k, augment along a minimum-cost path from s to t in the residual graph R( f k ), with respect to the costs k (v, w) = k (v) - k (w) + (v, w) for all edges (v, w) in R( f k ). If k (v) denotes the cost of a shortest path from s to v with respect to the costs k, set k + 1 (v) = k (v) + k (v). Obviously, k (v, w)  0 for all (v, w)  R( f k ). Since 0 (s) = 0 and k is nonnegative, k (s) = 0 for all k. We now have:
_ Lemma 5.2. For each v in V, k + 1 (v) gives the cost of a shortest path from s to v in the residual graph R( f k ) with respect to the cost function . If f k is a pseudo-extreme flow, then after a minimum-cost augmentation in R( f k ) with respect to the cost k, f k + 1 is still a pseudo-extreme flow with k + 1 as the associ-

ated labeling function.

 Proof. Let p(v) be a path from s to v in R( f k ). Then k (., .) = k (s) - k (v) + (., .), where  p(v) p(v)
is the cost function in R( f k ). Therefore, an s - v path in R( f k ) is of minimum cost with respect to  if and only if it is of minimum cost with respect to k.

Let p*(v) be a shortest path from s to v with respect to the cost function k (and ). Then k + 1 (v)

  = k (v) + k (v) = k (v) + [k (s) - k (v) + (., .)] = k (s) + (., .) = (., .). There-

p*(v)

p*(v)

p*(v)

fore, k + 1 (v) gives the cost of a shortest path from s to v in the residual graph R( f k ) with respect to the

cost function . The first part of the lemma is proved.

To s_how that f k + 1 i_s pseudo-extreme, we have to show that conditions (i) and (ii) hold for (v, w)  E, where v, w  V.

 We have k + 1 (v) - k + 1 (w) + cost(v, w) =

(., .) -

(., .) + (v, w)  0, since

p*(v)

p*(w)

 (., .) + (v, w) is the cost of an s - w path in R( f k ) and  (., .) is the cost of a shortest s - w

p*(v)

p*(w)

path in R( f k ). Thus (i) is proved.

 If k + 1 (v) - k + 1 (w) + cost(v, w) > 0, then in R( f k ), (., .) -

(., .) + (v, w) > 0,

p*(v)

p*(w)

i.e.,  (., .) + (v, w) >  (., .). This implies that (v, w) is not on a minimum-cost augmenting

p*(v)

p*(w)

path in R( f k ), and, therefore, f k + 1 (v, w) = f k (v, w).

- 11 -

Assume on the contrary that f k (v, w) > 0. Then (w, v)  R( f k ). From k + 1 (v) - k + 1 (w) + cost(v, w) > 0, we have k + 1 (w) - cost(v, w) = k + 1 (w) + (w, v) < k + 1 (v), where (w, v) is the value of edge (w, v) of the cost function in the residual graph R( f k ). Therefore, k + 1 (v) is not the cost of a shortest path from s to v in the residual graph R( f k ) with respect to the cost function  of R( f k ). This is a contradiction to the first part of the lemma. Therefore, f k + 1 (v, w) = f k (v, w) = 0, and this proves (ii).

The total number of flow augmentations is

_ __
max (S, D)

  2  

+

  log 

_m__va_x_(S__u__S_(_s_,_,_vD___)__)  .

Since



_ u
_

(

s



,

v)

=

_ __ O(m) and max (S, D)

=

O ( n ),

vS

max

_ __ (S, D)

  2  

+

  log 

_m__va_x_(S__u__S_(_s_,_,_vD___)__) 

=

O(n

log

_m_ ). n

Each augmentation takes time O(m + n log n) using Fibonacci heaps, and the total cost for solving the min-cost max-flow problem is O(n(m + n log n) log(m/n)). Therefore,
Theorem 5.2. The positive-flow and the covering-paths problems F(i2) and Pi(2), i = 2, 3, can be solved in time O(n(m + n log n) log(m/n)).

The following lemma shows that this bound is even tighter than O(mn log n), and we omit the rou-

tine proof.

Lemma 5.3. Let m be of order n 0 (log n) 1 (log log n) 1 ..., where 1   0  2. Then (i) n(m + n log n) log(m/n) is of order O(mn log n); (ii) for  0 > 1, n(m + n log n) log(m/n) is of order (mn log n); and (iii) for  0 = 1,

n(m + n log n) log _m_

lim ___________________n__ = 0.

n

mn log n

6. Minimum-Circulation Problems We now study flow and covering-paths problems on a directed graph G O without a source s or sink t.
Otherwise, the capacity bounds and costs are the same as in Section 1. A circulation on G is a preflow f such that l(e)  f (e)  u(e) for all e in E and such that the balancing index (v, f ) = 0 for all v in V. A distinguished vertex O is called the origin. The flow value out of O (or equivalently, into O), i.e.,
 f (O, v), is called the repetition of the circulation. We study the following circulation problems:
(O, v)  E
Problem C(10). Minimum circulation . Find a circulation for G with minimum repetition.
Problem C2(0). Minimum-cost minimum circulation. Among the minimum circulations of G, find one with minimum cost.
Problem C(30). Minimum-cost circulation. Find a circulation for G with minimum cost.
Strongly polynomial algorithms exist for Problem C3(0); see Tardos [1985]. Balancing gives an algorithm with a run time depending on the capacity lower bounds. However, it yields better algorithms for the

- 12 -

postman-tour problems.

We can replace the origin O by two vertices s and t, and replace edges (O, v) by (s, v) and edges

(w, O) by (w, t) with the same capacity bounds and costs. In this way, the minimum-circulation problems

C

( i

0)

can be reduced to the minimum-flow problems Fi(0), i

=

1,

2,

3, and Algorithms 1 - 3 can be applied.

Thus,

Theorem 6.1. The minimum-circulation problem C(10) can be solved in time O(mn log n). The

minimum-cost

minimum-circulation

problem

C

(0) 2

and

the

minimum-cost

circulation

problem

C(30)

can

be

solved in time O(mn log n + (m + n log n) L) if minimum-cost augmentation is used, and in time

O(m(m + n log n) log L)) if scaling is used, where L =  l(e).

eE

7. The Positive-Circulation and Postman-Tour Problems on Graphs with or without Capacity Upper Bounds

Similarly, as special cases of the minimum-circulation problems, we can define positive-circulation
problems, where the capacity lower bound of every edge e in E is l(e) = 1. We denote the corresponding positive-circulation problems by C(i1), i = 1, 2, 3.

Let G O be a directed graph with origin O. A closed path in G O is one in which the beginning and the ending vertex is the same origin O. A postman tour is a closed path that uses every edge at least once in the

direction of the edges [Kwan, 1960; Edmonds and Johnson, 1973]. Similar to the covering-paths problems

CPi(1), i = 1, 2, 3, we can define the following postman-tour problems on G O:

Problem

PT

(1) 1

.

Least-repetitious postman tour.

Find a postman tour with minimum repetition.

Problem

PT

(1) 2

.

Minimum-cost

least-repetitious

postman

tour.

Among the least-repetitious postman tours, find one with minimum cost.

Problem

PT

(1) 3

.

Minimum-cost postman tour.

Find a postman tour with minimum cost.

As special cases of the positive-circulation problems, we can consider the positive-circulation prob-

lems on graphs without capacity upper bound (or u(e) =  for all e in E). We denote the three corre-

sponding

problems

by

C

( i

2)

,

i

=

1,

2,

3.

We can also define postman-tour problems on such graphs, and

denote

the

corresponding

problems

by

PT

( i

2)

,

i

=

2,

3.

Similarly, it can be shown that the positive-circulation problems are equivalent to the corresponding

postman-tour problems, and the transformation of solutions between corresponding positive-circulation and

postman-tour problems can be done in time O(mn).

Since the approach is similar to that for the positive-flow and the covering-paths problems, we omit

the details. We summarize:

Theorem

7.1.

The

positive-circulation

and

the

postman-tour

problems

C (1 j )

and

PT

(j 1

)

can

be

solved

in

time

O(mn), j

=

1,

2.

The positive-circulation and the postman-tour problems C(i j)

and

PT

( i

j

)

,

i

=

2,

3, can be

solved in time O(m(m + n log n)) if j = 1, and in time O(n(m + n log n) log(m/n)) if j = 2.

Problem PT3(2) is the classical Chinese-postman problem [Kwan, 1960]. Balancing was used to reduce the problem to a minimum-cost maximum-flow problem on a balancing graph [Gibbons, 1985], and
the previously best-known algorithm ran in time O(mn log n) [Gabow and Tarjan, 1987]. From Lemma 5.3 and Theorem 7.1, our algorithm runs in time O(n(m + nlogn) log(m/n), which is asymptotically faster.

- 13 -

8. General Path-Covering Problems

We have not yet discussed the most general covering-paths and postman-tour problems on directed

graphs with arbitrary capacity upper and lower bounds. In general, we have

Theorem 8.1. Problems CP(i0)

and

PT

(0) i

,

for

i

=

2,

3, are NP-complete.

Proof.

We

first

show

that

Problem

PT

(0) 3

is NP-complete.

A special case of this problem is one in which all

edges have an infinite capacity upper bound, some edges have a zero capacity lower bound, and some edges

have a unit capacity lower bound. This special case is the well-known NP-complete rural-postman prob-

lem [Lenstra and Kan, 1976].

Given Problem PT3(0) on a graph G with origin O, we augment the graph by adding the edges (s, O) and (O, t), giving them a cost of zero, and a capacity upper bound of infinity and a capacity lower bound of

zero. Then a minimum-cost (minimum-cardinality) set of covering paths on the augmented graph provides

a solution for Problem PT(30).

Thus Problem PT(30)

can be reduced to Problem

CP

(0) 2

or Problem CP3(0);

therefore, they too are NP-complete.

Given

Problem

CP

(0) 2

on

G,

we

add

an

edge

(t,

s)

with

a

cost

of

zero,

a

capacity

lower

bound

of

zero, and a capacity upper bound of infinity. The covering-paths problem now becomes a minimum-cost

least-repetitious postman-tour problem

PT

(0) 2

on the augmented graph with s as origin.

Therefore, Problem

PT2(0) is also NP-complete.

In practice, however, additional constraints may allow polynomial-time algorithms to be devised for

these problems. For example, if the subgraph consisting of edges with positive capacity lower bound is

connected, then the problem is equivalent to a minimum-flow problem, and the reduction can be done in

time O(mn).

9. Problems on Mixed Graphs

We now discuss briefly the corresponding problems on mixed graphs. A mixed graph has both

directed and undirected edges. The optimization problems considered in this paper can also be formulated

for mixed graphs, and we have:

Theorem

9.1.

For

mixed

graphs,

Problems

X

( i

j

)

,

are

NP-complete,

where

X

=

C,

F,

CP ,

PT ,

i

=

2,

3,

and j = 0, 1, 2.

Proof.

We

first

note

that

Problem

PT

(2) 3

can

be

reduced

to

Problems

CP3(2)

and

CP

(2) 2

and

that

Problem

CP(22)

can

be

reduced

to

Problem

PT

(2) 2

.

Since

Problem

PT

(2) 3

is NP-complete [Papadimitriou, 1976], all of

them are. The reduction is the same as that in the proof of Theorem 8.1, and we omit the details.

Since

Problems

F(i 2)

(C i( 2 ) )

and

CP

( i

2)

(PT

(2) i

)

are

equivalent,

they

are

special

cases

of

Problems

X i( 1 ) ,

which in turn are special cases of Problems Xi(0), respectively, for X = F, C, P, p, i = 2, 3. The theorem

follows.

10. Conclusions

We started by considering basic questions arising in program and circuit testing. We showed that these questions are instances of several natural classes of network-optimization problems, and we derived a general technique for solving these problems. Our work provides a unifying framework for these optimization problems. A few of the problems have been studied in isolation, such as the testing and Chinesepostman problems, but our methods yield the fastest-known solutions even for these problems.

The results are summarized in the following three tables.

The

symbols

C

( i

j)

,

F

( i

j

)

,

CP(i j),

and

PTi( j)

refer to the four main classes of problems: circulation, flow, covering paths, and postman tours. The sub-

script, i = 1, 2, 3, distinguishes the three forms of each problem: minimizing the cardinality, minimizing

the cost and cardinality, and minimizing only the cost. The superscript, j = 0, 1, 2, classifies the capacity

bounds on the edges: 0 for arbitrary lower and upper bounds, 1 for a unit lower bound and an arbitrary

upper bound, and 2 for a unit lower bound and an infinite upper bound. In the tables, m is the number of

edges, n the number of nodes, and L =  l(e) where l(e) is the capacity lower bound on edge e. eE

- 14 -
____________________________________________________________________________________________ __P__R_O_B_L_E_M_________C_O_S_T_________P_R_O_B_L_E_M______C_O__S_T __CCC__1(1(1(210_)))_,,,_FFF__1(11((102_)))_______m_n_mm_lonn_g_n______CCC__PPP_((111(_120)))_,,,__PPP_TTT_(11(1(_012)))_____mm_?_nn_
Table 1. Minimum-cardinality problems.
__ ________________________________________________________________________________________________________________________________________________________________________ _P_R_O_B_L_E_M____________________C_O_S_T__________________ __P__R_O_B_L_E_M_______________C_O_S_T__________ _CCC_2(2((2210_)))_,,,_FFF__(2(22( 210_)))____m_i_n__{_( nm__( +m__n_+lo_mg_n_n( _ml)o_Lg+_,_nnm_l)_o(_gmlo_ng_+)_n(_ml_o_/gn_n_))_l_o_g_L_}___ _CCC_PPP__(2(2(2210_)))_,,,_PPP_TTT__(22(2( 210_)))____n_(_m__+_m_Nn_(P_ml-_oc_g+o_mnn_lp_)ol_gel_otne_g)__( m__/_n_)
Table 2. Minimum-cost minimum-cardinality problems.
__ ________________________________________________________________________________________________________________________________________________________________________ _P_R_O_B_L_E_M____________________C_O_S_T__________________ __P__R_O_B_L_E_M_______________C_O_S_T__________ _CCC_(33(3( 210_)))_,,,_FFF__(3(33( 210_)))____m_i_n__{_( nm__( +m__n_+lo_mg_n_n( _ml)o_Lg+_,_nnm_l)_o(_gmlo_ng_+)_n(_ml_o_/gn_n_))_l_o_g_L_}___ _CCC_PPP__3(3((3210_)))_,,,_PPP_TTT__(33((3210_)))____n_(_m__+_m_Nn_(P_ml-_oc_g+o_mnn_lp_)ol_gel_otne_g)__( m__/_n_)
Table 3. Minimum-cost problems.
Acknowledgment We are indebted to Mihalis Yannakakis for many valuable comments and stimulating discussions.
References
Aho, A. V., Hopcroft, J. E., and Ullman, J. D. [1974]. The Design and Analysis of Computer Algorithms, Addison-Wesley, Reading, Mass.
Edmonds, J., and Johnson, E. L. [1973]. Matching, Euler tours and the Chinese Postman, Mathematical Programming 5, 88-124.
Edmonds, J., and Karp, R. M. [1972]. Theoretical improvements in algorithmic efficiency for network flow problems, J. ACM 19, 2, 248-264.
Even, S. [1979]. Graph Algorithms, Computer Science Press. Ford, L. R. Jr and Fulkerson, D. R. [1962]. Flows in Networks, Princeton Univ. Press. Princeton, NJ. Fredman, M. L, and Tarjan, R. E. [1984]. Fibonacci heaps and their uses in improved network optimization
algorithms, Proc. 25th Annual Symp. on Found. of Comp. Sci., pp. 338-346. Gabow, H. N., Maheshwari, S. N., and Osterweil, L. J. [1976]. On two problems in the generation of pro-
gram test paths, IEEE Trans. Software Engineering SE-2, 227-231. Gabow, H. N. and Tarjan, R. E. [1987]. Faster scaling algorithms for network problems, Unpublished
manuscript. Galil, Z. and Tardos, E. [1986]. An O(n 2 log n (m + n log n)) min-cost flow algorithm, Proc. 27th
IEEE Symp. of Foundations of Computer Science, 1-9. Gibbons, A. [1985]. Algorithmic Graph Theory, Cambridge University Press, Cambridge. Knuth, D. E. [1984]. A torture test for TEX. Stanford University, CS Technical Report.

- 15 -
Krause, K. A., Smith, R. W., and Goodwin, M. A. [1973]. Optimal software test planning through automated network analysis, Proc. 1973 IEEE Symposium on Computer Software Reliability, pp. 1822.
Kwan, M. (Guan, Meigu) [1960]. Graphic programming using odd or even points, Chinese Math. 1, 273277.
Lawler, E. [1976]. Combinatorial Optimization: Networks and Matroids, Holt, Rinehart and Winston. Lenstra, J. K. and Rinnooy Kan, A. H. G. [1976]. On general routing problems, Networks 6, 273-280. Ntafos, S. C. and Hakimi, S. L. [1979]. On path cover problems in digraphs and applications to program-
ming testing, IEEE Trans. on Software Engineering SE-5:5, 520-529. Papadimitriou, C. H. [1976]. On the complexity of edge traversing, J. ACM 23:3, 544-554. Seth, S. C., and Agrawal, V. D. [1985]. Cutting chip testing costs, IEEE Spectrum 22, 38-45. Tardos, E. [1985]. A strongly polynomial minimum cost circulation algorithm, Combinatorica 5:3, 247-
255. Tarjan, R. E. [1983]. Data Structures and Network Algorithms, Society for Industrial and Applied Mathe-
matics, Philadelphia, PA. Uyar, M. U, and Dahbura, A. T. [1986]. Optimal test sequence generation for protocols: the Chinese post-
man algorithm applied to Q.931, Proc. IEEE Global Telecommunications Conference, 1986.

