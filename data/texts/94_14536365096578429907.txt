The University of Warwick
THTCRY OF COMPUTATON
REPORT
No. I
DECISlON PROCEDURES FOR FAMILIES OF DETERMINI STIC PUSHDO|'IN AUTOMATA
.} LESLIE G. VALIANT

Department of Computer Science University of Warwick
COVENTRY CV4 7AL
ENGLAN D.

August 1973

DECISION PROCEDI'RES FOR FA},TILIES OF DETERMINISTIC PUSHDOIIN AUTOI'{ATA
Leslie G. Valiant
Department of Computer Science, Itniversity of l.Ian"rick,
Coventryl England.
A dissertation submitted for the degree of Doctor of Philosophy. July 1973.

PREFACE
I ehould like to thank my superviaor, Michael Patergon for hie continued intereat and encouragement and for the numerous discuseions nith hirn that provided the etinulation for this research. The contente of Chapter 5 is the reeult of work done jointly with hin.
I am aleo grateful to Albert Meyer for bringing the regularity problen to uy attentionr to the Science Research Council for financial support, and to Jill Pladdys and Roeeuary llent for typing this theeie.

ABSTRACT
The existence and corrpLexity of decision procedures for fanilies of deterministic pushdown automata are investigated, with special eurphasis on positive decidability results for those questions, such as equivalence, which are known to become undecidable when the deterninistic restriction is removed.
The equivalence problem is proved decidable for the following three determini.stic families, all of which are already extensive enough to have undecidable inclusion problems:
(a) nonsingular automata - a realtirne subfamily, which extends the largest corresponding classes with previously known equival-ence tests,
(b) finite-turn aut,omata - characterised by having a bound on the nrmrber of times the direction of the stack rnovement can
change, and
(c) one-counter automata - defined by restricting the stack aLphabet to just one symbol.
tlhe prubLem of whether a )-anguage defined by a rnachine in one fani.ly1 can be recognised by one in another, is a convenienE formulation of numerous decidabLe or potentially decidable queseions, l,Ie ehow that such questions as whether a detennisusc:Le conte:rt-free language can be recognised by a noachine in any one of the above named classes, muet be, if decidable at all, at least as difficult to decide as wheeher such a l-anguage is regular. We re-exasnine the regularity test of Stearns, and obtain an improved algorithm. We

do this by reducing by an exponential order the upper bound on the possibLe state conplexity of regular sets recognised by deterministic pushdoltn aut.omata of a given size, to a level close to one knovn to be achievable.
I{e pursue an application of this analysis to a schema theoretic problem. We coneider the succinctness with which certain functional schemas can be used to e)rpress equivalent large fLowchart schemas, and obtain closely matching upper and lower bounds for a measure of this.

CONTENTS
Abstract Introduction
I Prelininaries Chapter 1 : DEFINITIONS 1.1 Determinis tic Pushdown Autonat'a
T,2 Elementary ProPerties 1.3 Subf aniLi.es 1.4 Some Famil.y ProPerties 1.5 Derivations 1.5 complexity Measures
L.7 Tradeoffs in DescriPtion
1.8 Famil-y RelationshiPs
Chapter 2 : EASILY DECIDABLE PROBLEMS 2,L Introduction 2,2 Emptiness 2.3 Finiteness 2.4 A NotmaL Form 2.5 Totality
II The EquivaLence ProbLeg chapter 3 : A REALTIME FAMILY 3.1. Introduction 3,2 Nonsingutar Automata 3.3 Al"ternate Stacking 3.4 Main Results 3.5 UndecidabilitY of Inclueion 3.6 A Ccnjeeture about Rg C:hepter 4 : FINITE-TURNAIJT0UATA 4.1 lntroduction 4.2 Definitions 4.3 Proof Strategy 4.4 ParalLel Stacking 4.5 Existence of Verifying Machine 4,6 The Decision Procedure Chapter 5 : ONE COUNTER AIEOI'{AIA 5.1 Introducrion 5.2 PrelioinarY Results 5,3 ProprietY 5.4 Decision Procedure

9 L2
t5
15 18 2L 23 27
29 30 33 34 37
39
42 44 46 47 54 57
59 60 63 64 67 72
75 77 82 87

III Containment Probleme Chapter 6 : RELATIVE COMPLEXITY 6. l- Introduction 6,2 Results 6.3 Conments Chapter 7 : TIIE REGULARITY PROBLEM 7,L Introduction 7.2 NuLl--transparency and {,-invisibiLity 7,3 Main Theorem 7.4 Bounds for SubfamiLies 7.5 Time Complexity
IV Asl Appli"catlon to Schenas Chapter 6 e MONADIC FUNCTIONAI SCHEMAS 8. 1 Introdr.rction 8,2 Evatuating Pushdown Automata 8.3 r!B-S.Autonata 8.4 Bounds on Succinctness
Conclusion References

90
93 94 101
104 105 111 1L5 119
L2L
t23 t25
L27 L29 L34 136

i.
INTRODUCTION
To understand the meaning of an executable computer program rre have to relate its finite specification to its possibly infinite distinct behaviours when applied to different inputs. Finding general ways of doing this is a prirnary goal. in the theoretical study of computaLions. The specific aims of such investigations are to gain insight into the computational behaviour of whole classes of prograns, and hence to be abl-e to analyse instances of various particular problems for any program within these classes. The recursive decidabiLity of the problems concerned is an important criterion of the practical viability of such analysis: the existence of an effective decision procedure capable of determining the truth of any instance of a particuLar question for a given cLass of prograns, uleans not only that this analysis can be automated, but usually atso that an a priori bound can be pLaced on its difficulty. In contrast, if the problenr is undecidable for the class, that is, there is no effective pr'rcedure for soLving it in general, then new instances of it can always be found for which the solution is more difficult than before and requires further creative effsrt"
The courpuLaurons we shaLl" study are those that can be carried out by abstract deter,"ntinisti.e autocnieta rhat have onLy a pr:shdown stack and a fini.te*state control for storage. This is a formalisation of the stack coniellt lrhi-cbE i.s wi.dei"y used in practical progrannning, for exampLe i.n wricing syntax anaJ-ysers, or in implementing reeursion in compi.Lers. Consequently our resuLts will relate to sreas outside autoloata ttreory, such as the syntax of programring nanguages, and cert.ai.n f,crmal" wdels of recursive programs.

2
The observation primaritr"y rnr:ti."uating r:ur worit i-s tlrat, whil-e these f,amiiies of autcmata are wide enough to be reievant t.o practical computations, rnany of the important questions atrout their behaviour can be shown to be dacid.abl.e. 'Ihis is a very rare conjunction of, attrributes for comprrtational rnodels so far sttrclied. It is generally found that for abstract models designed to describe useful classes of programs e nearly all the key properties can be shown to be undecidable. For exarnple, if rse extend any of the families we strall consider by introducing nondetern:inism, or bv a1 lowing a second staek, then rve already lase the deci.dability
properties we desire most.
The actual nnachines we investigate are deterrninistic pushdown automata (dpda), which have been widely studied beforei'2'3, anci cerLain restricticns cf them. These are all accePtors in the sense lhat the input consists of a sequence of symbols on a Eape, and Lhe output of ei.ther a tyest or a tnc,t depending on Lhe configurations of the machine afrer the input tape has been scanned. Thus each naehine defines a set of strings of syrnbols, or a language, namely that consisting of exactly the sErings that are accepted, i.e. lead ro a ryes?. These l.anguages are all context-free, 'and have the additional useful prcperty that they can all be parsed easily in linear cime.
We note that this input-outpur behaviour is not qrrite as restrictive as i"t would appear. Problems t0 do with related but superficially more general rnachines (e.g. transducers which output a syurbol for each symhol read ) can often be reduced to correspcnding
questions about acceptors and languages.

3
The decision problem with which rre are most concerned for these families of automata is that of equivalence, i.e. is there an effective test co determine whether two rnachines perform equivalent computations? The existence of such a test has the practicaL significance that it provides a most convenient model-independent mechanism for verifying correctness. Thus if we have an automaton which is optinised in some rray, and therefore perhaps complicated, and we want to prove that it will perform exactl-y as it is intended, then we could build a second automaton which is nore perspicuous in structure but possibly othervise unsuitable, and test the Ewo for equi.vatence. Other criteria of correctness would, in contrast, necessitate that a new distinct language for describing the intended computation be introduced and related to the automata formal-ism.
The inclusion problem (i.e. to decide whether one language is a subset of another ) is related to the equivaLence problem in that any procedure for deciding the former would lead directly to one for the Latter. Thus, as distinct from the existing analysis of such classes as the regular sets3, bounded Languages4, and parenthesis languages5, for all of which both inclusion and equivaLence are decidabi.e, positive sol-utions to the equivalence problem for families with an undecidable inclusion problem assume new significance.
Our main results for the equival-enee problem are to show for three distinct families of automata that they are in just this category. The onLy comparable family we know of is that of Ewo-tape acceptors6rT. For rhe class of LL(k) languages8 (which include the sirnpleg languages), atthough equivalence has been shown to be decidable, the inclusion problem is currently open. We will show that both Ewo-tape acceptors and LL(k) languages correspond closely

t+
to particular restrictions of two of our farnilies, and hence that the decidability of the equivalence problem for botl'r of them now also follows as corollaries to our results.
In addition to proving dec_idability results we are also concerned with giving bounds for the complexity of the derived decision procedures. A bound on the time complexity of a problem (i.e. on the time required by the best possible decision procedure in the worst case ) gives an indication not only of how much time may be needed for an automatic anaLysis, but also ofthe possible difficulty in an informal senserof resolving parricular instances of it. The complexiries are expressed in terms of functions r,rhich have the paraineters of the machine description as arguments. Thus if we have a polynomial ti-roe bound sn a decision procedure for one problern, but know that an exponential time is necessary for deciding another, then this will indicate that for: sufficiently large machines,it will be easier to solve a problem of the first kind than one for the
second.
Valid measures of absolut.e ccmplexity for decision procedures are numerous, and may depend additir:nally on the nachine model on which one int,ends to execute them. For this reason we are usuai-ly eontent with answers speeifying cnly the nurnber of levels of exponentiationn if any, involve-d. ?hus tvpicaliy l,Ie may say that a procedure takes polynomial, or perhaps exponential time, without giving further detaj-l-s. This kind of ciassification is known to be robust enough not to depend on which one of the customary machine modeLs is chosen.lo
More satisfying results, which are now totally machine

5
independent, can be given, however, for the relative complexities of the various decision probLems. Thus we show that, in a specified sense, certain decision problerns sust be equally difficult, and that some others must be at least as difficult as these. Such results, besides confirming our experience with known decision procedures, also throw light on several specific currently open problems, which we show to be at least as difficul-t to decide as a qLrestion for which the best procedure ure have been able to find works in double
exponentiaL time.
Although the decidability and complexity results themselves yield considerable information, the techniques used in the proofs and the properties on which they depend are equally important in givi.ng insight into the structure of trese computations. Our presentation will therefore attempt to highlight informally the ideas we believe are new and nost important. We shall omit details of arguments whi.ch are well. known and occur elsewhere in the literature. ,W?rere for the sake of compleEeness, we mention resuLts not directly related to our main theme, Ire shal-l, just sketch the main ideas from which a proof can be reconstructed.
We suggest the fotr-lowing as appropriate both for preLiminary reading and for providing rrctivation to our work from diverse angles: A general exposition of the concepts of automata and decidability is given in Hopcroft and U11rnan3. Basic resul-ts about dpda are also to he found there, as weLl as in Ginsburg and Greibachl. Various grrrnrnatical eharacterisations of fanilies of deterministic languages and their relevance to parsing are described by Knuthl1, Korenjak and llopcroftg, Rosenkrantz and SteamsS, and Harrison and llarell 2. An introduction to progran schemas, and a description of the relation-

6
ship bemeen certain recursive schemas and pushdown automata can be found in Patersonl3.

7
PRELIMINARIES
This first section introduces the definitions, basic notions, and prel-iminary results which we shall use in subsequent chapters. Fron the start we take a rDre complexity conscious approach to the subjact than is available elsewhere in the literature. Consequently the preLininary ideas we have to introduce, although rnostly well known, have had to be reformulated so as to give the rnore precise constructions which we now require. In particular we have to bypass those of the widely used standard constructions that lead to
exponential explos i.orrs .
We first define the class of deterministic pushdown automata. Our criterion of acceptance differs from the most popuLar one3, but is the nore natural for our purposes. The definition is very broad in the sense that for any dpda specified in one of the other standard ways, there is al-ways an equivalent one in our formuLation that is not much nore complex. Further, by placing sinrple restrictions on this class, Iile can also define several important subclasses which we sha11 later study.
The size or compLexity of a dpda we describe by means of several of the parameters of its description, which \ile go on to specify. I.Ie then investigate the tradeof fs that can be realised when a machine is transf,ormed to another equivalent one in order to economise on one of these parameters at the expense of the others.
In the second chapter we give results about the complexity of problens atready known to be decidable. I{e justify the clain that

B
these problens are 'easy'by verifying that sinple decision procedures exist for solving them, which work in tirne depending only polynornially on the paraneters of the tested machines. In the course of this ne define a normal form for dpda, and il-l-ustrate its use by deriving some of the decidability results as trivial consequences of its existence.
Throughout we judge the relative pohrer of the various subfanilies of nachines by comparing the classes of languages to which they correspond. For sirnpLicity, therefore, when this is not otherwise confusing, we often identify a family of machines with the cLass of languages it defines.

Ctrapter 1 DETINITIONS
1.1 Deterministic Pushdown Autonata
A pushdown automaton (pda) is an abstract device whose menory consists of a pushdom stack and a finite state control. It can read a string of characters from a finite aLphabet from its unique input tape, which can progress past the input head of the machine in only one direction, and only once. At any step of the computation the transitions which the machine can undergo are determined by the state of the finite state control, the contents of the top of the stack, and the character under the input head. An input word is either ttaceept,ed" or "rejected", d.epending on the "confi.gurations" the rnachine can reach after having read its l-ast character. Each such automaton defines a Language i.e. the set of words it accepts. The languages which are defined by the class of pushdown automata are exactly the context-free languages of Chomskyl4'3.
We are here interested in the deterministic restriction of this cl"ass, namely the case where each coribination of state, top stack symbol, and input character defines a unique machine transition. The cLass of such deterministic pushdown automata (dpda) we caLl D.
More forma11"n for a machine M e D, let I be its finite input al"phabet {a, b, c, ...}, f its finite stack_4-p@. {A, B, ...} and Q its finite state set {s1, szr...}. We denote strings of input characters by o, B, etc., and strings of stack symbols by (,)I t rrr2 etc. We define e and A to be the null elements of I* and l*

10
resPectively. In addition we use the special symbol $? to denote an
eropty staek.

A configuration c = (s, o) is an eLement of Q x ({n} v I+) and describes the state and stack content (starting from the enpty stack end) of the machine at some instant. The mode of a configuration c is an element frour Qx ({A}uf) and describes the state and top stack symbol of c. Thus the mode of (s, oA) is (s, A), and that of (s, 0) is (s, 0). The machine has a set F . Q* ({CI} vr) of distinguished
accepting modes.

The set of transition rules A is a set of rules of the form
(s, A) -l* (st, ,r)
where r e x u {e}, with the additional restriction that each mode is
ei ther (i) an e-mode i.e. occurs on tteleft in just one rule, and t.here with an j* t.urr"ition.
or (i i) a reading upde i.e. has at most one a rule for each a e f,, and no i+ rule.

The machine M makes the move (s, oA) 1I (st, ,rt) frorn the
-+
one configuration to the other if and only if one of the rules is (s, A) i* (s', ,t)rwhere n e X u {e}. If n e I then n, the input character currently under the input head on the tape, is eonsidered
to have been read, and the head rpves to the next position on the tape.
Otherwise the head does not nove.

A derivation c -+ ct is " sequence of moves starting from

configuration

c

and

ending

with

t.
c

rt

is an a-derivation,

*5 "

"t,

11
if the execution of it is accompanied by the reading of the word s on Ehe input tape.

There is a distinguished starting configuration c", which for simplicity we assume t,o belong to Qx (in) u r). we say that a configuration ct i" rea"hable from c iff there is some derivation c cr . I^Ihen we say that cl is reachable we mean that it is
->
reachable from c".

An input string cr is accepted by M iff

S "s

c for some c

whose mde bel-ongs to F, and rejected iff it is not accepted. Tr,ro

configurations c, c' are distinguished by o if a-derivations can

take one to an accepting mode but not the other. The rank of two

configurations c and ct (denoted by rank (", "t)r) is defined as the Length of a shortest string distinguishing the two, if one exists,

and - othervise. Two configurations are said to be equivalent,

i.e. c f cf, iff rank (c, ct) = -. Two nachines M, Mt are equivalgnt

iff their starting configurations are equivalent.

I,Ie denote the set of strings which can take the machine from a
configuration c to accepting rmdes, by L(c). Then clearly c = c' Ltt L(c) = i,(c'). For a machine M we denote L(cs) by L(M), and for a class X of such machines , we wi.1l abbreviate {L (M) | U . X} to L(x).

' Thus, to summarise, each dpda (as well as the language it defines) is completely specified by a sextuple M(I, l, Q, F, A, cs). The foll-owing iLlustrates the main points:

ExampLe 1.1

t2

For machine M let I = {a, b, c}, f = {Ao, A, B}, Q = {s1, s2, s3}, F = Q x {o}, cs = (sr, Ao) and A the set of transitions:

(sr, Ao) j* ("r, A) (s r, A) b, ("r, B)

(sr, A) *9* (sl, AA) (sr, B) b , ("r, BB)

(sr, B) -3* 1s2, n) (sz, B) 3> (s2, A) (sz, A) 3* 1s2, n)

(sr, B) 5 (s3, A) (s e, B) j+ r1s 3 A) ("s, A) 5 (s3r A)

Then it can be easily verified that

L(M) = {anbman lr, r:il u {anbmcn lr, * ril.

For our notation we follow standard conventions for sets. For a string x we denote the reversal of x by xR, the length of x by l"l, and the concatenation of n copies of x by xn. Fot Z a set of strings, z* and Z+ rLLL denote its transitive closure under concatenation, with and without the nuLL string respectively, and I will- denote the empty set. The syrnbol $ wilL always stand for an input character which, by convention, does not belong to the I being discussed.

L.2 Elementary Properties
We first note that the trDre customary definition of acceptance is by states rather than rnodeslt3. IE can be however easily verified (Hopcroft and ULl-nan3, Lettuna I2.3) that the classes of languages defined by the two methods are identical. Further, as we shall now

f
rl

13
indicate, all the key properties on which theorems particular to dpda depend, are a consequence of determinism, and are independent of the manner of acceptanee chosen.

One effect of the deterministic restriction is to ensure that once a sequence of e-moves has started, the subsequent eomput.ation is uniquely determined by the original configuration, and can depend on the input tape again only when the E-sequence has Eerminated. Thus if, the latter never terminates, then it is cl-ear1y redundant and can be eliminated. If it is finite and gives rise to the derivation (s, urA) ", ("t, ootB; where (rt, B) is a reading mcde, then such e-derivations can be eliminated by replacing the e-rule for (s, A) by rules of the form (s, A) -3t (stt, r,rtrtt) for each rule ("t, B) -g* (s", ,"). Thus we conclude that e-moves can only be essential i"n a dpda for derivations which cause the stack to decrease in height"

Similarly, but for other reasons, having a multiplicity of states cannot be essential in derivations where the stack is increasing. State information can always be coded into the top stack symbol and thus transrnitted indefinitely, as long as no top symbol is ever rernoved. Thus in Example f.i-, while the distinctness of scates s2 and s3 is essential, the information which sl carries' i.e. that the stack is in che increasing phaseo coutd be coded into the stack symbols. We could therefore nndify M to obtain another equivalent one with state set just {s2, s3}, but with an enlarged stack alphabet {A0, A, A', B, Bt}, if we replaced cs by (s2, A6), and replaced the transition rules involving st by the following:

(s2, A9) a ("2, At) ->

("2, A') -g+ (s2, AAt)

("2, A') 4 ("r, n')
(r2, B') -3+ (sz, A)

L4
(sz, n'; A q"r, BB')
(s2, B') -9> (ss, A)

Another consequence of determinism that is useful for showing that certain languages cannot be recognised by any machine in a given class, is the following observation, of which a formal version is stated and proved by Ginsburg and Greibachl:

Observation f.i
The effect of input strings periodic in a given word a (i.e. of the form on for n > 1) on a dpda is
either (a) to cause the stack to never grow larger than some
eonstant hei.ght,
or (b) to creete etacks which are periodic. in some stack word e..'erywhere except for parts of bounded length at the top
and bottom.
Using this we can formaLly verify that e-moves, multiple states, and a mriltiple stack alphabet, are all essential- features of any dpda reeognisi.ng the J.anguage of Example 1.L. Formal- arguments of this ktnri are given by Ginsburg and Greibachl, and by Harrison and Havell2. We note that the normai- form given by Greibach for context-free languages shows tha.t in the nondeterrninistic case, e-moves and multi.ple state sets are inessential"iS.

1.3 Subfamilies

15

We can define some important subfamiLies of D by specifying sinple syntactic restrictions on the machine descriptions:

One-counter machines (C) are those dpda with just one stack symbol. In these the stacks can only be used to count, and hence a configuration is best described as (s, n) where s E Q, n : o. Such counters are closely related to the registers of Minskyl6.

ReaLtime machines (R) are those with
recognise strings in rea1 time, as opposed

e-modes. They
merely linear time"

Stateless machines (S) are those with just one state. This state can therefore be omitted from the description of the configurations or transition rules. A consequence of the restriction is that no information can be transmitted during stack decreasing
derivations.

Thar the languages defined by each of these three classes is properly contained in L(D) follows from the previously urade observation that the l-anguage defined in Example 1.1 cannot be recognised by any machine in C, R or S.

For alL such classes we can have the additional restrictions
that
(a)FcQx{CI} or that (b) no rule is defined for modes in Q x {521.

For the classes D, C, R and Srwe respectively define the sub-

16
elasses Dg, C0, R6 and So by imposing both restrictions (a) and (b), and D1, Ct, R1 and St by imposing just the first of these. That each of the implied containnents is proper can be easily verified by observing that if X is any one of D, C, R or S then I* eL(X1) but t"* t L(Xo), and {anbn | *: n} e L(X) but I L(Xr). Alrhough X1 rhus properly extends Xg, it does not use the stack in any more general wa5 and consequently many of its properties can be deduced directly from those of the corresponding X6. For simplicity, therefore, we shall only study the classes X and X6.
We note that classes equivalent to D6 and R9 have been studied by Harrison and Harzef 2 lwho caLl them strict, and realtime strict deterministic respectively), and the class So by Korenjak and Hopcroftg. To show that Sg is just the rsimpler machines of the latter, we have to demonstrate that e-noves are redundant in it. This is obvious since stack symbols with the property that A 5 n can clearly be elj,minated from the rules, while e-moves which cause increases in stack height can be removed in the manner indicated in 51.2.
L.4 Some F_amil"y Pfoperties
There are some further restrictions on families of machines and languages that are related to the definitions above.
A language L c I* is said to have the prefix property iff F c X+ and a e L *uB I L" ?rom the definition of D6, C0, R6 and 56 it is immediate that these all have this property. For L(Do) we can

17
sayr further, that it contains all the languages of L(D) that have this property. For consider an M e D s.t. L(M) has the prefix proBerty, and nodify it to an equivalent Mr e Dg as follows: rntroduce "a special 0-simulating symbol at the bottom of the stack to ensure that no accepting derivation has an intermediate empty stack configuration. Then for each accepting npde of M introduce an e-move to a new state frnm which any stack wiLl be emptied by further -moves.
The modified machine clearLy has the required propertiesl2.
The quasirealtimel2- property is a relaxation of the realtime restriction. E-moves are now allowed to occur, but only a bounded nurnber of tirnes consecutively. rf this bound is say n, then only up to n stack characters can be removed in a single e-derivation. Thus, by changing the sta.ck alphabet so that each stack is now specified by symbols encoding bLocks of n + I old symbols (with a block of possibly fewer synbols at the top of the stack), and changing the transition rules so that these blocks are manipulated correctly, the old machine carr be simulated by a neh/ one with the same states, but with no e-nodes. A npre formal proof of a similar statement is given by Harrison and Havel12. Thus we can conclude the forlowing:
Observation 1"2
The power of the quasirealtime machines is no larger than that
of R.
Finall"y we mention a syntactic restriction on the transition rui.es. A dpda is conservative iff in any ru1-e (s , A) -+ (s t , to) it.nlt-ere luJl I Ir 1t is the case that the f irst syrnbol of o is A.

18
Lemna 1.3 will show directly that this is not a proper restriction on the power of D, C or of the quasirealtime machines. However S and S9 are properly restricted to the symnetric l-anguages, Sy and Syo respectively. An innnediate property of these symrnetric machines is that they cannot transmit information even while the stack is increasing. Thus the language {an$an | " : 1} cannot be recognised by such a machine since the latter could not distinguish between being in the upward phase from being in the downward phase of the computation. Consequently Ey6 g Sg and Sy g S.
1.5 Derivations
We now introduce some terminology and notation for describing the geornetrieal rbvements of the stack, that are in addition useful concepts in talking about derivations.
The height lcl of a configuration c is the length of its stack i.e. l"l = lrl if c = (s,,,r) for some s.
The derivation " 3, "' is a stacking derivation iff l"l . l"'l and every intermediate configuration in the derivation has height greater than l"l. It is then written as c +(o) ct. The derivation is a popping derivqtion iff l"l t l*'l and every intermediate configuration in the derivation has height greater than lc'1. It is then written as c +(o) "t. (N.8. The notation t, * is used by Stearnd but with the converse rneanings.) It is a positive derivation, written as c f "t, iff no internediate eonfiguration has
empty stack.

1Y
We define the slggElqg sequjlnge r:f a stacking derivation as a
sequence of nndes ui, Each ug is the nnode of the unique configuration of height (i + 1) in the derivation that is not followed by any configuration of height < (i + f) subsecruently in the derivation. Note that if (s, ur) +(o) (s', ,') then ui is not defined unless lrl 5i+f S lr'1, and may not be defined for atl intermediate values (e.g. if the derivation consists of a single move corresponding to a transition rul-e of the form (s, A) * (s', o1) where lrt | > 2.1 The significance of pi for the configuration corresponding to itn is that it contains all the information about the previous computation that may influence the subsequent part of the derivation.
lJe def ine analogously the popping _sequeEe for a popping derivation to be a sequence of ,st.gte,s oi. Each oi is the state of the unique configuration of height i in the derivation that is not preceded by any configuration with height < i.
For trr e I'* , j " i: o we define oirj to be the substring of o s tar ting fron the (i + f)th character and ending with the jth. An index seE N is an ordered subset of the positive integers. Thus anv N induces a natural- segmentation of o into words oirj, where i < j and i, j eN.
The stacking and popping sequences w.r.t. index set I (Fig" 1) are just the subsequences of these corresponding to the elements of N. We def ine ttre segmenf"_ation of u in the stacking derivation c +(a) "t qr11rt, an index set N = {ii, ... ir}, as the unique sequence of input words o\ , ! ,... , cin_', i' with the properties that therc exist qip, iI, oin, in+l whm ig +1 = l. | , inal+1= I "' | , s. E.

Trace of c t(g) "t

20

i3
- l--zo

Trace of c *(cl) "t

lE-
I
I
I I I
*{ I
I
I 1oI
L

-

.. ct. ". .14 t13
rig. L

d - oiori10i1ri2

27.
oinrin+1'

and that if cf has stack o, ther: for the stacking sequence

{(sr, Ar)} w.r.t. {io,

inal},

(sr, Aa) +(airrir+i) (sr+i, rrrirrir*rAr+r)

f,or 1 : r : n. In other words cirrir+I is just that part of the input stri.ng which takes the derivation from the last configuration of height ir+L to the last one of height iral+l" provided that neither
is fol lowed by c'enfigurations srnal"ler than themselves. We can similarly define ui,3 for i < j and i, j e N.

Analogously the segmentation of a popping deqivation w.r-jJ:- N can also be defined. oi,j is then the part of the input string that takes the derivatiorr from Lhe first configuration r:f height in to the firse configrrratiori of height j. r+here now i > -j"

1.6 Complexity MeasursE
We shall describe the size of a dpda in terms of the following
paralneterg !
t = size of stack alphabet q = siae tlf state set p = size af input alphabet h = Length of longest stack word occurring in the transition
rules
u = number of transition rules.

22
We shall express the complexity measures relating to these machines in terms of functions with these parameters as arguments e.g. X(t, g). We shall be primarily concerned with the asymptotic values, as the arguments become large, of positive valued functions monotonic in each parameter. We introduee the fol-Lowing notation to
describe such behaviour:

Definition

The function X(x1r..., xn) is of order En iff n is the largest integer such that

Tffi 1og(n+-I)x(y,.. .,
y-)- rog y

t)

,

o.

Then, for exampte, x2 , /*, *logx will be go, *y2/*2 and xl wil-l be El, etc. For convenience rre shall refer to an expression X, even if it is of several variables, as poLynornial if it is bounded above by some multinomial.

When we are interested in the leading exponent in an expression, we use the following more detailed notation;

Def ini tion
The function X(x1, ".. xm) is of order En(Y(x1, ... *n,)) iff 3 k, k' > 0 s.g.for all sufficiently large x1, tnr
Expn(kY) < X < Expn(k'Y).
[ner" rxp0(x) = x, Expr*l(*) = 2Expr(x) tor r: o, and simiLarly for Lo9, which we shall always take to the base 2.]

23
L,7 Tradeoffs in Desg:'iption
The dpda definition allows equivalent machines to have very dissimiLar specifications. For example any language recognised by a finite state auto{naton with n states can clearly be recognised by some dpda with q = n and t = 1, and also by some with Q = 1 and t = n. We investi-gate an aspect of this flexibil-ity of description by asking to what extent an arbitrary dpda can be modified to obtain an equivalent one, so es to econosiise on one of the Parameters at the possible expense of the others.
We define LD(n1, n2 I n3) as the class of languages specified by dpda with q j nI, t j nz and h 5 ns. Then the questions rre want to ask can be naturally phrased as inclusion probl-ems for these elasses. We note. howet'er, that only the f irst of the fcrllelwing
lemras depends on deterrninism.
Lema 1. I
LD(qo t, h) # tD(fl , tlz, n3) for an] n2, n3. Harrison and Havel"l2 show that the set
{a%karlbk il":t jn, 1<m} can he recognised by a dpda with n states, but not by one with fewer. I

Lernma 1.2

24

LD(q, t, h) c LD(q, th, 2) for t > 1.
Proof
We give a simple construction for converting an arbitrary dpda to an equivalent one which simulates it closely, but does not require long right hand sides in the rules, or extra e-moves. We leave the state set unchanged but enlarge the stack alphabet to consist of all strings in f+ of length less than h, each typically denoted by [as..C], in the following way:
Replace each rul-e (s, A) i* (st, 81 ... Bn), .where n e I u {el and n ,_ 2, by the set of ruLes
(s, [rl] > g (s ' , [rn1] [n2 Bn] ) ,
one for each o e I*, s.t. lrl < h - 1, and make the analogous replacenents for the rules with n < 2.
Then ctearly the new stack al-phabet will be of size t + t2 + .. . + gh-l " th, and if acceptance is defined in the obvious way, then the new nrachine riill be equivalent to the old one.
Note 1
The new stack syrnbols that are not redundant in the rnodified nachine are exactly those of the form [uA] where Bu-ror'appears in some rule of the old nachine for some B and ut. Consequently the Rew stack alphabet is essentially of size at nost thu, and so really depends only polynomially on the original machine description. Frorn

25
this it fol-lows that the number of transition ruLes, and hence all of the description, need only be increased poLynomially by this cons truc tion.
Note 2
The construction prGservcs the conscrvativc property. Thus even synurnetric languages have a normal forrn with h - 2.

Lema 1. 3

LD(q, t, h) . LD"on"(qth, r, 2) for t > 1 and LD(q, 1, h) - LD(qh, 1, 2).

Proof
At the expense of introducing ncn e-rpves and incraasing q we ean reduce h to 2 and make the machine consarvative.

The new state set consists of

Q u i[t, ,J | " . Q, o e r+, l.l < h]
Each transition rule (s, A) -I* (rt, Bt ... Brr), with n > 2, we repl-ace by the set:

(s, A) Jt 1["', Bz nrr] , rr) (["', Bi... Br,] , Bi-ilj* ([r', ri+l (["', Br,], Br-r) 5 ("', Bn-rrn)

B"] , Bi-rBi) for r < i < n

This construction merely ensures that instcad of a large stack word being added in one move, it is buiLt up in a succession of specially

created E-rnoves. I

26

Note
The non-redundant subset of the new state set depends only polynomially on the original- parameters and is bounded by uh. The rnachine description as a whole is again increased only polynorniai- ly.

lem+e-L.S.

lD (q, t, h) e LD(qt, 2, h.ftogtl ) .

Proof

We code each stack syrnbol into binary words of fixed length

r1
llogt

l.

For each old state of the machine, Ehe nerr one has to be

able to interpret the top coded word in the stack. To do this it

traces down, via e-moves, a path of a binary tree of depth ftogtl while popping this top word. Thus the new machine needs a tree with

about t nodes in its staEe diagram for each original state. Thus

the state set is now of size qt, and h has increased to tr.flogtl. il

I,le e,,:ncl"ude by reJ-ating the other parameters p and u to q, t and h. By the determinist{c condition on the transition rulesr u is clearly bounded above by qtp. On the other hand rhe input al-phabet mayr in theory, be arbitrari.ly Large. llowever, the number of characters whieh prardulee distinct behaviour from the automaton is bounded by the other parameters in the fr:l-lowing way: Each input character can occur in at nost qt rules, each of which has one of no rnore than qth+l different possible ri-ght hand sides. Thus the

27
machine can only distinguish up to (qth+t)et aifferent input characters, and if there are more, then at least some of them can be identified with each other without influencing the computations.
1.8 Family Relationships
lJe conclude by su'nnarizLng in fig. 2 the retative. polter of the classes of automata with which we shall be most concerned., We use the foLLowing relations for arbitrary classes X and Y:
(i) X t only if V M e Y, I M' e X s.t. L(M) = L(l'l') ->
(ii) X ---+ Y only if V M e Y, I M' e X s.t. L(M)$ = L(M') where $ is a disti.nguished syn$ol.
For the definitions of N0, T and dB - S, see chapters 3' 4 and 8 respectively. Al-1 the relationships in the diagram ae irnnediate from the definitions or well known, with the exception of the position of N9, which we prove in Chapter 3, that of 2-tape acceptors, explained in Chapter 6, and that of S, for which we mit
the proof.

Family Relatiernships

28

t finite-turn

D
dpda r I
realat i

Do
a f,l-accerP
I
I
I
B-S \tI t
I

c;
one-c0unter

I
,I
I
I I
I
'0
s
t state ess

(two-tape acceptors)

ce
r

Fsa ./
a
finite-state automata

.- t simple

Fig.2

Chapter 2

29
EASILY DECIDABLE PROBLEMS

2.L Introduc-t,ion.
Here we shal1 discuss some properties of deterministic languages which have been previousry known to be decidable. we give decision procedures for these, and show them to be easier than the procedures f,or equivaLence and regularity that we derive i.n later chapters, in the sense that they all require only polynomial time.
These "easily decidable" problems for t e L(D) include
(i) menbership - does a e L? (ii) eurptiness - is there sor o s.t. o e L? (iii) finiteness - is L finite or infinite? (iv) totality - is there some o s.r. a l. t? (v) equivalence with reguLar set Lt - is L = Lt? (vi) has L the prefix property?
The first three of rhese are decidable for context-free Langrrages in general. but the last three rely on the determinist.!"c restric.tion. Techniques for proving such decidability results are given by Bar-Hillel, Perl"es and ShanirlT and by Ginsburg and Greibaahl. I{ere we shalx concentrate on the complexi.ty of just some of thern.
we know of rro arguments giving interesting lower bounds for the time complexity of any of these decision probrems, and, for this

30
reason, we sha1l not linger to give exact uPper bounds either. Ilowever, for each problem there is often an alrernative natural measure of complexity. For some of these we can give upper and lower bounds which differ by only a modest arnount. Examples of such particular measures of complexity include, for the emptiness problem, the maximum length of shortest strings accepted by non-empty machines of a given size, and, for the reguLarity problem, the maximum size of the smallest finite-state automata equivalent to some dpda of a
given size.
2.2 Emptiness
We shaLL consider from two viewpoints the complexity of this problem, which plays a crucial rol-e in subsequent decision procedures.
The proof of decidability of emptiness given by Bar-Hil1el, PerLes, and Shami-rI7 for context-free languages depends on the derivation tree3 of the gramnar for a shortest accepted string. If the grarrrar has x non-terminals and right hand sides never longer than h, then in any derivation, starting with a non-terminal, of a shortest string, no non-terminal need repeat along a path in the tree, which therefore can be taken to have depth < x. lrle now define the depth of each non-terminal to be the depth of the shallowest derivation tree of which it is a root. Then, knowing which nonterminal-s have depth < i, we can find all those that have depth < i + 1 siurply by looking for productions in which all the symbol-s on the right hand side have depth < i. Thus by going through the list of productions at most x times, and establishing the depth of

31
all the non-terminats, we can deterrnine whether the starting symbol has a defined depth i.e. whether the language is empty.
Thus it fcllows that (a) there is a decision procedure for empciness which works in time depending only polynomially on the gramar description, and (b) the shortest accepted string can be no Longer than hx"
Ttre standard constructionr for a pda with q states and t stack synbols gi.ves a granmar with qzt non-terminals. Further if (and only if) h is taken to be a constant, the nunber of productions in the graunnar wiLl depend only polynomially on the parameters. However, from the notes to Lernmas 1.2 and 1.3 we already know that rde can modify any pda to an equivalent one with h = 2, with only polyn'cmial g'rowth. Thus we can concLude that:
Lenrna 2. L
Emptiaess ft:r pushdofrtn automata can be tested in po1-ynomial time. tJ
Since Ehe standard construction of the graflurnr from the nactrine does nst change h, it aLso foll-ows that:
Lerrlna 2.2
If M has parameters h > l, q and t, and L(l'l) is not empty, tken 3 a e L(M) s.t. lol : hq?t. il

32
We can show that for q = 1 the order of this bound is achievabl-e.

Example 2.1
Let M e S9 be the simple machine defined by Ai+AqhT+t forl"<i<t lj -3* n where the starting syurbol is A1 and acceptance is by empty stack. Let min(Ai) be the length of the unique string generated from A{. Then from the productions it is clear that min(Ai) = 1 + h.min(Ai..1) for 1. < i < t.
t-i Since min(Ag) = 1, it follows that rnin(Ai) = f, hr. Thus M accepts
r={
just one word, and this is of Length of order nl(t.logh). I
For q > t we can find a class of rnachines which achieves a bound of order fl(qt,logh).

Ex_ample 2. 2

Let M e Rg have states {rt,

sq}, stack symbols

{Ai, ... At-1, B}, and transition rules:

(si, A3) e* ("t, a!+r) 1 j i : q, I j j . t - 1
(si, Ag-t) -3* (si+r, BAI) 1J i < q

(sqn As-t) -3* (sq, A)

(si, B) -1* (si-1, A)

I. i: q

33
Let the starting configuration be (s1, A1) and the unique accepting mode be (sr, $l).
This is a generalisation of the previous example. Each occurrence of Ai proliferates to produce an exponentiaL number of At-lts, but now instead of these being renrcved by a single input character, they are each allowed to proliferate themselves all over again for a different state. For any configuration the depth reacheci in this sequence of renewal"s is given both by the state and the nurnber of r:ccurrences of a B in the stack. By a second induction process, similar to that given in the previous example, it follows that the unique string accepted by M is of lenglh of order nl (qt. logh) . I
We leave unresol-ved the gap between this lower bound and the previousLy derived upper bound of El(q2t.logh).
2.3 Finiteness
Bar-Hillel-, Perles, and ShamiriT show that a context-free Language is i,nfini-te if and onLy if there is some derivation tree which has a path atong which some non-cerminaL repeats and in so doing generates distinct terminal strings. Thus to test for fin:,te* ness nre produce a polynomial size grarunar, eliminate redundant non* terminal-s (i.e. 'those that do not generate terminal words, or cannst be derived frorn f.he starting symbot), and then test for the proper embeddi.ng properEy. This last test can be done by looking at each of the remaining prodr:ctions that have some terminal on the right hand

34
side, and searching through the other productions to see whether a self-enbedding cyctre of productions can be found for this given nonterminal. As all this can be done in polynomial time it follows that:
Lerma 2.3
Finiteness for pushdown automata can be tested in polynomiaL time. I
2.4 A Normal Form
There is a well known3 normaL form for dpda, which is very useful for our purposes and fits in naturally with our definitions.
Def ini tion A dpda is loop-freel iff every input word can be read in a
finite nunber of machine moves.
This condition excludes the possibilities of either (i) nnves from some reachab,Le configuration being undefined, or (ii) there oceurring an infinite sequence of consecutive -moves, thus preventing further inputs from being read.
T,enrna 2.4
Every dpda M has an eguivalent loop-free Mt with the sane stack alphabet, and just one extra state"

Proof

35

I^Ie f,iret au$nent 1"1 by introdr-rcirrg I new staEe s' and new transition rules (s', A) ..3t (st, A) for each a e I and A e iin without changing F.

For each reading mode we add the rules (s, A) ", (u' , A) whenever (s, A) --4, does not previously oecur. Thus instead of stopping, the maehine will now continue to read the tape and reject it.

To exci-ude the otber possibility mentioned above, we first have to note that in any infiniie e-derivation there must be some configuration which has a smallest stack. If the mode of this is (s, A), then hy replacing the Eransition rule for this by the set (s, A) :S' (nt, A; for each a, we again ensure that bire r*:sL of, the tape is read and rejected. These rmdes can be effectively found by appropr!"aL'. emptiness teses. il

A11 the neru rul-es introduced serve the same role and therefcre do not create additional comptexity in any significant sense. eonsequently r*e shall frosi now on assume that the loop-free machine i.s nf eseentialXy the same size, in every way, as the original one.

Def ini tion
A dpda i-s in pormal_rEgmrr iff it is loop-free, and every accepting mede i"e a reading mode,

Lenuna 2 .5

36

For each M e D with q states and t stack syurbols, there is an equivalent Mt in normal form with the same stack alphabet and 2q + L states.

Proof
}Je first make M loop-free by introducing a distinguished state "t as in the previous leqma. For each other state si E Q we introduce an sitt. The role of si" is the same as that of si, except that the former indicates in a derivation that an accepting mode of M has been passed since the tast time an input was read.

Thus for each accepting e-rnode of M, we replace

(si,

A) - r*

(sj,

o) by (si,

A) - 3+ (sj'

,

u:)
"

For each readiug rule (si, A) -3* (s5, ur) we add the extra rule ("i", A) -3+ (s5, rrr), and for each e-ruLe (si, A) -n (sj, ur) we add the extra rule (si", A) -:' (s3", ,l).

This new machine clearly simulates M and accepts the same strings if we define the new set of accepting modes by
F' = 1(si", A) | (si, e) is a reading mode) u {(si, A) | (si, A) e F and (si, A) is a reading mode}.
I

2.5 TotaLity

37

A,s corrol-lari"es to Ehe lemna above, decidability proof,s for properti.es whi.ch are known to be undecidable in the nondeternninistic case3, can now be easily derived.

CorolLarv 2.I
For each M e Dr3 M' e D with about twice as many states, which accepts exactl"y the cornplement of L(D).
Proof
We change M to M" in normaL form. Then we redefine the accepting:,rnod,eg to be jr-lst those reading modes which are not aceepting nodes in U" " [J
Corollarv 2.2
Total"ity ferr dpda can be tested in polynonial time.
Proof
ConstrucE ttre eomplement machine and tesE for emptiness. I

cqrq.l legy !. 3
For M e D, and Mr a finite state automaton, the following can

38
be tested in time depending polynomially on the parameters of M and M': L(M) = t(M'), L(M) n L(Mr) = /, L(M) c L(M'), L(M')cL(t{).
Proof
rf Mr has state set Qt of size qt, and M state set Q of size q,
then both machines can be simulated together by a dpda which
resembles M, except that it has state set Q * Qt and is able to mirnic Mr in the finite state control at the same time as simulating M. Provided that M is in normar form, each of the above questions can be tested by defi.ning acceptance suitably in the new machine and testing for emptiness. I

39
rr THE EQUMLENCE PROBLEU
I.Ie have aLready observed that an equivalence test for a class of automata can provide a method of verifying the correctness of a given machine by eomparing it with another of the same kind. In addition, we can attribute other useful properties to classes for which equivalence is decidable, that give us increased confidence in the possibility of systematicalLy analysing and handling particular machines contained in them.
We first notice that for aLl automata with a decidable membership problem, inequivalence is partially decidable, For we can enumerate all strings over the input alphabet and test whether the two machines behave differently in each one. Then if the machines are inequivalent, we are sure to recognise this when we reach the first offending input string.
We then observe that all the automata in a syntactically defined class, such as D, can be enumerated in some lexicographic manner. It foLlows that if we can decide equivalence, then for any automaton in such a class we can enumerate all other equivalent ones. Conversel-y, if we can enumerate all machines equivalent to any partieuLar one then, since inequivalence is partially decidable, we can decide equivaLenee by running this enumeration simultaneously uri.eh ehe partiatr decision procedure.
Thus we arrive at the following intuitive interpretation of the signif,icance of this problem: equivalence is decidable if and only if for any automaton in the classr r{e can en!.merate al-1 other

40
\rays of doing equivalent computations. Undecidability then means that the relationship between the automaton descriptions and their computational behaviour has a distinctly higher order of complexity, and we can no longer hope to be able to describe adequately all the different ways in which the freedom avaiLable within Lhe class can be used to perform a given task.
The partial decidability of inequivalence has also the following imnediate consequence for all the classes we shal1 study:
Observation
If equivalence is partially decidable, then it is decidable.
The decision procedure consists of simply running the partial decision procedures, for equivalence and inequivalence concurrently.
Thus, except when we can derive meaningful results about the complexity of an equivalence test, we shall, for the sake of sirn plicity, be content with proving decidability by showing partial decidability.
This section consists of three chapters in each of which a distinct subfamily of D is shown to have a decidable eguival-ence probl.em. There is an essential unity in the methods used for aLl three, for which the basic inspiration comes from Rosenkrantz and StearnsS. They show that for dpda recognising the LL(k) languages, there is an easiLy derived canonical forn with the property that any two equivalent machines must, after reading the sarne input rdord,

41
have stack heights differing by less than a ce.rtain constant. Two such machines can therefore be simulated by a single dpda with a t'{ro track tape, and equivalence verified by a suitable emptiness test" Wtrat we sha1l show is that even for m<rre general classes, where no such close relationship between the st.ack movements need occur, suitable pushdown automata can be devised to simulate equivalent
machines.

42
Chapter3 A REALTIIfl FAI.{ILY
3.1 Introduction
The syntax of progranrning languages is customarily defined in part as a general context-free granmar. Most frequently, however, the languages generated by such granmars are not only deterministic, but also expressible as Rg languages, i.e. those recognised by realtime deterministic pda accepting only by empty stack, and even subclasses of these. such subclasses as the simple languagesg, and the LL(k) languages8 which generalise them, have been studied with exactly this nnotivation, and equi"valenee tests have been found for these particular ones.
The principal restriction on LL(k) recognisers is that they require essentially only one state, and therefore cannot transmit information during stack decreasing derivations. Thus, for example, in Al9o1 60, after some expression'((.. (( Expression ))..))'with arbitrarily nested matching brackets is gcanned, no such machine can remenber whether the contents of the innermost brackets was an arithmetic or a boolean expression. since'if ((..(( Expression ))..))' has distinct valid sequeLs depending on just this condition, we conclude that no essentially one state machine can recognise arithuretic expressions as specified in that language.
Here we shall define a fanily N6 of quasirealtime dpda such that L(No) properly contains the tl(k) languages. N6 machines may have an arbitrary number of statcs, and can easily accormodate the above

43
mentioned example. In addition, however, they extend the LL(k) languages in a much more significant wave thus indicating that our generalisation of the equival.ence test is an important one. The procedure for LL(k) languages given by Rosenkrantz and SEearnsS relies on the fact that nin(c), the length of the shortest string accepted from a configuration c, is a very well behaved function of the stack c(rrents. The value of this function for any configuration can be deduced to within an additive constant from the contents of the stack atone, and, further, can only change a bounded arnount from one configuration to the next in a derivation. This property does not hol-d for scme languages in L(No), such as {anbcn} u {ande2n}. The concept of tthicknessr of stack words, central to the proof of Rosenkranta and Stearns, is no Longer applicable here.
ldhile the inclusion pr6blem for sinnple and LL(k) l.anguages is at present open, we can already prove this to be undecidable for Ng" In fact we strali show that L1"L2 is undecidable where L1 is a simple
language and !,2 e L(Ng) l'ras ja"rst two states"
We eonjecture that the property on which the validity of rhe equi-velence test fnr Ng depends hoLds also for R6 in general, and betieve t-hat a n:r*of of this "*rc,r-rtd be illuminating'
?he enphasi,s 'i"n this c.'ixapter is ern the derision procedu::a itse1"f,, rathex'tlran the elass l-{60 which !ile use merely to demnsEraee Eire iucreased generality sf o,+rr E,eehnique over previous ones.

3.2 Nonsingular Automata

44

We defi"ne the cl-ass Ng of nonsingular machines as fol1ows.
Def inition M e D9 is nonsingular iff 3 m > O s.t. Vr^,, ot , f*, s, st e Q where lrl > m, L(s, urto) = L(st, ,t) + L(st, ,rr') = y'.

Theorem 3.1
(i) LL c L(No) whcell, is rhe class of all LL(k) languages.
(ii) L(N6) e L(Ro).
Proof
(i) For a configuration c let rnin(c) be the length of a shortest string in L(c). Then from Lernma 8 of Rosenkrantz and stearnsS, we can deduce for eertain canonical LL(k) recognisers, when translated into our terminology, that there exist positive eonstants .c, L' , s.t. for all s, st, o, and rrtt,
(a) | nin(s, o'o) - min(st, rrrt) - min(s, ,^,) | : l, and
(b) 0', lrl t *itt(", r,r) 2 lrl,
provided that min is defined throughout.
It follows directly that any dpda with these properties

45
belongs to N6, with nonsingularity constant m equal to 1,. We note that for the sinple9 machines this constant can alwavs be taken to
be sero.

To show that containrnent is proper, consider the following dpda M recognising the l-anguage {anbcn} u {ande2n} for n > 1.

A:

(sr, A) a
-)

(sl r AA)

(s i, A) --b> (s2 r A), (s2, A) - r'+ (sz, A)

(sr, A) -$d (ss, A), (s3, A) - 3'+ (s4, A), (s4, e,) 5 (s3, A)

cs = (s1, A), F=Qx{CI}.

In M for any i, j and m, n where m f n,
t (sir An) # L(s5, An).
Thus !{ e N0. However, it is inplicit in conditions (a) and (b) abova: that :\e value of min can only change by up to a bounded amount: from one cnnfiguration to the next in a derivation. For any dpda accepti.ng che above language, this cannot be true for the set of ubves in which a synbol d is read. [,Ie therefore conclude that
r.(M) g LL"

(ii) nf a rnaetline is nonsingular, then the appropriate constanc lri clearn"y sees an !"ipper bound erra Lhe arount the height of a configuraeion can eharage in clnc csurse of any sequence of e-moves, for any two eonfigr"u:ra&iones in sueh a derivation must necessarily be equivaLent. Thus, from an argunen8 given in 51.4, it follows that the same l"anguage can be aeeepued by a realtime machine.

46
To show that the converse is not true, consider the language ianbcn) u {andczn}, which clearly be1-ongs to L(Ro). Let a dpda M recognising this language reach the equivalent configurations (s, .rr) and (str rt) after reading a2nb and and respectively for some large n. Then from Observation 1.1 (gf.2) ve know rhar lrl is abour rwice loltl , and further that the effect of ck for some "small" k is to reduce (st, ,t) to a configuration whose stack is periodic right to the top. Thus for an infinite set of distinct values of n, some string ek takes the two equivalent configurations to new ones with stacks stil1 differing in height by about n, but with one srack being a prefix of the other. Thus M I No. I
3.3 Alternate Stacking
We now describe a way of constructing a single stack machine, Mn, for simulating Erro realtime dpda M, fr together.
A configuration of M' can be specified by a pair of states, one from each of M and il, and a stack which consists of alternate segments of words from the stack alphabets (assumed distinct) of the two machines. The simulated configurations of M and fr can be recovered by taking the corresponding state component, and concatenating the appropriate set of alternare segments of the stack of Mt n to obtain the original stack. On reading each input symbolrM' simulates M and M by sirnultaneously manipulating the two topmost segments in its stack according to the respective transition rules of the component nachines.

47
More formally, distinguishing the notation for M and ll by over-lining everything concerned with the tatter, so that M' has stack alphabet f u T and state set Q * Q, we describe a typical configuration of Mt by
(t [|s, -s1j, olo2o3or] ... uozn-262rr-lo2n), where only the last segnent, i2n, may be enpty.
hrithout loss of generality we shalL assume that the tno topnost non-nuli. segments of the stack ar o2n-t = oA and i2n = ;f. If the traneition'rulee of M, il specify that
(s, A) t, ("tr lrof ) and (1, f) tr (6r, ii'), (rhere n e I if rrrt is non-nul.! and nefu{A} otherwise, and sinilarly ror i) then for input a in M' , rhe segment urAil will change ro ,niir'-.t, and the state rrom [s, i] to [rt, ir].
An iuoportant inplication of this notation is that if, for exauple, ii = A, then the words un and r,lt wilL merge into one segnent si.nce they are from the same alphabet.
3"4 Main tr('esults
The alternate stacking eonstruction is only useful to us if we can ensurc that the simulating naehine is itself a pushdown automaton"
Definition
Alternate stacking for a pair of nachines, for a given set

48
of input strings is said to succeed iff the simulation of them
together for these strings by the above construction produces stack segments of only bounded size.
We define an input- string o to be live for a dpda M iff it is the prefix of some accepted string, and a configuration c to be live iff L(c) * l.
Theorem 3.2
For M, M equivalent nonsingular dpda, alternate stacking succeeds for all live inputs.
Proof
We shall shsw that in the simulating machine M' constructed as described in F3.3, no input a that is Live in M, il "at lead to a configuration
([s, s] , oriz ... u,;)
with lrl > z(22 + m). Here z is the maximum of the lengths of the shortest strings accepted by dpda of size no larger than M and M, and m is the larger of the nonsingularity constants of these two machines, which are taken to be realtime,
Let us assume the contrary. Consider the configurations e and E of M and fr respectively at the moment when the bottorn symbol of the segrnent il was actually placed there. Let s be the input read since that time, which has taken u, fr to the present live configura-

49
tione cr, Er respectively. By our choice of E and a, all the configurations in the a-derivation in fr ha.re height 3 l;1. Also, by virtue of the alternate stacking construction, all the configurations in the a-derivation in M have height > l"rl, for what is finally the i segrent in Mt has been in existence throughout the o derivation, and hence the segment below it cannot have been increased in the neantine (Fig. 3).

Let B be a shortest string in f.(ir), and let B = BtB3 where ;l +(Br) E2 and l"rl = l;1. Then lBrl : lrl uy the realtime
property. 'Also B nust be a shortest string in L(cf ). But then B is the concatenation of segments induced by the popping sequence in M, each one taking some (q,A) to sorne (s2, A). If B is minirnal, each
such segment must also be nininaL and of length no rDre than z.
Thus Bl consists of a sequence of such nininal segments terminated possibly by a proper prefix of another such segment. Let Bzt a prefix of 83, be the completion of this last segment. Then 1et c2 4A^ ca and -c2 4A^ cg. ClearlY

l"rl-l"gl:lsrll".

(a)

Now consi"der a shortest string y taking M from cto ca. Then
the def initions of E2, E3 "tt",rte that lyl : " + l82l 7 22. Let c --Lt ct g. Then

l.i - l"'si :22.

(b)

But if M and l'1 are eguivalent then by construction ca _-l e 3.
:But from (a), (b) and the observations that l"l : l"tl and ler | l;l
we conclude that

50 M:
It:
fig. 3, Derivations in Proof of Theorem 3.2

51
l"rl : l"'.1 + 2z - lillz.
Thue if lil t " - 2z > m then we have a contradiction to the non-
singularity condition.
l{e therefore have to eoncLude that for equivalent nonsingular autonata, alt,ernate stacking succeeds for alL Live inputs. n
Theorem 3.3
If alternate stacking succeeds for all live inputs for all pairs of nachines M=E in sore class Ic D, then the equivalence problem is decidable for X.
Proof
Assume, as ig permitted by Lema 2.5, that M, M are in normal form. First Buppose that we know the bound to which stack segments can grow in the alternate stacking sinulating nachine for ll and il. Then we can effectively construct a pda Ut' with the property that t(ld') is ernpty iff l,t = il. M" nimics the alternate stacking nachine llr for M, E by encoding the top segrent of Mf in its f inite state controL. As Long as this top segment never gets larger than the given bound, M" accepts iff exactly one of the configurations it is eimulating is in an accept mde. I.lhen the bound is exceeded, M" proceeds nondeterninistically to ninic one of M or il, and acceptsas
the appropriate machine would.
By assr:mption , if M = Ii then alternate stacking will succeed for live inputs, and the stack segment bound will only be exceeded

52
once nothing rncre can be accepted by M and M. 'Thus l-t" will be empty by construction"
Conversely, if M" is empty, then clearly no input can produce different behaviour in M and il, which are therefore equivalent.
Thus, if we have an a priori bound, \Je can test equivalence by constructing this pda and testing it for emptiness. However, even if we do not know this bound, by enumerating and testing for emptiness the possible candidate machines, we can obtain a partial decision procedure, That is,we construct pda of the form M" for assumed segment bounds of L, 2, successively. If M, M are not equivalent, then none of these constructed nachines can be empty, while if they aren then one of them must be.
We therefore have partial decidability and hence, by an earlier observation, decidability. tl
Corol lary
The equivaLence problem for nonsingular machines is decidable.
Proof
Immediate from Theorems 3.2 and 3.3. D
Note l.
Nondeterminism in the siurulating rnachine is an inessential convenience, which can be avoided. M and fr couLd have been preprocessed to recognise instantLy whether a configuration reached is

53
live, and to enter a distinguished dead state if it is not. A simulating deterninistic pda could then be easily constructed.
Note 2
I{e can show that the order of the bound on the segment growth derived in Theorern 3.2 is achievable for simpl-e urachines. For these we have already observed that the nonsingularity constant m is zero, and, in 92.2, that z is El(t.Logh). Thus the bound z(22 + m) is of order El (t.logh) also.

Let A1 be the starting syrnbol for the simple grarmar of Example 2.1 generating the singleton string {an} where n is of order ht. Then consider the simpLe languages generated by B and C

resPectively:

B -5 nrBz

c j'lrcrcz

n2 -3, n1f2

C2 3, Cp2

n2J*41

Czj*n

Bl-3+A

C1 3n

Both B and C generate the set {arban+r I r 3 1}. However, if s - srx$6n, then t l* E , but C 3t Al. Thus in an alternate sEacking rnachine fon these tvo, the top segment can gro\t to size n,
which is of order EI(t.logh).

Note 3
To illustrate a s}ightly different way in which the success of alternate stacking can be used, we outline a proof that the equivalence problem for symetric dpda, Syo ( 1.4)rcan be solved in polynomial tine.

54
We recall from the notes to Leruna 1.2 (91.7) that any such machine can be transformed to one, only polynomially increased in size, with h = 2. Since alternate stacking clearly succeeds, and the enptiness test is itself polynoniaL, it remains only to prove that the simulating rnachine is itseLf of only polynomial size. The key observation here is that, instead of having to mernorize the ruhole top segnent, it is now sufficient for the finite state control to remenber just the top symbol of the next-to-top segment, and to treat the top segment itseLf in the normal stack-like way. The property of Syg machines from which this can be derived is that any rcve that causes the stack to increase, also eauses the value of the function min( ) to increase.
We note, honrever, that for the class 561 and therefore also Syg, algebraic properties can be derived9 which give nnre detailed insight into these restricted classes than our more macroscopic approach. Thus for Sy6 grarnr,ars with a fixed terminaL alphabet and with h = 2, an equival"ence test on the lines of Korenjak and Hopcroftg can be obtained, that works in tirne cubic in the number of non-
terminals.
3.5 Undecidability gE_Inclusion
FriedmanlS prolr"s the undecidability of the incl-usion problem for dB - S schemas (chapter 8) by showing that for each instance of the Post Correspondence Prob1em3, a pair of appropriately related dpda M1, M2 con be constructed with the property that L(Mr) c L(Mz) iff it has no solution. The construction is valid for certain

5.'.,
classes (e.g. dB - S) which accept b:y enpty stack'buc are essentially not real-time, and also for rea.Lcime fanil-ies that do not tiave this empty stack restriction (e.g. S).
We use a similar formulation of the problem but, by taking a refinement of the correspondence prnblem that is implicit in the customary proof of its unsolvability, we can show that inclusion is undecidable even for a real-time class with enrpty stack acceptance. Because of the slight novelty in'roLved, we shall digress here to give this undecidability proof.
Theorem _3..4
For M1 e S0, M2 e Ng ir is undec,idable whether i"(M1) . L(Mz).
Proof
The instances of the correspondence problem that we take are just those obtained directly from Turing machine computations in the standard proofs of its undecidability. Thus Hopcroft and lJl1man3 shord that for each Turing machine a correspondence problem with the
foll"owing properties can be constructed:
Let X = xl, .". xk, Y = yle .,r yk be the sequences of non-nulL words over a finite alphahet X. kle def{ne a sequence of positive integers i1, io (a3"1 5 k) to be a solution (or partial sotution respectivei.y) for X, Y iff x:xil .". "in is equal to (or a proper prefix cf,, respectively) !:he stri"ng; )llli1 ... yirr. Then the construetion is sr.ech that a solution exi.sts for X, Y if and only if the Turing nachine has a terminating eomputation, but no partial solution

56
for Y, X exists under any circums tances.
lle construct two dpda M1, M2 which both reject strings not of the form aRB$ where c is a string over the integers {1, ... k}, 8eX * and$is a distinguished terminating character. Both machines initiall-y place a special syrnbol A at the bottom of the stack.
M1 is a simple (Sg) machine which accepts exactly the strings crRB$ where B is the word indexed in Y by the sequence o. Thus M1 records aR in its stack, matches it with B, and accepts iff the natching never fails and the $ is read when there is only the symboL A Left in the stack. It rejects al-1 other strings by placing a special symbol on Lhe stack which permanently freezes its motion once matching fails.
M2 also tries to match o and B, but now as specified by X. If natching is successful and the $ is read when the syrrbol A is reached at the bottom of the stack, then rejection occurs. Otherwise, if matching fai1s, M2 goes into a second state, in which the effect of any X-input is to pop the stack without changing the state. Wtren the A is reached in this second state, all input synbols leave the configuration unchanged, except for $ which pops the A. If acceptance is defined by empty stack then clearly the length of a shortest string accepted frorn a configurafion is just the height of the configuration. Thus it follows that M2 e No.
If there is a solution to the chosen instance of the correspondence problen then the inpuE string which specifies it is, by definition, accepted by Mr but not by Mz. Thus L(Mr) - L(Mz) implies that it has no solution. Conversely, if it has no solution,

57
and oRB$ is any string accepted by Mt, then there can be at most a partial solution specified by an initial segment of a. However, by our particular choice of X and Y, we have ensured that at the point where the c, B faiL to match in M2, the stack of M2 has fewer syrnbols left than that of M1. Since M2 proceeds to accept any string from I-*$ that is long enough to empty its stack, it must accept "Rg$ in particul-ar, since M1 will take aE least as long to accept the remainder of this string as M2 will take to reach the bottom of its stack. Thus if there is no solution then L(Mr) . L(Mz).
Since for any Turing machine rde can construct an instance of the correspondence problem, and hence also the machines M1, Mz with the above properties, it follows that if we could decide inclusion for
such dpda, then we could decide whether Turing nachines had
terminating computations, which, howeverr Ite cannot. I
3.6 A Conjecture about R0
We conjecture that Theorem 3.2 hol"ds for M, fr e R9, and hence, by Theorem 3.3, that the equivalence problern is decidabl-e for R9. $ere we shall- outline the proof of a property of R9 which, though not Btrong enough to prove the eonjecturer maY throw some light on it.
Lema
There exists a function F(Q, t, h, 9), aslmptoticall-y linear in 9, with the property that for t:tro machines M, il e Rg rdith

58
par:rmeters appropriately bounded above by q, t, and h, if c, i tt" equivalent configurations of M, il respectively, then

if c t(a) cI nhere cris live and l"tl - l"l 2 e., then

Jcr' s.t.

c f(cr')

c1 and

(l t C-->

11 where l"t | - l;l > F(q, t, h, P.\ "

Outl-ine Proof
Choose the crr to give the shortest stacking derivation from c to c1. If ct, c" are any two configurations occurring in this derivation with l"' | - 1"" | 7 zt (where z is as in Theorern 3.2), then it is easy to verify that min(c') > min(""). Thus o,t can be segmented into lengths of no npre than 22, such that each further segment in i.t takes c, and therefore also i, to new configurations with increased values of min. The nain argument then is to show, using this segmentation, that no subderivation of the or derivation in fr can produce a stack drop of nore than G(q' t, h), where G is an El function. This is done by assurning the opposite and inducing on the number of states that can be reached at this lowest level by popping derivations from the previous configurations in the subderivation. The observation used is that if min(s1, ,r'; ' nin(s2, rrrott) for some sI, s2, o, ot, ,tt, such that ltt l/lr"l 2 zt then 3s s.t. (s, ,rl) is not reachabLe from (s2, otl"). Since the reading of the successive segments of qt must lead to a set of pairwise inequivalent configurations, the statement of the lemma then easily follows. I

Chapter 4

59
FINITE.TURN AUTO},IATA

4.L Introduct,ion
We consider a family of deterninistic pushdown automata on which the only restriction is one on the movement of the stack. Using a technique related to the one given in the previous chapter, we show that the equivalence probLem is decidable. fuain we build a pda to try to simulate the tested machines, but now this is an intrerently nondeterninistic one. Since two equivalent machines in this family may have totally unrelated stack movements, a deterministic simrlation by a pda is no 1-onger possible.
A speciaL case are the l-turn machines. The undecidability of the inclusion problem for these is wel-l- known, and is also implicit in our proof of Theorern 3.4. A further restriction gives a class which is intimatel-y related to the tr*o-tape acceptors of Rabin and Scott6, for which equivalence has already been proved decidabLe by Bird7. From our proof, therefore, another equivalence test can be abstracted that is not directly related to that of Bird and, while possibly less efficient, involves a technique of apparently more general- applieability.
Although the finite-turn property is essential to the proof of the effectiveness of our main construction, we know of no pair of equivalent dpda for which a simulating machine of a broadly sinilar nature cannot be found. Thus it is possible that, when more detailed knowledge about the structure of dpda in general becomes

50
availabLe, our methodology nay be extended to prove decidability for the unrestricted case.
4.2 Definitions
We define the class T c D of finite-turn dpda as a deterministic anaLogue of the nondeterministic class studied by Ginsburg and
Spanier I 9.
Definition A derivation in a dpda is a stroke if either no single nove in
it decreases the stack (i.e. an upstroke) or if no single move increases the stack (i.e. a downstroke).
Definition A dpda M belongs to the class n - T, for some n > O, iff every
derivation in M fron the starting configuration can be segmenred into no nore ttran n + I strokes alternating in direction.
Definition A dpda M e T iff M e n - T for some n > O.
In other words, the restriction we impose on T is that in the set of all derivations from the starting configuration of a machine, there is a bound on the number of times the direction of the stack
movement can change.

51"
Clearly the language {arbr I t: l}m belongs to r,(l2rn - t] - rl but not to L([Zr - Z] - rl. Further, -in general, L([2"] - 11 = r,([Zn - f] - T). This is because after an even number of Lurns the stack is inereasing, and so after its last turn a [2"] - T machine can only proceed to recogni.se a regular set. Thus the last turn in such a machine cannot be essential for recognising the language. In particular we note that L(O - T) are just the regular sets'
lJe give Erilo properties of f inite-turn autornata which can be
derived from analogorls properties given by Ginsburg and SpanierI9.
Ttrey both depend on the fact that for any pda M, an equivalent one l'lt can be constructed to minic M in every way and, in addition, to remernber in its state set lthether the derivation it has been doing is in an upstroke or a downstroke.
Observation 4.1
It is decidable for M e D whether M e T.
Proof
For M we eonstruct a nondeterministic pda M" wtrich mimics all the stack movements of M by e-moves instead of reading the norrnal inputs. In addition M" remembers in i"ts finite-state control the direction of the current stroke, and reads a character $ whenever this changes. Then M e T iff L(M") has strings of only bounde<l length (i.e. iff L(M") is finite). Thus to test M for the finiteturn property, we test L(M") for finiteness. D

Definition

52

AmactrineMen-Tis ordered iff

(i) its state set ie the disjoint union of sets Qg, Qnr and (ii) a state reached in a derivation from the starting configuration
is in Qi iff the derivation has undergone exactly i turns.

Definition A state s of an ordered nnachine is of order i iff " e Qi.

Observation 4.2

For any M e n - T we can construct an equivalent ordered Mt e n - T.
Proof
l{e first nodify M so as to be abte to remennber the stroke direction, and then make n + I copies of the transition rules, each referring to a distinct state set Qi, for O : i _. n. We obtain M' by slightly nodifying this ners set of rules. Mt starts in the starting configuration corresponding to QO, and mimics M in every way except that whenever it is in a state s e Q1 and the current stroke is terminated by a nove in the opposite direction, the appropriate transition occurs to a state of Qi+i, instead of Qi. The computation continues within the new copy of the transition rules, with acceptance defined as in M, until further directional changes occur. Mr is cl-early deterministic and has the required properties. u

63
We notice that we can test easily whether M e n - T for a particular n, by buil,ding the candidate ordered M' t [n + t] - t equivalent to it, and testing whether any derivation in Mt can reach a state of order n + 1. The latter can be done by suitably redefining acceptance in M' and testing for emptiness.

4.3 Proof Srrategy

We shaLl prove that equivalence is decidabl-e for T by showing that it is partially decidable. In particular, we shal1 show that for each pair Mi, M2 E Tp a faurily P of pushdown automata can be constructed with the properties that

(i)

if

L(MI) = L(Mz) then for some

t
M

e P, L(Mt) = 6,

and

(ii)

if

L(Ml) * L(M2) then for all

I M

eP,L(M)*1.

Thus the enunneration and testing for emptiness of all the machines in P constitutes the required partial decision procedure.

For sinplicity of presentation, we shaLl- form a machine M from the dis joint, uni.on of the two tested machines M1, M2 as f ollows. M initially reads a character from the input tape and, depending on what this is, moves to the starting configuration of one of M1 or M2r which it then proceeds to simulate precisely. Clearl-y, if MI 1 ll2 e T, then M e T also. The advantage we gain by this construction is that now rre need only talk about the equivalence of configurations in a single finite-turn machine.

In our constructions we shal1 further assune that this rnachine

M is:

64

(i) in normal. form (52.4), and (ii) ordered (SA.Z1.

Lenma 2.5 and Observation 4.2 ensure that any finite-turn autornaton can be transforned into this form.

We shall present our proof in a nurnber of stages.

4. 4 Paral'lel Stacking
We shaLl first outline the general form of the nondeterministic pda Mt that is to sinnrlate M.
A configuration of Mr has a stack which can be thought of as having a Left track and a right track, the top of each one being associated with a state of M. The stack is segmented into lengths of bounded size by special syrnbols, called 'rceiLings", occupying both tracks. The finite-state control is able to manipulate directly the top segrpnt (i.e. the part of the stack above the topnost ceiling).
rn each segnent both tracks contain stack words of length greater than one. rnto each ceiling is encoded the following information about the previous history of the computation:
(1) a quadruple (st, At, s2, A2) which states that at the tine the ceiling nas created, the two tracks had nodes (st, At) and (sz, Lz) respectively.

65
(2) an inlic,ator IgLr from {L, R}2 specifying the connecEion of the tracks above the ceiling to the ones irnmediately below. For example, (L, L) will mean that both the tracks above are to be associated with the left track below.
Each configuration of Mt is to be interpreted as corresponding to two configurations of M in the obvious way, i.e. the M configurations can be recreated by taking each track in the top segment of M' and concatenating it with the appropriate words in the segments below as specified by the indicator pairs in the ceilings, and by
adopting th'e corresponding state.
The basic operations of Mr are to try to urirnic simultaneousLy for all inputs the transitions appropriate to the two simulated con-' figurations of M. rn order to be able to do this, while at the same time maintaining an upper bound on the length of the segments that can arise, the machine Mr can also on occasions, depending on the contents of uhe top stack segment, do one of, the f,ollowing additional operations without reading inputs:
(a) if one of the tracks in the top segment is empty, and the other contains a word from a certain set of tshortf words, then the ceiLing below it is rernoved, and the tracks formerty irunediately below and above this ceiling are fused tc form one segnent, in the manner specified by the indicator pair.
(b) if both tracks have more than one symbol, then a ceiling is placed to be jr:st below the top symbol of each track. The indicator pair (L, R), and the quadruple corresponding to the modes of the tracks are encoded into this
ceitins "

move (a):

gt

(1

c

) (RR)

rl
ll

A

BA BA

) (rR)

rcve (b) :

66
')

__-:_l

rpve (c) :

st

c c
A A
A
(

A A
A
) (RR)

st B lc (sBsfC) (tR)
A A AC
( )( )
s4 Ar
(r) t
4l
(t
(s A s2A2) CtE

(erAt e2A2) (LR
Fig.4

1A1s2A2) (LR)

67
(c) if one track is eurpty or has just one syrnbol, while the other contains a word from some. speci.fied set of tlongl words, then Mt has the foLlowing nondeterministic choice of moves: A replacerent stack word, with the same mode and indicator as the large track, is introduced to reptace either one of the tracks in the top segrent. The simulation is then to be alLowed to continue to compare the newly introdueed configuration with whichever one of the old ones is left. The replacement word is tshortr in the above sense, and is uniquely specified by the Mr configuration.
Examples of each of these three kinds of moves are illustrared in fig. 4. We notice that once a ceiling has been created, though its quadruple cannot be modified, its indicator can be changed by trpveg of type (a) or (c) .
I{e define acceptance to occur in Mt when both tracks of the top segment are in reading nndes, exactly one of which is an accepting rcde of M.
4.5 Existence of a Verifying Machine
l{e have to shor, that if M has two equivalent configurations, then there exists a simulating pda M' of the kind just described, which starts with these configurations in its tracks and accepts no input string.

58
Clearly any pair of eonfigurations of M, reached via the same input string from a pair of equivalsnt configurations, will be equivalent. we have to show that when the tracks get too much out of step in Mt, we can, by uraking appropriate replacements, get them back within a finite bound while still naintaining the equivalence of the pairs of configurations simulated. Further, tre have to verify that the replacements, and the whole simulation, can be carried out by a pda.
[,le nors define the function Rep over
Q * f xQ x f xQ x (fu {n}) * Q' f x {1, 2}
Eo determine these replacements.
Definition
Rep(sl, Al , s2, A2 : s3e A3 3 s4, A4, 0) = ar,where ur, if defined, is a shortest non-nulI stack word with the properties that
(i) (s r, Ar) --t (sq, oA4) , and (ii) yol, t^l2 . f*, if (s1, tr:1A1) = (s2 , w2A2)
then (sa, arlurA4) = (sf , rr.rUA3) .
I,lithout having to construct this function or to determine the arguments for which it is defined, we can observe that since it has a finite domain, ne can define p to be the maxirnrm of the lengths of the stack words in its range.
rn Mr , if the top ceiling contains (st, At , s2e A2) and (L, R), and the right tsack above contains (s3, A3), and the left one some

69
(",., ,'Aq) where (sq, Aa) is a reading mode, then we make the nondeterninistic replacement by (s,*, oAr+) whgeRep(s1, Al, sz, A2 : 83r A3 ! 84, Aq, 2) E o, provided that lrl . lr'1. This is illustrated in fig. 4(c). If the indicator were (L, L) then the vatue of Rep for 0 - 1 would have been appropriate, while if the top trackg were interchanged we would treat them in a sinilar way by sp@try.

It is easy to see that under the circr-rmstances specified for the replacement, the function Rep nrst be defined, for ro' is itself a guitable candidate for its value: I{e first notice that the sinpleet way of realising the necessary conditions is if there is Some c 8.t.

(sr, Ar) * (sz-, Az) *

t"u, ,,,'Aq) and t"s, As).

Then tor clearly has the properties required of a value of Rep (except poesibly ninimality). In addition, all other ways of reaching the specified situation in M' (i.e. if nondeterministic replacementa have been rnade in the meantime) invotve only valid eqrrivalence preserving replacetrpnts which are defined completely by the ceiling concerned and subseguent computations, irrespective of the stack contents below. Thus by induction on the nuniber of such replacernts made during a derivation in Mf , we can deduce that a valid repLacement is available whenever it is necessary.

A finite-state control can carry out these replacements since Rep is finite in every senae, provided that it can always appropriately nanipulate the whole of the top segtrent. Thus it renains to prove that a borurd x exists such that no track segment can become

70
longer than x in any computation. It is here that che finite-turn property is required.
I^Ie f irst consider in turn the various eventualities that
may arise:
(1) If both tracks are steadily increasing then new ceilings will be frequently added and no segment will become 1-arge.
(2) If one track is increasing steadily in an upward stroke, while the other one is stationary (i.e. with stack height not changirg) then after a stack increase of q2thin the one, a valid repLacement musf be possible. For there must be two intermediate points in this derivation at which the mode of the growing track and the configuration of the stationary one both repeat. Thus a replacement word can be obtained by cutt,ing out a segment from the growing track. Therefore, for however long this track is trying to grow, the effect on Mt will be to repeatedl-y rnake nondeterministic rpves so as to keep the segment lengths bounded.
(3) If one track is decreasing then situations can arise in which the length of the segment created depends in a bounded way on the size r:f the prerriously existing segnents, and is not a priori bounded by p + 1". There are just tlro ways in which a Lrack can grotl "out of bounds" without imnediately being arrested by a nondeterministic replacement:
(i) If one track in the top segment is empty, but the other one is not Eqrite i"ong enough tcl qualify for a replacement, then the ceiling below may be rennoved by atr (a)-move. Thus the resulting fusion may create a top segment which is suddenly longer by y than before, where y is the previous bound on the segments occurring in

VL
the configuration.
(ii) A track may grow larger and larger without a replacement being possible, if the other track does not become enpty or a singleton in the meantirne. This second track can be assured to be steadily decreasing since, as in (2), stationary periods do not contribute to growth. Thus if the decreasing track is initially of height y, then this may cause to arise a segnent of
length no more than q2t2hy.
The crucial observation for both (i) and (ii) is rhar rhe gain in length achieved by each nethod can only be exploited to achieve further gains by the sarne method, once the order of at least one of the simrlated configurations of M has increased (i.e. after a turn
has been nade).
More preciselyrwe define the order of an M' configuration to be the pair (i, j) when i, j are the orders of the states of rhe left and right track respectively. Thus the effect of a replacement on a configuration of Mf of order (i, j) is to create one of order (i, j) or (i, i) or (j, j), while an ordinary simularing move would lead ro one of order (i, j) or (i + f, j) or (i, j + 1) or (i + 1, j + 1). we have to enslrre that the sinulating nachine cannot enter any ttloop" which could cause the segrnents to increase in size indefinitely. The ease we have to consider is that of derivarions from configurations of Mt of a given order to others of the same order, via ones of differertorders. clearly these must involve repLacements of the kind that substitute for the empty or singleton track. Since by definition the rcdes of the tracks are the same after any such repl-acement, either both tracks will be in an upstroke, or both in a downstroke. rn the former case ir is obvious that before the two

72
tracks can again extribit dd.fferent behaviour, turns must be rnade by both tracks. In the latter case the height of the top segment can be exploited by method (ii) for further growth, after a turn has been made by just one of the tracks. Howeverrthe new gains will only be achieved in the track that has undergone a turn, and cannot be exploited for further gains untiL a turn has occurred in the other track also.

Thus the times when successive gains can be made in the size of segments in excess of the bound p, can be regarded as occurring at periods"during which M' has configurations whose orders form a
npnotonic increasing seguence under the ordering defined by:

(i, j) r (i', j') iff:

1r

J

>

,l l"

, or

1,

J

>J .f

t

or i > it and j j',orjtj'andi:i'.

If M can only make n turns, then this sequence can have no more than about n2/2 paLrs. Hence we conclude that there is a bound on the maximum size of a segment that may occur in any computation of Mt. Consequently a finite-state conErol is sufficient to specify for each stack word that nay arise in a track of the top segment, whether moves of type (a), (b) or (c) are appropriate and what form these should take, and to carry out the normal simulation with inputs
otherwise.

4.6 The Decision Procedure If a machine Mt is constructed for the tested automata Ml, M2

73
as described above, with an arbitrarily guessed repl.acement function and segment bound, and if it is found to be enpty, then we have a verification of equivalence. For let us assune to the contrary that the starting configurations of M1 and M2 are inequivalent. Then at each point in the conputation of M' we can folLow the shortest string distinguishing the sinulated configurations. Then as each input character is read, the rank of the sirmrlated pair decreases. Wtren nondeterministic replacements are made then, clearly, at least one of the new pairs has rank no greater than that of the old one. Further, the rgplacerents all occur in reading modes to ensure that further progress along the shortest distinguishing string can be nade imediately. The only exception to this is the situation that occurs when successive replacements without intermediate inputs have to be made because of a long stack decreasing e-derivation. However this mr.rst once come to an end since the stack is finite. Thus we conclude that if l\ I 142 then for some input string we will reach an accepting configuration of Mr after a finite nurber of steps.
Conversetlr !t have already shown that if Mt = Mz then some M exists which aLways simrlates pairs of eguivalent configurations of M, and therefore accepts no string.
Thus enumerating such siutulating machines for M1, Vl2, for aLl possible replacement functi.ons and appropriate fi.nite state controls, and testing each f,or emptiness is a partial decision procedure
f,or equivalence.
The mai.n result therefore follows.

Theorem 4.1

74

Equivalence of deterministic finite-turn pushdown automata is decidable. I

Corollary
Equivalence of deterministic Ewo-tape acceptors6 is decidabLe.
Proof
For a Ewo-tape acceptor M' with input aLphabet Xt, and words (cl, g) on its input tapes, construct a dpda M, with f = X', and X = X'u {$}, that accepts exactly the strings oR$B such that (c, B) is accepted by Mf" The oR part is read by M, and stored syrnbol by synbol on the pushdown stack. Once the $ is read the finite state control treats th.c input tape and the stack exactly as M'treats its pair of input tapes. M can be made to accept whenever M' accepts, whichever of the various criteria of acceptance is taken (e.g. Rabin and Scott6, nird7l . l,t is evidently a one-turn machi.ne. !

_/{

Chapter 5

ONE -COIJNTE R AI'TOMATA

5. 1- Introduction
Counters have heen snudied in a variety of computat,ional contexts as simple and naturat mechanisms for unbounded storage. A counter can be convanientl-y regarded as a stack with an aLphabet of just one syml"'ol". The gain :i.n simptric!"ty achieved by this restricfii"ar. is that 6 eouatr llae eesentiall"y just two behaviours, depending on whether it is enapty or not.
Despite the apparent severity of this Lirnitation, it is well known that severaL basic probLems that are undecidabl.e for automata with staeks, remain so even when these are restricted to counters. Such ',:nderi-dability resuLte r,sa be- deduced from rhe theorem cf Minsky1A'" that any Turing machine can be sinnulated by a 2-register machine" 'fhisr tratter can be regarded as a deterrninistic automaton with twc counters, a finire sEate controL, and transitions reading no i,nputs. The computation executed by such a machine can be described by a sequence of triples, each giving the state and the empriness *ond{ei.ons cf fhe trvo counterso of the successive configurations resrchecl . Si.nee a deterrninistic one-counter automlton (doca) can check whether successive triples correspond to valid transi.t!.ons, and alsa whecher the ,:veralt aetion induced in one of the tg{o colmters f s *ons.i.stent with the sequence, the terrnination prcbleu for Z*register mactrlines (arad hence Turing machines) can be reduced to bhe nullity of -{ntersection probLem for doca. Thus this latcer probJ.en musfi he r-s+decidabLe

76
Since the class of doca CC) can be sholin to be closed under corylenenration by the siune arguments as used in 92.41 52.5 for dpda, it can be easily deduced that totality, and hence equivalence, for nondeterministic one-counter autonnta, and, more pertinently, inclusion for the deterministic case, are alL
undecidable.
Against this background we are neverthelees able to develop a detailed analysie of the structural properties of the computations of doca, and hence derive a decision procedure for equivaLence.
lJe have seen that any doea can be transformed into normal form (52.4) with h = 2 (91.7) with no more than a polynonial increase in q We shall assume that the machines are all in thie form, so that rre can e)rpress all the derived properties in terms of just rhe one paraneter q.
The decision procedure takes the form of a nondeterninistic sinul-ation, as in the previous chapter, but now the properties we deduce are eufficient to speci.fy exptricitly the nondeterministic replacenents regr-rired, Vire note, however, that, as in Chapter 3, nondeterminisrft here is a convenience that is not essential. A procedure could also have been obtained in the form of a finite number of deterru.i.nietic sinmrtations.

5.2 Preliminary Results

77

The function S(q) (which also gives rhe maximal order of an element in the syrunetric group on q elerents) will. be the dominating factor in the bounds we derive.
Definirion

S(q) = nrax {{,.e.m. inr} I Xri = {, ni > 0}
Lenora 5. 1
-_
s(g) = "6Toaq'1(q) where 1(q) * 1 as q * -,
Proof

(outri.ne) uaing etandard nuurb.er theoretic resulte, this aslmptotic functi.on can be easily obtained for the case where {n. } in the definition is additionally reetricted to be a set of prines. To show that the sane bornd is valid for arbitrary {nr}, it remains to prove that the possible extra contributions from prime porrers is not significant. Details of this argument are given in Valiant and patersonzo. I
For a deternninistic one-counter automaton M, we describe a configuration c with state s, and counter contents n (n > 0) , by (s, n). For this c, we u6e c + m to denote the configuration (s, n + m)r provided that n + m > o.

78

Definition

The input word B is a stan{$ffS,eqg for the configurations c, ct iff

(i)

B

ie

a

shorrest

string

such

that

c

B
?

c',

(ii) g = Blg;83 where lgr8sl. q2, llzl = q, and r > o, and

(iii) Forgomestates andwrd>0, forall-vs. t. O <vSEr e

c ---R-Ln:*+V2

(s e

,

w

-

vd).

Legrna 5.2

For a doca with q states there is a positive integet Z, no

greater than s(q), such that if l"l

l"'l

,- q,2, l"'l

> q2
"r,a

c? ct, then there is a standard sequence for c, cr in which the

loop drop d divides Z.

Proof

We define the efficieqcy of a state s to be the maximtm vaLue (possibly infinite) ot d/ fyl, where, for all sufficiently large n, the derivation (s, n + d) * (s, n) existsrbut repeats no state except I at the beginning and end. Clearly d, l1l S q.
Suppose o ie a shortest string such that " * "t. We mark the laet occurrence of one of the states with greatest efficiency

af\

in ttr^is derivation, Let this state be sur and ret its efficient simpl-e loop be generated by y, and carrse a dr:op of d, where d > c, Now excise from this derivation a set ot (not necessarj.lv sirnple) disjoint loops of maximal tertal length, suctr that the totaL drop due to thern is a multipre r:f d, ar:.rl fhe rnarked occurrence of, so is preserved" trte ean show that rhe l-ength m of the remaining derivation is no more ehan qi * t* brl firsfr rgs4lpring that at 1,east t = [(m + Z)iq - el disje,int simple loops, nor containing the markecl su in thei.r interiors must occur it. But k > d would imply that some non-null subset of these 1"oops accounts f,cr a total drop ttrat is a nultiple of d. This subset eould therefore have been removad in the originsl exe.i.sion contrary to the maximality conditiou" Ilence (nc + 2) I .q * 2 < d - 1-, anel $o Tll < qi * i follows inrnedi.an:elv {.f d < q. By a simitar arglffient ir c,en be shsr,n that t?le Length of the derivssli.on *f,ter the malr,.*C s* i"s i*-cs than q(q - 1), if d < q,

Let g* *$* be Ehe input stri,ngs fnr the parts of this remaining derivation before and after ihe choseR oecurf,enee of se reepectivel.y. 'thene cLea::?"y, for some integer r

rPt1Ri',*
e ..''--'-'
+

'

,"1 ' + l-ci ,

Eut l*l* l*'i > r'? > m ::rn ! i e{ r.ha;: r :, {";.

'!ti:I -,
f.

t

since the bounds derive'C f;r the rarts of this derivation in the case d . q, and eiraple opeciaL argtlF"le::lrs in the trivial case d = e' osur that the eounter is at na strlge e'*pt:y. Also, since we have repl-aced

80
arbitrary loops by ones of at l-east the sane efficiency, BrttB, nust stil1 be of ninimal length.
I,Ie not,e that Ehe caee of a null Y has not been excLuded in this argunent. t{e aLso note that a sinrpler argument would suffice if the bounds of q2 were relaxed to 2q2.
To obtain a value for Z we investigate the set of possible values of d in the above construction. For each state s we sel-ect, if possible, a maximally efficient sinple loop Ehrough s' and denote the set of states in this loop by Loop(s). ClearlY' if st e Loop(s), then the efficiency of st is greater than or equal to the efficiency of s. Alsor any standard sequence whose principal loop is based on s couLd be replaced by one based on s' , by applying the construction to the derivation of the old sequence, in which st must occur sincer by definition, r > O.
Let s t > I be the transitive cl-osure of the relation defined by en e Loop(a). Defining s, sr to be equivalent iff st > I and s 2 st, the relation > becomes a partial ordering on the equivalence classes" Let slr..r8k be a selection of representatives, one from each clase that is maxinaL in this ordering. It is easily verified that the corresponding loops must be disjoint, and that standard seguences can always be based on some such toop. Then the drope due to atrl these must add up to no more than q, and each one must divide Z where
z = 1,. c,n { <la I a. is the drop due to Loop (sr) } .
Thus Z < s(e). I

81
That thie bound for Z is achievable can be verified by
examioing Exanrple 7.3.
As we are concerned only with asytnptotic bounds, and as SCq) clearly dominates any fixed polynomial in q as q becomes large, it will be sufficient for our purposes to prove the existence of, rather etran obtain specific expressions for, the various polynomials we derive. The proof of the foLlowing Lerma introduces a useful
technique "
Lemg 5.3
Ihere is a polyaonial F3 such that for any configuration c with l"l > nr(e), and any positive nultiple Y of Z,
(i) uank (er c*Y) +Y/q<rank {c+Y,, c+2Y) <rank Cc, c+Y) +Yq, (ii) c = c+ Y iff c +Y = c + 2Y.
Proof
Assming that c and c + Y can be distinguished, there nnust be a
nrinimal dietinguislaing sequellee S6* whene
.: ;-bt (s, q-) for eooe s. Provided that p, is sufficiently large, Lema 5.2 ensures that I noay be taken to be in the forn of a standard sequence OUOfOr. Let the drop due ta 3, be d, where d > o. Since Bd

82
dietinguiehes c and c + Y, clearly grul * t'u uro distinguishes c + Y and c + 2Y. since lgrl < q and d > 1, the right hand
inequaLity follows.
In a similar fashion lre can choose OrO!016, where r > 'Ild, to be a rninimal string distinguishing c + Y and c + 2\. Then 8rl'r- t'uuro distinguishes c and c + Y. But lBzl > 1, for
otherwise, since d divides Z and thus also Y, the sequence would not distinguish c + Y and c + 2Y, The Left hand inequality then foLlowssincedsqalso.
Statenent (ii) is an imrndiate consequence of Ci) . n
5.3 Propricty
I.le now eetabLish some retationships that hoLd for periodic sets of configurations,
Definition
A configuration c is impgrper iff c = c + mZ for all integers m (not necessarily positive) such that
l"l + nz > nr(e).
Len'na 5. 4
If c = c + rnZ for eome m > O and l"l > nr(e), then c is
funproper.

83
Proof
It ie easy to eee that for any set of configurations ' {crr...1crr}1
rank (cor "t') t 1.isli5" {rank ("3, "3*1)}.
Hence, if rank (c, c + fl) = or then rank (c, c + z) > min {rank (c + iZr c * (i + l)z)i.
13i<m
By Lemra 5.3(i) it foLloqrs that these ranks ngst all be infinitet and therefore atso, by Lerma 5.3(ii)' that c is inproper. D
Definition
A conf iguration is propel if f it is not iryroper. That the period Z is optimal for the propriety condition can be seen from Example 7.3, where for any configuration c in the starting Btate, c r c + i iff i is a nultiple of Z = S(q - 1).
Lenma 5.5
Ttrere is a polynomial p5 such that if l"l > Pr(9).2, l"'l t q.2 and c = ct, then c is improper"
Proof
Suppose rhat c is proper, and fet ErBlBr6 be a string distinguishing c and c + Z, constructed exactly ae in the first part of the proof of

84

Lenrna 5.3, but for the case Y = Z. We define "rr, ".1 for n > 0

by

B. B:

g', Bl

"r, and ct

"ir,

where, in the case of e{oves, naxinal derivations ci.e. to readi-ng
rnodes) are Eaken. If c = cr, then cLearly .r, = "rl for all n' The polynomial p, is chosen to ensure that r is sufficiently large for
the following argr:ment to work: Either in cip...pc'(rr|) sourc
configuration repeats, or else eome cl in this set has height not
less than 2q3. In the latter case it is easy to verify that for
some i1 j such that i , 3 < 2q4, oj -i
"-'i.+'?J,J1 cl and cl=c-*w,

for some w > o. In either case, for some i, j such that i ' J = 2q4, we have' putting g = (j-i).21

"i*1, = sl+wZ
where now w > o. By Lemna 5.3(i) if w > 0, and trivially if w = or

rank (ci, clas) < rank ("i*o' cj.+2g).

However, if r is large enough then from the propriety of c' and Leurna 5. 3 (i) '

rank (cr,

> rank ("i*0,
"i*.Q,)

"i*2t).

T1li-s contradicts the assrmtption that "* = "rl for all n' Thus c must be inproper. D

65
l{e can now derive, as a consequence of this result, the property of equivalent configurations on which our decision
procedure depends.
Definition
Integers m, n are (x, :r)-rational,ly related iff there exist integers a, b with 0 < a, b { xr such ttlat
lna-nbl sy.
Lerrma 5.6.
There exist polynonialr p6, il6 such that if c = cr, l"l t FU(e).2, and c is proper, then l"l, l"'l are (c2, e5,(q).2) - rationally
related "
Proof
Suppose that c = ct, that c is proper, and that l"l , FU(g).2, for f'b. sufficiently large for the fotr lowing argument to work. Choose
81rg2r$316, and define "rrr ni as in the previous lemma. Let !, be the leaet n such that
miur (i*,r1, lc;l) . q2.
l, mugt exiet, for otherwise ti"*l] would be an infinite strictl-y decreasing sequence. c* ia proper for all n s l, and therefore
c' I cr, + Z if l"rrl > nr(e).

86

rf l";l . q2 tb.n by Le,r,rna 5 and the propriety of co, we have
rbar l"gl = p5(q).2.

Alternatively auppose l"cl . q2. For some i, kt such that O < i < i + kt 3 q, the states of clr clalt are the same' .i.*t, * ci e Bay' where l"l = q'. Then if k is a large enough nultiple of kf to ensure that l"o-nrl t pg(q), the propriety of the cn-cives
t,-kzl tu-t, + dkZ = tL-zkz'

Hence
that is

,L-vz t .L-nr,

"i,*"tz*ei+Zekz'
By lernrna 5, l";l < nr(e).2, for othemise lcil woula be proper, contrary to the previous statement.

Thus for a suitable choice of p; we have in both cases
ll-l - ,rsl . pi(q) .z and ll"'l - ellkl ' ni(q)'Z
Since O < d < q and 0 < e/k n q2, it follows for soroe p, that
lIcl"e/k - l"'l.al < nu(e) ,2. n

af
5.4 Decieion Frocedure
Using the result of Le'smE 5.5 'are construct a nondeterminiscic one-counter automaton Mt which is abie to sirnulate, in a certain sense, the computations of a pai.r of equrvalent doca. By taking the disjoint union of the star.es and transition rules of the two rnachines, we can regard the simulation as maintaining a representation of pairs of equivalent confi"gurations, c and co, of the cornbined machine. We ensure that at each point in the si"mulation alcl - Ul"'l = f , for some arbrf such that 0 < a, b. q?o arrd if l . pg(q).2. Then Mt can represent c and cu h;l hol-ding alcl in i-ts counter and remernbering f ,arb, and the states of c and co, in its finite state
controL.
The action of n' is as f'ollows " Let Fo be some polynomial such that wheneveE m or n is greaier than po(q),2, and they are (g,-, lU(!.).2)' raLionaLl"y reX-ated, then they are rel-ated wittr respect to only one admissible rational ratio a/b" Whenever l"i, l"'l are both Less than lo(e).2, their values are stored in tire finite state control. When a simuLation step is about to exceed tlris bound, the finite state control det.e;mines the coefficie&8s arb, ri any, and sets up the counter for the appropriate represenfiagion. aia]"rten sj.mulation step would reach a pair of configura;i.r:ns not ratr-!.l.a.lii lr:X.:rr*erln s.!)'c ie jusC too large for ctn then by Lerflm.l5.6, i"f q1 :: {i:'1 ':[len c must be improper. Instead of, cont"inuing the sinulaticn wiLti tr: o *t), a nondeterministic step is made either to Ehe simulatior: c",t ic * Z, e') g to the simulation of (c, c 'Z), Ttren, i-f c = r{ a.:ld eo also c = c - Z, tl:.e simulation continues to be one for equi'v'atent cgnfigurations in either case.

88
Since the originaL doca are in normal form, we can easily define acceptance in llr to occur if and onl-y if exactly one of the simulated eonfigurations is in an accept mode. Thus if the starting configurations are indeed equivalent, our discussion shows that no string is accepted by Mr. 0n the other hand, if they are inequivalent, we can show, as in the previous chapter, that some stri.ng must be accepted, For if some d distinguishes the starting eonfigurations, then either both derivations wiLl be simuLated directly to their different concLusions, or else the rational relationship nust fai1" In the latter case, if (c, ct) is reached where c I ct, then the remainder of a distinguishes one of the new pairs created. The assumed normal fora guarantees that any long e-derivations wiLl steadily reduce the counter. This, in turn, ensures that further progress a1-ong o can always be made in a finite number of moves, and therefore that o will- eventually be
accepted.
The construction and testing for enptiness of the sinnrlating machine described therefore constitutes a decision procedure for equivaLence. The nuniber of states of this nachine need be no more than p(q),2* for some polynoniaL p, where q is the totaL nuriber of states of the tested machines, and Z is bounded above by S(q) * ev'_g'_ro--g-e;-q. Assr,rrning a fixed input al-phabet, and recalling
Lenma 2.1 we conelude that

E9
Ttreorem 5.1
The equivalence problem for doca is decidable, and there is a decision proeedure whieh, for q state machines, has a running
time bounded above by
,r,G.-ffi
for some constant k. fJ

90
III CONTAINMENT PROBLEMS
Certain restricted classes of deterministic pushdown automata have gome important basic properties which do not hold for the whole cLass. For exanpte, finite-state machines recognise a class of languages that are closed under the Boolean operations, one-counter nachines, we have seen, have a rigid periodic structure, while for simple machines eaeh configuration can be related very directly to the language it generates. Furthermore, within these and some other subclasses we know how to test for equival-ence. It is also plausible that even for problems for which decidabil,ity can be proved in the unrestrieted case, easier decision procedures ean be found for these subclasses than for the whole c1ass.
For any of these reasons we may want to determine whether for a given dpda there exists an equivalent one beLonging to a particular subcLass. Formally we ask the foLlowing containment problem: If X, Y are Ewo elasses of automata and M e X, then is there an Mf e Y such that L(M) = L(M')? I,Ie denote the containment problem for X, Y by (x:Y).
Emptiness, f i"niEeness and total-ity can all be phrased as containment probLems, Testing for the prefix property we have seen in 51"4 to be equival-ent to the problem (D:D6). 0f the rnore difficult probLems mentioned above, the onLy one known to be deeidable is that of regularity, i.e. (D:Fsa). A proof of this hae been given by Stearns2. Without resolving the remaining open prnblems we shall nevertheless throw sone light on their expected

:t !.
difficulty by relating them ro the regularity problem in the following way.
I{e shaLl define a very generar notion of reLative complexity with which one can compare the inherent difficulty of various containment problems. ResuLrs expressed in terms of this are of wide applicabiLity. For example, our result that testing for enptiness, and for the prefix property are, in che defined sense, equally diffieult, irnplies that if the time conrplexity for deciding these two probLems on any machine modeL are polynomiaLs in the parameters of the tested automata, then the leading terms of these polynomials E i11 differ by on1-y a multiplicative consLant.
The result$ we then prove using this notion are that such containment rroblems as (D:C), {n:t1, and (n:Sg) must be, if decidable at arL, at least as difficult to de*:ide as regularity.
with this as one source of urotivation, we then pr.oeeed in the following ehapter to investigate the reguJ.arity probLem in detail. For a naturai particular nreasure of complexity used by stearns, rde improve his upper bound from a trebLe to a dou"nle exponential level, which now closely approaches a knorn"n double *xponential l-or*rer bound" As a consequence r/* can a1"so si,g*l'r"ficantLy improve the upper bound on the tine complexi.ty of ttris prob!.em.
we observe that all the eontainment problems in which rde are here intereeted become undeeidairl* if D is replaced by ND, the class

92
of nondeterninistic pushdown autonata. This can be deduced from a theorem of Korenjak and Hopcroft9*ho construct, for each instance of the Post Correspondence Problemr a context-free grailnar over a terminal alphabet r u {$}, with the properties that
(i) if the PCP has no eolution the language generated is ,*$,
(ii) if the PCP has some solution then the tr anguage is not deterministic.
From this we conclude that for any class Y c D such that [*$ e L(Y) ' (ND:Y) is undecidable. It therefore folLows that (M:Y) is undecidable if Y is DorSorTrCrFsa, etc.

Chapter 6

93
RELATM C0MPLEXITY

6.1 Introduction
I{e shall define a partial ordering on decision problems to e:(press the relative difficulty of solving them. Thus Pt > P, wilL nean that ifr on any rnachine model, the probLem P, needs Eine x to be decided, then P, will require at least about the sane time. Furtheraore, similar concLusions can then aLso be made about sPace
reguirenents, and various other measures as weLl.
We could define guch an ordering very sinply by saying that tl = P2 iff any procedure to decide Pn is effectiveLy able to decide P, also. For our appLications to dpda problems, however, it is convenient to relax this condition slightl-y. We denote by D(nrrnrrn3rn4rn5) the cLass of dpda whose parameters grtrhrPru are respectively bounded above by nlrtr2rt3rnO and nr. t'le define a transformation of a machine description to be direct iff it can be carried out by an aLgorithm that makes only one pass of the transition rules, (and nodifies each one as necessaryr) requires on1-y a finite amount of memory additional to the capability of recognising accepting modes, and increases each parameter at nost linearly. We then say that a procedure can decide problem P directly for a cLass X, iff there is a direct transformation which takes all rnachines in X to a form in which the application of the procedure effectively
decides P.
Definition
Pl > P2 iff 3 k > O s.t. any procedure to decide P, for

94
D(knrrknrrknrrknOrknr) can directly decide P, for D(nrrnrrn3rr4,r5).
Definition P1 = P2 iff P1 > P, and t2 = Pl. It is iarnediate from the definition that for the classes of
autooata XrXr,Xrr the foLloning reLation holds among the containment
problems:
(i) Xf c Xrr + (11":X) > (Xf :X), I{e obeerve that, in order to decide any global property of a machine, lre require operations at least as difficult as a direct transformation. Thus the relaxation of our definition of the ordering does not endanger its validity for our purposes.
6.2 ResuLts
As ie per:mitted by virtue of Lewra 2.5, we shall aseune here, for convenience, that all dpda are in normat form.
Theorem 6.1
(D:T) > (D:Fsa).
Proof
Let L = t(M) c X* where M e D, and let L'= (Lf)* where

95
$ f t. We shall show that Ll = L(l,tt) for some Mt e D which is only slightly larger than, and easily obtained frorn M, and, further, that Lt e L(T) iff L is regular. Thie is clearly guff,icienr, for then any M can be tested for regularity by testing the appropriate t(X') for containrnent in t(t).
We create Mr to recognice Lr by modifying M in the following Iray" For every accepting mde of M we introduce a move on $ input to a nelr epecial state that causes the stack to enpty and the starting configuration of l{ to be reetored, all via an e-derivation. If we make the starti:rg and accepting configurations of Mf to be the starEing configuration of M, then clearly L(Mt) = O$l*. To do all thie we need add no tpre than one state, and one input s;rmbol, and we will at lmst have doubled the nunber of transition rules. Furthermore, Mr can be obtained from M by a direct transformation.
To shon that L regular + Lt e T, we sinply observe that
L regular + (tf)* regular'+ Lt e O-T =' Lf e T.
To ehow the converse, rre recall a coment made in 84.2 that L(O-T) = L(Fsa). Ttrue, if L is not regular then in any recognising machine for (tf1*, turna may have to occur during the parsing of each eubetring between eucceesive $ characters. In that case the machine cannot be finite-turn. D

96

Theorem 6.2

CD:C) > (D:Fea).

Proof

=Let L = L0{) c E*, where M e D, and ter L, il9,$1"$r",

where f, $, I r.

n=1
we shall shon thar there is an Mr e D recognising

L' that is only slightly larger than M, and that any procedure for

testing Lr e t(C) will autornaticalLy decide whether L is regular.

I{e construct Mr to simulate M repeatedln and to count the number of stringe from Lf read, by keeping a string An at the bottom of the stack, where A is a new symbol. Thus as in the previous theorem, whenever an accept mode of M is reached and a $ inmediately follows, the staek is emptied, but now onty up to the toprrost A, an extra A is added, and the starting oode is restored on top of this. liltren the $, characters are read, they are checked one by one against the Ate, and acceptance occurs iff they are equal in nrsber. Such an Mr can clearly be produced from M by a direct transforrEtion, and will not be much larger.

It renaine to show that Lr e L(C) iff t is regular. Clearly if L ie regular then a recognieing rnachine for Lt exiets which only uses ite stack to store the Ars. Thus Lr e L(C). Conversely suppose L is not regular. Any nachine recognising Lr must have an infinite set of pairwise distinguishable configurations reached

97
via input strings terminating with a $. If it is a l-counrer machine and L is not regular, then to recognise some words from L from any such configuration, the machine will have to enupfy iCs stack, for othenrise, regularity would be inplied. Ilowever once the stack is enpcied, all but a finite anount of inforrnation about the nrsber of inst:urces of L$ atready parsed, is tost. Thus Lf c LcC)" 0
Definition
ForalanguageLcX*: Sinit(t) =E*-LE+.
Lenrna 6.1
If L has the prefix property then: L regularc+ Sinit(t) is regular.
Sroof
Ci) Since SinitCL) is defined by regularity preserving operations, if L is regular then so is SinitCt).
(ii) If L has the prefix property then it consists of just those lrords in Sinit(L) ttrat are not proper prefixes of other worde in Sinit(L). Thus a finite state automaton for L can be obtained from one for Sinit(t) by sirnply removing all- states from wtrich any further strings can be accepted, from the set of accepting states. 0

98
Theorem 6.3
For any cl.ass Xo c Ro such that L(I's.)$ . LO(O), - CD!x^) > (D:Fsa)
Proof
Let L = t(M) c X* wtrere M e DOr and let Lr = Sinitct)$, wtrere $ I l. I,rle rnodify M by reptacing all x-transitions from accepting rnodee to ones co a special reject moder ard by adding a $ traneition for all reading nodes (other than the reject nnode) to a nelr node which is now declared the sole accepting trcde. Then this new machine, say Mr, recognises Lt, and so L(|,tr) is regular iff t ie regular (from Leuna d.1).
If L(Mr) is regular rhen, by definirion, LCM') e LQ(o). However' if L(uf) is not reguLarr then sinit(L) is not regular and so requires arbitrary large st,acks to occur during recognition. But from any such live configuration we e:(pect acceptance to be possible in M' with a further input of only a single character $. Thue L(M') not regular =t L(Ur) I L(Xo).
we can therefore concLude that L(ltt) e L(xo) iff t is regular,
and hence that
)@o :xo > (Do :Fga).

99
Ilowever, from property (i) in 96.1 we know that CD:xo) > (Do :xo).
Also, eince any test for the regularity of t$ for any L c E* can be used as a tegt for the regularity of L by the now farniliar arguuent,
we al"eo havc that
(Do :Fsa) > (D rFaa).
By the transiti.vity of the ordering the result follows. I
Theorem 6.4
(O:enpty) = (Dltotal) = @l:Do), where enPtYr total refer to the class of nachines accepting nothing, and x*
reepectively.
Proof
From the argument in Corollaxy 2.1 to Lenma 2'5 it is imediate that a direct transformation exists to nodify any machine M in normal form, to one that recognises exactly the conplenent of L(t{). It follows that emptiness and totality are equally difficult to decide in our sense.
To sholr that (D:enpty) > (o:Dg) we recalt that the latter is equivalent to teating for the prefix property. For any M e D

100
lte can construct en Mr consisting e88entia11y of two copies of the transition rules for M with distinguished state sets. These rules are mdified so that transitions from accepting rnodes in the first copy lead to the appropriate states of the second copy' The starting configuration of ilt is defined to be that of the first copy of M, while the acceptingnodes are those of the second copy. Clearly Mr accepts just those strings of t(M) that trave proPer prefixes in t0{). Thus testing Mr for emptiness is equivaLent to testing wh.ether L0{) e L(Do).
To see that (D:D') > (D:erytY) we observe that any M e D can be mdified by replacing all- the traneition rules from each aceepting node by a reading rute leaving the mode unchanged. Then testing this nachine for the prefix Property will effecCively test M for enPtiness. I
Ttreorem 6,5
(DrFsa) > (D:finiee) >(D:enptY)
Proof
Let L - L(l{) c X* where }t e D, and let L' = L$*. clearly M can be transformed to hecome a recogniser for Lr with little change in size. since L' is finite if and onLy if I is emptyr L can be tegted for emptiness by testing Lr for finiteness'

101

To show the other inequalitlr tre use the observat,ion that for

a dpda M', LOi') is infinite iff Mt has sone live derivation

that repeats a configuration, or has a repeated node in its sEacking

sequence. I{e introduce some nen stack synbols, an E, for each

Ai . I, and a special B.For each mode (srAr) we replace each rule
$_(s,Ar) 1T Cst,w) bI Cs{) 3 (sl,w) and add rhe rute (s,Ar) i 6r,{),

and also, if

it

is

an

acceptingrgd",

the

rule

(srAi)

$.,
-*

G*rn)

where

sa-

i.s

a

nelr

epecial

state,

rnd
$"

$" ,

$'l.,

are

nelr

input

characters.

I^Ie also add the transitions (srA) -5 (srl) for any mode with

t = r., or A = B, and add (surCI) to the set of accepting rnodes.

Aseuming that Mt is in a fo::sl never requiring to eupty its stack, it

can be verified that the mdified nachine jusr described will

recognise a regular set iff L(M') is finite. I

6.3 Comentg
We have only obtained theorems for (X:y) where X = D. However numerous corparable results can be derived by sinilar neans for X equal to various subsets of D.
Thus we can relate the realtime property, and the stateless property to regularity. If we define T1 to be the class of ordered deterministic one-turn machines, with only one state of ord,er zero, then we can show that (T:R) > (TI:Fsa) and that (T:S) > (T1-:Fsa). To do this, the construction we need for each Mr e tl is of an M e T that accepts the language

LO2
{ "$s$v I ey' L(M') } u { "$o$r1 | oy' L(M') }
rthere each cr, B is a turn*free prefix of LOtf). We note that despite the restricted nature of tl, our analysis of regularity (Chapter 7) gives no indication of this problern being substantially easier to decide for T1 than for D.
The equivalence problem is not a containment problen. Ilowever the above mentioned kind of argument shows imediately that it is no easier to decide for D9 than for D. For to test for LL = L2 in D, we could test for tr$ = lr$ in Do. Even more trivial-ly we notice that since enptiness is a particular instance of equivalence, it cannot be more difficult to decide.
I{e conclude by sumarising our results in the following diagram, in which Pl* P2 inplies Pl = P2, and each language is assumed to be specified by a dpda in normaL form.

103

ieL
sinple?

finite-turn?
I

one-counter?

ieL
regular?

isL
finite?
J

Fig. 5. ReLative Complexity of Containment problems,

Chapter 7

104
THE RXCULARITY PROBLEM

7,L lntrodgction
Ste"trr"2 shows that the problen of whether a dpda accePts a regul-ar set is decidable. To do this he proves that if a dpda of a certain form, with q states and t stack eymbols' accePts a regular language L, theo L is also recognised by some finite-state automaton' the statee of which nrnber no more than some E3 expression in q and t. I'leyer and Fisch.t2l gi.r. an example to show that under these circumstances a finite-state autonaton of n2 size nay indeed be
necesSary.
Our main reeult in this Chapter is to reduce the upper bound given by Stearns for this, by an exponential level, to an E2 function which differs from the lower bound of Meyer and Fischer by only a rnultipticative factor in the leading exponent. As a consequence ne can also derive an E2 tine algorithrn for testing dpda for regularity.
By siuilar analysie for the regularity of each of the classes R, C and S6we obtain distinct E1' expressiong, the orders of which in each case rre can show to be valid as both upPer and lower bounds.
Alnoet all the ideas we sha1l use can be for.nd in stearns' paper. llowever, in addition to the improvenent in the final results' the following differences are notertorthy.
Our proof is fot the general case allowlng arbitrarily long right hand sides in the transition rul-esr while Stearns considers

105
only conservative mechines with h - 2. Thus, although for some dpda q may have to grow et(ponentially when it is reduced to the h = 2 form, we shal.1 show that this is not a oource eontributing an extra e:cponential in the main result. Furthermre r our analysis will be directly applicable to' for example, stateless and dB-S machines (Chapter g), for wtrich equivalent consetltative machines do not exist in general.
Ttre notions of nuLl-transparent and C-invisible segments, introduced by Stearns, and the proofs of their existence in sufficiently large stackc, remain at the centre of the argurnent. tlowever, we have r.rnified the proof,e of theee theorems Cl,errma 7.2) by applying the technique used by Stearne for the one Cnulltransparency) to obtain the now improved reeult for the other (f,-invieibility) also. Our definition of the latter is a generalisation of that of Stearns, that contributes a further enaller iryrovement.
In addition lre are rather mre e:cpLicit about the phenomena that eonespond to regularity and irregularity respectively. ![e exhibit the fact that our main construction picks out a fanily of conputations that reeernblee a one-cotmter autonaton in structure and tras the sane behaviour vie-a-vis regularity.
We shall use the notation introduced in 51.5.

106

7 .2 Null-transparency dnd Sinvisibil-ity
It will be convenient here to say that, in a derivation c i (c) ct, r*rere q = o1ct2o3, "the o, subderivation pcips the segment urU" in c iff c * (of) ,"ruoJ) and (srtlo,5) * (oZ) (sr 'oqi) for some B, B t .

Definition

(srto) + (q) ct is a i-deritation w.r.t. index set N iff there are fewer than j pairs (nrn) of consecutive elements of N with the property ah.t ,rr' is popped by a non-null subsequence of d.

Definition

the segrnent trtf i" $!1g!g!!!g in (srutttttJ") w.r.t. index set N iff for any sr, and any l,-derivation (srutt^ttto") + (cl) (sr rtttlt), it is the case that (strttot) * (e) (s',o).

In other words, the existence of the seguent or can only be detected in the configuration by derivations which pop by non-null input etringe at least t, of the segments of o" induced by N.

Definition

The stack word o it @

iff for all- s e Q'

(s ,o) + (e) (s' ,0 ) * (s' ,o) * (e) (s' ,o) .

LO7
A null-transparent seglnent therefore has the property that if (ero) + (e) (et$) I then for alL n > l, (rrrt) + Ce) (st,n). Thue e-derivatione which PoP sequences of a null-transparent word are incapable of distinguishing different numbers of occurrences of thern.
Lema 7.1
If rrl ie null-transparent, then for all sr 01, no string a of length n can distinguish (srrtfl frorn (srttrt ) for mrm' > n.
Proof
Congider s derivations from the t\to configurat,ions. If these have at no stage popped the top n + 1 copies of r,r in the stack, then clearly they cannot be distinguishing derivations. However, if they have, then at least one copy of trl must have been popped by an e-subderivation. But then by null--transparency' the rest of the o seg@nts'rould al.so have been popped at the same time, without leaving any trace of their number. Thus we conctude that no a of length n can distinguish the given configurations' I
I{e now prove by an inductive argument the existence of both kinds of segnents in sufficiently tr arge configurations.
Lema 7.2
For a configuration c with stack r.l and an index set N of fr' etements all lese than lrrrll

108

(i) fr't q! + some segrnent of o induced by N is
null-transparent ,
(ii) F t l(gq)q + some segmenr of ur induced by N is 0-invisible in c, provided that Lrj. > 2.

Proof

For each part ne produce an inductive aesertion of the

form A(Pn'rNm) for m = 0r1r2..., wherep* c a finite set p, and N, . N. We show that A(PorNo) is true for Po = / and No = N, and that, it -% is eufficienrly large and A(prrNr) holds, then

either

Nm

already

induces

the

required

segment,

or

else

we

can

find Pm+l and N*, such that A(P*lrNrn+l) is true also. We

ensure that the induction terminates, and thus guarantees to

produce the required segrnent, by showing that Pm qE t*L

and that -Nm-+-'Iis

greater than sone given function of F_. m-

Then by

picking N large enough initially, lre can ensure that, though the

sete N, nay get successively snaller, they will always be large

enough to enable the induction to continue untiL P ie exhausted.

We take P to be Q, and the assertion A(PrrNr) to be:
irj e Nr, " . Pr* (sro-) * (e) (srn), Then A(PorNo) is trivially true.
(i) We agsume that A(PrrNr) is true, and that k and kr r the srnallest and largest elenents of N, respectively, are distinct.

109

Thcn if eK_rKr_' r is null-transparent, the result is proved. Othemise, by definition there erist srsr such that

(g) (s,r,rn,n, ) * (a) (s' ,0) , but (b) not (c' ,\,1r ) + Ce) (e' ,o) "

Thcn let N*, be the eubset of N,o indexing the most frequently

occurring etater Bay stt, in the popping sequence for (a) w.r.t,

N$-,

and let

PlE_t"I,

=

P_ m

u

{e"}.

No state in this popping sequence

q4n belong to Prr for that would iryly, by the inductive assertion,

that I| = srr . Pr, which would contradict (b). Thus it follows
that Pr Pm+l, and then aleo that Fr*1 =F*/(C-m), for m ( g. A(u*rrNr*1) ig then clearly true. Also, if fr'= Fo t Q!, the

induction can continue, if necessaryr until P, erhausts Q, without

"r"t

F- < 2 occurring. This completes the proof of m

Ci).

(ii) We assume that A(Pr,Nr) is true, and thst k and kr, now the srnelleat and eecond smallest elements of N, respectively, are dietinct. Then if utrk, is 0-invieible in c, the result is proved. Othenriee, by definition, there is some a-derivation that i3 an .0-derivation rcndering it visibl1 i..

(a) c * (o) (stroorkf),

but (b) not (s t ,rrto ,U, ) * (e) (s t ,t^ro ,n)
From the c derivation extract the e-subderivation that poPs the rc8t Begrnnts induced by Nrr and let Nt*l b" just those indicee inducing theae segmnts. Then, by definition, Ft*, > tF -flll.

110

No etate in the popping sequence induced by fr'rr*t can belong to

Prr for that w,ould contradict (b). Let s" be the nost frequently

occurring Btate in thie sequence, let N*, be the set indexing

theee occurrences, and l-et P*, = pr, {s"}. Then Nntl > Ntr*l /(g-a),

Now if

fr'= f^ o

> 0([q)Q irriti"lly,

the induction will continue

eucceggfully until Q is extrausted. [l

Note 1

The bo'nd for (i) of q! is the same as that of stearns. rt can be ghown to be optimal by looking at Begnents that are e-popped fron all stateg thereby performing peruutation operations on them, and regarding these as elements of the symetric group on q e1ement6.

Note 2

rn the main theorem we sha1l be interested in c-invisible segnents, where.Q, is e:(ponential in g. rt is here that we gain our most eignificant iryrovenent, by obtaining a bound of order (gq)q as compared with one of oc+9 given by stearns. rn general, if.0 is of larger order than q, we can ehow that our bound is of optimal order tn the fotlowing sense. A dpda can be derived from rhe proof of 7.2(ii) with the properties that for some configuration and index set of size (llq)9, no .t-invisible segment can be found.

t11
7.3 Main Theorem
Theorem 7.1
rf l'{r a dpda in norrnar. form, has q states, t stack syrnbols, a-nd stack words of l-ength at most h in its transition rules, and if t(M) is regular, then L(!"1) is recognised by sone finite automaron with fewer than X(qrtrh) states, where X is of order E2,
Proof
I{e shall prove that there is a function ycq,t,h) of order E1 such that, if any reachable eonfiguration of M has height greater than Yr then either we can cut a segment out from the stack to obtain a small-er equivalent reachable configuration, or el_se there are input strings 6r$, s.t" the configurations reached after inputs of orol for m = Lrzr... are all pairwise inequivaLent, Thue if L(M) is regular, the first possibir.iry musr always hoLd for configurations larger than y, and consequently M can onLy be using up to qtY painvise distinguishable configurations in recognising the language. fhis gives us the required result,
To prove the existence of Y we consider an arbitrary derivation cI -*c= (errrr), lrhere l*l = n > y(qrtrh). tle let N be the set of f"ntegers indexing the most frequently oecurring rnodes in the staeking sequence of this derivation. Then cLearly f > n/qth,

I I I
f
I
t
I I I I I
ot
I I I I
I I
1
I
I I
I I

tL2

I
I
I
t
I
c2l
IjI
I
crJ
I
I I
I
.,
I I
I
)I
I
t
I

nu11-transparent
segment
invisible
segment

r
(It
I I
I t
r
(I
I
I

I I I
L
I
clt
I I I
cir
rY
I
o
I
I
I
I

a,
K TIII
o.KrE ct
K TID ct
K rlll c,
K rlll

iterations of
nul 1-transparent
segment

Fig.6. Constructions in Proof of Theorem 7.1

113

rf N is large enough, then by Lenma 7.2 (ii) , we can find a segrnent

o.:, in it 1J

that ie (qgl)-invisibl-e in c

w.r.t. N. Furthermore, by

the choice of N, the configuration ct = (sroorirjrr) is reachable

from cI^ via the input string ou^ra10jr:D_. I^le shall_ prove that if t(M) is regular, then c lct. For siruplicity we shaL1 not nodify the

indexing of the segments of the stack in the translation from c to cl

(e,g we shall still refer to the top s)mbol of ct m rrr-r,rrr.

Suppoee c I cr, and let I be the shortest string distinguishing them. Then by the construction of ct, for some yrr1 s.t. B = yl,
c * (V) (strt'lori) where thie is not a (qq!)-derivation. It foll-ows that we can pick an Nf c N of at least ql + t integers between j and n with the properties that
(a) no segment of tir induced by Nt is popped by an e-subderivation of y, and
(b) the elements of N' all index identical states in the popping sequence for y.
lle now pick a null-transparent segment ,Or, irdrced by Nr in ,jrrrr as guaranteed by Lemra 7'2 (i). We define sone nerr configurations to do with the popping of this segment in c and cr:
c * (trrrr) "2, .z * (v*rn) "1, c' * (trrro,) .i, .) * (v*,n) ci.
Since yn is a minimal distinguishing string for c, ct, yr,jn must be a mininal one for "2, "Zr, and ykrjn for ca, .i. Since, by the construction of N', yrrk is non-nu1l, ylrj .rU t*rj rr"a be of different lengths. Ilence it is impossibLe rhar both c, = c, and ci = cj.

114

I.lithout loss of generaLity we shall assume that c, * c2,

We define the farnily of configurations'{rclr

> oi b-y cs- f

1'*oo,k*,k:

)
rrn

r".

By the choice of NrNt the top part6 of the stacks of these will consist of

iterations of the null-transparent word. If we let {, = orrryrrr{,n

forr=0r1r..., then

r+'-1c-]Ec2r an.d rc *E"1r forr)0.
Thus c, I c, =t t" l t*1" for all r > O. From thie, and the nu1l transparency of ,krr, we can now deduce that

t" I l*t" for all r > o, I > o.

For if ate aseume othemise for some t, L, and conaider the effect on the configurations x'c+r" of inputs olr, and onrr, fot successive
values of x of Orlrz..., then lte are led to deduce that

x'c*t" rc
=

rnd *l*t*l"

t*1"
=

for

all

x)

o.

Howeverr by Lenma 7.1, the shortest distinguishing string for t", t*1" cannot distingui"h *0+r", xf,+r+l" for sufficiently large x.

To sr:cnmarise, the assuqtion c f ct has forced us to the conclusion that the configurations'{rc} (or a corresponding set constructed from ct r)are all reachable and pair*dse inequivalent. Thus for regularity it must be that c = ct, which is the result we
want.

From Lema 7.zGD we recall that for the above construction it is sufficient that fr b" gr"ater than (e2q!)q*l. Therefore

1L5

Y(q,t,h) - qth(q2q:)qnl
is the function we requirc. This is of order fI(tog 6 + 1og h * q2 lcg q), and hence X(qrtrh) is of order r21tog t + log h + q2 log q)" il

Note 1

Meyer and Fisch.r2l

that for a certain one-turn dpda wittr

"hoo,

q = t and h = 2t utl equivatent finite-state automaton requires r2(q)

states. The bound obtained by Stearns for X is of order s3(q * log t)

for the case of h = 2.

tilote.l

We notice that the family of configurations {rc} exhibits phenomena strongly reminiecent of the notion of propriety in onecounter automtte. In particular, they are either all equivalent, or all pairwise inequivaLent,

7,4 Bounds for Subfanilies

!,le now give irnproved upper bounds for the function X for three restricted families of dpda, and show in each case that the order sf ttee hound ie achievable.
For the classes Sg and R, since eltpves no longer play a part, the above analysis becomes trivial. From the definitions in 57.2 it is imediate in such cases that N > L is sufficient to induce a nuLl-

116
transparent segment, while N > l, + 1 guarantees an l,-invisible one. Substituting these in the above argument gives the fol.lowing:
-C*orol-lary 7. 1 For the class Sg there is a bound X of order fl1ht.l"og t).
CorolLarv 7.2
For the class R there is a bound X of order nl(nq2r.1og r).
From Len'rna 5.4 it can be easily deduced that for C with the rcsniction h = 2, the bound q. (S(q) + pf (q)) suffices, where the dominant factor, S(e), is of order El(/alog-q ). We can obtain a eimilar bound rnore directLy as fol.lows.
Corollarv 7.3
For the class C, with h = 2, there is a bound X ^, q2.S(q),
**:ngre
S(q) = lrrx {i"c,ru in1,}1l' in- = q},
Proof
Ler {xri be the set of net staci( drops due to loops of e.ru*ves in the di.agrann for non*enpty counter transitions of the

LL7

machine M. It follows i&nediately that any stack segment of
length
x = max {g.c.m.{x.}, q}
will be nuLl"-transparent, where, rnoreover, x S S(q) since the e-loops must be disjoint.

I^Ie can then obtain the claimed bound from the construction in Theorem 7,L Lt we also observe that any jderivation (w.r.t. the positive integers) popping a segmenr longer than jq must fini.sh within an e-loop" I

We now ehow that the order of each bound is achievable in both of the genses defined in gl-.6.

Exanple 7*L

Let M be a sirnple machine with t = aU, fB, where

fA =' {A.lr = i < m}, l, = {Brlo * i < m}, with x = tailr s i < rn] u {arlo e rf,}, wirh ", = Bo, and rransirions

a
BJ, $

sBr., J+T

C < j ( s1

B -9--t A m
A" *la-,+ A J

lsj<n

Clearly the stack has to grow to height nm + L for B, to be reached
and the turn to occur. But there "r" rtt distinguishable reachabLe configurations of rhis height. Since L(M) is evidentLy regular,

l_ 18

this shows that X of order fI1nt.log t) is achievable. !

Exanple 7.2

I.Ie construct an Mf e & by generalising the previous exarnpLe in the following way. We introduce a state set Q = {.or...rk}, eugment I by a synbol g, repLace c, by (sorB.) and F by {(s"rfl)}, l"eave the input alphabet unchanged, and replace the transition" rules by

(s'Br)*,tar*l,r'rBl)

osi<k,

a
(ri,Bj) --l!-* (si,oB5+l)
(s*rB*) atr (sorcorBl)

o < i < k, 0 < j * r,

a1
(so,Br) --:> (sk,A)

(sirA3) *-6.J* (si,A)

O<i(krO.j.m,

(s1C) ---9'* (s.-1,4)

o<i<k.

Th:i,o again is a l-turn machine. After the turn is made in a ctrer:h"ation, the rernaining string i"s accepted iff it natches the staek contents, and there are exactl.y k occurrences of C in the stae[a,, Thus the turn has to be made when there are about k2rur symbols in the stacko since each e is added after successive segments of length kurr" fhus L(Mt) is regular, and Mr has order f11nq2t.1og t) distinguishable eonfigurations " I

1" 19
Exanple 7.3
Let {xrr.".**} be the Fartition of q * 1 with the greatest least comnon nnulti"ptre. Let M e C read a string frcrn a* and increment the counter by one for each a, while staying in the starting state" Then if a character i frorn {1,"".n} is read, an e-Loop wi.th x. $rates causi-ng a stack drop of x' is entered. A.ceeptance occurs iff the contents of the counter at the turn was divisible bY xn' Such an M wi.th q states clearly exists, and recognises a regular set. lloweveru after each input of am it needs to know n(nod y) for y = *tn..rxn. This requires S(q) distinguishable configurations. fi
7 "5 Tigq Camql.qxitv.
To test- a language accepted by given dpda for regularity we can constrrrct the candidate finite-state automaton speeified in the proof of fheorem 7.Lr say Mr, and test for their equivalence. Since this last test can be done in polynomial time (92.5), and since M' is of E- size, to show that the regulari.ty test i,tself takes no more than E^2- timeo it ::earei:r,s to show that the construcf ion of I'lt can be done I..*n2!; tlme.
The states of Mr *orresponcl to the no nore than E2 configurations of M of height less Lhan Y. To construce Mr the on1-y new transitions we need are those that specify for each configuration just larger than Yr the (qq!)-invisible segments with respect to the appropriate index sets (57.3)r that can be rerreved from their stacks. For each segment

L20
or of o, lre can determine the set of pairs (srst) with the property that (sro') * (a) (st rO) for o f e, and also those for which cr = e. The poasibl-e ways of reaching each point in the stack by (qq!)derivations can then be deduced, and hence the invisible segments found. To do all this for all the tr2 configurations requires only E2 time.
In a eimilar way, the bounds for R. and C give single exponential time tests. However for Rg1 and hence aLso for Sgr regulariry can be tested much more easily, and in only poLynomial- tine. If in M e Ro an aecepting derivation goes through some configuration c with height greater than hqa't, then for some pair of levels repetitions must occur in both ehe stacking and popping sequences respectively, of the derivations before and after the occurrence of c. This would irnpLy that accepting derivations can go through arbitrarily Large configurations, and hence' by the restrictions particular to the class R0, that L(M) is not regular. Since the converse of this is obvious, we conclude that bte can test for regularity by testing whether, once a stack leveL
.,
exceeding hq-t has been reached, any further inputs lead to acceptance. This requires only an emptiness rest on a polynomiaL size machine.

121
IV A}I A?PL]-CATION TO SCTM},IAS
schemas are direct formaLisations of coinputer prograns, and closely resemble them in syntax. Their essential characterisation is that the meaning of the conrnands is left undefined. The theory of schemas relates the description of such a formalised program to its possible computational effects once interpretations of various kinds are given to its uninterpreted comands.
The relaticnship between certain schemas which have just one working register3 and automata with one-way input tapes, is now well known. Rutledget, " has established a elose connection between one-register flowchart (Ianov) schefiras, and fi"nite-state automata. When such schemas are augmenteetr by a pushdown sta.ck, lhe correspondence transfers to deterministic pushdown autornata" This corresponclence is such Lhat, as il"l.ustrated by Patersonl3, an equivalence test for a subfamily of this class of automata leads directly to a test for strong equivalence (in the sense of Luckham, Fark and Faterrorr23; f,or the corresponding class of schemas. Thus, for exampler our result in Chapter 5 implies that strong equivalence is decidable for lanov schemas with an auxiliary counter. trn an analogous way, the regularitl' problem corresponds to the question of whether a tranov schema with a pushdown stack is strongty equivalent to one without a stack.
As the translatabiliny of such decidability results from autonata to schenas is direct, and depends on a well estabtrished techni{r"l3, we shall not pursue these further here"

t22
In contrast, holrever, the complexity measures for these problems do not necessarily'translate directly. For exampLe, a canonical dpda for some such schema may require to be of exponential size in terms of the parameters of the schema description. For this reason rre shal1 investigate the coupLexity of just one of these problems, for a case which is of special schema fheoretic interest.
Monadic functionaL (deBakker-scott) ."h"r.r13 ,24 t25 are a f,ormalisation of recursive programs with a single working register. Faterson26 h", shown that for some such schema there does not exist an equivaLent flowchart scherna with any finite nuriber of registers. This ean be interpreted as corroboracing our intuitions about the increased poner of recursive notation. Other examples are known whieh can be flowcharted, but not with a single register. tr{e shall now elaborate on these relationships by considering those monadic ftrnetional schemas that do have equivalent ranov schemas, and giving a measure to the subetantial succinetness with which soup large Ianov sehemas can be re-enpressed by equival-ent srnall ftrnctional ones. In particular, we shaLl show that sorre functional schemas require an equivalent fLowchart to be of a double exponential (r2) size in terms of {es original parameters. Further, we shall show that they may not require larger flowcharts than this order.
Thus we shalL be giving a theoretical resuLt to correspond to our f.ntuitive knowLedge about the considerable econony of description that can sonetines be gained by recursive notation.

L23

Chapter 8

UONADIC FUNCTIONAL SCHE}{AS

8.1 Introductisn
In our definitions we shall- in the main follow Ashcroft ' Manna and Pnueli24, tho give iLLustrative examples and rather more
detaiLs.
e d!:S_gg@_ has a finite set F,of, t., monadic fungFion variabl-es {F-. } (with a distinguished initial fqnglrg4 F^), a finite
t.
set f, of t monadic function constants {f,}, a finite set of g rncnadic !f,e4:Sgggg. {pi}, and an individual variable x. A term is a cornposition of functions applied to x' e.g. ttFZ(f ,(x))) which is written aB f,iF_2^3f. for short, omitting -the brackets and the x. A conditional ter:n is any finite expression of the forrn
if pi then t, else t,
where 11 , ,2 are terme or conditional terms. The schema itself is
specif ied bya set of function definitions, one for eac.h F. , of the
form
F.  r 1
where t ie some tern or conditional. term. It is useful LU reserve the nane 1 for the idenrity funttion (I(x) = x) r and l.-, for the undefined iunction (F* e F-) "
The schena is evaluateC in the expected way by starting from fo(x), and appLying the rightmost function variable each time to the argument (i.e. to the string frorn f*x to its right). The only

1"2t+

further information lre need to define completely Ehe course of such an evaluation is to specify the val"ues taken by the predieates each tirne a conditional term has to be evaluated. Thus an interpretatiog specifies the values taken by the predicates for each argument, and we assume that it does so uniquely. Thus in eval.uation steps in which no function constant is applied to the argument, the truth values of the predicates cannot change. In other words, hre ean regard an interpretation as a function from f*x to 6 =' {-, +}9, where - and + indicate falsity and truth
respectively.

Since each interpretation for a schema uniquely specifies an evaluation, it defines a string (possibly infinite) of the form:

6 f. 6. 0111o1

t.

....

where 6, is the truth vector defined by the interpretation for the J
ergunoent

t.tj-t .... f.tl t.t.o x.
Conversely, each such string describes the step by step eval-uation of a function, as well as a set of interpretations.

The schexna for a partieular int,erpretation is said to have a defined vaLue if and orrly if the eval-'-retion terminates producing a germ containing no more function variables. This term, consisting of only function constants applied to x, is then the defined value.

L25
8.2 Eval-uating Pushdown $rtomatg
A dpda M can be easily eonstructecl to evaluate such a functional schema. At each step M keeps all the unevatuated functions (i.e. everything to the Left of the argument) i"n its pushdown store, with the rightrnost function variable at the top. It reads input words from (6f)* i.e. strings of al,ternating truth vectors and function constants.
Wtren there is a function variable at the top of the stack and a truth vector has just been read, the variable is replaced in the staek by the term specified by the corresponding function definition for the truth values read. The vect,or is remembered in the finite state control, and these repl"acements continue in accordance with it, until a function constant first appears at the top of the stack. This is checked against the next symbotr- on the input tape, and rejected via a F- replacement if it does not match. Otherwise, the function constant is popped (and can be regarded as being output and appLied tc the previous argumentr) and the next 6. is read. If further function *en-stenes then appear at the top cf the staek, ttrey are similarLy c.hecked against the input tape! with the intermediate truth vectors on the tape bei.ng ignored"
The dpda M ctarts with F i"n its stack, and accepts strings 0
by enpty stack. Then elearly any tape accepted by it wi1l specify the vaLue taken by the schema for all interpretations consistent with the tape. Also, the language recognised from an arbitrary configuration

L26

of M wilL relate in the same way to the values taken by the corresponding term in the schema for different interpretations' Fron this it fol-Lows that two configurations of M are equivalent in the automnton sense if and only if, for any interpretation, the trro corresponding terms in the schema either evaLuate to the same value, or are both undefined. Thus if M has only a finite number X, of pairwise distinguishable reachable configurations, then the scherna can be rewritten as a lanov schema with X boxes.

By examining the dpda M we have just described, we find that it can be constructed to have the following parailEters:

t=t+ttc v'

h=hr

where trr is the l"ength of the l-ongest term in the function definitions,

p=28*t",
q = 28 + 1'
I{e notice that the only kind of memory capacity Ehat M needs is that of being able to remember the Last input character read. The suhclass of Dg with thi.s property we shall denote by dB-S. I^Ie note that the evaluating machine M is a special form of a dB-S machine, sinee a subset, f, of its input alphabet need not be distinguished in nernory, and also no element of f, regarded now as stack syutbolst can be e-popped. That dB-S is itsel-f properly contained in Dg can be verified by examining the language { anb"t } u { anac?n },

L27
8.3 dB-S Autonata
The above mentioned restriction on memory implies directly that for dB-S nachines, states eaRnot change in the courge of e-derivations. A consequenqe of this is that a simplified analogue of Lenma 7,2 car. be derived.
Lema 8.1
For a configuration c of a dB-S machine, if c has stack til, and N is an index set of fr- elements all Less than l.,rl, ttet
(i) Any segrnent of o is nulL trensparent, and (ii) If F > 2.Q,t, where l, > 4 then some segment of
(,) induced by N is .Q,-invisible in c.
Proof
(i) Trivial. (ii) Using the sarne notation as in the proof of
Letma 7.1'
I{e apply the induction principle there stated. However, no!il we chooee P = I and the inductive aseertion A(PmrNn) to be
irj e Nrr A e Pr+ A does not occur it rirj. Ttren A(PorNo) is trivially true if Po = 6 ar.d No = N. hre then assume that A(PrrNr) is true, and that rrrt, the smallest and second snallest elenents of N, are distinct, tt ,rrr, is

L28
0-invisible, then the desired result is proved. 0therwise there must be some o-derivation that is an l-derivation rendering it visible i.e.
(a) c * (o) (s t rr^ro., r)
but (b) not {e|,oorr,) * (e) (st,oorr).
We notc that this second condition now necessarily iurplies that oE-rE-r cannot be e-popped at all fron the configuration (str'uro^rt-',). Let N*, be the Largeet subeet of N* induced by the popping sequence of an e-eubderivation of the o derivation. Then fr.*, > (Nm-l-)/1,. This e-derivation must eventualLy terninate when some Af in the stack is reached. Furtherr this occurrence must be at a higher level in ur than r, whieh means that Ar I Pr" Atso, Ar cannot occur in any Begrnnt induced by Nnrl, for then that occurrence could not have been popped in the sane e-derivation. Thus, if Pr*l = P*, {At}, then A(Pr*lrNrn+l) must also be true. To ensure that the induction can proceed, if necessary, untiL l ie exhausted, it is now sufficient that fr' > zr,t. n
In the light of this we can rework Theorem 7.1 to obtain the fol"loring.
Lerma 8.2
A dB-S dpda recognising a reguLar set can have no more than X = E7'(t.1og q + 1og h) pairwise inequivalent reachable configurations.

L29
Froof
Wc use the same notation as in the proof of Theorem 7.1. Flav$.ng ehosen l{, we now require oni.y a q-invisible segnerrt indrrced by !i. Fcr then, usi"ng the shortest distinguishing string g, assuming 8rlaf. i"t exj-sts, we can find a nutt*transparent segrnent induced by N such rhat the B-subderivation that pops it reads sone inprrt, but lre'e's nsf cause a net change in steee. This is the construction we require* anei, frenn Lenmna 8.1.n it clearLy works for any confi.guration of hei-ghe greater than YrwhereY is of order 2hqtqt. This gives the required trotnd for X. I
m-s"
Th{"c shows that the dB-s restriction reduces the q-dependence *f, the l:o'urd x from a double to a singl"e exponential expression.
8,1* Bgqnllq*g rsuccinctness
Freim Lenuna 8.2 and the observations of 58"2 we imediateLv
e'l.1.Vg
Sbes.gss" -E-*L
For a dE-S sohema wi,th t funeti.on syrnboLs, g predicates, and terrns of !.ength no more than h f,n its fr,nction definitions, if a l-anov schema strongly equivatenc to it (i.e. under all interpretations) exisBsr then the !.atter need have no more than order n2Gg + 1og h)
howss, [,-l

130

It remains to show that an E2 order of size rnay indeed be
neceSaary.

Theorem 8.2
For each positive integer n, there is a dB-S schema with 3(n+1) function synbolsr f, * 1 predicate symbols, h = 2, and with total description linear in n, that has strongly equivaLent lanov schenas, hut only of size at least n2(rr).

Proof

I{e use the same idea as Meyer and Fisch.t2l ,rr" for their corresponding resuLt for dpda, and show that it can be made to work even in this more restricted framework.

For each n lte construct the following schema with fr.nrction
variables {For tir...tlr ti,...ti, !t,...1r,}, fr:nction constants
' {f*, f-} and predicate"' {prp1r...prr}:

Fo  lf pt then (if p then tl to f+ el'se ti to f+1 else 'f p2

else if p' then (if p then F+ to t* else F- Fo f*)

eLse

F+-+f
t

.

F+:  i.f p, then I else "f p2

. . else if pi-t then I

else if pi then (if n then \ f+ else I)

eLse if pi*l th"t F-

. . . . else 't Pn then F-

else I.

131

F.  if pl then I else "t pZ

. " el"se if Pi-l then I

else if pi then (if p then I el-se F. f )

etrse if pi*1 then F* .

. eLse 't Pn then F

el-se L.

&. * if p, then I'- eLse 't pZ else I.

. . else 'f pi then F

Ler *= nin' i j I rrttf*tj) is false for 1 < i < n ] for a particular interpretation. Then the corresponding evaluation will consist of taro partsp the first one consisting of m appLications of the F_ definition, and the second only of appLications of the others,
o
The first part produces an unevaluated term which is a string of l-ength m over rhe function variables irj,...tl, F;,...t;), whiLe the second nonotonically shortens this, unless an F- occurs.

Changing tG our dpda eerminology, we notice that we have a l-turn
machi"ne which, depending on the inputl cdrl read any word from {-t+;.r...Frr, Flr...trr}* into the stack on the uPstroke. Denoting by b *ny trr-lth vec!:or such that p1 = Erue, but p. = false for j ' k, we observe that each fl1-Ior Fr- as e-popped by k if k < i, and leads directly to rejection if k.'i. If k = i bgt rhe sign *i F. does not rnatch the tru8h vslue *f p, then the syr:bol is again e-popped. However, if there
J"s mlat,ching, ,;hen the apprcpriate one of f+ of f is "evatruated" and the next trurh veetor is read from the input tape (i.e. the "interpretat{.or:"'} ' Leaving q *t the top of the stack, The rol.e of li. it to insist that the next vector be k for k > i.. Thus in the downstroke no more than n truth
u-reeeffr's, aud n furrction rii:rrr$tiri"its e,nn he readu from whieh we deduce that

L32

there are only a finiCe number of inequivalent configurations in
such a machine.

To see that this number is, however, of order E2(rr), t" show that for any of the 22t r,rbr.ts of {r*, f-}o, there is some configuration which can evaluate, depending on the interpretation' to everything in the subset but to nothing in its complement. We observe that any such subset can be represented by a binary tree of depth n with branches marked by a sign from {+, -}. Furthermore any such tree can be represented by a string from {t;r"..F*, F;r.'.F-}* in the following polieh notation: Each Fl represents a Left branch from rhe (i-l)th to the i-th leveI of nodes, and f] a siurilar right branch. fire string itsel"f is the expansion of the tree from the O-th l-eve1 (the root) by the foi-Lowing recursive process:

<tree.> + <branchl> <branchlt, O < i < n
111

<tree >
n

+

A

<branchl> + A I tl*, <tree.+l>, o s i < n

<branchl>
L

*

A I' rl1+I-

<tree1,+I-),

O<i

<n

Any string generated from a!te6> defines the set of paths in the tree that go from the root to n-th l-eveL nodes. It is easy to verify that the eval-uation of such a string by our schema corresponds exactly to tracing a path in the tree it specifies, and that the possible final values such a string can take correspond to the paths in this tree. I

133
trle have therefore esrablished rhat the sr.lccinctness rueasure we are i-nvestigaEing involves two l-evets of exponentiation' lle note, however, that, in the above example g and t cannot be varied independentLy. Thus to obtain more deuailed results for uhe leadi-ng exFonent for the different combinations of parameter value$, furEher analysis is necessary. For exarnpteo in the schema above, we eould have economised on the ntrnber of predicates used, aE Lhe expense erf greater comptications in description' to obtain a sii.ghtly better result for one partieular such c:t6.

134
COI{CLUSION
l,Ie have shown that the various deterministic families of pushdown autonrata are rich in decidable and potentiall"y decidable properties. In doing so hre have also indicated areas outside automata theory to which our results relate.
Several weLl motivated decision problems have been left tmresolved. Moreover, even for those shown to be decidable, the derived procedures usually require at least exponential time. As we do not know of any arguments to show that polynomiaL time aLgorithms do not exist for these, important gaps remain here al-so.
lrle can, however, single out from among these open questions the ones which appear the most inurediate.
Finding an equivalence test for the unrestricted class of deterministic pushdown automata nas the primary unachieved goal of our work. Although the existence of one can perhaps be now conjectured with considerabLe confidence in the light of our results, a proof of this would still be of great interest, for the additional insights it may pro'.ride. It appears plausible that techniques related to our parallel and alternate stacking constructions, and our simulations by nondeterministic pushdown automata, wi1L play a part in settl-ing the probLern. Our work suggests that the resolution of our conjecture about aLternate stacking for the class \ r and the finding of an equivalence test for the class S, My be significant next steps to that end. A positive solution to the latter problem, which we have not investigated,

rj5
also appears to be a prerequisite for finding a test of strong eguivalence for deBakker-Scott schemas -
For the regularity problen, since we have improved Stearns I test, to a near optirral level, to achieve further improvements a new approach is necessary. The relationship we have established between this and a number cf containment problems which are currentl-y open, can be interpreted as a trto sided challenge. In the abse:ree of a more efficient regularity test, it hints that if these other problerns are decidabl-e, then it may be difficult tc prove them to be so.
We have not given much attention to the inclusion probtrem because of ttre welL-known negative results concerning it. However, since sre ha"rq proved its undecidability for even a very restricted case of R6 , a resol-ution of this probLem for the sinrple machines Sg
seems mcst t.imeLy'
Thus our work suggests that there remain numerous distinct fealures of fhe strlrcture of these classes of automata yet to be uncovered, and indicates some speaific directions along which these might be sought" The rer'rards E:f this search will be' we betieve" to increase ottr understanding of these computations, and to i:ender particutar instances of them more susceptible to practical
analysis.

136

REFEREI{CES

tt"l l2l t3l t4l t5l t6l 17) t8l t9l
t10l

GINSBURG, S. and GREIBACH, S. A.
Deterministic Context-free Languages.
Inf. and control, 9 , 62A-648, (1966).
STEARNS, R. E.
A Regularity Test for Pushdown Machines. Inf . and Control, !!, 323-340, (L967). HOPCROFT, J. E. and ttLLl4AN, J. D. Formal Languages and their ReLation to Automata. Addison-Wesley, Reading, Mass. ' (L969). GINSBURG, S. and SPAI'IIER' E. H. Bounded Algol-like Languages. Trans. Amer. Math Soc., L13' 333-368' (L964)
McNAucHToN, R.
Parenthesis Grammars. JACM, 14, 490*5oo! (L967).
RABTN, M.O. and SCOTT, D.
Finite Automata and their Decision ProbLems. IBM J. Res. 3 : 2' LL5-L25, (l-959).
BrRD, M"R.
The Equivalence Problem for Deterministic Two-tape Automata. JCSS 7, 218-236, (L973). ROSENKRAI.ITZ, D. J. and STEARNS, R. E. Properties of Deterministic Top-Down Grarunars. Inf. and Control. L7,226-255' (1970). KORENJA,K, A. J. and II0PCROFI, J. B.
Simple Deterministic Languages . IEEE 7th Synrp" on Sqri.tching and Automata Theory'
Berkeley, California' (1966).
I(ARP, R.
Reducibil-ity Anong Combinatorial Problems,
in Complexity of Computer Computations (R. E. Miller and J. I,f. Thatcher, eds.), Plenun Press, N'Y. (1972).

t 11.1

Oi{tn{urtlhr e"

lt.
translation

of

Languages

from

left

to right.

Inf. and Control, 8, 607-6390 (1965)"

[12i

HARRTSON, M. A. and HAVEL, r. M.

Or, a Fanily of Deterministic Grarnmars,

in Aueomata, Languages and Prograrming (1"1. Nivat, ed.),

brorth-trtc1land, (1973) .
[elso three more detailed reports; Department of

flornputer Science, University of Cslifornia, Berkeley.i

il-31

PATERSON, M. S.
Decisinn Problerne in Cornputational Models. Pror:. of ACM S:rrnp.on Froving Assertions about Programs, Las Cruces, New Mexico , (1972) .

[14]

ciroMSKY, N.
Context-free Grammars and Pushdown Storage"
Quart. Prog. Rept" No. 65, MIT Res. Lab. Elect., LB7'L94,
(te62) .

[15-1

GREfBAc]i, s. A" A- New Normal. Fonn Theorem for Context-free Phrase Strrrcture
Grancnars.
JACM, U-, 42-52, (1_965) "

t16J

ii.j-l{SKY, M. L.
Comprrtation: Finite and Infinite Machines. Frentice-Ha13., New Jersey, (L967).

t17l tl.8:l

tsAR-IITLLEL, Y", PERI.ES, M" and SI{AMIR, R. On Formal- Properrties of SirnpLe Phrase Structure Grantnars, in Y. 8ar-Hi1Le1,, Language and Information,
Aeiuisuri*WesLey, F,eading, Fla$rr., (1964i "

E.F R"TESMA$I,

R.

Tn* k*. ].'L;s:;,eir Prerbienr f*r Mor:tarii-e R*,:i:rsion Sc.hemes'

B"*pnrt-u Center for Res*, ar:ch iri Conputing Technology'

Ilar."varr: Ljni.versitl'. r (1i73) .

t19l

4TNSBURG, S. snd SFAN{ER, E. iair'ite * Lurn Fuehelor*n Autcngta SIAI'I J. on Control 4, 423'434", (i.966),

tzO-l

vA{,I.A}iiTo L. G. and PA'rERS0}I, M. S.
Deterministic One-Counter Automata.
Iroc" ,lli Conf , otri &trtnnrata T'heqrry and Formal Languagest
Bon.ro Gernany, (i-qi3)r.

138

i21l MEYER, A. R. and FISCHER, M. J. Economy of Deecription by Automata, Grarmnars, and
Fornal Systems. IEEE 12th Symp. on Switching and Autonara Theory, (1971).

122)

RUTLEDGE, J. D.

On lanovts JACM 11, 1

P- rogg,ra(m19S6c4h).emata.

l23l t24l

LUCKIIAM, D. C., PARK, D. M. R. and pATERSON, M. S.
On Formalised Computer Programs.
JCSS !, 220-249, (1970).
ASHCRoFT,8.,l,tANNA, Z. and PNIIELI, A. Decidable Properties of Monadic Functional Schemas. Int. Symp. on Theory of Machines and Conputation, Haifa, Israel, (1971).

t25l

DE BAKKER, J. t{. and SCOTT, D. A Theory of Programs. Memo. , L969.

1261

PAIERSoN, M. S.
A Sinple Monadic Recursive Schema which is not Equivalent to any Program Schema. ,Memo. 1"970.

139

APPENDI X TO SECOND TI"IPRESS ION
;.j.trce this rcport was first issued several

iaesl-i.r1,.s ha',.e been ob';ained that relai.e directly Lo its

conLents

f.iere we drarv att.ention to some of these: frr Chapter 2 iL was shown that an arbltary

dpda can be converted to one in normal form by an

qA-l.'r-vrilhnr

]L_>ql^lir-rrv

yvt.:/lrrnata!\iJ-rlltL<aL *uiqrra:is

\/ a--- ^unPnpnvcrEodu

lL-nv tLhrors

;lnalogous exponential time construction of Hopcroft and

U1.l man-1 ) . It has since been shown by the author that the

conversion can be done in linear time on a random access

nachine. This strenqthens t.he force of the reductions

given in Chapter 6. I^le note that an algoriLhm requiring

quadr:atic time has been reported by H.B. Hunt and D.J.

Rosenkrantz (Computational paralleIs between the regular

and context-free languages, Proc. 6th ACM symp. on Theory
of Computing, SeattIe, I974) .
The construction used in the undecidabilitv
,arl\r)r irr r-h-rnlsy 3 (i.e Theorem3.4) has been used by
I
ii.P. l'riedman (Inclusion Problem for Simple Machj-nes,

Eth Princeton Conf. on Information and Systems Science,

LC)7 4 ) to show that the inclusion problem f or simple lanorracres is also undecidable.

A modified formulation of the contents of Chapter 4 can be found in: Valiant L.G., The equivalence problern for deterministic finite-turn pushdown auLomata, Inf. and

Control, 25, June L974, L23 -f33

1/^

The results in Chapter 5, with revised proofs

wiI I appear as : Val iant. L. G. , and Paterson M. S . ,

Determinisuic one-counter automata, JCSS , L975.

The nain reductions of Chapter 6 and t-he

substance of ChapLer 7 will appear in: Valiant L.G-,

ri.u;JouLqrL :rrla-iiL-vlrr anrl rol:ied

nroblems for deterministic
r!v+

pushdown

;ru Loma t-a , ,.j-AC14 L97 5 .

In relation to the monadic functional schetnes

of chapter B it has been shown by E. P. Friednan t.h.at t-he

decicl"ibil i ty of equival-ence f or these would imply tlie

decidability of equivalence for the whole class of

deterministic pushdown automata.

L.G.V.

tlnirznrsitv of I.eeds :je:pLcnber, 1974.

