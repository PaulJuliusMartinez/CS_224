From: AAAI-02 Proceedings. Copyright © 2002, AAAI (www.aaai.org). All rights reserved. 

Speeding Up the Calculation of Heuristics

for Heuristic Search-Based Planning

Yaxin Liu, Sven Koenig and David Furcy

Atlanta, GA 30312-0280

fyxliu,skoenig,dfurcyg@cc.gatech.edu

College of Computing

Georgia Institute of Technology

Abstract

Heuristic search-based planners, such as HSP 2.0, solve
STRIPS-style planning problems efﬁciently but spend about
eighty percent of their planning time on calculating the
heuristic values. In this paper, we systematically evaluate al-
ternative methods for calculating the heuristic values for HSP
2.0 and demonstrate that the resulting planning times differ
substantially. HSP 2.0 calculates each heuristic value by solv-
ing a relaxed planning problem with a dynamic programming
method similar to value iteration. We identify two different
approaches for speeding up the calculation of heuristic val-
ues, namely to order the value updates and to reuse infor-
mation from the calculation of previous heuristic values. We
then show how these two approaches can be combined, re-
sulting in our PINCH method. PINCH outperforms both of
the other approaches individually as well as the methods used
by HSP 1.0 and HSP 2.0 for most of the large planning prob-
lems tested. In fact, it speeds up the planning time of HSP 2.0
by up to eighty percent in several domains and, in general, the
amount of savings grows with the size of the domains, allow-
ing HSP 2.0 to solve larger planning problems than was pos-
sible before in the same amount of time and without changing
its overall operation.

Introduction

Heuristic search-based planners were introduced by (Mc-
Dermott 1996) and (Bonet, Loerincs, & Geffner 1997) and
are now very popular. Several of them entered the sec-
ond planning competition at AIPS-2000, including HSP 2.0
(Bonet & Geffner 2001a), FF (Hoffmann & Nebel 2001a),
GRT (Refanidis & Vlahavas 2001), and AltAlt (Nguyen,
Kambhampati, & Nigenda 2002). Heuristic search-based
planners perform a heuristic forward or backward search
in the space of world states to ﬁnd a path from the start
state to a goal state.
In this paper, we study HSP 2.0,
a prominent heuristic search-based planner that won one
of four honorable mentions for overall exceptional perfor-
mance at the AIPS-2000 planning competition. It was one
of the ﬁrst planners that demonstrated how one can obtain
informed heuristic values for STRIPS-style planning prob-
lems to make planning tractable.
In its default conﬁgura-
tion, it uses weighted A* searches with inadmissible heuris-
tic values to perform forward searches in the space of world
Copyright c(cid:13) 2002, American Association for Artiﬁcial Intelli-
gence (www.aaai.org). All rights reserved.

484    AAAI−02 

states. However, the calculation of heuristic values is time-
consuming since HSP 2.0 calculates the heuristic value of
each state that it encounters during the search by solving
a relaxed planning problem. Consequently, its calculation
of heuristic values comprises about 80 percent of its plan-
ning time (Bonet & Geffner 2001b). This suggests that
one might be able to speed up its planning time by speed-
ing up its calculation of heuristic values. Some heuristic
search-based planners, for example, remove irrelevant op-
erators before calculating the heuristic values (Hoffmann
& Nebel 2001b) and other planners cache information ob-
tained in a preprocessing phase to simplify the calculation of
all heuristic values for a given planning problem (Bonet &
Geffner 1999; Refanidis & Vlahavas 2001; Edelkamp 2001;
Nguyen, Kambhampati, & Nigenda 2002).

Different from these approaches, we speed up HSP 2.0
without changing its heuristic values or overall operation. In
this paper, we study whether different methods for calculat-
ing the heuristic values for HSP 2.0 result in different plan-
ning times. We systematically evaluate a large number of
different methods and demonstrate that, indeed, the result-
ing planning times differ substantially. HSP 2.0 calculates
each heuristic value by solving a relaxed planning problem
with a dynamic programming method similar to value iter-
ation. We identify two different approaches for speeding
up the calculation of heuristic values, namely to order the
value updates and to reuse information from the calculation
of previous heuristic values by performing incremental cal-
culations. Each of these approaches can be implemented
individually in rather straightforward ways. The question
arises, then, how to combine them and whether this is ben-
eﬁcial. Since the approaches cannot be combined easily,
we develop a new method. The PINCH (Prioritized, IN-
Cremental Heuristics calculation) method exploits the fact
that the relaxed planning problems that are used to deter-
mine the heuristic values for two different states are similar
if the states are similar. Thus, we use a method from al-
gorithm theory to avoid the parts of the plan-construction
process that are identical to the previous ones and order the
remaining value updates in an efﬁcient way. We demonstrate
that PINCH outperforms both of the other approaches indi-
vidually as well as the methods used by HSP 1.0 and HSP
2.0 for most of the large planning problems tested. In fact,
it speeds up the planning time of HSP 2.0 by up to eighty

Unordered Updates
Ordered Updates

Non-Incremental Computations
VI, HSP2
GBF, HSP1, GD

Incremental Computations
IVI
PINCH

Table 1: Classiﬁcation of Heuristic-Calculation Methods

percent in several domains and, in general, the amount of
savings grows with the size of the domains, allowing HSP
2.0 to solve larger planning problems in the same amount
of time than was possible before and without changing its
overall operation.

Heuristic Search-Based Planning: HSP 2.0

In this section, we describe how HSP 2.0 operates. We ﬁrst
describe the planning problems that it solves and then how
it calculates its heuristic values. We follow the notation and
description from (Bonet & Geffner 2001b).

The Problem
HSP 2.0 solves STRIPS-style planning problems with
ground operators. Such STRIPS-style planning problems
consist of a set of propositions P that are used to describe
the states and operators, a set of ground operators O, the
start state I (cid:18) P , and the partially speciﬁed goal G (cid:18) P .
Each operator o 2 O has a precondition list P rec(o) (cid:18) P ,
an add list Add(o) (cid:18) P , and a delete list Delete(o) (cid:18) P .
The STRIPS planning problem induces a graph search prob-
lem that consists of a set of states (vertices) 2P , a start state
I, a set of goal states fX (cid:18) PjG (cid:18) Xg, a set of ac-
tions (directed edges) fo 2 OjP rec(o) (cid:18) sg for each state
s (cid:18) P where action o transitions from state s (cid:18) P to state
s − Delete(o) + Add(o) (cid:18) P with cost one. All opera-
tor sequences (paths) from the start state to any goal state in
the graph (plans) are solutions of the STRIPS-style planning
problem. The shorter the path, the higher the quality of the
solution.

The Method and its Heuristics
In its default conﬁguration, HSP 2.0 performs a forward
search in the space of world states using weighted A* (Pearl
1985) with inadmissible heuristic values. It calculates the
heuristic value of a given state by solving a relaxed version
of the planning problem, where it recursively approximates
(by ignoring all delete lists) the cost of achieving each goal
proposition individually from the given state and then com-
bines the estimates to obtain the heuristic value of the given
state. In the following, we explain the calculation of heuris-
tic values in detail. We use gs(p) to denote the approximate
cost of achieving proposition p 2 P from state s (cid:18) P , and
gs(o) to denote the approximate cost of achieving the pre-
conditions of operator o 2 O from state s (cid:18) P . HSP 2.0
deﬁnes these quantities recursively. It deﬁnes for all s (cid:18) P ,
p 2 P , and o 2 O (the minimum of an empty set is deﬁned
to be inﬁnity and an empty sum is deﬁned to be zero):
if p 2 s
otherwise

0
X
mino2Ojp2Add(o)[1 + gs(o)]

gs(p) =

(cid:26)

(1)

gs(o) =

gs(p):

p2P rec(o)

(2)

procedure Main()

forever do

set s to the state whose heuristic value needs to get computed next
for each q 2 P [ O n s do set xq := 1
for each p 2 s do set xp := 0
repeat
for each o 2 O do set xo :=
for each p 2 P n s do set xp := mino2Ojp2Add(o)[1 + xo]
until the values of all xq remain unchanged during an iteration
/* use hadd(s) =

p2P rec(o) xp

p2G xp */

P

P

Figure 1: VI

P
Then, the heuristic value hadd(s) of state s 2 S can be
calculated as hadd(s) =
p2G gs(p). This allows HSP 2.0
to solve large planning problems, although it is not guaran-
teed to ﬁnd shortest paths.

Calculation of Heuristics

In the next sections, we describe different methods that solve
Equations 1 and 2. These methods are summarized in Ta-
ble 1. To describe them, we use a variable p if its values are
guaranteed to be propositions, a variable o if its values are
guaranteed to be operators, and a variable q if its values can
be either propositions or operators. We also use variables
xp (a proposition variable) for p 2 P and xo (an opera-
tor variable) for o 2 O. In principle, the value of variable
xp satisﬁes xp = gs(p) after termination and the value of
variable xo satisﬁes xo = gs(o) after termination, except for
some methods that terminate immediately after the variables
xp for p 2 G have their correct values because this already
allows them to calculate the heuristic value.

VI and HSP2: Simple Calculation of Heuristics
Figure 1 shows a simple dynamic programming method that
solves the equations using a form of value iteration. This
VI (Value Iteration) method initializes the variables xp to
zero if p 2 s, and initializes all other variables to inﬁnity. It
then repeatedly sweeps over all variables and updates them
according to Equations 1 and 2, until no value changes any
longer.

HSP 2.0 uses a variant of VI that eliminates the vari-
ables xo by combining Equations 1 and 2. Thus, this HSP2
method performs only the following operation as part of its
repeat-until loop:

for each p 2 P n s do set xp := mino2Ojp2Add(o)[1 +
HSP2 needs more time than VI for each sweep but re-
duces the number of sweeps. For example, it needs only 5.0
sweeps on average in the Logistics domain, while VI needs
7.9 sweeps.

p02P rec(o) xp0 ].

P

Speeding Up the Calculation of Heuristics

We investigate two orthogonal approaches for speeding up
HSP 2.0’s calculation of heuristic values, namely to order
the value updates (ordered updates) and to reuse information
from the calculation of previous heuristic values (incremen-
tal computations), as shown in Table 1. We then describe
how to combine them.

AAAI−02    485

procedure Main()

procedure Main()

forever do

set s to the state whose heuristic value needs to get computed next
for each q 2 P [ O n s do set xq := 1
for each p 2 s do set xp := 0
repeat

o

set xnew
if xnew

P
for each o 2 O do
:=
6= xo then
o
set xo := xnew
for each p 2 Add(o) do

o

p2P rec(o) xp

set xp := min(xp; 1 + xo)

until the values of all xq remain unchanged during an iteration
/* use hadd(s) =

p2G xp */

P

Figure 2: GBF

0

0) of some other state s
0

IVI: Reusing Results from Previous Searches
When HSP 2.0 calculates a heuristic value hadd(s), it solves
equations in gs(p) and gs(o). When HSP 2.0 then calcu-
lates the heuristic value hadd(s
, it
solves equations in gs0(p) and gs0(o). If gs(p) = gs0(p) for
some p 2 P and gs(o) = gs0(o) for some o 2 O, one could
just cache these values during the calculation of hadd(s) and
0). Unfor-
then reuse them during the calculation of hadd(s
tunately, it is nontrivial to determine which values remain
unchanged. We explain later, in the context of our PINCH
method, how this can be done. For now, we exploit the fact
that the values gs(p) and gs0(p) for the same p 2 P and the
values gs(o) and gs0(o) for the same o 2 O are often similar
if s and s
are similar. Since HSP 2.0 calculates the heuristic
values of all children of a state in a row when it expands the
state, it often calculates the heuristic values of similar states
in succession. This fact can be exploited by changing VI so
that it initializes xp to zero if p 2 s but does not re-initialize
the other variables, resulting in the IVI (Incremental Value
Iteration) method. IVI repeatedly sweeps over all variables
until no value changes any longer. If the number of sweeps
becomes larger than a given threshold then IVI terminates
the sweeps and simply calls VI to determine the values. IVI
needs fewer sweeps than VI if HSP 2.0 calculates the heuris-
tics of similar states in succession because then the values
of the corresponding variables xq tend to be similar as well.
For example, IVI needs only 6.2 sweeps on average in the
Logistics domain, while VI needs 7.9 sweeps.

GBF, HSP1 and GD: Ordering the Value Updates
VI and IVI sweep over all variables in an arbitrary order.
Their number of sweeps can be reduced by ordering the vari-
ables appropriately, similarly to the way values are ordered
in the Prioritized Sweeping method used for reinforcement
learning (Moore & Atkeson 1993).

Figure 2 shows the GBF (Generalized Bellman-Ford)
method, that is similar to the variant of the Bellman-Ford
method in (Cormen, Leiserson, & Rivest 1990). It orders
the value updates of the variables xp. It sweeps over all vari-
ables xo and updates their values according to Equation 2.
If the update changes the value of variable xo, GBF iterates
over the variables xp for the propositions p in the add list of
operator o and updates their values according to Equation 1.
Thus, GBF updates the values of the variables xp only if
their values might have changed.

486    AAAI−02 

forever do

set s to the state whose heuristic value needs to get computed next
for each q 2 P [ O n s do set xq := 1
for each p 2 s do set xp := 0
set Lp := s
while Lp 6= ;

set Lo := the set of operators with no preconditions
for each p 2 Lp do set Lo := Lo [ fojp 2 P rec(o)g
set Lp := ;
for each p 2 P do set xnew
for each o 2 Lo do

:= xp

p

P

p2P rec(o) xp

set xo :=
for each p 2 Add(o)
> 1 + xo

if xnew
p

p
set xnew
:= 1 + xo
set Lp := Lp [ fpg

for each p 2 P do set xp := xnew

P

p
p2G xp */

/* use hadd(s) =

Figure 3: HSP1

Figure 3 shows the method used by HSP 1.0. The HSP1
method orders the value updates of the variables xo and
xp, similar to the variant of the Bellman-Ford method in
(Bertsekas 2001).
It uses an unordered list to remember
the propositions whose variables changed their values.
It
sweeps over all variables xo that have these propositions as
preconditions and updates their values according to Equa-
tion 2. After each update of the value of a variable xo, GBF
iterates over the variables xp for the propositions p in the
add list of operator o and updates their values according to
Equation 1. The unordered list is then updated to contain
all propositions whose variables changed their values in this
step. Thus, HSP1 updates the values of the variables xo and
xp only if their values might have changed.

Finally, the GD (Generalized Dijkstra) method (Knuth
1977) is a generalization of Dijkstra’s graph search method
(Dijkstra 1959) and uses a priority queue to sweep over the
variables xo and xp in the order of increasing values. Similar
to HSP1, its priority queue contains only those variables xo
and xp whose values might have changed. To make it even
more efﬁcient, we terminate it immediately once the values
of all gs(p) for p 2 G are known to be correct. We do not
give pseudocode for GD because it is a special case of the
PINCH method, that we discuss next.1

PINCH: The Best of Both Worlds

The two approaches for speeding up the calculation of
heuristic values discussed above are orthogonal. We now
describe our main contribution in this paper, namely how
to combine them. This is complicated by the fact that the
approaches themselves cannot be combined easily because
the methods that order the value updates exploit the prop-
erty that the values of the variables cannot increase during
each computation of a heuristic value. Unfortunately, this
property no longer holds when reusing the values of the vari-
ables from the calculation of previous heuristic values. We

1PINCH from Figure 5 reduces to GD if one empties its priority
queue and reinitializes the variables xq and rhsq before SolveE-
quations() is called again as well as modiﬁes the while loop of
SolveEquations() to terminate immediately once the values of all
gs(p) for p 2 G are known to be correct.

thus need to develop a new method based on a method from
algorithm theory. The resulting PINCH (Prioritized, INCre-
mental Heuristics calculation) method solves Equations 1
and 2 by calculating only those values gs0(p) and gs0(o) that
are different from the corresponding values gs(p) and gs(o)
from the calculation of previous heuristic values. PINCH
also orders the variables so that it updates the value of each
variable at most twice. We will demonstrate in the experi-
mental section that PINCH outperforms the other methods
in many large planning domains and is not worse in most
other large planning domains.

k

if,

swsf)

for every j 2 1 : : : k,

DynamicSWSF-FP
In this section, we describe DynamicSWSF-FP (Rama-
lingam & Reps 1996), the method from algorithm theory
that we extend to speed up the calculation of the heuristic
values for HSP 2.0. We follow the presentation in (Rama-
lingam & Reps 1996). A function g(x1; : : : ; xj; : : : ; xk):
+ ! R+ is called a strict weakly superior func-
R
tion (in short:
it
is monotone non-decreasing in variable xj and satisﬁes:
g(x1; : : : ; xj; : : : ; xk) (cid:20) xj ) g(x1; : : : ; xj; : : : ; xk) =
g(x1; : : : ;1; : : : ; xk). The swsf ﬁxed point (in short: swsf-
fp) problem is to compute the unique ﬁxed point of k equa-
tions, namely the equations xi = gi(x1; : : : ; xk), in the k
variables x1; : : : ; xk, where the gi are swsf for i = 1 : : : k.
The dynamic swsf-fp problem is to maintain the unique ﬁxed
point of the swsf equations after some or all of the functions
gi have been replaced by other swsf’s. DynamicSWSF-FP
solves the dynamic swsf-fp problem efﬁciently by recalcu-
lating only the values of variables that change, rather than
the values of all variables. The authors of DynamicSWSF-
FP have proved its correctness, completeness, and other
properties and applied it to grammar problems and shortest
path problems (Ramalingam & Reps 1996).

Terminology and Variables
We use the following terminology to explain how to use
DynamicSWSF-FP to calculate the heuristic values for HSP
If xi = gi(x1; : : : ; xk) then xi is called consistent.
2.0.
Otherwise it is called inconsistent. If xi is inconsistent then
either xi < gi(x1; : : : ; xk), in which case we call xi under-
consistent, or xi > gi(x1; : : : ; xk), in which case we call
xi overconsistent. We use the variables rhsi to keep track
of the current values of gi(x1; : : : ; xk). It always holds that
rhsi = gi(x1; : : : ; xk) (Invariant 1). We can therefore com-
pare xi and rhsi to check whether xi is overconsistent or
underconsistent. We maintain a priority queue that always
contains exactly the inconsistent xi (to be precise: it stores i
rather than xi) with priorities min(xi; rhsi) (Invariant 2).

Transforming the Equations
We transform Equations 1 and 2 as follows to ensure that
they specify a swsf-fp problem, for all s (cid:18) P , p 2 P and
o 2 O:

(cid:26)

0
s(p) =
g
0
s(o) = 1 +
g

0
mino2Ojp2Add(o)[1 + g

0
s(o)]

X

0
s(p):
g

p2P rec(o)

if p 2 s
otherwise

(3)

(4)

procedure AdjustVariable(q)

if q 2 P then

if q 2 s then set rhsq := 0
else set rhsq := 1 + mino2Ojq2Add(o) xo

P
else /* q 2 O */ set rhsq := 1 +
if q is in the priority queue then delete it
if xq 6= rhsq then insert q into the priority queue with priority min(xq ; rhsq )

p2P rec(q) xp

procedure SolveEquations()

while the priority queue is not empty do

delete the element with the smallest priority from the priority queue and assign it to q
if rhsq < xq then
set xq := rhsq
if q 2 P then for each o 2 O such that q 2 P rec(o) do AdjustVariable(o)
else if q 2 O then for each p 2 Add(q) with p 62 s do AdjustVariable(p)
set xq := 1
AdjustVariable(q)
if q 2 P then for each o 2 O such that q 2 P rec(o) do AdjustVariable(o)
else if q 2 O then for each p 2 Add(q) with p 62 s do AdjustVariable(p)

else

procedure Main()

empty the priority queue
set s to the state whose heuristic value needs to get computed
for each q 2 P [ O do set xq := 1
for each q 2 P [ O do AdjustVariable(q)
forever do

P

SolveEquations()
/* use hadd(s) = 1=2
set s0 := s and s to the state whose heuristic value needs to get computed next
for each p 2 (s n s0) [ (s0 n s) do AdjustVariable(p)

p2G xp */

Figure 4: PINCH

P

0
s(o)], and 1 +

0
s(o). The
The only difference is in the calculation of g
transformed equations specify a swsf-fp problem since 0,
0
mino2Ojp2Add(o)[1 + g
s(p) are all
s(o) for all p 2 P and all o 2 O. This
0
swsf in g
means that the transformed equations can be solved with
DynamicSWSF-FP. They can be used to calculate hadd(s)
0
since it is easy to show that gs(p) = 1=2g
s(p) and thus
0
s(p).
hadd(s) =

0
s(p) and g
P
p2G gs(p) = 1=2

p2C g

p2G g

P

Calculation of Heuristics with DynamicSWSF-FP
We apply DynamicSWSF-FP to the problem of calculating
the heuristic values of HSP 2.0, which reduces to solving
the swsf ﬁxed point problem deﬁned by Equations 3 and 4.
The solution is obtained by SolveEquations() shown in Fig-
ure 4. In the algorithm, each xp is a variable that contains
0
s(p) value, and each xo is a variable that
the corresponding g
contains the corresponding g

0
s(o) value.

PINCH calls AdjustVariable() for each xq to ensure that
Invariants 1 and 2 hold before it calls SolveEquations() for
the ﬁrst time. It needs to call AdjustVariable() only for those
xq whose function gq has changed before it calls SolveEqua-
tions() again. The invariants will automatically continue to
hold for all other xq. If the state whose heuristic value needs
0
to get computed changes from s
to s, then this changes only
those functions gq that correspond to the right-hand side of
Equation 3 for which p 2 (s n s
0) [ (s
0 n s), in other words,
where p is no longer part of s (and the corresponding vari-
able thus is no longer clamped to zero) or just became part of
s (and the corresponding variable thus just became clamped
to zero). SolveEquations() then operates as follows. The
xq solve Equations 3 and 4 if they are all consistent. Thus,
SolveEquations() adjusts the values of the inconsistent xq.
It always removes the xq with the smallest priority from
the priority queue. If xq is overconsistent then SolveEqua-

AAAI−02    487

procedure AdjustVariable(q)

if xq 6= rhsq then

if q is not in the priority queue then insert it with priority min(xq ; rhsq )
else change the priority of q in the priority queue to min(xq ; rhsq )

else if q is in the priority queue then delete it

procedure SolveEquations()

while the priority queue is not empty do

assign the element with the smallest priority in the priority queue to q
if q 2 P then

if rhsq < xq then

delete q from the priority queue
set xold := xq
set xq := rhsq
for each o 2 O such that q 2 P rec(o) do

if rhso = 1 then
p2P rec(o) xp
set rhso := 1 +
else set rhso := rhso − xold + xq
AdjustVariable(o)

P

else

set xq := 1
if q 62 s then

for each o 2 O such that q 2 P rec(o) do

set rhsq = 1 + mino2Ojq2Add(o) xo
AdjustVariable(q)
set rhso := 1
AdjustVariable(o)

else /* q 2 O */

if rhsq < xq then

delete q from the priority queue
set xq := rhsq
for each p 2 Add(q) with p 62 s
rhsp = min(rhsp; 1 + xq )
AdjustVariable(p)

else

P

set xold := xq
set xq := 1
set rhsq := 1 +
AdjustVariable(q)
for each p 2 Add(q) with p 62 s

p2P rec(q) xp

if rhsp = 1 + xold then

set rhsp := 1 + mino2Ojp2Add(o) xo
AdjustVariable(p)

procedure Main()

empty the priority queue
set s to the state whose heuristic value needs to get computed
for each q 2 P [ O do set rhsq := xq := 1
for each o 2 O with P rec(o) = ; do set rhso := xo := 1
for each p 2 s do

rhsp := 0
AdjustVariable(p)

forever do

P

p2G xp */

SolveEquations()
/* use hadd(s) = 1=2
set s0 := s and s to the state whose heuristic value needs to get computed next
for each p 2 s n s0
rhsp := 0
AdjustVariable(p)
for each p 2 s0 n s do
rhsp := 1 + mino2Ojp2Add(o) xo
AdjustVariable(p)

do

Figure 5: Optimized PINCH

tions() sets it to the value of rhsq. This makes xq consistent.
Otherwise xq is underconsistent and SolveEquations() sets
it to inﬁnity. This makes xq either consistent or overcon-
sistent. In the latter case, it remains in the priority queue.
Whether xq was underconsistent or overconsistent, its value
got changed. SolveEquations() then calls AdjustVariable()
to maintain the Invariants 1 and 2. Once the priority queue
is empty, SolveEquations() terminates since all xq are con-
sistent and thus solve Equations 3 and 4. One can prove
that it changes the value of each xq at most twice, namely
at most once when it is underconsistent and at most once
when it is overconsistent, and thus terminates in ﬁnite time
(Ramalingam & Reps 1996).

488    AAAI−02 

Algorithmic Optimizations
Its main inefﬁciency is
PINCH can be optimized further.
that it often iterates over a large number of propositions or
operators. Consider, for example, the case where q 2 O has
the smallest priority during an iteration of the while-loop in
SolveEquations() and rhsq < xq. At some point in time,
SolveEquations() then executes the following loop

for each p 2 Add(q) with p 62 s do AdjustVariable(p)

The for-loop iterates over all propositions that satisfy its con-
dition. For each of them, the call AdjustVariable(p) executes

set rhsp := 1 + mino2Ojp2Add(o) xo

The calculation of rhsp therefore iterates over all operators
that contain p in their add list. However, this iteration can
be avoided. Since rhsq < xq according to our assumption,
SolveEquations() sets the value of xq to rhsq and thus de-
creases it. All other values remain the same. Thus, rhsp
cannot increase and one can recalculate it faster as follows

set rhsp := min(rhsp; 1 + xq)

Figure 5 shows PINCH after this and other optimizations. In
the experimental section, we use this method rather than the
unoptimized one to reduce the planning time. This reduces
the planning time, for example, by 20 percent in the Logis-
tics domain and up to 90 percent in the Freecell domain.

Summary of Methods

Table 1 summarizes the methods that we have discussed and
classiﬁes them according to whether they order the value up-
dates (ordered updates) and whether they reuse information
from the calculation of previous heuristic values (incremen-
tal computations).

Both VI and IVI perform full sweeps over all variables
and thus perform unordered updates. IVI reuses the values
of variables from the computation of the previous heuris-
tic value and is an incremental version of VI. We included
HSP2 although it is very similar to VI and belongs to the
same class because it is the method used by HSP 2.0. Its
only difference from VI is that it eliminates all operator vari-
ables, which simpliﬁes the code.

GBF, HSP1, and GD order the value updates. They are
listed from left to right in order of increasing number of
binary ordering constraints between value updates. GBF
performs full sweeps over all operator variables interleaved
with partial sweeps over those proposition variables whose
values might have changed because they depend on oper-
ator variables whose values have just changed. HSP1, the
method used by HSP 1.0, alternates partial sweeps over op-
erator variables and partial sweeps over proposition vari-
ables. Finally, both GD and PINCH order the value updates
completely and thus do not perform any sweeps. This en-
ables GD to update the value of each variable only once
and PINCH to update the value of each variable only twice.
PINCH reuses the values of variables from the computation
of the previous heuristic value and is an incremental version
of GD.

Problem Size
LOGISTICS-4-0
LOGISTICS-7-0
LOGISTICS-10-0
LOGISTICS-13-0
LOGISTICS-16-0
LOGISTICS-19-0
LOGISTICS-22-0
LOGISTICS-25-0
LOGISTICS-28-0
LOGISTICS-31-0
LOGISTICS-34-0
LOGISTICS-37-0
LOGISTICS-40-0

#P
48
99
168
275
384
511
656
855
1040
1243
1464
1755
2016

#O
78
174
308
650
936
1274
1664
2664
3290
3982
4740
6734
7812

Length

26
52
59
102
121
144
160
206
243
269
291
316
337

#CV
15.10
29.43
39.73
52.48
63.33
84.26
108.65
104.28
124.14
148.05
161.16
165.82
186.08

#CV/#P
11.98%
10.78%
8.35%
5.67%
4.80%
4.72%
4.68%
2.96%
2.86%
2.83%
2.60%
1.95%
1.89%

HSP2
0.07
0.82
1.06
5.25
12.01
30.93
101.72
104.12
201.38
315.95
434.81
1043.80
1314.80

VI

0.09 (-29%)
1.13 (-38%)
1.54 (-45%)
8.08 (-54%)
18.27 (-52%)
43.12 (-39%)
165.72 (-63%)
168.14 (-61%)
316.96 (-57%)
491.25 (-55%)
688.98 (-58%)
1663.30 (-59%)
2112.70 (-61%)

IVI

0.09 (-29%)
0.97 (-18%)
1.32 (-25%)
6.54 (-23%)
15.03 (-25%)
34.36 (-11%)
137.86 (-36%)
128.58 (-23%)
249.55 (-24%)
382.49 (-21%)
518.06 (-19%)
1333.00 (-28%)
1464.30 (-11%)

GBF

0.06 (14%)
0.58 (29%)
0.69 (35%)
3.52 (33%)
7.86 (35%)
18.25 (41%)
69.67 (32%)
73.15 (30%)
140.38 (30%)
201.35 (36%)
296.51 (32%)
759.29 (27%)
900.32 (32%)

HSP1

0.06 (14%)
0.60 (27%)
0.76 (28%)
3.77 (28%)
8.13 (32%)
18.55 (40%)
71.64 (30%)
87.08 (16%)
151.34 (25%)
220.12 (30%)
307.26 (29%)
824.53 (21%)
936.42 (29%)

GD

0.09 ( -29%)
1.13 ( -38%)
1.51 ( -42%)
13.75 (-162%)
19.69 ( -64%)
45.45 ( -47%)
178.57 ( -76%)
188.62 ( -81%)
362.90 ( -80%)
546.57 ( -73%)
801.60 ( -84%)
2132.00 (-104%)
2488.30 ( -89%)

PINCH
0.05 (29%)
0.49 (40%)
0.52 (51%)
2.05 (61%)
4.11 (66%)
9.16 (70%)
34.98 (66%)
27.99 (73%)
51.09 (75%)
72.86 (77%)
105.07 (76%)
219.82 (79%)
275.39 (79%)

Table 2: Experimental Results in the Logistics Domain

Experimental Evaluation

After describing our experimental setup and the collected
data, we discuss the results and draw conclusions.

Experimental Setup
To compare the various methods for calculating the heuristic
values, we integrated them into the publicly available code
for HSP 2.0.2 We used the default conﬁguration of HSP 2.0
for all experiments, namely forward weighted A* searches
with a weight of 2.0.

HSP2 is already part of the publicly available code for
HSP 2.0. We therefore used it as the baseline method against
which we compared the other methods. To make this base-
line as efﬁcient as possible, we deleted all code from the
existing implementation of HSP2 whose results are not used
when planning with the default conﬁguration, which reduces
the planning time of HSP2, for example, by over 20 percent
in the Logistics domain.

Most of our test problems came from the publicly avail-
able AIPS-98 and AIPS-00 competition problem sets. We
used all instances of the Gripper, Mprime and Mystery do-
mains from AIPS-98.
In addition, we generated random
problems in the Gripper domain that are larger than those
from AIPS-98. We used all domains from AIPS-00: all in-
stances of the Blocks World, Elevator, Freecell, and Logis-
tics domains and small instances (with two to nine parts)
from the Schedule domain. Finally, we generated additional
problems in the Blocks World domain that are larger than
those from AIPS-00. These problems, randomly drawn from
a uniform distribution of problems, allow us to reliably iden-
tify a trend for large problems (these results appear in a sep-
arate graph).

We performed the experiments on a cluster of 32 Sun
Sparc Ultra 10 workstations with 256 MBytes of memory
each. We limited the planning time to 10 minutes for each
problem.

Reported Data
Table 2 contains detailed data for the Logistics domain.
These results are not directly comparable to the results from

2We followed the publicly available code for HSP 1.0 when
reimplementing HSP1. All priority queues were implemented as
binary heaps. The threshold on the number of sweeps for the IVI
method was set to 10.

the AIPS-00 competition since HSP 2.0 solved most Lo-
gistics problems in the competition with backward search
(Bonet & Geffner 2001a). The rows corresponds to prob-
lems of increasing size. The ﬁrst column contains the prob-
lem name. The next two columns contain the number #P of
propositions that are contained in at least one add or delete
list of the applicable ground operators and the number #O
of applicable ground operators, respectively. The sum of #O
and #P is the size of the graph used to compute the heuristic
values. The fourth column contains the length of the plan
found by HSP 2.0. The ﬁfth column contains the average
number #CV of proposition variables whose values changed
from the calculation of one heuristic value to the next. The
sixth column contains the ratio of #CV and #P. The seventh
column contains the planning time for HSP2, our baseline.
Finally, the next six columns contain both the planning times
of the other methods and their relative speedup over HSP2.
None of the planning times include the time required for
generating the propositions and ground operators because it
is the same for each method.

Figure 6 contains less detailed data for all planning do-
mains.
It plots, for each domain, the relative speedup in
planning time of all methods over HSP2 as a function of
the size of the graph used to compute the heuristic val-
ues. (Thus, the horizontal line at y=0 corresponds to HSP2.)
Each data point corresponds to a single problem. Lines av-
erage over all problems of the same size. When a problem
could not be solved within 10 minutes, we approximated the
relative speedup in planning time with the relative speedup
in node generation rate and indicated this with a dashed line.
This approximation is justiﬁed because we checked empiri-
cally that the node generation rate remains roughly constant
over time.

Results and Discussion
The relative speedups of the methods in planning time over
HSP2 vary substantially, both across different methods in
the same domain and across different domains for the same
method. However, we can draw two conclusions.

First, PINCH and GBF are the best and second best meth-
ods for large domains, respectively. Indeed, PINCH is sig-
niﬁcantly faster than GBF in ﬁve domains, about as fast as
GBF in two other domains, and only signiﬁcantly slower
than GBF in the Freecell domain. (GBF, in turn, is signif-
icantly faster than all methods other than PINCH in all but
three domains.) Furthermore, the relative speedup in plan-

AAAI−02    489

)

%

i

 

(
 
e
m
T
g
n
n
n
a
P
n

 

l

i

i
 

p
u
d
e
e
p
S
e
v
i
t

 

l

a
e
R

)

%

(
 

i

 

e
m
T
g
n
n
n
a
P
n

 

l

i

i
 

p
u
d
e
e
p
S
e
v
i
t
a
e
R

 

l

)

%

i

i

l

(
 
e
m
T
 
g
n
n
n
a
P
 
n
i
 
p
u
d
e
e
p
S
 
e
v
i
t
a
e
R

l

100

80

60

40

20

0

−20

−40

−60

−80

−100

100

80

60

40

20

0

−20

−40

−60

−80

−100

100

80

60

40

20

0

−20

−40

−60

−80

−100

Blocks World

Blocks World: Random Instances

Elevator

GBF 

PINCH 

PINCH
GBF
HSP1
GD
IVI
VI

6000

7000

3000

5000
Problem Size (#P + #O)

4000

)

%

i

 

(
 
e
m
T
g
n
n
n
a
P
n

 

l

i

i
 

p
u
d
e
e
p
S
e
v
i
t

 

l

a
e
R

100

80

60

40

20

0

−20

−40

−60

−80

−100

0.5

1

1.5
3
Problem Size (#P + #O)

2.5

2

Freecell

Logistics

PINCH 

GBF 

PINCH
GBF
HSP1
GD
IVI
VI

3.5

4

x 104

PINCH 

GBF 

)

%

i

 

(
 
e
m
T
g
n
n
n
a
P
n

 

l

i

i
 

p
u
d
e
e
p
S
e
v
i
t

 

l

a
e
R

)

%

(
 

i

 

e
m
T
g
n
n
n
a
P
n

 

l

i

i
 

p
u
d
e
e
p
S
e
v
i
t
a
e
R

 

l

)

%

i

i

l

(
 
e
m
T
 
g
n
n
n
a
P
 
n
i
 
p
u
d
e
e
p
S
 
e
v
i
t
a
e
R

l

100

80

60

40

20

0

−20

−40

−60

−80

−100

100

80

60

40

20

0

500

1000

1500

2500
Problem Size (#P + #O)

2000

Schedule

−20

−40

−60

−80

−100

100

80

60

40

20

0

−20

−40

−60

−80

−100

1000

1500

0.5

1

2000

2500

Problem Size (#P + #O)

Mystery

2

1.5
Problem Size (#P + #O)

2.5

3

PINCH 

GBF 

PINCH
GBF
HSP1
GD
IVI
VI

3500

3000

PINCH 

GBF 

PINCH
GBF
HSP1
GD
IVI
VI

3000

3500

PINCH 

GBF 

PINCH
GBF
HSP1
GD
IVI
VI

4.5

x 104

3.5

4

1000

2000

0.4

0.6

0.8

GBF 

PINCH 

PINCH
GBF
HSP1
GD
IVI
VI

1.8

2

x 104

1

1.2

1.4

1.6

Problem Size (#P + #O)

Gripper

GBF 

PINCH 

1000

2000

4000
Problem Size (#P + #O)

3000

PINCH
GBF
HSP1
GD
IVI
VI

5000

6000

1000

2000

3000

4000

5000

6000

7000

Problem Size (#P + #O)

Mprime

PINCH
GBF
HSP1
GD
IVI
VI

8000

9000

PINCH 

GBF 

0.5

1

1.5

2

2.5

3

3.5

Problem Size (#P + #O)

PINCH
GBF
HSP1
GD
IVI
VI

4

4.5

5

x 104

)

%

(
 

i

 

e
m
T
g
n
n
n
a
P
n

 

i

l

i
 

p
u
d
e
e
p
S
e
v
i
t
a
e
R

 

l

)

%

i

i

l

(
 
e
m
T
 
g
n
n
n
a
P
 
n
i
 
p
u
d
e
e
p
S
 
e
v
i
t
a
e
R

l

100

80

60

40

20

0

−20

−40

−60

−80

−100

100

80

60

40

20

0

−20

−40

−60

−80

−100

Figure 6: Relative Speedup in Planning Time over HSP2

ning time of PINCH over HSP2 tends to increase with the
problem size. For example, PINCH outperforms HSP2 by
over 80 percent for large problems in several domains. Ac-
cording to theoretical results given in (Ramalingam & Reps
1996), the complexity of PINCH depends on the number
of operator and proposition variables whose values change
from the calculation of one heuristic value to the next.
Since some methods do not use operator variables, we only
counted the number of proposition variables whose values
changed. Table 2 lists the resulting dissimilarity measure
for the Logistics domain. In this domain, #CV/#P is a good
predictor of the relative speedup in planning time of PINCH
over HSP2, with a negative correlation coefﬁcient of -0.96.
More generally, the dissimilarity measure is a good predic-
tor of the relative speedup in planning time of PINCH over
HSP2 in all domains, with negative correlation coefﬁcients
ranging from -0.96 to -0.36. This insight can be used to
explain the relatively poor scaling behavior of PINCH in the

Freecell domain. In all other domains, the dissimilarity mea-
sure is negatively correlated with the problem size, with neg-
ative correlation coefﬁcients ranging from -0.92 to -0.57. In
the Freecell domain, however, the dissimilarity measure is
positively correlated with the problem size, with a positive
correlation coefﬁcient of 0.68. The Freecell domain repre-
sents a solitaire game. As the problem size increases, the
number of cards increases while the numbers of columns
and free cells remain constant. This results in additional
constraints on the values of both proposition and operator
variables and thus in a larger number of value changes from
one calculation of the heuristic value to the next. This in-
creases the dissimilarity measure and thus decreases the rel-
ative speedup of PINCH over HSP2. Finally, there are prob-
lems that HSP 2.0 with PINCH could solve in the 10-minute
time limit that neither the standard HSP 2.0 distribution, nor
HSP 2.0 with GBF, could solve. The Logistics domain is
such a domain.

490    AAAI−02 

Second, GBF is at least as fast as HSP1 and HSP1 is at
least as fast as GD. Thus, the stricter the ordering of the vari-
able updates among the three methods with ordered updates
and nonincremental computations, the smaller their relative
speedup over HSP2. This can be explained with the increas-
ing overhead that results from the need to maintain the or-
dering constraints with increasingly complex data structures.
GBF does not use any additional data structures, HSP1 uses
an unordered list, and GD uses a priority queue. (We imple-
mented the priority queue in turn as a binary heap, Fibonacci
heap, and a multi-level bucket to ensure that this conclusion
is independent of its implementation.) Since PINCH with-
out value reuse reduces to GD, our experiments demonstrate
that it is value reuse that allows PINCH to counteract the
overhead associated with the priority queue, and makes the
planning time of PINCH so competitive.

Conclusions

In this paper, we systematically evaluated methods for calcu-
lating the heuristic values for HSP 2.0 with the hadd heuris-
tics and demonstrated that the resulting planning times dif-
fer substantially. We identiﬁed two different approaches for
speeding up the calculation of the heuristic values, namely
to order the value updates and to reuse information from the
calculation of previous heuristic values. We then showed
how these two approaches can be combined, resulting in
our PINCH (Prioritized, INCremental Heuristics calcula-
tion) method. PINCH outperforms both of the other ap-
proaches individually as well as the methods used by HSP
1.0 and HSP 2.0 for most of the large planning problems
tested. In fact, it speeds up the planning time of HSP 2.0 by
up to eighty percent in several domains and, in general, the
amount of savings grows with the size of the domains. This
is an important property since, if a method has a high relative
speedup for small problems, it wins by fractions of a second
which is insigniﬁcant in practice. However, if a method has
a high relative speedup for large problems, it wins by min-
utes. Thus, PINCH allows HSP 2.0 to solve larger planning
problems than was possible before in the same amount of
time and without changing its operation. We also have pre-
liminary results that show that PINCH speeds up HSP 2.0
with the hmax heuristics (Bonet & Geffner 2001b) by over
20 percent and HSP 2.0 with the h2
max (Haslum & Geffner
2000) heuristic by over 80 percent for small blocks world in-
stances. We are currently working on demonstrating similar
savings for other heuristic search-based planners. For exam-
ple, PINCH also applies in principle to the ﬁrst stage of FF
(Hoffmann & Nebel 2001a), where FF builds the planning
graph.

Acknowledgments

We thank Blai Bonet and Hector Geffner for making the
code of HSP 1.0 and HSP 2.0 available to us and for answer-
ing our questions. We also thank Sylvie Thi´ebaux and John
Slaney for making their blocksworld planning task genera-
tor available to us. The Intelligent Decision-Making Group
is partly supported by NSF awards to Sven Koenig under
contracts IIS-9984827, IIS-0098807, and ITR/AP-0113881

as well as an IBM faculty partnership award. The views
and conclusions contained in this document are those of the
authors and should not be interpreted as representing the of-
ﬁcial policies, either expressed or implied, of the sponsoring
organizations, agencies, companies or the U.S. government.

References

2001b.

Bertsekas, D. 2001. Dynamic Programming and Optimal Control.
Athena Scientiﬁc, 2nd edition.
Bonet, B., and Geffner, H. 1999. Planning as heuristic search:
New results. In Proceedings of the 5th European Conference on
Planning, 360–372.
Bonet, B., and Geffner, H. 2001a. Heuristic search planner 2.0.
Artiﬁcial Intelligence Magazine 22(3):77–80.
Bonet, B., and Geffner, H.
Planning as heuristic
search. Artiﬁcial Intelligence – Special Issue on Heuristic Search
129(1):5–33.
Bonet, B.; Loerincs, G.; and Geffner, H. 1997. A robust and
fast action selection mechanism. In Proceedings of the National
Conference on Artiﬁcial Intelligence, 714–719.
Cormen, T.; Leiserson, C.; and Rivest, R. 1990. Introduction to
Algorithms. MIT Press.
Dijkstra, E. 1959. A note on two problems in connection with
graphs. Numerical Mathematics 1:269–271.
Edelkamp, S. 2001. Planning with pattern databases. In Proceed-
ings of the 6th European Conference on Planning, 13–24.
Haslum, P., and Geffner, H. 2000. Admissible heuristics for opti-
mal planning. In Proceedings of the International Conference on
Artiﬁcial Intelligence Planning and Scheduling, 70–82.
Hoffmann, J., and Nebel, B. 2001a. The FF planning system:
Fast plan generation through heuristic search. Journal of Artiﬁcial
Intelligence Research 14:253–302.
Hoffmann, J., and Nebel, B. 2001b. RIFO revisited: Detecting re-
laxed irrelevance. In Proceedings of the 6th European Conference
on Planning, 325–336.
Knuth, D. 1977. A generalization of Dijkstra’s algorithm. Infor-
mation Processing Letters 6(1):1–5.
McDermott, D. 1996. A heuristic estimator for means-ends anal-
ysis in planning. In Proceedings of the International Conference
on Artiﬁcial Intelligence Planning and Scheduling, 142–149.
Moore, A., and Atkeson, C. 1993. Prioritized sweeping: Rein-
forcement learning with less data and less time. Machine Learn-
ing 13(1):103–130.
Nguyen, X.; Kambhampati, S.; and Nigenda, R. S. 2002. Plan-
ning graph as the basis for deriving heuristics for plan synthesis
by state space and csp search. Artiﬁcial Intelligence 135(1–2):73–
123.
Pearl, J. 1985. Heuristics: Intelligent Search Strategies for Com-
puter Problem Solving. Addison-Wesley.
Ramalingam, G., and Reps, T. 1996. An incremental algorithm
for a generalization of the shortest-path problem. Journal of Al-
gorithms 21:267–305.
Refanidis, I., and Vlahavas, I. 2001. The GRT planning system:
Backward heuristic construction in forward state-space planning.
Journal of Artiﬁcial Intelligence Research 15:115–161.

AAAI−02    491

