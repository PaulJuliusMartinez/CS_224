Technical Report, TU Vienna

TR-186-2-00-04 (2000),

Incoming First-Shot for Non-Diffuse Global Illumination
László Szirmay-Kalos, Mateu Sbert, Roel Martínez, Robert Tobler Department of Control Engineering and Information Technology, Technical University of Budapest
Budapest, Magyar Tudósok krt. 2, H-1117, HUNGARY szirmay@iit.bme.hu

Abstract This paper presents a method that can replace the small and medium size lightsources by their effect in nondiffuse global illumination algorithms. Incoming first-shot is a generalization of a preprocessing technique called the first-shot that was developed for speeding up global diffuse radiosity algorithms. Alternatively, it can also be approached as a generalization of the direct-lightsource computation involved in gathering type methods. In order to reduce the prohibitive memory requirements of the original first-shot when it is applied to non-diffuse scenes in a direct manner, the proposed new method computes and stores only the incoming radiance generated by the lightsources and the reflected radiance is obtained from the incoming radiance on the fly taking into account the local BRDF. Since the radiance function of the reflection is smoother and flatter than the original lightsource function, this replacement makes the integrand of the rendering equation have significantly smaller variation, which can speed up global illumination algorithms. The paper also discusses how the first-shot technique can be built into a stochastic iteration algorithm using ray-bundles, and provides run-time statistics.

Keywords: Non-diffuse global illumination, stochastic iteration, Monte-Carlo quadrature, global methods, finiteelement techniques, first-shot

1. Introduction

Global illumination algorithms aim at obtaining the power detected by a collection of measuring devices. The measurement process is characterized by the following equation

ZZ
ML(~y ) cos  W e(~y ) d~y d = L

(1)

S

where L(~y ) is the radiance,  is the angle between the surface normal and direction  and We(~y ) is the sensitivity of the measuring device. A measuring device can detect, for example, the power reaching the eye through a pixel.

The radiance function can be obtained by solving the rendering equation 10 that has the following form:

TL = Le + L:

(2)

TIn this integral equation, operator describes the light trans-

presented at SCCG 2000.

port
Z
T ;L(~x ) = L(h(~x 0) 0) fr(0 ~x ) cos 0 d0

(3) where L(~x ) and Le(~x ) are the radiance and emission of the surface in point ~x at direction ,  is the directional sphere, h(~x 0) is the visibility function defining the point that is visible from point ~x at direction 0, fr(0 ~x ) is the bi-directional reflection/refraction function, and 0 is the an-
;gle between the surface normal and direction 0 (figure 1).

Let us substitute function L in the right side by the complete right side (which equals to L) recursively. If the integral operator is a contraction, this provides the solution in the form of an infinite series:
T T TL = Le + L = Le + (Le + L) =

T T(Le + (Le + (Le + : : :) : : :):

(4)

Thus the measured power is
M M T TL = (Le + (Le + (Le + : : :) : : :):

(5)

Random-walk 20 and stochastic iteration 21 algorithms evaluate the integrals of this formula by Monte-Carlo

2 Szirmay-Kalos, Sbert, Martínez, Tobler / Incoming First-Shot

h(x, - ')

the value of the integral R Lr() d everywhere in the do-

main.

 L(x, )

L(h(x, - '), ') '' '
x

Figure 1: Geometry of the rendering equation

quadrature. Monte-Carlo integration is justified by the facts that its complexity does not grow with the dimension of the domain of the integration and it does not accumulate the error.

One way of reducing the variance of the Monte-Carlo integration is the application of some form of importance sampling 17, which means that p(0) mimics the integrand Lr(0) to make Lr(0)=p(0) approximately constant. Unfortunately, the integrand of the rendering equation is not available explicitely, thus the probability density is usually based only on the local BRDFs 9 11 -- i.e. it mimics fr cos 0 instead of (Le +Li) fr cos 0, which can be quite inaccurate.
Another possibility is a different formulation of the global illumination problem as an integral, where the integrand is significantly flatter. Since the problematic part is the incoming radiance which stems both directly and indirectly from the emission of the lightsources, we aim at replacing the lightsource term by a different function which is flatter. For example, we can replace the emissions of the lightsources by their first reflection, which leads us to the core idea of the first-shot methods.

The integrals providing the solution of the rendering equation have the following form:
T T T(Le + (Le + : : :) : : :) = (Le + Li) =
Z
(Le + Li) fr cos 0 d0

where Li is the indirect illumination computed by the subsequent integration. Monte-Carlo estimates are accurate if the integrand
Lr(0) = (Le + Li) fr cos 0

2. The basic idea of first-shot First-shot is a method that shoots the power of the small lightsources onto other surfaces, increase the emission of the other surfaces by the reflection, then removes the original lightsources from the scene.
=+

is "flat", i.e. close to constant, otherwise the estimates have

high variance. Let us examine this statement formally. Sup-

pose that this integral is evaluated by Monte-Carlo quadra-

ture, thus it is converted to an expected value, which is estimated by an average. Assume that a random direction 0 is sampled from a probability density p(0). The integral to be

computed is:

ZZ
Lr(0) d0 =

Lr (0 ) p(0 )

p(0) d0 =



Lep T Lep
Figure 2: First-shot technique Formally, the unknown radiance L is decomposed into two terms:

E

Lr (0 ) p(0 )

L^ r

=

1 N

N
i=1

Lr(0i ) p(0i ) :

(6)

Estimator L^ r is also a random variable whose standard devi-
pation is = N where 2 is

0 1Z @ ; A2 =

Lr (0 ) p(0)

Z2
Lr() d p(0) d0:

(7)



This standard deviation is small if Lr(0)=p(0) is close to

L = Lep + Lnp

(8)

where Lep is the emission of the small area and point lightsources, Lnp is the emission of the larger area lightsources

and the reflected radiance. Substituting this into the render-

ing equation we have:

TLep + Lnp = Le + (Lep + Lnp):

(9)

Expressing Lnp we obtain:
; T TLnp = (Le Lep + Lep) + Lnp:

(10)

presented at SCCG 2000.

Szirmay-Kalos, Sbert, Martínez, Tobler / Incoming First-Shot

3

Introducing the new lightsource term
; TLe = Le Lep + Lep

(11)

which just replaces the point lightsources (Lep) by their sin-
Tgle reflection ( Lep), the equation for Lnp is similar to the

original rendering equation:

TLnp = Le + Lnp:

(12)

Note that when this equation is solved, integrand Lr (0) = (Le + Li ) fr cos 0

is flatter than the original integrand.

Summarizing, first-shot computes the direct illumination caused by the small lightsources, then removes these lightsources from the scene during global illumination calculation, and adds them again at the end of the computation. First shot is indispensable for all global methods and for all gathering type local methods.

The reflection of the small lightsources can be computed in a preprocessing phase of the global illumination algorithm, or simultaneously with the global illumination algorithm when it is needed. Furthermore, it is also possible to do some parts of the calculation in the preprocessing phase while completing the computation on-the-fly with the global illumination algorithm.

We can consider the following alternatives:

1. Classical first-shot: The reflected radiance is computed completely in the preprocessing phase. This method 6 works well in the radiosity setting, since in this case, the representation of the reflected radiance requires a diffuse "emission" in each patch, thus the memory overhead of the first-shot is just one variable per patch. However, in non-diffuse scenes the classical first-shot has prohibitive memory requirements, since even if the original lightsources are diffuse, their reflection may have general directional function, which requires the representation of the complete reflected, non-diffuse radiance function. If the directional variation of the radiance is represented by n basis functions (i.e. n is the number of small solid angles in which the radiance can be supposed to be constant) in each patch, then the method requires n new variables for each patch.
2. Diffuse first-shot: The BRDF, the light-transport operator, and the reflected radiance are decomposed into diffuse and non-diffuse components and the previous firstshot is applied only to the diffuse reflected radiance. This method can be used in those finite-element, non-diffuse global illumination algorithms which can make a distinction between the first and the other bounces of the light.
3. Incoming first-shot: The incoming radiance is computed in the preprocessing phase and the reflected radiance is obtained from the incoming radiance on the fly. Since the surfaces can also be non-diffuse, the incoming radiance received by the patches from each point lightsource

should be stored (this requires l additional variables per patch, where l is the number of point samples of the lightsources) 22. The secondary, non-diffuse emission to a direction is computed from these irradiances. The method is feasible if l is small, which is the case if the scene contains a few point lightsources and small area lightsources whose contribution can be accurately evaluated. 4. On-the-fly direct lightsource computation: Everything is done simultaneously to the global illumination algorithm. This happens in gathering type random walk algorithms, for instance in path tracing, when at each hit point shadow rays are traced towards the lightsources and the direct reflection of the visible lightsources is added to the radiance of the hit point. This approach requires neither preprocessing nor storage but is slower than the previous methods using finite-element tessellation.
This paper discusses the incoming first-shot method and its application in a stochastic iteration algorithm.

3. Incoming first-shot of point light-sources

Suppose that the scene contains l point lightsources at locations ~y1 : : :~yl with powers 1 : : : l, respectively, then their reflection at point ~x is:

T  j ; j(

Lep)(~x

l
) =
i=1

i v(~yi ~x) 4 ~yi ~x 2

fr(0i ~x ) cos 0i

(13)

where tween

0i0i

is the direction of lightsource i, i0 is and the surface normal, and v(~yi ~x)

the angle indicates

bethe

mutual visibility of ~x and ~yi. Suppose that the patch under

consideration is patch j and its area is Aj. The average re-

flected radiance is:

hT i hT i TLep j() =

Lep

j ()

=

1 Aj

Z (

Lep)(~x ) d~x =

Aj

 j ; jl 1 Z i v(~yi ~x)
i=1 A j A j 4 ~yi ~x 2

fr(i0 ~x ) cos i0 d~x:

(14)

To compute the reflection of a lightsource at a point, the visibility of the lightsource from the point must be determined. We can use shadow rays evaluated by ray-shooting, but this is rather slow. Another alternative is to exploit the image synthesis hardware in the following way. The eye is put at the lightsource and the window is defined as one of the faces of a cube placed around the eye. Rendering the images for each faces using constant shading and using the index of the patches as color values, the visible areas of the patches from the lightsource can be determined.

The integral in equation (14) can also be evaluated on the six window surfaces (W ) that form a cube around the lightsource. Note that this is similar to the famous hemicube approach of the diffuse radiosity problem 8. In fact, first-shot requires the vertex-patch form factors that can be computed

presented at SCCG 2000.

4 Szirmay-Kalos, Sbert, Martínez, Tobler / Incoming First-Shot

yi p

point

f

lightsource



 'i

x

' Pj

patch j

windows W
Figure 3: Computation of the lightsource visibility by hardware

by the hemicube. In this section, we re-derive the basic formulae to show that they can also be used in cases when the reflection is non-diffuse.

To find formal expressions, let us express the solid angle

dp, in which a differential surface area d~x is seen through

pixel area d~p, both from the surface area and from the pixel

area:

j ; j j ; jdp

=

d~x ~yi

cos 0i ~x 2

=

d~p ~yi

cos p ~p 2

(15)

where p is the angle between direction pointing to ~x from
j ; j~yi and the normal of the window (figure 3). The distance
~yi ~p between pixel point ~p and the lightsource ~yi equals to f = cos p where f is the distance from ~yi to the window plane, that is also called the focal distance. Using this and
equation (15), differential area d~x can be expressed and sub-
stituted into equation (14), thus we can obtain:

hT iLep j() =

l 1 Z i v(~yi ~x)

i=1 A j W

4

fr(0i ~x )

cos 3p f2

d~p:

Let Pj be the set of pixels in which patch j is visible from the lightsource. Pj is computed by running a z-buffer/constant shading rendering step for each sides of the window surface,
assuming that the color of patch j is j, then reading back the "images". The reflected radiance on patch j is approximated by a discrete sum as follows:

hT Lepi j()

 l i
i=1 4 f 2A j

fr(0i ~x ) cos 3p p2Pj

P

(16)

where P is the area of a single pixel in the image. If R is the resolution of the image -- i.e. the top of the hemicube contains R R pixels, while the side faces contain R R=2

pixels ­ then P = 4 f 2=R2: If the BRDF can be assumed to be f~j(i0 ) in patch j, then the reflected radiance can be decomposed into 3 factors: the power spectrum of the lightsource i, the BRDF f~j(0i ) which is also a spectrum and is the only factor which depends on viewing direction ,
and a scalar factor:

1
ri j = R2A j

cos 3p: p2Pj

These scalar factors are computed and stored at each patch, which requires just one float variable per each patch and each point lightsource.

If variables ri j are available, then the incoming first-shot phase is complete. During global illumination when the re-
hT iflected radiance Lep j() is needed at point ~x of patch j,
this is computed on the fly from the stored scalar parameter
ri j, from the directions pointing from ~x to the lightsources and from the power of the lightsources:

hT i Lep j() =

l
i ri j

frj(0i ):

i=1

(17)

4. Small area light-sources

Now let us discuss the computation of a single reflection of the light coming from a small area lightsource S of emission Le(~y ) to a point ~x. The reflection at point ~x is
T( Lep)(~x ) =
Z
;Le(h(~x 0) 0) fr(0 ~x ) cos 0 d0 =
S

j ; jZ

Le(~y 0) cos  v(~y ~x) ~y ~x 2

fr(0 ~x ) cos 0 d~y

S

(18)

where S is the solid angle in which lightsource S is visible, ~y is a running point on the lightsource and  is the angle between 0 and the surface normal of the lightsource at ~y.

The average reflected radiance of patch j is

hT i TLep

j ()

=

1 Aj

Z (

Lep)(~x ) d~x =

Aj

j ; jZ

1 Aj

Z

Le(~y 0) cos  v(~y ~x) ~y ~x 2

cos 0

fr(0 ~x ) d~x d~y

S Aj

(19)

The outer integral is estimated by trapezoidal rule. It means

that the lightsource area is tessellated to triangles (or quadri-

laterals). The integrand is evaluated at the common vertices

and is assumed to be linear between the vertices. If the num-

ber of vertices is l, then the quadrature rule is:

hT Lepi j()

presented at SCCG 2000.

Szirmay-Kalos, Sbert, Martínez, Tobler / Incoming First-Shot

5

 j ; jl Sti
i=1 A j

Z Le(~yi 0i ) cos i v(~yi ~x) 3 ~yi ~x 2
Aj

cos 0i

fr(0i ~x ) d~x

where Sti is the total area of the lightsource triangles that share vertex i and factor 1=3 comes from the fact that a tri-
angle has 3 vertices.

Note that the inner integral is the same as the integral in equation (14), with the substitution

(i
4

Le(~yi 0i )

cos i

Sti :
3

There is another slight difference in the window surface. A one-sided area lightsource can emit light into that halfspace which is "above" the plane of lightsource. Thus the window surface becomes a hemicube (figure 4). An even better window surface is the cubic tetrahedron 2, since it has just 3 faces while the hemicube has 5.

Summarizing the incoming first-shot from a small area lightsource consists of the following steps. First the light-

source is decomposed into a triangle mesh. A hemicube or a

cubic tetrahedron is placed at each vertex ~yi of the mesh and the visibility of the other surfaces are determined. Scalar fac-

tors

ri j

=

4Sti cos i 3R2A j

cos 3p p2Pj

are stored in each patch.

The reflected radiance can be obtained from this scalar factor during the global illumination computation in the following way:

hT i Lep j() = Le(~yi i0) ri j frj(0i ): i

(20)

5. Application of the incoming first- shot to ray-bundle based stochastic iteration
In this section the incoming first-shot technique is applied to stochastic iteration.
The ray-bundle based stochastic iteration 21 works as follows. At each step of the iteration a uniformly distributed random global direction is sampled, and the radiances of all patches in the scene are transferred into this direction. Having computed the transfer, each patch may have some incoming radiance depending what is seen in selected direction. This incoming direction is reflected towards the eye, which results in an image estimate. The average of image estimates of subsequent iteration steps will provide the final result. Note that in the next iteration step, when the radiance is transferred again in the new direction, the radiance is obtained from the incoming radiance of the previous transfer. Thus the method requires just one variable per patch which stores the incoming radiance of the previous iteration step.
presented at SCCG 2000.

Figure 4: Placement of the hemicube around a lightsource point and the images on the 5 hemicube faces
The combination of this method with the proposed incoming first-shot techniques is quite straightforward. At a given iteration step not only the incoming radiance of the previous transfer is reflected towards to new direction but also the illumination of the lightsources that are associated with the given patch. Thus the overhead is just l BRDF computations per each patch at each iteration, where l is the number of those point lightsources and vertices of the area lightsources which are visible from the patch.

6 Szirmay-Kalos, Sbert, Martínez, Tobler / Incoming First-Shot

incoming first-shot

first shot
previous radiance transfer current radiance transfer
eye transfer

radiance transfers in an iteration step
previous global random direction
current global random direction

Figure 6 compares the speed of the convergence of stochastic iteration with and without the proposed incoming first-shot step. In figure 7 the timing and the image quality of the two methods can also be compared. For the first-shot, the area lightsource has been subdivided into a mesh of 8 triangles and 9 vertices. The incoming first-shot phase took 55 seconds, which were needed by the 9 5 z-buffer/constantshading rendering steps and the reading and processing of the generated images. A single radiance transfer by a raybundle took 1.5 seconds without the first-shot results and 2 seconds when the incoming first-shot was also used. The 0.5 second overhead is due to the reflection of the result stored by the incoming first-shot both towards the eye and towards to next global direction.
However, we can conclude that incoming first-shot is worth for this small extra time, since the resulting algorithm converges very quickly, and the image is almost fully converged after 2.5 minutes. Comparing the error curves, we can see that the stochastic iteration is about 10 ­ 20 times faster with the incoming first-shot than without it.

computation of the image estimate in an iteration step
current global random direction
image plane
Figure 5: Ray-bundle stochastic iteration with incoming first-shot
6. Simulation results The presented algorithms have been implemented in C++ in OpenGL environment. The running times have been measured on a PC with 300 MHz Pentium II processor without any graphics accelerators. The image and the hemicube resolutions were 800 800.
The scene of figure 7 contains a 3D Sierpiensky set and has 22768 patches. The diffuse albedo of the patches in this set is (0:18 0:06 0:12) on the wavelengths 400 nm, 552 nm and on 700 nm, respectively. The specular albedo is wavelength independent and is between 0.8 and 0.4 depending on the viewing angle. The non-diffuse reflection was modeled by the physically plausible stretched Phong model 14. The "shine" parameter is 3.

7. Conclusions
This paper has presented a preprocessing method which replaced the emission of small and point lightsources by their reflection. This replacement makes the integrand significantly flatter, which improves most of the global illumination algorithm. Incoming first-shot requires the identification of the surface areas that can be seen from the sample points of the lightsources. We adapted the hemicube approach for this calculation, inheriting also its deficiencies, which can be reduced by increasing the resolution of the hemicube. Note that in our approach the hemicube is placed just at a few sample points, thus its performance and resolution are not critical issues. The incoming first-shot method has also been combined with ray-bundle based stochastic iteration, and we come to the conclusion that incoming first shot pays off since it significantly increases the convergence speed. With this combination the global illumination of scenes of ten thousand patches becomes possible in a few minutes.
This method makes a greater part of the global illumination problem view-independent thus it provides a promising framework for developing interactive walkthrough animations for non-diffuse global illumination renderings. Instead of storing the complete radiance function 16 19, this approach stores just the effect of the lightsources, thus the required preprocessing time and the storage remain moderate.
8. Acknowledgements
This work has been supported by the National Scientific Research Fund (OTKA ref.No.: T029135) and the SpanishHungarian Fund, ref.No.: E9.

presented at SCCG 2000.

L1 error L1 error

Szirmay-Kalos, Sbert, Martínez, Tobler / Incoming First-Shot

7

Error of rendering the Sierpiensky set

Error of rendering as a function of time

11

With incoming first-shot

With incoming first-shot

Without first-shot

Without first-shot

0.1 0.1

0.01 1

10 100 iterations

1000

0.01 0

100 200 300 400 500 600 700 800 900 1000 time (seconds)

Figure 6: Error of ray-bundle stochastic iteration with and without incoming first-shot

0 iteration, 0 secs

47 iterations, 70 secs

100 iterations, 150 secs

+first-shot 0 iteration, 50 secs

+first-shot 10 iterations, 70 secs

+first-shot 50 iterations, 150 secs

Figure 7: Comparison of stochastic iteration without (upper-row) and with incoming first-shot (lower-row)

presented at SCCG 2000.

8 Szirmay-Kalos, Sbert, Martínez, Tobler / Incoming First-Shot

References
1. Ph. Bekaert. Hierarchical and stochastic algorithms for radiosity. PhD thesis, University of Leuven, 1999. http://www.cs.leuven.ac.be/ cwis/research/graphics/ CGRG.PUBLICATIONS/PHBPPHD.
2. J. C. Beran-Koehn and M. J. Pavicic. A cubic tetrahedral adaptation of the hemicube algorithm. In James Arvo, editor, Graphics Gems II, pages 299­302. Academic Press, Boston, 1991.
3. G. Besuievsky and M. Sbert. The multi-frame lighting method - a monte-carlo based solution for radiosity in dynamic environments. In Rendering Techniques '96, pages pp 185­194, 1996.
4. K. Bouatouch, S. N. Pattanaik, and E. Zeghers. Computation of higher order illumination with a nondeterministic approach. Computer Graphics Forum, 15(3):327­337, 1996.
5. C. Buckalew and D. Fussell. Illumination networks: Fast realistic rendering with general reflectance functions. Computer Graphics (SIGGRAPH '89 Proceedings), 23(3):89­98, July 1989.
6. F. Castro, R. Martinez, and M. Sbert. Quasi MonteCarlo and extended first-shot improvements to the multi-path method. In Spring Conference on Computer Graphics '98, pages 91­102, 1998.
7. P. H. Christensen, E. J. Stollnitz, D. H. Salesin, and T. D. DeRose. Global illumination of glossy environments using wavelets and importance. ACM Transactions on Graphics, 15(1):37­71, 1996.
8. M. Cohen and D. Greenberg. The hemi-cube, a radiosity solution for complex environments. In Computer Graphics (SIGGRAPH '85 Proceedings), pages 31­40, 1985.
9. Ph. Dutre, E. Lafortune, and Y. D. Willems. Monte Carlo light tracing with direct computation of pixel intensities. In Compugraphics '93, pages 128­137, Alvor, 1993.
10. J. T. Kajiya. The rendering equation. In Computer Graphics (SIGGRAPH '86 Proceedings), pages 143­ 150, 1986.
11. E. Lafortune and Y. D. Willems. Bi-directional pathtracing. In Compugraphics '93, pages 145­153, Alvor, 1993.
12. L. Neumann. Monte Carlo radiosity. Computing, 55:23­42, 1995.
13. L. Neumann, A. Neumann, and P. Bekaert. Radiosity with well distributed ray sets. Computer Graphics Forum (Eurographics'97), 16(3):261­270, 1997.
14. L. Neumann, A. Neumann, and L. Szirmay-Kalos.

Compact metallic reflectance models. Computer Graphics Forum (Eurographics'99), 18(3):161­172, 1999.
15. M. Sbert, X. Pueyo, L. Neumann, and W. Purgathofer. Global multipath Monte Carlo algorithms for radiosity. Visual Computer, pages 47­61, 1996.
16. F. X. Sillion, J. R. Arvo, S. H. Westin, and D. P. Greenberg. A global illumination solution for general reflectance distributions. Computer Graphics (SIGGRAPH '91 Proceedings), 25(4):187­198, 1991.
17. I. Sobol. Die Monte-Carlo Methode. Deutscher Verlag der Wissenschaften, 1991.
18. M. Stamminger, Slussalek P., and H-P. Seidel. Three point clustering for radiance computations. In Rendering Techniques '98, pages 211­222, 1998.
19. M. Stamminger, A. Scheel, A. Granier, F. PerezCazorla, G. Drettakis, and F. Sillion. Efficient glossy global illumination with interactive viewing. In Graphics Interface'99, Kingston, Ontario, 1999.
20. L. Szirmay-Kalos. Monte-Carlo methods for global illumination. In Spring Conference of Computer Graphics '99, pages 1­28, Budmerice, 1999. invited talk.
21. L. Szirmay-Kalos. Stochastic iteration for non-diffuse global illumination. Computer Graphics Forum (Eurographics'99), 18(3):233­244, 1999.
22. L. Szirmay-Kalos and W. Purgathofer. Global raybundle tracing with hardware acceleration. In Rendering Techniques '98, pages 247­258, 1998.

presented at SCCG 2000.

