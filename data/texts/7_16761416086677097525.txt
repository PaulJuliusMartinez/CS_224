A COURSE OF 
 ALGO L 60 PROGRAMMING
with special reference to the DASK ALGOL system
Second edition by
Peter Naur
REGNECENTRALEN, COPENHAGEN 1961

C~0

~t~,~1(~1~.t.~

~ и и и и ~ и o и ~ ~ ~ и и ~ i, и и t B ~ o. o, o и и ~ e, и

Co~'~ ~- . . . . . . . . . .

.........................

,~rmmm, 'to m~e of t,he lw~,lem

. .......

. . . . . . . . .... . .

I. X ~

for a ~

'~ble . . . . . . . . . . . . . . . . .

- 2. '1'he so,I.d..foR oil z~.l~te ~

......... ....

- 3. ~e .t,u~:r,~ ot LlSo~'r,~mm . . . . . . . . . . . . . . . . . . . .

- 4. T h e ~use o~ b.lo~iras~ 1~eeednz~s . . . . . . . . . . . . . . . .

и
.

7

28 
 ~2 
 ~, 
 ~? 
 ~8 


INTRODUCTION.

5

~TRODUCTI~.
The d i f f i c u l t y o f l e a r n i n g t h e a l g o r i t h m i c l a n g u a g e ALGOL 60 may b e both under and over-estimated. While it is true that a few hours of study under sult~ble supervision may place the student in a position to express 
 himself intelligently in a basic part of the language, it is clear that a 
 complete mastery of all the possibilities of the language will require 
 conslderably more stu~v. On the other hand the feeling of despair which 
 may seize the student who for the first time tries to acquaint himself 
 with the ALGOL 60 report is caused largely by the special character of 
 this report. In fact, being designed to present as concise and complete a 
 description of the language as possible, ~he ALGOL 60 report cannot be ex- 
 pected to act as a well balanced first introduction as well. 

The purpose of the present course is to act as a guide for the stu-
dent who wishes to acquire a thorough knowledge of the is~guage and some
facility in expressing himself in it. Since thoroughness is aimed at it seems obvious from the outset that the course must be based firmly on the ALGOL 60 r e p o r t itself. For this reason the course itself basically consists only of a set of directions in how to read the AL~0L 60 report and
a set of accompanying exercises. 0n~y occasionally have special notes, dealing with l~rticular points in the ALGOL 60 report, bee~ added. Thus it is hoped that having worked through the d41rections given in the present
course, the student will be in a position to understand the ALGOL 60 re-
port and to use it as his stendard refere~e. Since the course ~s written primarily for students of the DASK ALGOL 

translator syste~ the special characteristics of this system are explained 
 end used. This gives the added a~Ivantage over a pure reference is~guage 
 course that conventions for input and output are available. On the other 
 hand since the DASK ALGOL representation in its appearance lies very close 
 to the reference lam~uage ~ch of the material presented will probably be 
 of more general interest. 

Because of the special character of %~ course the student who is 
 completely u~rel~red will need an informal introduction to the language. 
 Danish readers may use one of the following articles for this purpose: 

W. Heise: AL~0L - et internationalt sprog for elektronregnemaskiner.
Lugeni~re~ mr. 17, i. sept. i959 (this article is s ~ w h a t out of date, being based on a preliminary version of the language, but will serve as introduction all the same).
P. Naur: ALGOL - det internationals sprog til at beskrive logiske og 
 n~eriske processer. Nordisk ~tematisk Tidsskrift, Bind 8 (1960) 117.

6 XIfi'~3DUCTION. 

The course is divided into consecutively n~bered points. Within each of these points additional notes and problems ~ y appear. Section nmnBers will refer to the secti~s of the ~ ~60 report. References to A MANUAL OF THE DASK ALGOL LA~UAGE will be written as for example MANUAL section 7.1.2. For each point there is left space open for the student to note the 
 time required to ~ork thltt point. 


THE COURSE.

7

~ E COURSE.

1. Read through section 1, not including 1.1.

(Time

mln. )

2. Reed through the same section, this time noticing particularly the fol- 


lowing concepts: 


arithmetic expressions 


assi~ent stat~ents 


statements 


labels 


c~pound statements

declarations

blocks

program

(TAme

m~.. )

3. Read carefully through the problem description given in Appendix 1. Try to recognize instances of some of the concepts listed in point 2.

3 Problem i. Which of the concepts listed in 2 do not sppear in the pro- 
 blem description of Appendix i?. 


4. Study section 1.1 Formalism for syntactic description. (Time

rain.) 


A~ Note 1. The m e a n i ~ of the syntactic formulae may he further explained

by ~

that words enclosed in the bracket < >, like (ab>, denote clas-

ses whose members are sequences of basic symbols. Class desiKnatlons of

this kind are found in any description of a language. For describing ordi-

nary natural languages designations like word, verb, noun, are used. This

of co'uLrse introduces the logical difficulty that a clear destinctlon be-

twee~ the languaKe described and the language used for description (the

meta-la~uage) is not ~ e (the designatlon verb is itself a word, but not

a verb). This difficulty is avoided in the description of AI~0L by intro-

ducing the special mark < > for metal~nulstic classes.

The fact that the syntactic rules of AlgOL may be described fully and

c o n v e n i e n t l y b y means o f t h e very simple forn~!is~n of section 1.i i8 of

course simply a consequence of the ~wy the Is~uage has been defined.

8 TEE COURSE. 


4 Problem 1. Half of the following sequences are values of <ab> as defined 


in section 1.1, the rest are not. Find those which are. 


I. 213

5. [2.73( 

9- (a + b)

3. f~(34  ~. 

v. [2?(3(((
s. ((a

11. [22(2(3) 12. (987(65

5. Read once carefully through sections 2, 2.1, 2.2.1, 2.2.2, 2.3, inclu- 
 the footnote 1 to section 2.1. Do not try to learn this section by 

heart. 


5 Note I. Note the following special features of the DASX AL00L represen- 


ration: 


The DASK ALGOL alphabet includes m,Б,~,@. 


. is not included in DASK ALGOL. 


F o r T DASK ALGOL u s e s 


is not included in DASK ALGOL

For -~ DASK ALGOL uses -,

For ' and ' DASK ALGOL ~ea б and

For Boolean DASK ALGOL ~ea boolean

The third form of c~ent is permitted only in the restricted form

end <any sequence of digits or letters>

(Time =in.)

5 Problem i. Some of the following characters or groups of characters re- 


present basic ALGOL 60 symbols, others do not. Using sections 2 - 2.3 as 


reference, find those which do. 


1. a7 

5. ~

9. end 


2. function

6. x 

i0. 


3. value 

7. :=

11. unt_.__~

4.  :

8. -:

12. ->

rain. )

5 Problem 2. Use the ccmnent conventions to contract the f o l l o w i ~ sequen-


ces as much as syntactically possible: 


1. a:=b+3 ! ccmam~t Now comes the inner loop ! V: l~/:=n ! 


2. be~in comment This is executed whenever q~7 ! if I ~ 0 then o ~ W ! 


3. ~I~T.'-~ ~ section 2 els___~~ t_~W 
 . . . . . . 


4. t u : = v ~ 2 end block V and ~_d block sub V ! 


(Ti=e ~. )

6. Study section 6: 8-channel punch tape code and flexowriter keyboard. 


6 Problem 1. F o r each o f t h e d e l i m i t e r s which i s n o t an u n d e r l i n e d word,

find out how it will be typed using the DASK ALGOL keyboard. Ass~

that

the previous case shift is unknmm, find the number of keys to be depres-

sed for each of the delimiters. Arrange the dellmlters in groups according

to the number of keys to be depressed and find the ntmber of dellmiters in

each group.

(Time

mln. )

THE COURSE. 


9

7. Study sections 2.4.1 - 2.4.3.

7 Note 1. In DASK ALGOL only the first six characters of an identifier 
 will be recognized. Thus, although identifiers of any length may be used, 
 two identifiers, to be different, must differ in one or more of the first 
 six characters. 


7 Note 2. The complete list of reserved identifiers of DASK ALGOL is given 
 i n MANUALs e c t i o n 7.4.

7 Note 3. The sentence in section 2.4.3 on the same identifier denoting

different quantities implies that at any one place in an ALGOL program one

cannot have an identifier denoting, say, both a simple quantity (a nulber)

and a m a t r i x (an a r r a y of nmabers). This r e s t r i c t i o n i s not obvious since

it is al~ays possible to recognize array identifiers by the following bra-

cket [ ].

(Time lldJm.)

7 Problem 1. Some of the following sequences of characters can be used as 


identifiers, others cannot. Mark those which can. 


1. begin

5. P7.2

9. 7VPQ

2. axv

6. Start value

I0. _~ 


3. 4711

7. nmnber

11. a29v3

Ii.. PPP3

8. Q(2)

12. epsilon
xL,.) 


8. Reed section 2.5.1 -2.5.4.

(~ ,~.n. )

8 Note 1. In DASK ALGOL nmnbers must be confined to the following ranges 
 - 524288 < integer ~ 524287 

2.9%.9 ~ ~bs(~) ~ 3.40~8 


8 Problem 1. Write numbers having the same values

which do not include an exponent pert.

1. +7.293~8o

3. ~+3

2. 98.121o+2

4. - . lt:~4~-5

as the followlng,
5. -~-6 

6. и-g. 81o~

but

8 Problem 2. The values given by the following n ~ b e r s may, in some cases,

be expressed more economically by using a number with an exponent part.

Show where t h i s i s the case.

1. 17ooo

3. -o.oo134

5. -o.oo2oo41298

2. 1000

4. 1.0024

6. 170
(TJ.ffi~ ,~. } 


8 Problem 3. Some of the followir~ sequences of characters represent num- 


bers, some do not. Mark those which do. 


1. -.0 08

5. -17.2.30

9- 13.411 732

2. +13.47m+18

6. +4.2

10. 2.48~n 


3. 4 ~ _-2
4. (16.2%)

7. --88 -7
8. 1,2]~

11. ~ 64~.2 

~2. 12.1o8 

(T~,~ ~n. ) 


10 THE COURSE. 


9. The sections 2.6 end 2.7 may be skipped for the moment. Read section 
 2.8. Continue to read section 3 up to and including section 3.1.3 leaving 
 out, however, anything dealing with subscripts or arrays. 


9 Note 1. A recursive definition is a definition which uses the defined 
 object itself as a part of it. 


9 Note 2. The definition in section 3.1.1 of a simple variable is unne-

c e s s a r i l y complicated since the construction <variable identifier> is com-

pletely equivalent with <simple variable>. The formulation given ~as cho-

sen because it ~as considered desirable that there exist a <variable iden-

tifier> analogous to <array identifier>, <procedure identifier>, and

<switch identifier>.

(Time

rain.)

9 Problem 1. Which of the examples of section 3.1.2 denote simple varia- 


b:e,~.

(Ti,,,e ~n. )

10. Study section 5.1.1 - 5.1.3 on type declarations. 


10 Note 1. Remember that DASK ALGOL writes boolean.

(Time rain. )

10 Problem 1. Same of the following
some do not. Mark those which do. 
 i. in_~_~r q l 0 qll, h
2, _~._~.Б~r
3 . boo__l~H} i n t e g e r 4. ..~..~.~r.a5, 7
5- ~_~_ number, HH
6. i m _ ~ r 2,~b, L2, ~

sequences denote type declarations, 


7. own boolean t r u e
8. _~..'~,._~. xz, (v)
9. r ~ ! k I B
10.
ii. r ~ 2.3~
12. E ~ ! STUFF 
 (TJ.m

~.n. )

11. Read sections 3.3.1, 3.3.2, the first paragraph of 3.3.3, a n d 3.3.4 -

3.3.5.2, leaving out, however, anyth!n= dealing with function designators,

if clauses, end subscripted variables.

(Time

rain. )

11 Note 1. DASK ALGOL does not include ,. 


11 Example 1. The proof that a given construction is an ALGOL 60 arithme- 


tic expression is equivalent to showing that the construction may be for- 


reed through applications of the rules Of section 3.3.1. Thus for elmmple 


the construction 


(b+c

e f) g 


is proved to be an expression through the following steps:

Primaries:

ab cdefg

Factors:

ab cd

g

and therefore also:

d


Terms:

a

and therefore also:

Simple arit~etic expressicas:

and therefore also:

b c
 c xd~ e~ f
 b
 b +c xd~ e~ f

THE COURSE. 


11

Arithmetic expression:

IeI'b+cxd

Primry:

e r)

Factor:

+ c d e f)

Term:

a x и r)

and. therefore also:

a x + c d e f) x g

Simple arithBetlc expression: a x + c d e f) ~ g

Arithmetic expression:

ax

e f) x g

Through the analysis we have had occasion to introduce the following num-

bers of syntactic units:

Primaries:

8

Factors:

8

Terms:

6

Simple arithmetic expressions: 3

Arithmetic expressions:

2

(Time

rain. )

11 Problem 1. Analyze in the sane way as in the previous example the con- 
 struction of each of the following arithmetlc expressions and find the 
 nt~ber of different syntactic units in each case. 
 1. ((e))
2. ~/~s+~) 

3. +A-2x ( C+D,~,(E-F) ) 
 Having worked through these examples you will realize that the apparently 
 rather c~pllcated rules of section 3.3.1 essentially are only a concise 
 formulation of the ordinary rules for writing arithmetic ex~resslons. 

(~ ~n. )

11 Problem 2. S u e of the followir~ sequences are arithmetic expressions,

some are not. Mark those which are. 


i. ~b/~/exr

5. 3.~(V+n)/4 


2. +ax-b

6. PQ~+7.3 + 


и ~6x4.3 + Q

7. -(+(-v))

4. 2,5o6/4.3

8. p/qrsxtu-v

(Time

rain. ) 


11 problem 3. For each of the correct arithmetic expressions of 11 Problem 


2 write a reasonable type declaration for the variables which occur in the 


expression.

(Time

rain.) 


11 Problem 4. Assuming that at a certain point in a program t h e values of 


seven slmple variables are as follows: 


va = 2, vb - 3, vc = 4, vd = 5, ve - 6, vf = 7, vg - 8, 


find the values of the following expressions: 


1. "V'a -I- YC x v b / v e

2. vd x VC + V g ) / v e / ',m

3. vc + vd - vb) 
 4. vf a ~ ( ~ - v c ) / v b /

(vh+vc)

5. 
 6. 


7. (VC vb~ .~ Va

8. 


9. vb ~ ~ - v e ) ~ ( - v a ) + ~ ) ~ v a + v e ) ~ ( ~ - ~ ) ) -vS + 2 10. vc + ( v s - v b ) 


11. I v S - ~ ) ~ v b + r e

12. ve v r - va) + vc

(Time ~n.)

12 THE COURSE.

11 Problem 5. Write the following mthesmtical

pressions, without using redtmdant parentheses:

I.

S

+

8
-

-
-


t

v2

exI~'eulo~ as AT.J~OLex-

2. (u - w)O. - ~-~---~ ~ n+m 


5. d░+~ 
 6. (4')g 


7. 
 r~
t 

a


b


~(j-k) (~) 
 h +q

( ~ e ran.) 


12. Read sections 4.2.1 - 4.2.1~ ignoring f o r the ~ e n t t h e references to subscripted variables and the entler funeti~.

12 E x a m p l e 1. As e x p l a i n e d i n g r e a t e r d e t a i l l a t e r s t a t e m e n t s a n d d e c l a r a -

tions are nor~y

lep~r~ted by a semicolon and consecutive itatemente

will nor~lly be executed in the order in which they are written. Thus a

p a r t of a p r o g r a m might l o o k llke this:

real a, b, p, q !

a := b := 7 ! 


p :- a + 3 x b - 2.310-1 ! 

q,-p+(~+3)/(-b-l~) I

a :- p :=q-b

x 0.2 !

In o r d e r t o f o l l o w t h e sntl~ o f l:~ese stateaents it is useful t o w r i t e a

table with a colmm for each variable, where each new value of this varia-

ble is entered. Such a table II s h o ~ below, where in addition the inser-

ted numbere from 1 to 6 show the order in which the new values are formed.

ab p q

I: 7

2: 7

3, 27.77 ~: 27.27 


5:25.87

6:25.87 


Thus the final values of a, b, p, and q, are 25.87, 7, 25.87, and 27.27, 


respectively.

(Time

rain.) 


THE COURSE. 


13

12 Problem 1. Using the same system as in 12 Exmmple 1, follow the action of the following statements and find the final values of the variables.
re_al rl, r a , rb !

n :==5 ;
rl : n~(n + 15) ; 

rb := n + 6/(6 x rl + 0.5) ; 

i := n := n - 2 | 
 J :=rb-i ; 
 ra := (J - I ) x rl x (rb - /4) ! 
 rl := r a + rb + n + I + J + 8 x rl ! 
 rb := (rl - rb x n + J - ra) $ (rb - j )
J := n :- l + n ~ - (J - 2) ; 

i :=n+ ra;

+ ra , 


13. Read sections 3.4.1 - 3.4.6.2.

(~NJe (~e

,~.,.) 
 ran.)

13 Note 1. In DASK ALGOL the implication operator D is not included. 


13 Problem 1. Using the ssme technique as the one explained in 11 Exsmple 


1, analyze the following Boolean expressions and find the number of rela- 


tions, Boolean pr~v'ies, Boolean secondaries, Boolean factors, Boolean 


terms, Implications, simple Booleans and Boolean expressions entering into 


each of them: 

i. (( ) ^ ( P > Q v W ) ) 


17.2 vWAQv-,

T


13 Problem 2. For each of the expressions of 13 Problem I, write suitable 


type declarations for the identifiers.

(Time

min. ) 


13 Problem 3. Using the s a n e scheme as in 12 Example 1, work through the following statements and find the final values of all variables.
Ee_~ ra, rb ;

boolean ha, bb | 

:'7.3 ! 

la :=5 ; 
 rb := 3 x r a - 2 x ia l 
 ba := rb > la ^ ia > ra ; 
 ra := 2 x ( r a - la) - 1 ; 
 ba := -, ra > l a v b a ; 
 bb := (ba = rb > ia) A ra < rb ! 
 ba := -,(ha v b b ) ,

(Time

~.) 


14 THE cotr~E.

14. Convince yourself that according to section 3.5.1 a label may be an 
 unsigned integer or an identifier and that a designational expression may 
 be a label. Read sections 3.5.5 and 4 and the first three lines of section 
 4.1.1. Read sections 4.3.1 - 4.3.3. 


14 Note 1. In DASK ALGOL unsigned integers cannot be used as labels. 


14 Problem I. The following statements generate a sequence of values for 


SUM. Find the first four of these values.

re___~ p, q, SUM !

in~e~r n 1

n:=l!

p := 0.5 !

SUM :=0 !

q:~l!

loop:SUM :- SUM + q/n !

q :mqxp!

n :-n+ 1 ;

~qto loop !

(Time

mln.)

15. Reed sections 4.4.1 - 4.4.3.

(Time

mln. )

16. Read sections 4.5.1 - 4.5.4 ignoring for the moment those syntactic u- 
 nits which have not yet been defines during the course. 


16 Note 1. The necessity of introducing the <unconditional statement> ari-

ses because a construction like

If B1 then if B2 t_h_en S := exp els___SV :- Q + 1 !

must be avoldecl since its meaning is not clear.

(Time

sin. )

16 Note 2. The basic point of the syntax o f conditional statement is the
following: An i__fcan never follow a th_e_n.

16 Problen i. Using the syste~ of 12 Example 1 follow the action of the 


following statements and find the final values of all variables. 


~rea.! u, W !

boolean B ! u:=3!

B := t~_e ! repeat : W : = u - 2 !

i ~ ~ - 1 / u > o ^ w > -2 th_.~ u : - 1/u e l s e i~' B t.,3e_n 6_o_~ Z else ~ot.~ end !

Z:  B :- f~lje ! 


u:=W+2xu! 

~2to repeat I 


end:  B := u _> W

(Time

mln.) 


THE COURSE. 


15

17. Read sections 4.1.1 - 4.1.3 ignoring the syntactic units which have 
 not yet been covered: procedure statea~nts, for statements. Reed also sec- 
 tion 5. 


17 Note 1. Section 4.1.1 gives the important rules of how to Join state- 
 ments and declarations together to form a program. The -w~n difficulty of 
 this section is that of punctuation, particularly of when to write semi- 
 colon and when not to. The difficulty is directly connected with the use 
 of the delimiter .~. As a guide for the student the relevant rules may be 

restated as follows: 


PUNCTUATION RULE I: Within a program the first symbol following any 


statement (whether basic or not) must be one of the following three: 

; e_lse ~__.d

Ptq~C'FJATION RULE 2: Any sequence . . . end end end . . . within a

program must always be terminated by semicolon or el_...se.

Punctuation rule 1 follows directly from the syntactic rules gover-


ning statements (sections 4.1.1, 4.5.1, 4.6.1, and 5.4.1). Punctuation ru- 
 le 2 follows from observing that an end, whenever it occurs, is the last 


symbol of some statement, and then applying punctuation rule 1. 


(Time

rain. ) 


17 Note 2. Recall the special comment conventions for en_d (section 2.3). 


17 Note 3. In DASK ALGOL the declarations in a block head cannot be given

in an arbitrary order, but must a p p e a r i n the following order:

First: type declarations

Second: array

-


Third:

s~rJ.tch

-


Fourth: procedure -


17 Exawple i. The concept local may be illustrated by an example of a pro- 
 gram structure as follows: 
 LI: h e r re___~A, B, C ! 


ии

иии

L2: P: A : - B + 2 x C ! 


L3: ~ s _ ~ _ ~ _ A, ~ ; 


Q i ;-'2".'B э c ,
LS: D:-2+B+A! 


L6:
L7: 
 58: 


P: C := 2 x A - D
иии ии

!


Lg: _~d ! 


L10: R: ~ o _ ~ P 


Ll1: ena 


16 T~C0~E. 


Here we have a larger block, from L1 to Lll, containing as one statement a 


mml]er block froR L3 to Lg. In the outer block we work with the identi- 


fiers A, B, and C, which are local to this block. In the statement at L2 a 


value is asslgned to this A. The inner block introduces a new, local, A 


an~ a D. Thl8 A, then, has no relation to the A of the outer block, which 


is now screenecl. The variables B and C, on ~he other hand, are the same in 


both blocks. At L4 they are used to aselgn a value to the local A. This 


value is again used ~o assign a value to the local D at L5 и These opera- 


tions make no use whatsoever of the A of the outer block. At L6 a value is 


assignecl to the non-local C, using the local A and D. Labels are autoaBti- 


cally local. Thus the labels Q and P at lJ~ and L6 are only accessible from 


inside the inner block. The gO to statement at L7 will therefore lead to 


the s t a ~ a ~ n t at L6. The go to statement at LS, on the other hand, will 


lead out of the inner block to L10 because the identifier R, bein6 not de- 


clarecl in the inner block, will be non-local. The moment this passe~ge out 


of the inner block occurs the local variables A and D are completely lost. 


The go to sf~tf~ent at L10 will lead to L2 because the label P at L6 is 


local to the inner block end thus inaccessible from L10. (Time

min. ) 


17 Problem 1. Using the system of 12 Example 1 follow the action of the 


following program and find the values of those variables which are defined 


at the label STOP. 


beD__ ~__~W, S, B, C ; 


Li: W := 8 ; 


L2: S := 3 ! 


L3: B := 2 x W - S ! 


IJt:

C :- B - W ; 


LS: W := B - 2 x C ; 


56: P :- C~2 - B ! 


L7: AA: W :- P - 2 x W ! 


LS: C :-C+ 1 ; 


Lg: i_f W > 1 then 6o_t_o AA ! 


L10z

S :=W - P + S 


Lli:  W := W - C + S ! 
 STOP: 

en_~ !

(Time rain.) 


1 7 P r o b l e m 2. Cheek the syntactic structure of the program of 17 Problem 


i ~ainst the rules of section 4.1.1 and find the number of unlabelled 


basic statements, basic statements, unconditional statements, statements, 


colpouncltails, block heads, unlabelled c~apounds, unlabelled blocks, com-


pound statements, and blocks.

(Time min.) 


18. Read section 2.7. 


18 Note i. The scope of a label comprises, so to speak, all those state- 
 ments from~hich the label may be seen. 


18 Note 2. The definition of scope should be changed to read: 
 The scope of a quantity is the set of basic statements, if clauses 

and for clauses .... 


THE COURSE. 


17

18 Example 1. The concept of scope may be illustrated by the e~-.Dle given 


in 17 E ~ m p l e i. The scopes of the different quantities are as follows: 


Scope includes stat~__ents at 


A and P in outer block

L2 L10 


B, C, and R

L2, L4, L5, L6, L7, LS, L10 


D, Q, and A and P in inner block

L4, L5, L6, LT, L8 


(Time

~.) 


18 Problem 1. Find the scopes of all the identifiers of 17 Problem 1. 


(TiMe

IE[n. ) 


18 Note 3. The meaning of the second paragraph of section 2.4.3 should now 
 be clear. 


19. Read sections 5.2.1 - 5.2.4.4.

(Time

rain.) 


19 Note 1. In DASK ALGOL ~ a r ~ y s cannot be handled (cf. MANUAL section 

7.12). 


19Problem 1. Write a declaratlon for tb~ following arrays: 

MatA a n d ~ t B , having two subscripts, the first runningfrom 1 to k, 
 the second from 1 to n, 

Zoop, having four subscripts, the first running from -7 to +7, the 
 second from 1 to 10, and the third and fourth from 0 to I. 

(~ ~n.) 


20. Read (revise) sections 3.1.1 - 3.1.4.2, paying special attention to 


the subscripted variables.

(Time

min.) 


21. Convince yourself that according to section 3.3.1 subscripted varia- 


bles maybe used in the same wayas simple variables in arithmetic expres- 


sions.

(Time

min.) 


22. Read (revise) sections 4.2.1 - 4.2.4.

(Time

rain. ) 


22 Note 1. In the fourth example of section k.2.2 there is a mistake in 


some of the editions of the AI~0L 60 report. The first symbol should be S 


(not s, cf. section 2.4.3).

(Time

min.) 


22 E ~ p l e 1. The detailed exllanations of secti~)ns 4.2.3.1 - 4.2.3.3 8re 


relevant in a case llke: 

~ n l ~ A [ I : 1o] 


n:=2| 


A [ n + 1] := n : = n + 2 ! 


Section 4.2.3.1 produces: 


A[3] : = n :=

Section 4.2.3.2 gives the value of the expression as 4. Section 4.2.3.3 assigns 4 to n and A[3].

(~i~

~.n.)

18 THE COURSE. 


22 Problem I. Using a ~ i n the system of 12 Exsmple 1 follow the action of 


the following program and find the values of all variables at the label 


STOP. 


b_e6~ ~ t e ~ r i, J I ~ ! ~ _ r ~ r ~ A[i:3, 1:2], C[0:2] I 


J := i :== 1 ! 


C[J-I] ; A[J,i] := J :~ i + 2 x J + 2 , 


;.A[2~i, C[J-2-3.i!-3] : J - 2 ~ i I
C[A[2,2~J-8]-3] : i := i + J

A[C[J-i+I~2. 4xA[l,l] - 3xi] : All, 2x(i-J)] :,, A[2,2] - A[1,1] ,

i := - A[3,2] ,

~:=i-J! 

All -J-2] ,- c[i-1] :. 7

A[A[2,2], C[I] - C[O]] : ~[i] := 2 x i ,

STOP:

~.) 


23. Read sections 3.2.1 - 3.2.5. Ignore the concepts <string> and <switch 
 identifier> and the references to procedure declarations and procedure 
 statements. If necessary use the alphabetic index at the en~ of the ALaOL 

60 report to find the definitions of any other syntactic units. 


24. Convince yourself that, according to section 3.3.1, function desi~a- 


tc s

be

In t tio .

.ions in the m 


riables. 


24 Problem I. Follow the action of the following
final values of all variables.
bes_L_l r e a l r , p, s, log I
~-:--4-V~ct~(1) , 
 .
r :- 4 ~ sln(W6) ; p :,, p/r | 
 s := 5 + cos(p x sqrt(2xr~2 + 1)) 
 r :- sign(r~ - 2 ~ s)~(s - r) ,
log ,- ~,x(s+r))/ln(1o) ,
p := p x (s+r)
e n_a и

stat~ents and find the (T~ ~. ) 


THE COURSE. 


19

24 Problem 2. Write an algorithm for calculating the complete solution of 
 the second order equation 

Az2 + Bz + C = 0 
 The algorithm should be written as a block having the real variables A, B, 
 and C, supplied from outside and itself supplying the solution in the form 
 of two complex numbers. These should be expressed as four real variables 
 using the following identifiers: 

zlr real part of first solution 
 zli ~m~inary part of first solution 
 z2r real part of second solution 
 z2i ~.~ginary part of second solution. 
 The quantities which have a meaning outside the block of course 
 should not be declared in the block head. 
 The solutions are given by the usual formula: 


Z~

- B▒
2A

- 4AC

If B2-~AC is negative this formula should be used for finding both of the 


complex solutions. If, however, B2-4AC is positive the following method 


should be used for avoiding forming the numerator as the difference be- 


tween two nearly equal nt~bers: The above formula should be used only for 


finding one of the roots, nsmely the one which results from taking that 


siga of the square root which makes the ntmaerator be formed as the sum of 


two numbers of equal sign in other words from taking + the square root 


when B is negative and - the square root when B is positive. The other 


real root may then be formed from 


z2 - ...C.
 . 
 Ax zl

0


where zl denotes the first ro~. 


If AgO the equation is ~inear and should be solved as such. If also

B~O the algorithm should go to a label outside the block c-11ed INDE~MI-

NATE.

If the two solutions degenerate to one both zl and z2 should be set 


equal to the correct solution. If the solutions are real the imaginary 


parts should, of course, be set to zero. 


Check your algorithm by following the action of it for the following 


sets of the parameters: 


Parameter set A B C 


1 0 0 2


2 o 4 8


3 2 o -8 


1 -lo 9 


5 -i +1o -9 


6 -i -4 -4 


7 2 -8 26 8 4oo

(~ime rain. )

25. Read (revise) sections 3.3.i - 3.3.3 peying special attention to the mechanism of the if clause and _else (see particularly the second paragraph 
 of section 3.3.3). 


20 THE COURSE. 


25 Note 1. In an expression like 


it is important to notice that the meaning is equivalent to 


i_fBth__y~p else (q + r) 


and not equivalent to 


( i f B the_..n p els__.e q) + r

The reason for this is the following: The + in the original expression

must, according to section 3.3.1, stand between a <simple arithmetic ex-

pression> on the left, and a <term> on the right. The <term> obviously is

r. The <simple arithmetic expression> must be q. It cannot be 
 i_f B  .t..he~ p els..__.~ q

since this is not a <simple arithmetic expression>.

(Time

min.) 


25 Problem 1. Follow the action of the following statements and find the 
 final values of all variables. 


a:-7; 
 V:  b := if a > i0 th_e_n 15+a e__lse 13-a ! 

a :- 1 7 - b ! 

STOP: 
 end

(Time

rain.) 


25 Problem 2. Find out whether the following construction is correct or 


not, and prove your conclusion on the basis of sectlon3.3.1: 


A + if q<O the___n7 sls~ 4

(Time man.) 


25 Problem 3. Write an al~orithm for finding the polar coordinates r and 


v when the rectangular coordinates x and y are given. This is equivalent 


to solving the equations 


r cos v = x 


r sin v ~ y 


The angle v, which should lie in the range from 0 to 27~, should be deter- 


mined through the use of the standard function arctan. The quadrant must, 


however, be determined from the sign of x or y. Be sure that your algo- 


r i t ~ will work also for x and/or y - O. If both are zero v should be set 


to zero. 


Check your algorithm by following its action when x and y are given 


initially as follows: 


Case:

1 2 3 4 5 6 7 B 9


x 0 1 1 0 -1 -1 -1 0 i 

y o o I I i o -i -i -I (Time rain.) 


26. Read section 3.3.6 and MANUAL section 7.6. on the arithmetics. 
 ( T ~ min. )

27.  Read (revise) section 3.4.1 paying special attention to the if clause 


and e~s_e. 

(T:bne ~i.. )

THE COURSE. 


21

27 Problem 1. Find the value of the sixth expression of section 3.4.2: 


for the following three sets of values of the variables:

k sw h c

Set i

-1 2 2 4 3

2 22243

3 1 4 5 2 2

(Time

~n.)

27 Problem 2. Find the value of the l a s t expression of s e c t i o n 3 . 4 . 2 :

if if if a th_s_nb el s_e c then d else f then g e_ls_e h<k

for the following three sets of values of the entering variables:

ab cd fgh k

Set I true true true false false false 5

7

2 false true false false true f~ise 5

4

3 fals_e _f_~_s..e _f_~.se_ t_~_e f a l s e false 5

m4n,) 


28. Read sections 3.5.1 - 3.5.4 and 5.3.1 - 5.3.5. These sections are intimatelybound together and cannot be understood withoutreference to each other. React (revise) sections 4.3.1 - 4.3.5. 


28 Note i. The kind of situation referred to by the remark
5.3.5 may be illustrated by the followlng example: 
 h e r switch W :- tt, Q[n + 2] ! 

switch Q : - Q1, Q2, Q3 !

of section 


blL " "

end

~ e go t o s t a t e m e n t a t TT r e f e r s t o W[2]. The d e s i g n a t i o n a l e x p r e s s i o n f o r

W[2] is Q[n+2]. Into ~his expression the variable n enters. Owing t o the

declaration real n in the head of block A the statement TT is outside the

scope of the-n-of q[n+2]. Consequently the go to statement is undefined.

(Time

~.)

28 Problem 1. Follow the action of the following statements, write a list 
 of the labels to which the go to statements successively refer and find 
 the final values of the variables: 


switch S :-SB, $2, $3 STOP ! 

~to---~ w := ~ , s[n - ~ + 7] , 

n:=7  t 

SB:  n :-n - 1 ! 
 s :-s+n!
o~w[n - 2] , 

$3:  n :-n-2 ! 
 s :=n-2| 

~__to w[n - s - 1],
STOP: 


(Time mln. ) 


22 THE COURSE. 


29. Read sections 4.6.1 - 4.6.6.

(Time

sin.) 


29 Note 1. The definition of <for statement> contains an ambiguity which 
 has not yet been officially resolved. Until this happens it is recommended 
 that it be corrected to read: 

<for statement> := <for clause><unconditional statement> I 
 <label: <for statement> 


29 Note 2. In DASK ALGOL the ~ontrolled variable of a for clause can only 
 be a simple variable, not a subscripted variable. 


29 Problem 1. Find the values assigned to the controlled
following for statements and the final value of s: 

besln ~ p, q, r, s ; !n...~er k, m ; 

p := 1 ! q := 2 ! r := 3 ! s := 0 ! 
 f_2r k := p + q, q - p, rxp - q _d_os :- s + k ! 
 fo_r m :- q _s~_~ r until 7xq + 1 do s := s - m ! 
 fo_r k := 2, s, 2 _s~'p 2 unt_._i.1 6 -~2 s :- s + 2xk ! for m := s + 4.5, m + 2 while s<0 d_o s := s - m I 

to_! k := i ~ta..~ I ~tl../ 5 do
for m := 3 s t ~ -i ~ t i l 0 do s :- s + k + m ~

variable in the 


(Time

sin.) 


29 Example I. For statements are particularly useful for executing opera- 
 tions on vectors and matrices (described in ALGOL as arrays). A simple ex- 
 ample is the addition of tvo vectors VA and VB to give a third VC. This 
 may be expressed as
inteser i ! a ~ VA, VB, VC [I : n] ! 
 fo_.E i := i s_t~ i ku~ti~ n do VC[i] := VA[i] + VB[i] ! 
 Note that the quantity n cannot be declared in the same block head as the 
 arrays VA, VB, VC (cf. section 5.2.~.2). 


29 Problem 2. Write a block for multiplying matrix A (subscripts from 1 to 
 i and 1 to J) by matrix B (I to J by 1 to k) to form a matrix C (I to i by 
 1 to k). Mathematically this is expressed as 


c = ~ ~s x Beq
s

(Time

sin. ) 


30. As an introduction to the study of the remaining part of the langus~e, 
 the procedure mechanism, the following notes may be of help. 

The procedure concept essentially has developed from the desire of 
 being able to. introduce any needed extension the basic mechanisms of the 
 language. A few ex~ples of such extensionb are matrix arithmetics, tran- 
 scendental function such as Bessel functions, and integration of differen- 
 tial equations. 

In ALGOL all such mechanisms may be expressed by means of procedures. 
 The ALGOL procedure concept is based on procedure declarations and proce- 
 dure statements. A procedure declaration is the means of defining a new 


THE COURSE. 


23

mechanism and associating an identifier with it. Thus the essential part 


of a procedure declaration is a piece of more ele~taryALGOL language, 


the so-called procedure body. The rest of the procedure declaration, the 


procedure heading, only serves to specify the ~anner in which the proce- 


dure body is connected with the rest of the program. 


The procedure declaration never executes any operations by itself. In 


order to put the process defined in it to work it is necessary to call it 


by means of a procedure stat~-~nt. This, then, m a y b e thought of as a 


short hand description of the complete process defined in the procedure 


declaration. This is all the more apt since the same procedure maybe cal-


led from~uy n~er of different places within the same program. 


Now read section 5.4.1 - 5.4.6. If necessary use the alphabetic in- 


dex of definitions.

(Time

min.) 


30 Note 1. In agreement with the correction of 29 Note 1 the declaration for Ab~xshould be corrected as follows: Insert a b~in ~-~diatelybefore if a n d a n e n d b e t ~ e n the two en__d's.

30 Problem 1. In each of the 5 examples of section 5.4.2 localize the pro- 
 cedure heading and its constituents: procedure identifier, formal Parame- 
 ter l~art, ! , value l~rt, specification part, and also the parameter deli- 
 miters. Find the formal parameters. Finally for each of the identifiers in 
 the procedure bodies find out whether it is local, for.~], or non-local. 


30 Froblam2. Quote the procedure identifier of those of the procedure de-

clarations of section 5.4.2 which define the value of a function designa-

tor.

(Time

sin. )

31. Read sections 4.7.1 - 4.7.4 and 4.7.7. 


31 Example i. The important rules of section 4.7.3 may be illustrated by 


the following elaboration of the examples of sections 4.7.2 and 5.4.2. The 


first procedure statement of section 4.7.2: 


Spur(A)0rder: (7)Result to: (V)

*~: 


can only make sense if it occurs in a block where, besides the declaration 


for the procedure Spur, declarations for A and V hold as follows: 


A[1:7o 1:7] ! _~=~ V !

Now the effect of the rule of section 4.7.3.1 will be to add the as-

sigr~ent statement

n :=,7 and the declaration ~__~ n at the head of the procedure body.

The effect of the rule of section 4.7.3.2 will be to replace a by A

and s by V throughout the procedure body. Thus, the effect of the above

procedure statement is the same as that of the following block

b_.~_n !_n_t_egerk, n ! 


n:=7! 


V:=O; 


fo=r k := I ~_te~ I until n _a2 V := V + AEk,k] 

en~ (Time

rain. )

24 THE COURSE. 


31 Probl~m 1. In the same ~ V as in 31 Example 1 execute the operatlons of 


section 4.7.3 to find the effects of the remaining procedure stat~ents of 


section 4.7.2: 


Transpose (W, v+l) 


Ab...nx (A, N, M. Yy, I, K) 


Innerproduct (Air, P, u], B[P], 10, P, Y)

(Time

mln.) 


31 Problem 2. Assuming that the value part: value n were removed f r o the 


heading of the declaration of Transpose (section-5.4.2), what would be the 


effect of the procedure statement 


Transpose (W, v+l)

(Time

mln.) 


31 Problem 3. Find the values of the quantities R, I, and K, at the label 


FINIS of the following program (the declaration for Absmax is that of sec- 


tion 5.4.2) : 


be6in ~

zero[l:2, 1:2] ! r e a l R ! integer I, K ! 


zero!l,2] :-

:- 0,

Absmax (zero)slze.(2,2)Result:(R, I, K) ! 


FINIS: 


e~! 


If you find the result unsatisfactory what improv~ent of the procedure 


declaration could you suggest.

(Time

min. ) 


32. Read sections 4.7.5 - 4.7.6. 


32 Note 1. In DASK ALGOL it ~ not be possible to call arrays by value. 


32 Note 2. In DASK ALGOL procedures calling t h ~ e l v e s , or using their own 
 identifier within their bodies recc1~ively, cannot be handled. 


32 Note 3. The re~ark of section 4.7.6 is closely related to that of section 5.3-5 ( s e e 28 Note 1 ) .

32 Example 1. Formal parameters should generally be called by value when they represent pure input data to the procedure, in other words when in the procedure statement they may correctly correspond to expressions. The effect of calling a formal parameter by value is
a) To screen the corresponding actual parameter, i.e. to mBke sure that it is left unaltered by the proca~ure, stat~ent.
b) To economize the procedure call in the case that an expression, and not Just a simple variable, is entered in the c o r r e s p o n d i n g position.
C) To allow the use of the formal ~ r a a e t e r as an internal w o r k i ~ variable of the procedure body.
The following example will serve to bring out these points:

THE COURSE. 


25

procedure EX(A, B) ; value A ! re__~ A, B ! 


beg~ix~ inteser k ! 


.A.-:V'--A~,2 - sin(A x ( A ~ - i)) ;

B:=O! 


_for k := 1 _stem 1 until 5 _d_oB := B + A x (B + 1)/k ~5 

_en_d 


If this procedure is called only as follows: 

m(a,b) 


value A may correctly be omitted. In this came the value of the variable a 


would, however, be changed by the procedure statement. If the procedure is 


called as follows: 


ZX(p+q, b) 


value A is necessary, since if it were not present the meaningless con-


struction 


p + q := (p+q)~. - sinCC~-q) x ((p+q)~ - I))

would result from the application of the rules of section 4.7.3. In addi-

tion Lal_ue A evidently achieves an economy in evaluating the first basic

statement of the procedure body, since the sum p+q is only evaluated once.

It should be noted, however, that not all pure input data should be 


called by value. An example of this is presented by the formal parameters 


a and b of the procedure Innerproduct of section 5.4.2. Evidently, the 


whole meaning of this procedure depends on the possibility of not calling 


these parameters by value.

(Time

rain.) 


32 Problem i. Write the declaration for a procedure for solving second or- 


der equations, using the principles of 24 Problem 2.

(Time

mln. ) 


32 Problem 2. Write a declaration for a procedure for finding the polar 


coordinates from the rectangular ones (cf. 25 Problem 3 ). (Time

rain.) 


32 Example 2. If a procedure has no formal parameter pert it must work on 

non-local quantities of the procedure body. An example would be the follo-
 wing: 

procedure R ; Q := sqrt(x~2 + % 2 ) 
 This procedure works on the three non-local parameters Q, x, and y. These 

must, of course, have a scope which includes the block in the heading of 

which the above declaration occurs. 
 Another variant is 


This must, to be useful, be used in expressions, e.g. 
 S :=p+q+R 

This example will serve to warn the reader that an apparently simple addi- 
 tion may, in fact, imply a procedure call. 


26 THE COURSE. 


52 Exsmple 5- The most intractable consequences of ALGOL will be realized if the above possibilities are combined. Thus the procedure real ~roeedure Sneaky(z) | _v~u~ Z ; real Z ;

W :=i+l

e.nd S n e a k y

will, when used in an expression such as

P :- Sneaky(v - 1) + 2 


cause a change of the value of W behind the back of the user, so to Sl0eak. 


Furthermore this construction will cause the effect of 


Pip := Sneaky(k) x W 


to be different from that of 


Pip := W x Sneaky(k) 


Evidently such possibilities, if used must be handled with utmost cau- 


tion.

(Time

min.) 


33. Read section 2.6.1 - 2.6.3.

33 Note i. DASK ALGOL uses the symbol A for space and effectively two dif- 


ferent kinds of string quotes: 


б~ I

forlayouts 


for other strings 


Strings within strings cannot be used. 


34. Read sections 5.4.6, 4.7.8 and MANUAL sections 8 - 8.7 on DASK ALGOL 
 STANDARD OUTPUTPROCEDURES. 


34 Note i. Most of the complications of the syntax of section 8.3.1 arise 


from the following restrictions: 


1. The neighbours of a space symbol A on either side must be n, d, 


or 0, and cannot be . or another A 


2. The sequence of letters d anddigits O may start w i t h a number of 


d's and must be followed by a number of O's, but the two cannot be mixed. 


(Time

rain.) 


34 Problem i. Show the printed r e s u l t s of the following statements:

'> q :-

tryk vr ; 

tryk tekst (~<PA=~) ;

p) 

tryk (б+dd.ddddJ~, -p+q~) 
 e_n_~ ;

(Time

mln. )

3~ Problem 2. Write four layouts which will produce the numbers in the 
 following four columns 


, 12.34

, ,-.973 24, ,+ 17

, , 7 777

~5, 


' 0.027 43, ,+.000 12, ,- 230

, , -628.3

l


,555.6

, ,-.015 45, ,+ 15m+ 6, , -1.538 2m-10, 


,-1300~-12, ,

0.222 


THE COURSE. 


27

35. Read MANUAL sections 9 - 9.7 on STANDARDINPUT PROC~URES.

35. Problem 1. Find the enact output fr~ the following program when supplied with the input symbols shown ,below: b_e~_ _ ~ r u, v, w 
 re_..~ Rr_oc_eecl_~_Innerproduct (a, b, k, p) ! ~ u e k !

beg..~,reel m 

s : = 0 ! for p:= I _lte_~ I unt____~k _dR s:= s + a x b ! 
 Innerproduct :. s 
 Innerproduct ! 


PROGRAM: 

t~op~ (бq,~), 

T: iRS (U, v, W)! 

b ~ _~...:jmr P, Q, R~-

и

~rAT~,-
 All:u, l:v], B[i:U, l:w], 


S:  Imsstreng| if strong (~<Ar}) then ~o to T; 
 line(Q, R)! trykvr! t r y k ( ~ - ~ K - Q , - R ~ 

tryk(~-~a,dd~, Innerproduct(A[P, Q], B[P, R], u, P))! 
 g_oto S! 
 _en~ 


S~le In~t ~ta / 

Ex~ple of ~z~, l~streng, streng. 
 Q R Sum(A[i,Q]xB[i, R]) 

;

Arrays: u - 3 , v = 2, w - 4, 
 A: 

.1, .2, 

и3, .4 
 и5, .6, 
 B: 

I, 2, 3, 4, 

5, 6, 7, 8, 
 9,  lO, 11, 12, 
 Q, R: 1, 3, 
 Q R: 2, 2, 

Arrays: u = 2, v = 3, w = 2, 
 A: 

-.9, -.8, -.7, 
 -.6, -.5, -.4, 
 B: 

6, 7, 

8, 9, 
 Q, R: 5, 2, 


28 ANSWERS TO SOME OF THE PR0"RT.'P~S.

3 Problem 1. Asslgr~ent statements, labels. 


4 Problem 1. 3,4,6,7,10,12. 


5 Problem 1. 3,4,5,7,11. 
 5 Problem 2. 1. a:=b+3 ! V: pW:=n ! 


2. herin if PQ-O then ~

W !


3. ~I~-~-7 ~ ~ ~_t_o ww 


4. tU:~VU/2 e ~ end !

6 Problem 1.
2 keys: + - x / < = >~^ , и I0 : , ( ) [ ]

3 keys: ~<_ t -, := A
4 keys: ~, -

7 Problem 1. 17476,7,11,12.

8 Problem 1. 1. +729300000. 2. 9812. 3. 1000. 4. -.000(~31834.

5. -.000001. 6. -4800. 


8 Problem 2. 1. 171o3. 2. ~ . 3. -1341o-5. 


8 Problem ~. 1,2,7,9. 


9 Problem 1. The 3 first. 


10 Problem 1. 1,3,5,7,10,12. 


11 Problem 1. Expression: I 2 3 


pr~ mantles:

3 5 8


Factors:

3 5 8


Terms:

3 5 7


Simple arith, expr. :

3 3 6


Arithmetic expr. :

3 2 3


11 Problem 2. 1, 3, 4, 7, 8. 
 11 Problem 3. 1. inte6s E a, b ! real c, d, e, f. 3. _~__~ Q. 4. - . 


7. real v. ~-.-real p, qrs,-tu--T v. 
 11 Problem-~.  1: 4, ~ T ~ , 3: 16, At: 7, 5: 2, 6: 4096, 7: 4096, 8 : 2 to the 


18th power, 9: 10, 1 0 : 0 11: 4, 12: O. 


11 Problem 5. I S + (s - t)/v~ 


2.  (v - w)x(1 - a ~, 3 1 k l(a - k)) 


3.  a 4(n + m) 


45..  a~ (4b(+~sn~)

n
)

6.  q v g 


7.  Plq~ r*(s + t) 


8. (e-b/c/(d-e~x(f+q) ))/(h4~lJb(J-k)+o~(m/(n+P) )) 


12 Problem 1. rl = 23, re = 2, rb = 10, n = 2, i = 4, J = 2. 


13 Problem 1. Expression no.

1 2


Relations

1 1


Boolean primaries

7 4


Boolean secondaries

7 4


Boolean factors

7 4


Boolean terms

6 3


Implications

5 i


Simple Boolean expressions

5 i


Boolean expressions

4 I


13 Problem 2. 1. boolean c, s, w ! re~! P, Q 


2. real u ! boolean W, Q, T 


13 Probl-em 3. re = I~, rb = 12.5, i a = 5 b a = z~s~, bb=_%~_e 


14 Problem 1. SUM - O, 1, 1.25 1.333333. и 


16 Problem 1. B = _t~__e, u - 13/15 w - -17/15. 


ANSWERS TO S 0 ~ OF THE PR0~LE~S.

29

17 Problem 1. W l -8, S - -9, B I 13, C I 7.

17 Problem 2. Umlabelled basic stat~enta: 12, basic statements: 24, un-

ecmdltlomal statements: 26, statements: 28, coz~ouncl tails: 28, block

heads: 2, unlabelled c~pounde: 0, unlabelled blocks: 2, compound sta-

~ e n t s : 0, blocks: 2.

18 Problem 1. S, B, C: all statements. W in outer block: 1, 2, 3, 4, 11, 


STOP. W in inner block, P, AA : 5, 6, 7, 8, 9, 10. 


19 Problem i. ~

MmtA, MatB [l:k, l:n], Zoop [-7:+7, i:I0, 0:i, 0:11 


22 m~bZem %. i.2~ ~ 3 , A[1,1~5. A[1,2]--2, A[2,1~7, A[2,2~3, A[3~1~ 


4, AL3,2Jb2, CLO]-6, c [ 1 ] - 7 , - c [ 2 ~ .

24 Problem 1. ~3.1~i59.., r--3, s-5, log-1.

25 Problem 1. a I -9, b I 26.

25 Problem 2. Not correct. If q<0 then 7 _~s_e 4 is not~a <term>.

27 ~blem 1. 1. r_~_e. 2. ~_ala__~. 3. t_~_. 


27 Problem 2. I. true. 2. false. 3. false. 


28 n~bxem 1. n --~,-~7. s3~-~, sB, mm--~- 


29 Problem 1. k = 3, 1, 1. S - 5. 


m - 2, 5, 8, 11, 1~. s . . 3 5 . 


k i 2, -31, 2, 4, 6. a I -69. 


m = -24, -22, -20, -18. s = 15. 


k l 1, m = 3 , 2, i, 0. S = 25. 


k l 2, m l 3 , 2, I, O. s ' 3 9 . 


k ' 3 , m = 3 , 2, 1, O. a ' 5 7 . 


k l 4, m = 3 , 2, 1, O. s I 79. 


k . 5, m i 3, 2, 1, O. s 1105. 


29 Problem 2. The arrays must be declared in a block outside of the block 


in which the mBtrix lu.ltiplioation is tattled out. 


b_e~_ ~rE~Y A[l.i,- l:J], B[I:J, l:k], C[l:i, l:k] ! 


f o r m :l 1 _s~p 1 ~t___~ i 


for n := I _st~ I until k 


---heRs :=0 !---


for p

:=
:=

1,aV_~._~.1

u.n t.i l

~ do

s

:.

s + A[m,p]xB[p,n]

!

c , ~ n t For running time economy the simple variable s,
and not C[~,n], is used during the s,-~.~tion! enc~ for m og n en_~ block !

30 Problem 2. Step.
31 Problem 1. T r a n s p o s e (W, v+l) will be executed as:
~ w | in_t_e~r i, k, n |
n :iv+ 1 | 

fo__E I :- 1 L i e d l u n t i l n do 
 for k :l 1+I s~M~ 1 until n ~o 

v ,. wEiT~ , -----
 WEik ,. W[k,l], 

WLk01J :- w 
 ez~Z Бor k

30 ANSWERS TO S 0 ~ OF THE PROHL~S. 


A b ~ (A, N, M, Yy, I, K) will be executed as: 


Yy :-0 ! 


for p := 1 step 1 until N do for q := 1 s_t~ 1 until M do 


~_~_ i~ ~p,q~-~-Yy

~e~ . . . . . . . . . . 


~S_~. YY :" a b s ( A [ p , q ~ - ! I := p ! K := q ~_d

e~nd f o r p

en_d procedure AbR~x

Note that an extra b~_ end bracket has been inserted in order to make 


the statement following d_o unconditional. 


Innerproduct (A[t, P, u], B[P], 10, P, Y ) w i l l be executed as: 
 begin real s | ~_~_~el2 k | 
 k := i0 ! S := 0 
 _f_orP := I _s_te~ 1 ~mtil k do s :- s + (Air, P, u]) x (B[P]) ! 
 Y:.,s 
 _~d Innerproduct 


31 Problem 2.
_~_~! w ! i n n e r i , k !
~or i :-.i s~p-1 ~_i.i (~+i) do
--- for k ;~ 1+I ~p i until (v+l) do 


~d Transpose

31 Problem 3. R = 0, I and K are undefined. Since the user must expect 
 that all of these quantities are defined upon exit from the procedure 
 this is unsatisfactory. Two possible improvements of the procedure decla- 
 ration may be s u ~ e s t e d to remedy this: 1. Replace the first statement of 
 the procedure body by, e.g., y := -1. 2. Replace the relational operator 
 > hy > 


32 Problem 1. 


proced__~ ~ 2 0 R (A, B, C, zlr, zli, z2r, z2i, IRDETER~INATE) ; 


value A, B, C ! _ ~ A, B, C, zlr, zli, z2r, z2i ! label I ~ D E T E ~ A T E ! 


be~_~ ~ dAscr~nant ;

if A + 0 then So to normal | 


if B = 0 then f~ to ~DETE~41NATE ! 


~ir := z2~-~; - c ~ ~ s o ~ set zero , 


normal: 

dlscriminant :- B ~ 2 - /t x A x C ! 


if dlscriminant > 0 then g~to real solution ! 


complex: 

~ r := z2r := - B / 2-7-A ; --

Zll := sqrtC-dlser4_mlnsnt)121A !

z2i :- - zli ! ~ _ t o finis !

real solution: zlr := (-B+(if B>0 th_en-i e_l_se l)xsqrt(discr~m~nant))/2/A! 


set zero:

и 2~ := cl~/z~ , 

zli := z2i := 0 !

finis:

AgSWER5 TO S O N OF THE p~wr.~34S. 


31

32 Problem 2. 
 procedure Polar (x, y, r, v) ! value x, y ! ~

x, y, r, v !

v :- if 3~0 then (if x>O then 0 else 3.14159265) 


.) 

34 Problem 1. 
 p - 9.0- 8.7778 


34 Problem 2. nda.d0OmO0

+.dad dd

35 Problem 1. 
 Exsmple of lms, l m e t r e n g , s t r e n g .
Q ~ S=(A[1,Q]xB[i,~])

'i 3 7.90 
 2 2 8.8o 

3 2 -8.50 


i~dOO~_+dd

-n~ddd.0OOzO~-dd 


32 Appendix 1. A PROGRAMFOR A SMALE TABLE.

A PROGRAM FOR A SMALL TABLE. 

An illustration of ALGOL. 

As an illustration of the use of ALGOL the complete solution of a 
 simple problem is given below. The additional notes will enable the reader 
 to pick up some of the basic features of the language in an informal man- 
 ner. 

It should be noted that the ALGOL program gives a complete descrip- 
 tion of the solution of the problem. Indeed, an ALGOL translator system 
 will be able to build up a complete machine code for the solution on the 
 basis of the ALGOL program in precisely the form given below. Both the 
 translation and the solution will be performed with the speed and effici- 
 ency characteristic of the electronic calculators. Consequently, once the 
 ALGOL program has been written the problem is practically solved. There 
 remains only a purely routine operation of the electronic calculating ma- 
 chine. 

Definition of the problem. 

It is desired to calculate a table of the following function: 

Acab(u, length) = u(len~ch2 - 0.037 u3 ) 


The p a r a l e t ~ r u v a r i e s from 0,0 t o 5.0 i n steps o f 0.2. The parameter length assumes the following six values 


l e n g t h - 1 . 0 , 1.2, 1.4, 1.6, 1.8, 2.0. 


The results should be printed in a table with seven colm~s end a heading 
 as shown below (the cos indicate spaces): 


,,,,,,,,,,,,,,,,,,,,,,,,,,,Table of function Acab. 

!


,U,, ,,,,,I.0, ,,,,, ,,1.2, ,, ,, ,, ,1.4,,,,, ,,,I.6, ,,, ,,,,i.8,,,, ,,,,2.0 


i 0.0, , , I iXX.XXXi
0.2i , , , ,XX.XXX,
etc.

i , I ,XX.XXX, , , , ,XX.XXX

i,,l ~ . l i ,, , ,XX.XXX,

, , I iXX.XXX, I , iX~IC.Ii

i , i IXX'XXX! , , , ,XXeXXX!

, i , ,XXeXXX , , ,XX.XXX

Appencllx 1. A PROGRAM FOR A SMALL TABLE. 


33

ALGOL program: c~ent Program for Acab| real u, len~h!
try~om (5o) I
tryktekat (~< 


Notes:

Any program must be embraced within the

statement bracket ~

end.

Notes in plain language my easily be

included.

This declares that the quantities deno-

ted by u and length represent arbitrary

qf~titnumbers. There is a considerable in choice of designations for
lea in ALGOL.
This is the first active instruction of the program. It causes 50 empty ro~ of tape to be punched by the output punch.
This will facilitate the handling of the
tape of results. - The following in-
struction punches the heading.

Table of function Acab. 


u
$),




1.0

1.2

for u :- o.o s ~ 0.2

until 5.Ol ao

t~k(бd.~, u), 

for ~

:- 1.0 s ~ 0.2 

--- l ~ n t i l 2.01 d_o 

beg~ trykml (5) ,  tryk ( ~dcl. ddd.~,,
w,(l~ngt~2-o,o37xu,~,~)/

ena ;  tryktom (50)  re_a; 

length 
 1.4 1.6 1.8 2.O 

This construction causes the following 
 statement (from be~i_n to en_d) to be exe- 
 cu%ed repeatedly by with u = 0.0, 0.2, 
 0.4, etc. 
 Output of a carriage return code (vr = 
 yogn_retur). This includes llne feed. 
 u is printed with one dec4,~1. Inside the larger repetitive process a 
 smaller repetition is performed, for the 
 calculation and printing of the six co- 
 lumns in each llne. 
 In front of each function value 5 spaces
(~e_n~) are printed.
The function value is calculated and printed in a layout of two digits before and three after the dec~-~! point. Arithmetic expressions must be written
linearly. Spaces and carriage returns may, however, be inserted freely. This ,~ the section controlled by the fo__E I ~ construction. This ends the section controlled by the fo_r u construction. Output of a suitable piece of empty tape. This is the end of the program.

3k Appendix 2. THE SOI.DTION OF A REALISTIC PROl~r!~l,i.

T ~ SOLUTION OF A I~ALISTIC pR0nT1214.

The following formulation of a problem is taken over directly from
that presented by a physicist: It is desirer to tabulate the following expressions for 12 and Aber:
1 2e 2 +

12 I -r 

_

2e2 +

2 . e2

whe re 

c " ir; t , g e l
rc
(for e2 = -~5 ░, 12 becomes r ~ c ) 


A b e t - - H r [c I + c 2 ] where 


H I 
 21 11~ [i + 11 + "~ e l ) 2 ]

+ 12 + ~ e2)2

r

Cl I  -~ [1 + (E-

el )2 [2

11

11 + ~

]3

r

r 2 1"2 + 3 ~ e2
c2 "  -2 [ 1 . (z'_ z2 z2 * .~ e2)2~7 ~

The parameter values are the following: 

11 is 50 
 e I assumes the values 0 to 50 dmgrees, in steps of 5 degreel 
 e2 assumes the values -20 to -50 degrees, in steps of 5 degrees 
 r assumes the values 30 to 120 in steps of 5 


The results should be tabulated in 11 tables, one for each of the va 


lues of e~, the value of which shouL~ be printed at the head of the table. 


The a~n~nt

of the tables should be as follows: 


11 = 50, el = 20

e2 - -20 -25 -3O -35 -~0 -45 -5O 


r  12 Abet 12 Abet 12 Aber 12 Aber etc. 


The results, which will be ~ 1 1 e r than 1000, should be printed with 
 one decline1. 


Appendix 2. THE SOLUTION OF A REALISTIC PR0~L~4. 


55

SOLUTION 1. 

be~_ comment This is a direct, but uneconomical program for 12 and Aber! 
 _in~e_~e_r 11, el; e2, r ! 
 re__~ 12, c, cl, c2, Aber ! 
 ~a~. procedure ~g(u) ! value u ! ~ u ! k~_n ~ cos
u := u/57.2957795 ! C0S := cos(u) ! tg := ~ CO,g~O t h e n 1o20 e l s e sin(u)/OOS e_nd tg ! co~men% It is easy to see that this way of treating the singularity of tg is correct in the present application !
BEGIN OF PRO6RAM: trykt~a (50) ! 11 :- 50 ! for ~1 := 0 ste_~ 5 until 50 do --- b_e~ tryktekst~<-- --
tryktekst (~< 

tryktekst (~<A~▒x~ LA▒ZZZA, -40XlX.~.AAZ, .U.J.A--45AJ..L.~ZA.LL~.A.~.-A-50 

~) , 

for r :- 30 s_~..~ 5 until 120 do 

- -- Ccl :=:=r/(lrl/ll++ Sixs(~e(le)l
l)xr.~/1.~/(l+(r/ll+~(el))~)
/ s q r t ( 1 + ( r / l l + t g ( e l ) )~2) , 
 for e2 := -20 ste_~ -5 until -50 do 

(1-tg(2xe2)/c+ ('~(2xe2)+l/c)x'~(e2)) !
c 2 :, - -(r112+5 xtg(e2) )xr,~2[l~"2/
( 1+( r/12+tg( e2 )),~2) 

Isq~(~+(rll~+"~Ce2) ),I,2) , 
 Abet := -11.,l~.~121~Ir~(l+(r/11+'~(e1))~) 

~sqr~(~+(rll~+~(e~))~)x(c~+cZ) 

tryk ($dddd.d~, Aber) 
 _e_nd for e2 
 end for r ! 
 tryk sum 
 _en_d for el ! 
 tryk tom (50) 
 en_d program ! 

This program may be improved c o n s i d e r a b l y , l ~ r t i c u l a r l y with r e s p e c t to efficiency. Obviously many parts of the expressions will be evaluated over and over again with the same numbers. This may be avoided by r e w r i t i n g the f o r m u l a e so a s %o e v a l u a t e as much o f a n e x p r e s s i o n as p o s s i b l e a s soon a s the entering quantities have been assigned. Also the repeated evaluations 
 of tg(e2) may be avoided by preparing a table of this quantity. Finally 
 the denominators of the formulae for cl and c2 may conveniently be evalua- 
 ted through a procedure. These features have all been incorporated in the 
 following version of the progrsm. 


36 Appendix 2. THE SOLUTION OF A REALISTIC I~3~4. 


SOLUTION 2. 

~__~_ cogent Improved program for 12 and Aber! 
 i_n~e__r 11, el, r, Q, i ! 
 real 12, crec, M, ml, m2, tee1, tgelt3, Aber ! 
 _~z  ~e2, t~2e2, ~t3 [1:'7] ,
~ ~roceaure re(u) I y~1__u_eu ; x ~ Z u
~ n ~ COS 
 u := u/57.2957795 ! COS := cos(u) ! 
 tg := if COS=0 then ~20 el_se sin(u)/COS 

end tg ! co~aent It is easy to see that this way of treatise the singula- 
 rity of tg is correct in the present application ! 
 ~ p_roc~ _ ~ HELP (y)! c _ ~ n _ t This helps to calculate the den~immtors 
 or cl and c2 ! value y ! real y ! 

.~_~  ~:-1.~,-~..~ := 17~7;~t(~) ~ ~-~ !
BEGIN OF PROGRAM: 
 for i := 1 seep 1 until 7 do 

tan2e2[i]: "tg(-10 x i : 30) ! t~t3[i] :- 3 ~ t~e2[IJ end for i ! 
 ~ k to=(5o) ; zl :- 50 ; Q :- 125o , for el := 0 ~ 5 until 50 do 

zz~-=5o,=ez~=D) , tryk(бd,.1..1,, eZ) , tryktekst (~< 
 .LLj.j.e 2A=AAJ.A--20_j_t,J.J.AA.L4~J_LA--25~.A.L.t.A.I.J.AJ..A.JL,J.--30' J и L.IJ.J.A.AAJ..I,J.--35~) ! 


tgeZ := tg(el) ! tgelt3 := 3 x "~el ! 


for r := 30 sty 5 unt:l.Z 120 do 


b_~.  t~k ~, ;~'~бd,:m.1.-;'r) , 


cr~c =- 1/(r/n * t,~z)., 


M := Q x ( ( r / l l . "l.,gel)4~~. + 13 !

=1 :- (r/z1 и t~elt3)/z~ x ~(r/zl * ~el) ;

for I  := 1 ste~ 1 until 7 do

.... begin Z~-:= -r~-t~2;~[i] и crew)

--,--- . / ( 1-ta.n2e2 [:I. ]xcree+(tan2e2 [ i ~ c r e c ) xtan.e2 [ i ])

try k=(~-dddcl,dd.d,~;, e2);~

: (r/z2*~t3FtD/z~2x~(r/z2*~e2EiD

,

~ e r :- - - - ~ Z 2 ~ r t (-( r-/ Z 2 * t ~ e 2 [ i ] ) ~ + 1 ) ~ ( = 1 * = 2 ) ,

t~k(б-aa~a.~, Abet)

end for e2 


e~. for r ! 


tryk sum 


end for el ! 


tryk t--~ (503

e~r,.d,program !

It will be clear from this example firstly that the efficiency by which a process will be carried out may be Improved even by Just a simple revision of the formulae. Secondly that the establishment of the most suitable formulae in a given case depends directlY on the desired form of the output.

Appendix 3. THE TESTING OF ALGORITHMS. 


37

THE TESTING 0FALGORITHMS. 

Experience shows that it is rare for an algorithm to be correct when 
 it is first written up. The testing of algorithms must therefore be consi- 
 dered to be a very important part of ALGOL progr~n~ng. The following 
 notes are intended as a first guide to this subject. 

Errors in an ALGOL program may be of two essentially different kinds: 
 (1) errors of form and (2) errors of content. In testing an algorithm 
 these two kinds of errors should be treated sepatately. 

Errors of form (syntax). 

Errors of form (syntactical errors) may be eliminated completely 
 through a purely mechanical process. Indeed it is possible to let the AL- 
 GOL-to-machine-code translator perform syntactic checking and reject In- 
 correct programs. Likewise a manual checking maybe (and should bet) per-
 formed in a routine manner. In ALGOL programs this is a comparatively easy 
 matter owing to the easily readable form of the language. In performing 
 the check the following list of some frequent errors maybe useful: 
 i.  Forgotten or wrong occurrence of ! or ~l_se or ~n_d (cf. the punctuation 

rules 1 and 2 , point 17 Note I). 
 2.  Declarations of simple variables forgotten. 
 3.  Multiplication symbol x omitted. 
 4.  the_ ~ i t t e d (there must be one for every if). 
 5.  Underlinln~ of basic symbols foxrgotten. 
 6.  Mixture of integer and ~__~ type variables on the left side of assign- 

ment statements. 

Errors of content. 

Errors of content are errors which cause the algorithm to perform a 
 different action from the one intended. Since the description of the in- 
 tended action is often vague and leaves a considerable freedom for the 
 writer of the algorithm the detection of this type of error may often be 
 quite difficult. Even so there are scae general suggestions which may be 
 of help: 
 I.  For each variable check that it is never used before a value has been 

assigned to it. 
 2.  Make sure that no division by zero or any other undefined operation
(in, sqr%, e t c . ) c a n o c c u r . 3.  Check for special values of input parameters, particularly zero. 
 4.  Remember to take absolute value when doing test on magnitudes of quan- 

tities. 
 5.  For each if clause of the program establish two test situations one 

which makes the Boolean true and one which mRkes it f_a_ise, and check 
 that the algorithm behaves correctly in both cases by following its 
 action statement by statement. 
 6.  Note that the method of following an algorithm step by step, as ex- 
 plained in point 12 Example I, far from being a beginners device must 
 be considered as the basic method for testing algorithms. When combin- 
 ed with a choice of values of input parameters merle according to 
 points 3 and 5 above it is the most efficient method for constructing 
 correct algorithms. 


38 Appendix 4. THE t~E OF N~0CE5 AND PROC~ES. 


THE ~ 0F N.OCI~ AWD FBDCC~I~ES. 


An importent step in the planning of an AI~OL progrsm is the subdivi-

sion of the l~rocess into parts which my conveniently be written as blocks

or procedures. In order to be able to do this the progru,~r ~t hate a

clear idea of the properties of these AI~OL units. As a first introduction

the following notes 17 be useful.

~locks are useful for expressing such l~rte of the progrel which form

a closed process. In particular a block is indirpensable if in a process

an array is needed whose size depends on the results of previous calcula-

tious. Such an array mast be local to a block. In addison apt other quan-

t i t y (simple variable, label, switch, procedure) which is used only inter-

nally during the work of the block, but whlch has no interest when this

work is done may be declared to be local to the block. This is particular-

ly useful ~hen different blocks of a pro6Fsm are wrltten b~ different pro-

gramners. By using blocks the progreu~ers will only have to a6ree on the

non-local identifiers of the blocks, while inside each block the progrsm-

mer is free to choose the identifiers of working quantities.

Procedures have three different important uses: 1. Generalization of 


the use of blocks. 2. Abbreviation of ~

ad-hoc run.ions. 3. Form of 


co~unication of closed processes between probers

at d/fferent times 


end places. 


i. Any block may be converted into a procedure by adding a heading to

it. The heading will attach an identifier to the block a n d u s u a l l y name

some or all of the non-local identifiers as formal. Where the block in

question is written specially for the pro~sm this conversion can be re-

commended only if the mechanim of the block is used two or more times

with different non-local quantities, corresponding to two or more calls

of the procedure, since evidently a call of a procedure is a more elabo-

rate process than a simple entrance into the correspondln6 block.

2. Frequently the formulae of a program may be shortened through the

use of suitable function designators. As in 1 above this will be econ~i-

cal only if the corresponding ad-hoc procedure is used more than once du-

ring the program.

3. In a near future it is safe to expect that all important methods 


of numerical analysis will be expressed in the form of ALGOL procedures 


and published (cf. the Algorithms section of the Coma. ACM and the AL~0L 


Programzir~ section of BIT). Since these procedures presumably will be a- 


bove avers~e with respect to efficiency it is strongly reccmlended that 


they be used wherever possible. 


