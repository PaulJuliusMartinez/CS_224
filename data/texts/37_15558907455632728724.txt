EMSE CMP-GC
LE LANGAGE C

1

Né en 1972 dans les laboratoires Bell AT&T
Auteurs : Brian KERNIGHAN et Dennis RITCHIE

· Conçu pour l'écriture du système d'exploitation UNIX

· Langage de programmation
· Normalisé en 1989 par l'ANSI
(American National Standards Institute)

EMSE CMP-GC

2

CARACTERISTIQUES

· Structuré
· Modulaire: peut être découpé en modules qui peuvent être
compilés séparement
· Universel: n'est pas orienté vers un domaine d'application
particulier
· Typé: tout objet C doit être déclaré avant d'être utilisé
· Portable: sur n'importe quel système en possession d'un
compilateur C
· ...

EMSE CMP-GC

3

Premier Programme

· saisir le texte ci-dessous en utilisant un des éditeurs: joe, pico ou vi

/* exemple de programme C : - calcul somme des nb entiers de 1 à 20 et affichage de la valeur - idem de 1 à 10 */ #include <stdio.h> main () {
int somme; int i; somme = 0; for (i = 1; i <= 20; i++) {
somme = somme + i; } printf ("%d\n", somme); somme = 0; for (i = 1; i <= 10; i++) {
somme = somme + i; } printf ("%d\n", somme); }

En C le programme principal s'apelle toujours main
déclarations de variables de type entier (cases mémoire pouvant contenir un entier)
instruction d'affectation de valeur à la variable somme
instructions exécutées en séquence
affiche à l'écran la valeur de l'entier contenu dans somme
l'instruction entre accolades est exécutée pour les valeurs de i allant de 1 à 10

EMSE CMP-GC

4

COMPILATION / EXECUTION

Compilation du programme prog.c
cc prog.c -o prog
ou
make prog

Cette commande compile le fichier prog.c et produit un exécutable (fichier exécutable) appelé prog

Exécution du programme
prog

Pour exécuter le programme il suffit de taper le nom du programme

EMSE CMP-GC
ELEMENTS DE BASE

5

· Structures de données
­ Notion de type : entiers, réels, caractères, ... ­ Notion de variables

· Instructions
­ Affectation de variable ­ Instructions Conditionnelles : if et switch
­ Boucles: while , do ... while, et for

EMSE CMP-GC
DONNEES

6

-> Les informations traitées par un programme
Ces informations sont contenues dans :
­ des variables ­ des constantes
· Variables :
­ doivent être déclarées ­ leur contenu peut être lu et/ou modifié pendant l'exécution du
programme
· Constantes:
­ doivent aussi être déclarées ­ initialisées par une valeur ­ leur contenu ne peut être modifié ­ elles peuvent être lues

EMSE CMP-GC
NOTION DE VARIABLE

7

· Association d'un identificateur à des cases mémoires qui doivent être déclarées avant utilisation

· Toute déclaration contient :
­ un identificateur : nom qui servira à désigner la case mémoire
­ un type : ensemble des informations possibles que pourra contenir la variable

EMSE CMP-GC

8

DECLARATION DE VARIABLE

· Syntaxe: <type> <variable>;

· Exemple: char rep; int compteur; float longueur, largeur; int i=0, j=0;

EMSE CMP-GC

9

INTERET DES VARIABLES

main() { int x;
x = 3; ... } programmeur

allocation en mémoire effectuée par le compilateur

x?
x3 machine

Intérêt : · le programmeur n'a pas à se soucier de l'allocation
précise des cases mémoires (repérées par des adresses) · l'emploi d'identificateurs significatifs améliore la
lisibilité du programme

EMSE CMP-GC
CONSTANTES (1)
4 types de base pour une constante: · entiers · réels · caractères · chaînes de caractères

10

Syntaxe:
#define <nom constante> <texte de remplacement>

Exemples (de déclarations) :

#define MAX 99

Attention: pas de ;

#define PI 3.14

#define CHAINE "langage C"

EMSE CMP-GC
CONSTANTES (2)
Exemples (d'utilisation) : float f = PI; char tab[MAX];

11

L'instruction MAX = 3;

est illégale :

une constante est définie une fois pour toutes suite

à sa déclaration et sa valeur ne peut être modifiée

EMSE CMP-GC

12

NOTION DE TYPE
· définit : ­ un ensemble de valeurs ­ un ensemble d'opérations applicable à ces valeurs
· détermine : ­ la taille de la mémoire qui sera allouée aux variables de ce type ­ le codage des valeurs
Différents types peuvent être utilisés : ­ types simples : entiers, réels, caractères, énumérés,... ­ types composites : tableaux, structures ­ pointeurs

EMSE CMP-GC
TYPES DE C

13

void scalaires fonctions union composites

pointeurs arithmétiques

tableaux structures

discrets

réels(flottants)

entiers

énumérés

caractères

EMSE CMP-GC
LES ENTIERS

14

· Les entiers sont rangés dans des cases mémoire de taille fixe : 8, 16, 32, 64 bits, ...
· Ces cases sont réservées par les déclarations de variables

· Résultats des opérations parfois non représentables: débordement (overflow)
· Exemple: 231+ 231= 0 si les entiers non signés sont représentés sur 32 bits

EMSE CMP-GC
TYPES ENTIERS

15

Entiers: représentent les nombres entiers positifs/négatifs

cela dépend de la machine

Type

Description

Min Max Nbr Octets

short

entier court

-32768

32767

2

unsigned short entier court non signé

0

65535

2

int
unsigned int

entier

-2147483648 2147483647

entier non signé

0 4294967295

4 4

long int

entier long

-2147483648 2147483647 4

unsigned long entier long non signé 0 4294967295 4

Exemples de déclarations de variables: int x; unsigned long y;

EMSE CMP-GC

16

OPERATEURS SUR LE

TYPE ENTIER

· Opérateurs arithmétiques:
+- * / %
/ division entière: 6 / 9 vaut 0 % modulo (reste de la division entière) 6 % 9 vaut 6

· Opérateurs relationnels:
> >= < <=
== teste l'égalité != teste la différence
...

== !=

EMSE CMP-GC

17

LITTERAUX ENTIERS EN C

Entier : signe optionnel suivi d'une séquence de chiffres

Un entier en C peut s'exprimer en · Base 10 : la séquence commence par un chiffre non 0 · Base 8 (octale) : la séquence commence par un 0 · Base 16 (hexadécimale) : la séquence commence par 0x

- 0xF = - 15 = - 017

Base16

Base10

Base8

EMSE CMP-GC

18

PRINCIPES DE CODAGE

DES CARACTERES

-> Interprétation des caractères comme un code entier non signé (i.e. `8' correspond au code 5610) :
­ la relation d'ordre entre les codes des caractères respecte l'ordre alphabétique :
­ les codes des lettres sont consécutifs :
­ les codes des chiffres sont consécutifs :

caractères ASCII `A' 65 `B' 66 ... `Y' 89 `Z' 90

caractères ASCII `a' 97 `b' 98 ... `y' 121 `z' 122

caractères ASCII `0' 48 `1' 49 ... `8' 56 `9' 57

EMSE CMP-GC

19

LE TYPE CARACTERE EN C

· char : type caractère en C · occupe 8 bits (1 octet) · traité comme un entier signé
Un «littéral» caractère est indiqué à l'aide de `' · `a' : caractère petit a · `.' : caractère point
· `5': caractère 5 et non le chiffre 5

`8' - `0' = 8 pourquoi?

EMSE CMP-GC
CARACTERE

20

Représente un caractère parmi l'ensemble des caractères du jeu de caractères de la machine (généralement les codes ASCII)

Type
char
unsigned char

Description caractère
caractère non signé

Min -128
0

Max Nbr Octets 127 1 255 1

char rep; rep = `a' ;

rep = rep + 3; rep vaut `d'

· Opérateurs arithmétiques: + - * / % · Opérateurs relationnels: > >= < <= == !=

EMSE CMP-GC
TYPES REELS

21

Réel: représente les nombres en virgule flottante

Type
float
double

Description réel
réel double

Min Max Nb Octets

1,17 E-38 3,4 E+38

4

2,22 E-308 1,7 E+308 8

float longueur, largeur; double masse_atomique;
· Opérateurs arithmétiques: + - * / · Opérateurs relationnels: > >= < <= == !=

EMSE CMP-GC
EXPRESSION

22

Une expression est une description d'opérations devant être effectuées sur des variables, des constantes et des fonctions
Retourne toujours un résultat qui peut être affecté, testé ou utilisé comme opérande d'une autre expression
Les expressions peuvent contenir des appels de fonctions et elles peuvent apparaître comme paramètres dans des appels de fonctions

EMSE CMP-GC

23

OPERATEURS ARITHMETIQUES

opérateur
+ * / + %

opération
moins unaire plus unaire multiplication division addition soustraction modulo: reste de la division entière

Remarques · Si les opérandes sont des entiers, l'opérateur / réalisera la division entière Sinon il réalisera la division réelle :
7 / 2 vaut 3 et 7.0 / 2 vaut 3.5
· Les opérandes doivent êtres des entiers pour l'opérateur % (modulo)

EMSE CMP-GC

24

OPERATEURS RELATIONNELS

opérateur
== != < <= > >=

opération
test si égalité test si différent test si inférieur test si inférieur ou égal test si supérieur test si supérieur ou égal

Le résultat de la comparaison entre deux expression vaut: 0 si le résultat de la comparaison est faux 1 si le résultat de la comparaison est vrai
Exemple: if (x >= 0) teste si x est positif

EMSE CMP-GC

25

EXPRESSIONS BOOLEENNES

· Le type booléen n'existe pas en C · Convention utilisée:
la valeur booléenne d'une expression est · fausse si elle est égale à zéro · vraie si elle différente de zéro
Exemples : 0 est une expression toujours fausse 16 est une expression toujours vraie x == 16 vraie si x est égal à 16 fausse sinon

EMSE CMP-GC

26

OPERATEURS BOOLEENS

opérateur && || !

opération ET Logique OU Logique NEGATION

Exemples 1 && 2 vraie

!3 fausse

0 || ! (2 > 0) fausse

EMSE CMP-GC

27

AUTRES OPERATEURS

Opérateurs d'auto-incrémentation (++, - -), arithmétiques étendus

x = e++; est équivalent à

x = e; e = e + 1;

x = e - -; à

x = e;

e = e - 1;

x = ++e; est équivalent à

e = e + 1; x = e;

x = - - e; à

e=e-

x = e;

x += 1; est équivalent à x ++;

x -= 3;

à x = x - 3;

(et à x = x + 1;)

Opérateurs de manipulation de bits (~, <<, >>, &, |, ^), opérateur d'expression conditionnelle (?), opérateur virgule (,), ...

Tous ces opérateurs s'appliquent avec des règles de priorité

EMSE CMP-GC

28

INSTRUCTIONS

Les instructions prescrivent les actions à faire exécuter par l'ordinateur

INSTRUCTION SIMPLE
Syntaxe:
;expression

Exemple: l'affectation
x = 2;
racine = sqrt(x);

;le appartient à l'instruction

EMSE CMP-GC

29

LES INSTRUCTIONS DE CONTROLE

· if · while · do ... while · for · switch

EMSE CMP-GC
if

30

· Syntaxe if ( <expression> )
<instruction 1> [else

·Description
La valeur de <expression> est évaluée et si elle est non nulle, <instruction1> est exécutée sinon c'est <instruction2> qui est exécutée (si elle existe)

<instruction 2>]

expression != 0
oui instruction1

·Exemple if (a > b)
non max = a;
(facultatif) else max = b;
instruction2

Remarque: <instruction> désigne : · une instruction unique:
x = 5; ou
· un bloc d'instructions: { tmp=x; x=y; y=tmp; }

EMSE CMP-GC

31

while

· Syntaxe: while (<expression>)
<instructions>

· Description: Tant que <expression> fournit une valeur non nulle, <instructions> est exécuté

expression != 0 oui
instructions

non fin du while

· Exemple: I = 0; while (I < 10)
printf("%d\n", I++);

· Remarque: <expression> est évaluée avant chaque exécution de <instructions>

EMSE CMP-GC
do ...while

32

· Syntaxe: do
<instruction> while(<expression>)

· Description: <instruction> est exécuté tant que <expression> fournit une valeur non nulle

instruction

expression != 0

non

oui fin du do ... while

· Exemple: I = 0; do
printf("%d\n", I++); while (I<10);
· Remarque: <instruction> est exécuté au moins une fois

EMSE CMP-GC
for

33

· Syntaxe: for (<expression1>;<expression2>;<expression3>)
<instruction>

expression1

non expression2 != 0

oui instruction

fin du for

expression3

· Description: 1- expression1 est évaluée 2- <instruction> est exécutée tant que
<expression2> retourne une valeur non nulle 3- <expression3> est évaluée après l'exécution de <instruction>
· Exemple: for (i=0; i<10; i++)
printf("%d", i);

EMSE CMP-GC
for / while

34

La boucle for est équivalente à la structure while

for (<expression1>; <expression2>; <expression3>)
<instruction>

<expression1>; while (<expression2>) {
<instruction> <expression3>; }

· Remarques: 1- en général <expression1> sert à initialiser, et <expression3> sert à incrémenter 2- toutes les expressions sont facultatives 3- Si <expression2> n'existe pas, elle sera supposée vraie

EMSE CMP-GC
switch

35

· SYNTAXE

switch (<expression>)

{

case e1: <instruction1>

break;

case e2: <instruction2>

break;

... ... ...

... ... ...

case eN: <instructionN>

break;

default: <instruction_default>

}

· Description 1- l'évaluation de <expression> doit
retournée une valeur de type int. 2- si la valeur de <expression> vaut
e1 ou e2... ... ... ou eN alors l' instruction correspondante sera exécutée sinon instruction_default sera exécutée
· Remarques 1- <expression> doit rendre une
valeur de type int 2- e1, e2, eN doivent être de type
int ou char 3- break permet de sortir du switch

EMSE CMP-GC
switch (diagramme)

36

expression ==e1
oui instruction1 break

non
expression ==e2 oui
instruction2 break

non
expression ==eN non oui
instructionN break
instruction_default

fin du switch

EMSE CMP-GC
switch (exemple)
switch (car) {
case `A': case `E': case `I': case `O': case `U': voyelle++;
break; case ` ': espace++;
break; default : consonne++; }

37
Remarque: si car est une voyelle et
break est absent, alors espace sera incrémenté

EMSE CMP-GC
break (2) et continue

38

Quelle que soit la boucle,
on peut toujours
· l'abandonner par break
· la recommencer par continue (en abandonnant la fin de la boucle en cours)

for(...) ou while(...) ou do
{ ... if (...) continue; ... if (...) break; ... }

EMSE CMP-GC

39

E/S de base : printf ET scanf

Les fonctions printf et scanf font partie de la bibliothèque standard d'entrées/sorties (stdio)
· printf: écriture formatée sur la sortie standard
stdout (l'écran, par défaut)
· scanf: lecture formatée sur l'entrée standard
stdin (le clavier, par défaut)

EMSE CMP-GC
EXEMPLES

40

int x = 12; float y = 28.08;

retour à la ligne après l'affichage

printf(" les valeurs sont: %d et %f \n", x, y);

int i; float r;

Pas de \n ici

printf("saisir un entier et un réel: ");

scanf("%d%f ", &i, &r);

adresse de i

adresse de r

EMSE CMP-GC
LES FORMATS d'E/S

41

LA SORTIE AVEC FORMAT: printf
%d : l'argument est un entier et l'affichage se fera en décimal %c : l'argument est un caractère %s : l'argument est une chaîne de caractères %f : l'argument est un float

L'ENTREE AVEC FORMAT: scanf
%d : la donnée est un entier saisi sous forme décimale %c : la donnée est un caractère %s : la donnée est une chaîne de caractères %f : la donnée est un réel (float)

EMSE CMP-GC

42

EMSE CMP-GC
LES FONCTIONS

43

Les fonctions sont les constituants de base d'un programme C :
· elles permettent de découper un programme en parties plus petites et plus faciles à mettre au point
· une fonction est un sous-programme qui effectue un travail bien précis, à laquelle on passe généralement des données et qui retourne éventuellement une valeur

EMSE CMP-GC

44

MISE EN OEUVRE D'UNE FONCTION

L'utilisation d'une fonction nécessite trois étapes: · la déclaration de la fonction · la définition de la fonction · l'appel de la fonction

EMSE CMP-GC

45

DECLARATION D'UNE FONCTION

La déclaration d'une fonction se fait par un prototype qui indique :
­ le nom de la fonction ­ le type de chaque paramètre ­ le type du résultat retourné
· Intérêt :
­ un prototype indique comment appeler une fonction ­ placé avant le point d'appel, il permet au compilateur de
vérifier la cohérence de l'appel

EMSE CMP-GC

PROTOTYPE

46

SYNTAXE: type identificateur (parametres_formels);

Exemple: float puissance(int, int);
ou encore float puissance(int p, int n);

EMSE CMP-GC

47

DEFINITION D'UNE FONCTION

SYNTAXE:

type identificateur (parametres_formels) {
déclarations instructions }

type: type de la valeur retournée par la fonction (int par défaut); le type void précise que la fonction ne retourne pas de valeur
identificateur: nom de la fonction
parametres_formels: (données) liste des paramètres formels; leur durée de vie est égale à la durée d'exécution de la fonction

EMSE CMP-GC

EXEMPLE

48

type de la valeur retournée

nom de la fonction

liste des paramètres formels

instructions

float puissance(int x, int n) {
int i, p=1; for (i=1; i<=n; i++)
p = p * x; return p; }

déclarations des variables locales

EMSE CMP-GC

49

APPEL D'UNE LA FONCTION

L'appel d'une fonction est réalisé en invoquant le nom de la fonction suivi de la liste des paramètres effectifs

Exemple: ... int main(void)

appel de la fonction puissance

{

float puiss;

puiss = puissance(2, 5);

printf("%f\n", puiss);

return 0;

} paramètres effectifs

EMSE CMP-GC

50

L'INSTRUCTION RETURN

SYNTAXE: return expression;

/* ou return (expression); */

· permet à la fonction de retourner la valeur expression à l'instruction appellante
· provoque une sortie immédiate de la fonction

EXEMPLE: return puiss;

REMARQUE: une fonction retourne au plus une valeur

EMSE CMP-GC

51

INSTRUCTION RETURN (suite)

Une fonction peut ne pas retourner de valeur
-> type de retour : void
EXEMPLE:
void affiche_flot (float x)
{ printf ("%f \n", x); return;
} facultatif

EMSE CMP-GC

52
LES PARAMETRES

Les paramètres permettent les échanges de données entre les fonctions
Les paramètres (formels) d'une fonction sont simplement des variables locales qui sont initialisées par les valeurs obtenues lors de l'appel (paramètres effectifs)
Le passage de paramètre ne se fait que par valeur

EMSE CMP-GC
EXEMPLE COMPLET

53

#include<stdio.h> float puissance(int x, int n);

prototype de la fonction puissance

int main(void) {
float puiss; puiss = puissance(2, 5); printf("%f\n", puiss); return 0; }

appel de la fonction puissance avec deux paramètres effectifs : 2 et 5

float puissance(int x, int n) {
int i, p=1; for (i = 1; i <= n; i++)
p = p * x; return p; }

définition de la fonction puissance avec deux parametres formels : x et n
x et n prennent les valeurs 2 et 5 à l'appel

EMSE CMP-GC

54

EMSE CMP-GC

55
LES POINTEURS

· NOTION D'ADRESSE · POINTEURS · POINTEURS ET FONCTIONS
­ Passages de paramètres ­ Exemples

EMSE CMP-GC

56

NOTION D'ADRESSE

· DEFINITION:
L'adresse d'une variable est une valeur qui indique sa localisation en mémoire

· En C, pour exprimer une adresse, on

dispose de l'opérateur &

Exemple:

adresses correspondantes

· int i;

&i

· char c;

&c

· float val;

&val

EMSE CMP-GC

57

NOTION D'ADRESSE

· int i=123;
adresses

1004 1008 1012 1016

123

i vaut 123 &i vaut 1004

EMSE CMP-GC
POINTEURS

58

· Définition
Un pointeur est une variable destinée à contenir une adresse (celle d'une autre variable)

· Terminologie
Si p est un pointeur (variable pointeur), alors la deuxième variable est dite pointée par p

EMSE CMP-GC

59

POINTEUR/VARIABLE POINTEE

La mise en oeuvre d'un pointeur se déroule en trois étapes (obligatoirement):

· 1: déclaration de la variable pointeur · 2: affectation de la variable pointeur · 3: utilisation de la variable pointée

EMSE CMP-GC

60

DECLARATION D'UN POINTEUR
· Syntaxe: <type_variable_pointée> *<pointeur>;

· Exemples: int *pi; char *pc; float *pf; ........

EMSE CMP-GC

61

DECLARATION D'UN POINTEUR
Valeur initiale indéterminée
adresses

#include<stdio.h> int main(void) {
int *p;
int i=23; ....... return 0; }

1004 1008 1012 1016

?
23

p i

EMSE CMP-GC

62

AFFECATION D'UN POINTEUR

#include<stdio.h> int main(void) {
int *p; int i=23;
p=&i;
....... return 0; }

adresses

1004 1008 1012 1016

1016
23

p i *p

EMSE CMP-GC

63

UTILISATION DE LA VARIABLE POINTEE

Elle se fait à l'aide de l'opérateur * (lecture, modifcation)

#include<stdio.h>

int main(void)

{

int *p;

/* déclaration */

int i=23, j;

p=&i;

/* initialisation */

*p = 24;

/* modification <=> i = 24 */

j = *p + 2;

/* j prend la valeur 26 */

..........

return 0;

}

EMSE CMP-GC
EXEMPLES D'UTILISATION EXEMPLE 1

#include<stdio.h> int main(void) {
int *p; int i=23;
p=&i;
*p=149;
........... return 0; }

1004 1008 1012
1016 1020
1024 1028

1016 149

64
p i *p

EMSE CMP-GC
EXEMPLE 2

#include<stdio.h> int main(void) {
int *p, *q;
int i=23; int j=28;
p=&i; *p=149;
q=&j;
.......... return 0; }

adresses

1004 1008 1012
1016 1020
1024 1028

1016 1028
149
28

65
p q
i *p j *q

EMSE CMP-GC
EXEMPLE 3
#include<stdio.h> int main(void) {
int *p, *q; int i=23, j=28; p=&i; *p=149; q=&j;
p=q;
return 0; }

66

adresses

1004 1008
1012

1028 1028

1016 1020 1024 1028

149 28

p q
i
j *q *p

EMSE CMP-GC
EXEMPLE 4
#include<stdio.h> int main(void) {
int *p; int *q; int i=23; j=67; p=&i; q=&j;
*p=*q;
............ return 0; }

67

adresses

1004 1008
1012

1016 1028

1016 67 1020

1024 1028 67

p q i *p
j *q

EMSE CMP-GC
EXEMPLE 5

68

#include<stdio.h>

adresses

int main(void) { int *p, *q;
int i=23;

1004 1008
1012

p=&i; *p=149;
*q=28; /* !!!!!!!! */
/* ERREUR : pas d'initialisation

1016 1020
1024 1028

de la variable pointeur*/

............

}

1016 ?
149

p q
i *p

EMSE CMP-GC

69

POINTEURS ET PASSAGE DE PARAMETRES

· Problème
­ Ecrire une fonction qui permette d 'échanger les valeurs de deux variables entières.

­ Données: a=5 b=9 ­ Résultat attendu: a=9 b=5

EMSE CMP-GC

70

PROGRAMME FAUX_ECHANGE.C

#include <stdio.h> void echange(int,int); int main(void) {
int a=5, b=9; echange(a,b); printf("a=%d b=%d\n, a, b); return 0; }

void echange(int x, int y); {
int tmp; tmp = x; x = y; y = tmp; }
Ce programme affiche: a=5 b=9 et non a=9 b=5

EMSE CMP-GC

71

Passage de paramètre par valeur

14982 14986 14990
14994 14998 15002 15006 15010 15014 15018 15022

5a 9b
La fonction
5 x manipule x et y 9y 5

En entrée de la fonction il y a recopie des valeurs de a et b dans x et y

14982 14986 14990

5 9

a b

14994

14998

15002
15006 9 x
15010 5 y
15014

15018 15022

5

En sortie de la fonction seuls x et y ont éte modifiés

EMSE CMP-GC

72

Passage de paramètre par adresse

· Pour résoudre ce problème d'échange de valeurs de variables
=> Solution par l'utilisation des pointeurs (passage de paramètre par adresse)

EMSE CMP-GC

73

PROGRAMME VRAI_ECHANGE.C

#include <stdio.h>
void echange(int*,int*);
int main(void) {
int a=5, b=9; echange(&a,&b); printf("a = %d b = % d\n", a, b); return 0; }

void echange(int *px, int* py) {
int tmp; tmp = *px; *px = *py; *py = tmp; }
Ce programme affiche: a=9 b=5

EMSE CMP-GC

74

PASSAGE DE PARAMETRE PAR ADRESSE

14982 14986 14990
14994 14998 15002 15006 15012 15016 15020 15024

5 9
14982 14986
5

a b
px py tmp

Après exécution

14982 14986 14990
14994 14998 15002 15006 15012 15016 15020 15024

9 5
14982 14986
5

a b
px py

EMSE CMP-GC

75

TABLEAUX

· DEFINITION:
un tableau est une variable contenant une suite d'éléments, tous de même type

· Exemples:
suite de caractères, suite d'entiers, suite de réels, ...

EMSE CMP-GC
DECLARATION D'UN TABLEAU

76

· syntaxe:
<type_tableau> <nom_tableau[<nombre_elements>]>;

· Exemples: ­ char tableau[26]; ­ int table[10]; ­ float vecteur[3];

le nombre d'éléments doit être spécifié lors de la déclaration

EMSE CMP-GC

77

ELEMENTS D'UN TABLEAU

· Les éléments du tableau sont indicés à partir de ZERO

· Chacun de ces éléments est désigné par le nom du tableau et son indice

23 7

11 13 17 19

tab[0] tab[1] tab[2] tab[3] tab[4] tab[5] tab[6] tab[0] vaut 2 ... tab[4] vaut 13 ... tab[6] vaut 19

EMSE CMP-GC

78

OPERATIONS SUR LES ELEMENTS DES TABLEAUX

· Exemples d'écritures:
­ tableau [0] = 'A'; int i = 3;
­ tableau [i] = 'D'; ­ tableau [i + 1] = 'E'; ­ table[3] = 125;
· Exemples de lectures:
­ X = table[3]; ­ vecteur[3] = vecteur[2] * 3.14;

EMSE CMP-GC

79

EXEMPLE D'UTILISATION (1)

#include<stdio.h> int main(void) {
int i,base; char tab[10]; base = 7; for (i=0; i<10; i++)
tab[i]= base * (i + 1); ...... }

adresses

5136 5137 5138 5139 5140 5141 5142
5143 5144 5145 5146

7 14 21 28
35 42 49 56
63 70

tab[0] tab[1] tab[2] tab[3] tab[4] tab[5] tab[6]
tab[7] tab[8] tab[9]

EMSE CMP-GC

80

EXEMPLE D'UTILISATION (2)

#include<stdio.h> int main(void) {
float vect[3]; printf("donnez le 1er élément : "); scanf("%f", &vect[0]); printf("donnez le 2ème élément : "); scanf("%f", &vect[1]); printf("donnez le 3ème élément : "); scanf("%f", &vect[2]); return 0; }

EMSE CMP-GC

81

TABLEAUX A DEUX DIMENSIONS
DEFINITION:
Un tableau à deux dimensions est interprété comme un tableau (uni-dimensionnel) dont chaque élément est un tableau (uni-dimensionnel)

Tableau à N éléments

..........

Tableau à 3 éléments

Tableau à 3 éléments

EMSE CMP-GC

82

DÉCLARATION DE TABLEAUX A DEUX DIMENSIONS

Syntaxe: <Type> <NomTabl>[<DimLigne>][<DimCol>];

Exemple (déclaration d'un tableau à 2 lignes et 3 colonnes): int mat[2][3];

EMSE CMP-GC
MÉMORISATION

83

Comme pour les tableaux à une dimension, le nom d'un tableau représente l'adresse du premier élément du tableau (c.à.d. l'adresse de la première ligne du tableau)
Les éléments d'un tableau à deux dimensions sont stockés ligne par ligne dans la mémoire

EMSE CMP-GC

84

EXEMPLE DE MEMORISATION

int mat[2][3] = {{1, 11, 111}, {2, 22, 222}};

Initialisation du tableau

Un tableau de dimension L et C, formé de composantes dont chacune a besoin de N octets, occupera L*C*N octets en mémoire.
Pour stocker le tableau mat, il faut 2*3*4=24 octets

1ere ligne 2eme ligne

1 mat[0][0] 11 mat[0][1] 111 mat[0][2] 2 mat[1][0] 22 mat[1][1] 222 mat[1][2]

EMSE CMP-GC

85

TABLEAU MULTIDIMENSIONNEL

Exemples d'utilisation:

int mat[2][3];
mat [0][0]= 1; mat [0][1]= 11;

1 mat[0][0] 1ere ligne 11 mat[0][1]

? mat[0][2]

11 mat[1][0]

2eme ligne

? mat[1][1]

? mat[1][2]

mat [1][0]= mat [0][1];

EMSE CMP-GC

86

ACCÈS AUX ELEMENTS D'UN TABLEAU

Accès à un élément se fait par:
<NomTableau>[<Ligne>][<Colonne>]

ATTENTION:
Les indices du tableau varient de 0 à L-1 et de 0 à C-1. mat[N-1][M-1] est l'élément de la Nème ligne et Mème
colonne

Les éléments du tableau mat se présentent ainsi:

mat[0][0] mat[0][1] mat[0][2] mat[1][0] mat[1][1] mat[1][2]

mat[0][2]: élément de la 1ère ligne et de la 3ème colonne

EMSE CMP-GC

87

TABLEAUX ET POINTEURS

· En langage C, il existe un lien fort entre les tableaux et les pointeurs :
· Toutes les opérations effectuées sur les tableaux peuvent être réalisées à l'aide des pointeurs

EMSE CMP-GC

88

ADRESSE D'UN TABLEAU

· Le nom du tableau représente son adresse
· L'adresse d'un tableau est égale à l'adresse de son premier élément :
tab &tab[0]

EMSE CMP-GC

89

IMPLANTATION D'UN TABLEAU EN MEMOIRE

· Les éléments d'un tableau ont tous la même taille mémoire (qui dépend de leur type)

· Les emplacements mémoire des éléments d'un tableau sont contigus

· Le nom du tableau désigne l'adresse du 1er élément de ce tableau

EMSE CMP-GC

EXEMPLE 1

90

int main(void) {
float vect[3]; float *pf; float x; vect[0] = 3.07; vect[1] = 2.79; vect[2] = 13.2; pf = &vect[0]; ......... x = *pf; return 0; }

adresses

45252 45256 45260 45264

3.07 2.79
13.2

632180 45252 632188 3.07

vect vect[0] vect[1] vect[2]
pf x

EMSE CMP-GC

EXEMPLE 2

91

int main(void) {
float vect[3]; float *pf; float x; vect[0] = 3.07; vect[1] = 2.79; vect[2] = 13.2;
pf = vect;
......... x = *pf; return 0;
}
Remarque

vect 45252 45256 45260 45264

3.07 2.79
13.2

vect[0] vect[1] vect[2]

632180 45252

pf

632188 3.07

x

pf = vect équivalent à pf = &vect[0]

EMSE CMP-GC

92

TABLEAUX & POINTEURS

vect &vect[0] &vect[i]

vect + i

*vect

vect[0]

*(vect + i)

vect[i]

EMSE CMP-GC

93

ARITHMETIQUE DE POINTEURS (1)

· SI p pointe vers l'élément d'indice 0 du tableau
· ALORS p+1 pointe vers l'élément d'indice 1 du tableau
p+2 pointe vers l'élément d'indice 2 du tableau ....................... p+i pointe vers l'élément d'indice i du tableau

EMSE CMP-GC

94

ARITHMETIQUE DE POINTEURS (2)

état initial de pf (adresse contenue dans pf)

int main(void)

{

45252 0.0

vect[0]

float vect[10]; float *pf; int i; pf = vect;

45256 45260
45264

0.0
0.0 0.0

vect[1] vect[2]
vect[3]

for(i=0; i<10; i++)

{

45288 0.0

vect[9]

*pf = 0.0;

pf++;

} état final de pf

.......

return 0; }

632180 45288

pf

EMSE CMP-GC

95

INDEXATION D'UN POINTEUR

Un pointeur sur un tableau peut s'indexer comme le nom d'un tableau
int main(void)
{
float vect[10]; float *pf; pf = vect; int i; for(i=0; i<10; i++)
pf[i] = 0.0;
.......
}

état initial de pf 45252 45256 45260 45264 45288
632180

= état final de pf
0.0 vect[0] 0.0 vect[1] 0.0 vect[2] 0.0 vect[3]
0.0 vect[9]

45252

pf

Remarque: pf pointe toujours sur le début du tableau

EMSE CMP-GC
PARAMETRE DE TYPE TABLEAU ET FONCTIONS
Exemple de déclaration:
float maximum(float *tab, int nombre);
ou
float maximum(float tab[], int nombre);

96

­ Les paramètres de type tableau sont traités comme des pointeurs
­ La fonction ne connaît pas le nombre d'éléments du tableau. Un paramètre additionnel est souvent utilisé (ici, nombre)

EMSE CMP-GC

97

PASSAGE D'UN TABLEAU EN PARAMETRE

#include<stdio.h> float maximum(float *v, int nb); int main(void) { float vect[10], max; int i; for(i=0; i<10; i++)
scanf("%f", &vect[i]);
max = maximum(vect, 10); printf("max = %f\n", max); return 0;
}

float maximum(float *v, int nb)

{

float m;

int i; m = v[0];

float v[ ]

for(i=1; i<nb; i++)

if (m < v[i])

m = v[i];

return m;

}

EMSE CMP-GC

98

ATTENTION

P et Q: pointeurs, T1 et T2: tableaux, I: entier

AUTORISE
P = Q; P = T1; P++; P = P + I;

INTERDIT
T1 = T2; T1 = P; T1++; T1 = T1 + I;

Le nom d'un pointeur est une VARIABLE

Le nom d'un tableau est une CONSTANTE

EMSE CMP-GC

99

Les Chaînes de Caractères

· Définition · Stockage · Opérations sur les chaînes de caractères
­ stdio.h : scanf, printf ­ string.h : strlen, strcmp, strcat, ...

EMSE CMP-GC

100

Les chaînes de caractères (définition)

Une chaîne de caractères est une séquence finie de caractères

Syntaxe :

" <séquence de caractères> "

"TOTO" TOTO "T" T 'T' ""

: chaîne de caractères comportant 4 caractères : identificateur : chaîne de caractères comportant 1 caractère : identificateur : caractère T : chaîne de caractères vide : 0 caractère

EMSE CMP-GC
STOCKAGE des chaînes de caractères

101

· Les chaînes de caractère sont rangées dans des tableaux de caractères · la fin de la chaîne est délimitée par le caractère '\0' · Une chaîne est désignée par l'adresse du premier caractère de la séquence (pointeur de caractère char *)

char chaine[5]="toto"

chaine
il faut un tableau de 5 char pour contenir une chaîne de 4 caractères

5674 5675 5676 5677 5678

'T' 'O' 'T' 'O' '\0'

EMSE CMP-GC
Contenant/Contenu

102

void f () {char T[5];

Contenant

contenu printf

??? ??? ??? ??? ??? ??? ???

T[0] = '\0'; printf("%s",T); T[0]='T'; T[1]='\0'; printf("%s",T); T[0]='T';T[1]='O'; T[2]='T';T[3]='O'; T[4]='\0'; printf("%s",T); }

'\0' ??? ??? 'T' '\0' ???
'T' 'O' 'T'

??? ??? "" ??? ??? "T"

T

'O' '\0' "TOTO" TOTO

EMSE CMP-GC

103

OPERATIONS SUR LES CHAINES DE CARACTERES

· les paramètres désignant les chaînes de caractères sont de type pointeur ou tableau de caractères
· Toutes les opérations sur les chaînes de caractères repèrent la fin de ces chaînes par le caractère spécial '\0' (Convention «C»)
· Les prototypes de ces fonctions sont contenues dans les fichiers <string.h> et <stdio.h>

EMSE CMP-GC

104

Initialisation d'un tableau ou pointeur de caractères

L'initialisation peut se faire à la déclaration du tableau ou du pointeur correspondant

char s[10]="mimi";

'm' 'i' 'm' 'i' '\0' ? ? ?

?

char mauvais[4]="mimi" 'm' 'i' 'm' 'i'

pas de place pour '\0': chaine de caractères invalide

5670 p
5674

5675 un tableau est alloueé en 5676 char *p="mimi"; mémoire pour la chaîne 5677

5678

5674
'T' 'O' 'T' 'O' '\0'

EMSE CMP-GC

105

Lecture des chaînes de caractères

scanf : lecture d'une séquence de caractères ne contenant aucun caractère d'espacement (espace, tabulation, fin de ligne,...). les espaces initiaux éventuels sont sautés

gets: lecture d'une ligne complète y compris la fin de ligne

Effet de scanf et gets pour la même séquence : alors après

#include <stdio.h> {char buf[9];

'a' 'l' 'o' 'r' 's' '\0' ? ? ?

scanf("%s",buf);

gets(buf);

'a' 'l' 'o' 'r' 's' ' ' 'a' '\n' '\0'

} l'adresse d'un tableau, c'est son nom (pas de &)

EMSE CMP-GC

106

Affichage d'une chaîne de caractères

#include <stdio.h>

int main(void)

{char buf[10]="toto";

char s[10];

char * p; printf("%s",buf);

affiche toto à l'écran

puts(buf); printf("%s",s);

printf("%s\n",buf);

puts(s);

erreur : s peut contenir n'importe quoi

printf("%s",p); p=buf;

erreur : p pointeur non initialisé

printf("%s",p); return 0;}

printf("%s",buf);

EMSE CMP-GC
Module de bibliothèque : <string.h>

107

Ce module définit des opérations sur les chaînes de caractère: ­ longueur : strlen int strlen(char *s); ­ copie : strcpy char *strcpy(char *dest, char *source); ­ concaténation : strcat char *strcat(char *dest, char *fin);

­ ... (cf. bibliothèque des fonctions prédéfinies)

EMSE CMP-GC

108

Exemples : copie et concaténation

#include <string.h>

#include <stdio.h>

main() {char s[5],d[5]; ? ?

s[0]='\0';

'\0' ?

s
? ?? ? ??

d
??? ? ? ??? ? ?

strcpy(d,s);

'\0' ? ?

s[0]='T'; s[1]='O';s[2]='\0'; 'T' 'O' '\0'

strcat(d,s);

strcat(d,s);

'T' 'O' '\0'

?? ??
??

'\0' ? ? ? ? ??? ? ?
'T' 'O' 'T' 'O' '\0'

printf("%s :longueur %s\n",d,strlen(d));} TOTO longueur : 4

EMSE CMP-GC

109

TABLEAUX ... DE POINTEURS

Les pointeurs sont des variables (presque) comme les autres : on peut ainsi les utiliser comme éléments d'un tableau Ex :
char *ete[3] = {"Juin", "Juillet", "Aout"};
for (i = 0; i <= 2; i++) printf ("mois = %s\n", ete[i]);

EMSE CMP-GC

110

ARGUMENTS D'UN PROGRAMME (1)

En "C", un programme accepte des arguments au lancement (ex : joe exo.c)
Les arguments passés sont considérés comme des chaînes de caractères
Leur nombre et le contenu de chacune de ces chaînes peuvent être récupérés au niveau du programme

EMSE CMP-GC

111

ARGUMENTS D'UN PROGRAMME (2)

Ex: > factorielle 3

pgm "factorielle" lancé avec le paramètre "3"

int main (int argc, char *argv[]) {
int i; printf ("nb_args = %d\n", argc); for (i = 0; i < argc; i++)
printf ("%s\n", argv[i]); return 0; }

pgm factorielle.c (nom exécutable:
factorielle)
2 affichage: factorielle
3

EMSE CMP-GC

112

ARGUMENTS D'UN PROGRAMME (3)

Ex. d'utilisation possible (fichier factorielle.c):
void main (int argc, char *argv[]) { int i = atoi(argv[1]); printf ("!%d = %d\n", i, fact(i));
}
int fact (int n) { int f = 1, i; for (i = 2; i <= n; i++) f *= i; return f;
}

EMSE CMP-GC
STRUCTURES (Plan)

113

· typedef
· définition d'une structure · accès aux champs d'une structure · structures et pointeurs · structures et fonctions

EMSE CMP-GC

114

DEFINITIONS DE TYPES VIA typedef

· typedef permet de créer de nouveaux noms de types

· Exemples:
typedef float Reel; typedef char Chaine[20];

Reel x, y, vect[3]; <=> float x, y, vect[3];

Chaine nom;

<=> char nom [20];

EMSE CMP-GC
STRUCTURES

115

Une structure est un type qui regroupe, sous un seul nom, plusieurs variables appelées champs et pouvant être de types différents.

Syntaxe:
struct Nom_Structure {
type1 champ1; type2 champ2; ........ ............ typeN champN;
};

EMSE CMP-GC

116

EXEMPLES

struct Date { int jour; int mois; int annee; };

struct Individu { char nom[15]; char prenom[15]; int num_secu; struct Date date_naissance; };
défini avant, obligatoirement

EMSE CMP-GC

117

DECLARATION DE VARIABLES DE

«TYPE» STRUCTURE

Attention : les déclarations précédentes ne sont pas des déclarations de variables; ce sont des déclarations de modèles (de types) à partir desquels on peut déclarer des variables

Syntaxe: struct Nom_structure ident1, ident2, ..., ident2;

Exemple: struct Date anniversaire, date_mariage; struct Individu pere, mere, fille;

EMSE CMP-GC

118

ACCES A UN CHAMP D'UNE STRUCTURE

Syntaxe:
· Nom_variable.champ_de_structure

Exemples: · pere. num_secu = 12678; · pere.date_naissance.annee = 1964; · scanf("%s", fille.nom); · printf("nom = %s", fille.nom);

EMSE CMP-GC
OPERATIONS GLOBALES SUR LES STRUCTURES

119

L'affectation globale entre deux variables d'un même type structuré est la seule opération autorisée

Exemples: struct Date dat1, dat2; dat1= dat2;

if (dat1 = = dat2)

INTERDIT

printf(" meme date ");

EMSE CMP-GC
DEFINITION D'UN TYPE STRUCTURE VIA typedef (1)

120

Les définitions précédentes peuvent s'écrire en utilisant le mot clé typedef:

typedef struct { int jour; int mois; int annee;
} Date;

typedef struct { char nom[15]; char prenom[15]; int num_secu;
Date date_naissance; } Individu;

EMSE CMP-GC

121

DEFINITION D'UN TYPE STRUCTURE VIA typedef (2)

Avec typedef, les noms des types sont Date et Individu et non plus
struct Date et struct Individu.

D'où une simplification dans les declarations des variables:
Date anniversaire, date_mariage; Individu pere, mere, fille;

EMSE CMP-GC

122

STRUCTURES ET POINTEURS

Comme pour les autres types, il est possible de définir des pointeurs sur des structures:

typedef struct {
int jour; int mois; int annee;
} Date; Date date_naissance; Date *p; p = &date_naissance;

EMSE CMP-GC

123

ACCES AUX CHAMPS D'UNE STRUCTURE

Avec un pointeur, l'accès aux champs se fait en utilisant les opérateurs
" -> " (flèche), ou " (*p). "

Exemples: Date date_naissance; Date *p;

p = &date_naissance;

p->jour = 12;

(*p).jour = 12;

p->annee = 1973;

(*p).jour = 1973;

EMSE CMP-GC

124

REPRESENTATION EN MEMOIRE

date_naissance

12 6 1973

p->jour ou date_naissance.jour p->mois ou date_naissance.mois p->annee ou date_naissance.annee

Ap A est l'adresse de date_naissance

EMSE CMP-GC

125

RESUME SUR L'ACCES AUX CHAMPS D'UNE VARIABLE STRUCTURE

· Si on utilise le nom de la variable: l'accès se fait par l'opérateur ' . ' (point)
· Si on utilise un pointeur sur la variable: l'accès se fait via ' -> ' (flèche)
ou par ' (*ptr). '

EMSE CMP-GC
REMARQUE

126

Dans une même expression, on peut être amené à combiner les deux opérateurs
'.' (point) et '->' (flèche)

Exemple: Individu pere; Individu *pt_personne;
pt_personne = &pere; pt_personne->date_naissance.annee = 1975;

EMSE CMP-GC

127

STRUCTURES ET FONCTIONS (1)

Comme avec les autres types, une structure peut être passée par valeur ou par adresse
Exemple:
void afficher(Date date_naissance) /* passage par valeur */ {
printf("%d\n", date_naissance.jour); printf("%d\n", date_naissance.mois); printf("%d\n", date_naissance.annee); }

EMSE CMP-GC

128

STRUCTURES ET FONCTIONS (2)

void initialiser(Date *pt_date)
{ pt_date->jour = 1; pt_date->mois = 1; pt_date->annee = 1997;
}

/* passage par adresse */

void main(void)
{
Date nouvelle_date;
initialiser(& nouvelle_date);
afficher(nouvelle_date);
}

EMSE CMP-GC
OPTIMISATION DES PASSAGES DE PARAMETRES

129

Le passage d'un paramètre par valeur entraîne la recopie de la variable passée dans le paramètre de la fonction

Temps d'exécution long si "grande" structure
"Habitude" de passer les structures par adresse même si la fonction ne modifie pas la variable structure

EMSE CMP-GC
EXEMPLE

130

void afficher(Date *pt_date) /*passage par adresse*/
{ printf("%d\n", pt_date->jour); printf("%d\n", pt_date->mois); printf("%d\n", pt_date->annee);
}

void main(void) {
Date nouvelle_date;
initialiser(& nouvelle_date); afficher(&nouvelle_date);
}

/* appel */ /* appel */

EMSE CMP-GC

131

RETOURNER UNE STRUCTURE

Une fonction peut retourner une structure:

Date saisir(void) {
Date d; scanf("%d", &(d.jour)); scanf("%d", &(d.mois)); scanf("%d", &(d.annee));
return d;
}

int main(void) {
Date date_saisie; date_saisie = saisir(); afficher(date_saisie); ................ return 0; }

EMSE CMP-GC

132

AMELIORATION

Il y a recopie de la structure retournée dans une

variable => manque d'efficacité

=> on utilise plutôt un passage par

adresse à la place du retour de

vfooind csatiisoirn(Date *pt_d)

int main(void)

{ scanf("%d", &(pt_d->jour)); scanf("%d", &(pt_d->mois)); scanf("%d", &(pt_d->annee));
}

{ Date date_saisie; saisir(&date_saisie); afficher(&date_saisie); return 0;
}

EMSE CMP-GC

133

TABLEAUX DE STRUCTURES

Comme avec les autres types, on peut définir des tableaux de structures:
Date liste_date[10];

Chaque élément du tableau est une structure:

liste_date[0].jour = 15; liste_date[0].mois = 9; liste_date[0].annee = 1996; ........................

liste_date[4].jour = 28; liste_date[4].mois = 8; liste_date[4].annee = 1996;
....................

EMSE CMP-GC

134

EMSE CMP-GC
FICHIERS (Plan)

135

· Définition d'un fichier · Déclaration d'un fichier · Ouverture / fermeture d'un fichier · Déplacement dans un fichier · Lecture / Ecriture dans un fichier

EMSE CMP-GC

136

DEFINITION D'UN FICHIER

Un fichier est: ­ une séquence d'octets, ­ repéré par un nom (dit nom externe), ­ enregistré sur un support physique non volatile de l'ordinateur: disque, bande magnétique. Il n'est pas détruit à l'arrêt de l'ordinateur.
La taille d'un fichier n'est pas précisée à sa création

EMSE CMP-GC

137

DECLARATION DE FICHIER

Syntaxe:
FILE *<nom_interne>; où nom_interne
· désigne un identificateur · est une variable "pointeur" associée à un
fichier de nom nom_externe · permet de réaliser toutes les opérations d'un
programme C sur ce fichier

EMSE CMP-GC

138

OPERATIONS SUR UN FICHIER

· Ouverture du fichier (fopen) · Déplacement éventuel dans le fichier (fseek) · Lecture éventuelle dans le fichier (fread,...) · Ecriture éventuelle dans le fichier (fwrite,...) · Fermeture du fichier (fclose)

EMSE CMP-GC

139

OUVERTURE D'UN FICHIER

L'ouverture d'un fichier se fait à l'aide de la fonction fopen de prototype:
FILE *fopen(char *nom_externe, char *mode);

chaîne de caractères

chaîne de caractères définissant le type et le mode d'accès du fichier

fopen retourne le nom_interne du fichier en cas de succès et NULL dans le cas contraire

EMSE CMP-GC
POSITION COURANTE
(dans un fichier)

140

A tout fichier ouvert est associé un "curseur" positionné sur le numéro de l'octet courant
L'opération de lecture ou d'écriture à suivre se fait à partir de la position de ce curseur, et déplace celui-ci du nombre d'octets lus/écrits

EMSE CMP-GC
MODES D'ACCES AUX FICHIERS TEXTE (1)

141

r Ouverture d'un fichier texte existant en lecture. Le
curseur associé au fichier est positionné au début du fichier
w Ouverture d'un fichier texte en écriture. Si ce
dernier existe, il est détruit. Le curseur est positionné au début du fichier
a Ouverture d'un fichier texte en écriture. Toute
écriture se fera en fin du fichier, quelle que soit la position courante du curseur

EMSE CMP-GC

142

MODES D'ACCES AUX FICHIERS TEXTE (2)

r+ Identique au mode r avec possibilité
d'écriture

w+ Identique au mode w avec possibilité
de lecture

a+ Identique au mode a avec possibilité de
lecture

EMSE CMP-GC
MODES D'ACCES AUX FICHIERS BINAIRES

143

Identiques aux modes d'accès aux fichiers
textes en ajoutant la lettre b
Exemple:
rb r+b w+b

Remarque: Sous Unix, pas de différence entre fichier texte et binaire, contrairement au monde PC

EMSE CMP-GC

144

OUVERTURE D'UN FICHIER

Syntaxe: <nom_interne>=fopen(<nom_externe>, mode);

Exemple: FILE *fic;
fic = fopen("repertoire.dat", "a+b");
Ouvrir un fichier revient à créer un lien entre <nom_interne> qui est: fic
et <nom_externe> qui est: repertoire.dat

EMSE CMP-GC

145

FERMETURE D'UN FICHIER (1)

La fermeture d'un fichier se fait par la fonction fclose de prototype:
int fclose(FILE *<nom_interne>) fclose retourne zéro en cas de succès

EMSE CMP-GC

146

FERMETURE D'UN FICHIER (2)

Syntaxe: fclose(<nom_interne>);

Exemple: fclose(fic);
Fermer un fichier revient à briser le lien entre <nom_interne> qui est fic et <nom_externe> qui est repertoire.dat

EMSE CMP-GC

147

DEPLACEMENT DANS UN FICHIER (1)

Prototype:
int fseek (FILE *nom_interne, long int dep, int origine);
Permet de positionner le curseur du fichier, relativement · au début du fichier si origine vaut SEEK_SET · à la fin du fichier si origine vaut SEEK_END · à la position courante du curseur si origine vaut SEEK_CUR
dep = valeur du déplacement en nombre d'octets

EMSE CMP-GC

148

DEPLACEMENT DANS UN FICHIER (2)

fseek(fic, 0, SEEK_SET)
Positionne le curseur au début du fichier

fseek(fic, 0, SEEK_END)
Positionne le curseur en fin du fichier

fseek(fic, 4, SEEK_SET);
Positionne le curseur sur le 5ème octet du fichier

EMSE CMP-GC
fread (prototype)

149

int fread(void *p, int taille, int nombre, FILE *nom_interne);
· fread lit dans le fichier "nombre" éléments, chacun de "taille" octets, et range les éléments lus en mémoire à l'adresse pointée par "p"
· fread retourne le nombre d'éléments effectivement lus (au plus "nombre" si la fin de fichier est atteinte)
· la lecture se fait à partir de la position courante du curseur, et déplace le curseur du nombre d'éléments lus

EMSE CMP-GC
fread (exemple)
typedef struct { char nom[15]; int age; } Individu;
Individu pers, ind[3];
fread(&pers, sizeof(Individu), 1, fic);
.....................................
fread(ind, sizeof(Individu), 3, fic);
.....................................

150

EMSE CMP-GC
curseur fichier

151

fread (mise en oeuvre)

mémoire

pers

1 élément fread(&pers, sizeof(Individu), 1, fic); 3 éléments

fread(ind,

sizeof(Individu),

3,

ind
fic);

EMSE CMP-GC
fwrite (prototype)

152

int fwrite(void *p, int taille, int nombre, FILE *nom_interne);
· fwrite écrit dans le fichier "nombre" éléments pointés par "p", chacun de "taille" octets
· fwrite retourne le nombre d'éléments effectivement écrits; l'ecriture se fait à partir de la position courante du curseur, et déplace celui-ci du nombre d'éléments écrits

EMSE CMP-GC
fwrite (exemple)
typedef struct { char nom[15]; int age; } Individu;
Individu pers, ind[3];
fwrite(&pers, sizeof(Individu), 1, fic);
.....................................
fwrite(ind, sizeof(Individu), 3, fic);
.....................................

153

EMSE CMP-GC
curseur fichier

154
fwrite (mise en oeuvre) mémoire
pers

1 élément fwrite(&pers, sizeof(Individu), 1 , fic); 3 éléments

fwrite(ind,

sizeof(Individu),

3,

ind
fic);

EMSE CMP-GC

155

ALLOCATION DYNAMIQUE DE MEMOIRE (1)

La taille des données n'est pas toujours connue lors de la programmation

la plupart du temps: réservation de taille "maximale"

gaspillage de l'espace mémoire

EMSE CMP-GC

156

ALLOCATION DYNAMIQUE DE MEMOIRE (2)

Saisie d'un tableau d'entiers avec demande

de la taille réelle utilisée :

...
int tab[100];

réservation de la taille maximale (supposée)

int nb_int;

printf("nombre d'entiers: ");

scanf("%d", &nb_int);

for(i = 0; i < nb_int; i++)

scanf("%d", &tab[i]); ...

Problème si nb_int >= 100

EMSE CMP-GC

157

ALLOCATION DYNAMIQUE DE MEMOIRE (3)

Si on veut ajuster la taille au besoin exact: demande d'allocation dynamique de mémoire

Utilisation de la fonction standard malloc de la bibliothèque <stdlib.h>

EMSE CMP-GC
MALLOC

158

· Prototype: void *malloc(int nbo);

dans<stdlib.h>

· Description: alloue un bloc mémoire de nbo octets

· Valeur retournée:
un pointeur sur le début du bloc alloué en cas de succès, et NULL sinon (place disponible insuffisante).

EMSE CMP-GC

159

POINTEUR VOID / CONVERSION DE TYPE

· malloc alloue une suite d'octets sans présumer de ce que le programmeur va y mettre (des entiers, des structures, ....)

· le pointeur retourné est de type void * :
il pointe sur une zone de mémoire sans précision du type des données pointées

· pour manipuler les données, il faut convertir le pointeur en un pointeur du type des données

EMSE CMP-GC

160

CONVERSIONS : Exemple

..
int *ptab;
int nb_int, nb_oct, i;

pas de réservation de tableau à la compilation

printf("nombre d'entiers: ");
scanf("%d", &nb_int);
conversion de
pointeur (cast) nb_oct = nb_int * sizeof(int);
ptab = (int *) malloc(nb_oct);

taille en octets d'une variable du type int

for(i = 0; i < nb_int; i++)

scanf("%d", &ptab[i]); ..

taille allouée (en octets)

EMSE CMP-GC

161

LIBERATION DE LA MEMOIRE

Lorsque l'on a fini d'utiliser une zone mémoire allouée dynamiquement,
il faut la libérer

Utilisation de la fonction standard free de la bibliothèque <stdlib.h>

EMSE CMP-GC
FREE (1)

162

· Prototype: void free(void *ptr);

dans <stdlib.h>

· Description:
libère la zone mémoire, pointée par le pointeur ptr, et allouée précédemment par malloc

· Valeur retournée: aucune valeur

EMSE CMP-GC
FREE (2)

163

Exemple: . . ptab = (int *) malloc(nb_oct); . . .
free(ptab);
. . .

EMSE CMP-GC

164

LISTES CHAINEES (DEFINITION)

Une liste chaînée est une suite d'éléments, appelés noeuds, chacun composé:
· de l'information que l'on veut traiter
· d'un lien de chaînage, qui est un pointeur vers l'élément suivant de la liste

info info

info info NULL

EMSE CMP-GC

165

LISTES (MISE EN OEUVRE)

· Chaque noeud pointe vers son successeur, sauf le dernier, qui contient le pointeur NULL
· L'exploitation d'une liste nécessite un pointeur "isolé", appelé tete, qui pointe vers le premier élément de la liste
tete

info info

info info NULL

EMSE CMP-GC

166

DEFINITION D'UNE LISTE (EN "C")

typedef struct noeud { int info; struct noeud *suiv; }T_noeud;

Exemple de définition d'un type noeud

T_noeud *tete;

Exemple de déclaration d'un pointeur qui pointe vers un noeud

Attention: tete doit être initialisée à la valeur NULL

EMSE CMP-GC

167

INSERTION D'UN NOEUD AU DEBUT D'UNE LISTE

Liste vide

NULL tete

tete

Liste non vide

tete

20 tete

30

10 20 30

10 NULL après insertion
50 60 NULL
50 60 NULL

EMSE CMP-GC

168

INSTRUCTIONS D'INSERTION D'UN NOEUD AU DEBUT D'UNE LISTE

... ... ... T_NOEUD *nouveau; nouveau = (T_NOEUD *) malloc(sizeof(T_NOEUD); nouveau->info = 10;

if (tete == NULL) {
nouveau->suiv = NULL; tete = nouveau; } else { nouveau->suiv = tete; tete = nouveau; } ... ... ...

EMSE CMP-GC

169

INSERTION D'UN NOEUD EN FIN DE LISTE

tete 10 20

30

40 50 60 NULL

tete 10 20

30

40

L'insertion d'un noeud en fin de liste nécessite de repérer la fin de la liste

courant 50 60 70 NULL
parcours des éléments jusqu'à trouver le pointeur NULL

EMSE CMP-GC

170

INSTRUCTIONS D'INSERTION D'UN NOEUD EN FIN DE LISTE

... ... ... T_NOEUD *nouveau, *courant; nouveau = (T_NOEUD *) malloc(sizeof(T_NOEUD); nouveau->info = 70; courant = tete;
while (courant->suiv != NULL) courant=courant->suiv;
nouveau->suiv = NULL; courant->suiv =nouveau;
... ... ...

EMSE CMP-GC

171

INSERTION D'UN NOEUD AU MILIEU D'UNE LISTE

tete 10 20

30

50 60 NULL

tete

precedent

courant

10 20 30 40 50 60 NULL

L'insertion d'un noeud au milieu d'une liste nécessite de repérer l'endroit d'insertion

parcours des éléments jusqu'à trouver cet endroit

EMSE CMP-GC

172

INSTRUCTIONS D'INSERTION D'UN NOEUD AU MILIEU D'UNE LISTE

... ... ... T_NOEUD *nouveau, *courant, *precedent; nouveau = (T_NOEUD *) malloc(sizeof(T_NOEUD); nouveau->info = 40; precedent = NULL; courant = tete;
while ((courant->info < nouveau->info) {
precedent = courant; courant = courant->suiv; } nouveau->suiv = courant; precedent->suiv = nouveau;
... ... ...

EMSE CMP-GC

173

INTRODUCTION A LA MODULARITE

Un programme de taille ou de complexité importantes peut être développé sur plusieurs fichiers ou modules

Intérêt du découpage modulaire: · réutilisation: un même module peut être utilisé dans
plusieurs programmes différents (stdio...);
· compilation séparée; · réduction de la complexité: l'utilisation d'un module
n'exige pas de connaître sa réalisation, mais son interface;
· travail en équipe; · ... ... ...

EMSE CMP-GC

174

LA MODULARITE SUR UN EXEMPLE SIMPLE

module combi

les directives, les prototypes... main() { ... ... ... }
void Triangle(int LIGNES) { ... ... ... }
void AfficheLigne(int P) { ... ... ... }
int C(int P, int Q) {
... ... ... }
int Fact(int N) { ... ... ... }

programme triangle_pascal

mcoodmulbeinatoire prmoogdpurliencipal

les directives les prototypes... int C(int P, int Q) {
... ... ... }
int Fact(int N) { ... ... ... }
les directives, les prototypes... main() { ... ... ... }
void Triangle(int LIGNES) { ... ... }
void AfficheLigne(int P) { ... ... }

module triangle

EMSE CMP-GC

175

LES COMPOSANTS D'UN MODULE

Tout module est constitué de 2 fichiers:

· une interface ou spécification des
fonctionnalités offertes: fichier .h (appelé
aussi fichier d'en-tête ou header file)

· une implémentation des fonctionnalités
spécifiées dans l'interface: fichier .c

EMSE CMP-GC

176

CONTENU D'UN FICHIER .h

Définitions «externes» c-à-d celles utilisables par d'autres modules clients:

­ Directives #define

­ Définition des types (typedef ...)

­ Prototypes des fonctions

Exemple:

int C(int P, int Q); int Fact(int N);

le contenu de combi.h

combi.h doit être inclus dans tous les modules utilisant C ou Fact

EMSE CMP-GC

177

CONTENU D'UN FICHIER .c

· Inclusion de fichiers d'en-têtes · Définition de variables globales · Définitions «propres» au module, c.à.d. non
accessibles aux autres modules :
­ constantes internes au module ­ types internes au module ­ prototypes des fonctions internes au module
· Définition des fonctions

EMSE CMP-GC
Utilisation d'un module

178

Tout fichier utilisant les fonctionnalités d'un module doit inclure
le fichier d'en-tête de ce module

Ceci permet au compilateur de vérifier la bonne utilisation de ces fonctionnalités

EMSE CMP-GC
#include <stdio.h>
#include "combi.h"
void Triangle(int LIGNES); void AfficheLigne(int P);

triangle.c

main() { int N; printf("Introduire le nombre de lignes N : "); scanf("%d", &N); Triangle(N); } void Triangle(int LIGNES) { int P; for (P=0; P<LIGNES; P++) AfficheLigne(P); } void AfficheLigne(int P) { int Q; for (Q=0; Q<=P; Q++) printf("%6.0f", C(P,Q)); printf("\n"); }

179
EXEMPLE COMPLET

int C(int P, int Q); int Fact (int N);

combi.h

combi.c
#include "combi.h"
int C(int P, int Q) {
return Fact(P)/(Fact(Q)*Fact(P-Q)); } int Fact(int N) {
int i, factorielle; factorielle = 1; for (i=2; i<=N; i++)
factorielle = factorielle * i; return(factorielle); }

EMSE CMP-GC

180

MODULES PREDEFINIS

· le langage C offre un certain nombre de modules prédéfinis:
­ stdio: entrées/sorties ­ string: chaînes de caractères ­ ...
· La bonne utilisation de ces modules nécessite une directive #include appropriée:
­ #include <stdio.h>

EMSE CMP-GC

181

GENERATION D'APPLICATIONS: l'utilitaire make

Le compilateur C a pour rôle de traduire un programme composé d'un ou de plusieurs fichiers sources C en un programme binaire exécutable
L'utilitaire make facilite la compilation séparée
de modules et va jusqu'à produire l'exécutable

EMSE CMP-GC

182

Commandes simples de compilation:
cc et make

cc source.c -o execut
compile le fichier source.c et génère le fichier exécutable execut

make prog
compile le fichier prog.c et génère le fichier exécutable prog (équivalent à: cc prog.c -o prog)

EMSE CMP-GC

183

LES DIFFERENTES ETAPES D'UNE

COMPILATION

Pour passer d'un fichier source prog.c à un fichier exécutable prog, la compilation se divise schématiquement en deux phases:

cc prog.c -o prog

cc prog.c -o prog

prog.c SOURCE

COMPILATION

prog.o OBJET

bibliothèque standard C

EDITION DE LIEN

prog EXECUTABLE

cc -c prog.c: compile prog.c et génère le fichier objet prog.o
cc prog.o -o prog: fait l'édition de lien de prog.o et génère le fichier exécutable prog

EMSE CMP-GC

184

COMPILATION MULTIPLE

cc triangle.c combi.c -o triangle

triangle.c SOURCES combi.c

cc -c triangle.c: compile triangle.c et génère le fichier objet triangle.o

COMPILATION

triangle.o

combi.o

OBJETS

cc -c combi.c: compile combi.c et génère le fichier objet combi.o
bibliothèque standard C

cc triangle.o combi.o -o triangle: réalise l'édition de liens de triangle.o et combi.o et génère lefichier exécutable triangle

EDITION DE LIEN triangle EXECUTABLE

EMSE CMP-GC
#include <stdio.h>
#include "combi.h"

module triangle

void Triangle(int LIGNES); void AfficheLigne(int P); main() { int N; printf("Introduire le nombre de lignes N : "); scanf("%d", &N); Triangle(N); } void Triangle(int LIGNES) { int P; for (P=0; P<LIGNES; P++) AfficheLigne(P); } void AfficheLigne(int P) { int Q; for (Q=0; Q<=P; Q++) printf("%6.0f",C(P,Q)); printf("\n"); }

185
EXEMPLE
module combi
int C(int P, int Q); int Fact(int N);
#include "combi.h"
int C(int P, int Q) {
return Fact(P)/(Fact(Q)*Fact(P-Q)); }
int Fact(int N) {
int i, factorille; factorille = 1; for(i=2; i<=N; i++)
factorille = factorille * i; return(factorille); }

EMSE CMP-GC

186

L'UTILITAIRE make (description)

Permet de gérer des projets constitués de fichiers sources multiples
Tâches du make:
· Lecture d'un fichier spécial, appelé makefile, créé auparavant
· Comparaison date/heure de modification de chaque fichier objet avec date/heure de modification des fichiers sources et des fichiers d'en-tête (en fonction des listes de dépendances indiquées)
· Recompilation si nécessaire (en cas de modification)
· Comparaison date/heure de modification des fichiers objet avec date/heure de modification du fichier exécutable (en fonction de la liste de dépendances indiquée)
· Edition de liens si nécessaire

EMSE CMP-GC

187

EXEMPLE DE FICHIER makefile

triangle dépend de triangle.o et combi.o
l'édition de liens n'est lancée que si triangle.o ou combi.o ont été modifiés
tabulation obligatoire et non des espaces

# mon premier makefile triangle: triangle.o combi.o
cc triangle.o combi.o -o triangle
triangle.o: triangle.c combi.h cc -c triangle.c
combi.o: combi.c combi.h cc -c combi.c

make triangle génère le fichier exécutable triangle

