Eurographics Symposium on Parallel Graphics and Visualization (2006)
Alan Heirich, Bruno Raf(cid:2)n, and Luis Paulo dos Santos (Editors)

A Scalable, Hybrid Scheme for

Volume Rendering Massive Data Setsy

Hank Childs1;2 Mark Duchaineau1 and Kwan-Liu Ma2

1Lawrence Livermore National Laboratory

2University of California at Davis

Abstract
We introduce a parallel, distributed memory algorithm for volume rendering massive data sets. The algorithm’s
scalability has been demonstrated up to 400 processors, rendering one hundred million unstructured elements
in under one second. The heart of the algorithm is a hybrid approach that parallelizes over both the elements
of the input data and over the pixels of the output image. At each stage of the algorithm, there are strong limits
on how much work each processor performs, ensuring good parallel ef(cid:2)ciency. The algorithm is sample-based.
We present two techniques for calculating the sample points: a 3D rasterization technique and a kernel-based
technique, which trade off between speed and generality. Finally, the algorithm is very (cid:3)exible. It can be deployed
in general purpose visualization tools and can also support diverse mesh types, ranging from structured grids to
curvilinear and unstructured meshes to point clouds.

Categories and Subject Descriptors (according to ACM CCS):
Graphics; I.3.3 [Computer Graphics]: Picture/Image Generation; and I.4.1 [Computer Graphics]: Sampling

I.3.2 [Computer Graphics]: Distributed/Network

1. Introduction
The power and capacity of parallel supercomputers are
growing at a fast pace, enhancing scientists’ ability to simu-
late and study complex physical phenomena at increasingly
greater accuracy. This added accuracy often is the key to ad-
vances in their studies. Their 3D simulations can generate
large volume data sets, which are best visualized using di-
rect volume rendering. Volume rendering is particularly ef-
fective in displaying complex 3D structures and features at
varying scales. Real-time volume rendering has become fea-
sible with commodity graphics hardware, but it requires the
data to (cid:2)t in video memory. Because the size of the data
sets generated by these simulations are currently in the teras-
cale regime, and will soon reach petascale, we must seek a
distributed-memory, parallel rendering solution.

We have developed a new, massively parallel, distributed-
memory, volume rendering algorithm. It is designed to run
on the same parallel supercomputers used to run teras-
cale/petascale simulations. It has demonstrated excellent

y This is UC report UCRL-CONF-218622

c(cid:13) The Eurographics Association 2006.

scalability and been used on some of the largest simula-
tions ever performed. The algorithm can be applied to many
diverse types of meshes, ranging from structured grids to
curvilinear and unstructured meshes to point clouds. It is im-
plemented inside of VisIt [CBB(cid:3)], a richly featured visual-
ization and data analysis application focusing on large data
sets. Throughout the development of this algorithm, a major
goal was to develop a technique that would seamlessly inte-
grate into a general-purpose visualization tool. This required
us to avoid schemes that place special requirements on I/O,
communication, available hardware, etc.

In a distributed memory environment, adaptive techniques
for dividing work among the processors are not possible due
to data ownership issues. In this environment, data must be
partitioned among the processors and each processor is re-
sponsible for calculating its portion of the picture. Of course,
load balancing issues can occur, especially with irregular
data or when camera placement focuses on a small sub-
region of the volume. This requires us to develop data par-
titioning strategies that ensure even workloads on each pro-
cessor. The quality of these strategies dictate the degree of
scalability we can achieve at high processor counts.

Hank Childs, Mark Duchaineau & Kwan-Liu Ma / A Scalable, Hybrid Scheme for Volume Rendering Massive Data Sets

We employ a multi-phase approach for distributing work.
This technique is a hybrid of previous techniques and allows
us to incorporate their best aspects with respect to balanced
processing. During each phase of our algorithm, our data or-
ganization naturally enforces hard limits on how much work
each processor can do. This creates excellent load balancing
which in turn creates excellent scalability.

In this paper, we present the details of our algorithm,
a scaling study, and some applications. Our algorithm is
sample-based, which requires us to implement custom sam-
pling techniques. We present a 3D rasterization technique
and a kernel-based technique, which trade off between speed
and quality, respectively. The scaling study shows linear
scalability of our algorithm up to four hundred processors.
In addition, we present the performance of this algorithm for
diverse mesh types: a one billion-particle point cloud simu-
lation, a 27 billion-element rectilinear mesh simulation, and
a one hundred-forty million element unstructured mesh sim-
ulation.

2. Related Work
Among the parallel rendering algorithms speci(cid:2)cally de-
signed for visualizing irregular-grid volume data, the most
relevant example for this work is the sort-last cell-projection
algorithm introduced by Ma and Crockett [MC97]. This
distributed-memory algorithm achieves high performance by
completely overlapping rendering and compositing, and by
keeping sorting costs to a minimum. However, its high scal-
ability partially relies on manual setting of communication
parameters. The other class of algorithms, those that require
a view-dependent sorting step, are not feasible when render-
ing terascale and petascale data sets.

Wang, Gao and Shen [WGS] use a multi-resolution
wavelet tree to allow parallel volume rendering of large data
in an error-guided fashion. In contrast, our goal is to render
the data at its highest possible resolution.

There is a growing interest in parallel GPU-based volume
rendering [LM, SMW(cid:3), CMF]. Nevertheless, a PC cluster
that is capable of rendering irregular-grid data sets at the
scale we are faced would be prohibitively expensive to build.
Our algorithm is designed to harness the power of parallel
supercomputers. Another option is to utilize geographically
distributed computing resources, which, if appropriately co-
ordinated, could become very attractive. Gao et al. demon-
strated such an approach with parallel rendering of large vol-
ume data distributed over a wide area network [GHJA].

3. Algorithm Overview
The algorithm itself consists of two high-level phases. In the
(cid:2)rst phase, samples are generated from the input data set. In
the second phase, those samples are classi(cid:2)ed and compos-
ited to form the (cid:2)nal picture.

Our goal in the sampling phase, for a given view frus-
tum, is to determine the value of billions of samples along
millions of rays, where there is one ray for each pixel of
the image and thousands of samples along each ray. In ab-
stract terms, a sampling algorithm takes a data set as input,
as well as parameters describing the volume rendering re-
quirements: the view frustum (i.e. camera location, view di-
rection, view angle, and near and far clipping planes), the
screen size (number of pixels in width, W, and height, H),
and the number of samples, S, to take along each ray.

Given these inputs, the goal of a sampling algorithm is to

create an output with the following properties:

1. A logically structured grid, G, of dimensions WxHxS
2. A (cid:2)eld F de(cid:2)ned on G, which has sampled the values of

the input data set

3. Each F[w, h, s] corresponds to the value of sth sample
along the ray corresponding to pixel (w, h) of the output
image for that view frustum

Given a black box that performs a sampling algorithm,
it is trivial to implement an algorithm for the second, com-
positing phase. For each pixel (w, h) and each sample for
that pixel, we can classify the (cid:2)eld value based on some user
de(cid:2)ned transfer function. Then the resulting colors and opac-
ities can be composited using the "over" function (front-to-
back compositing) to create the color for that pixel. Doing
this for all pixels yields the (cid:2)nal, volume rendered picture.

We also note that a sample-based approach makes for easy
integration with renderings of standard geometric primitives.
An additional image input to the compositing module can
specify background colors and prematurely terminate rays
when they reach the depth of the (cid:2)rst encountered geometric
primitive for that pixel. This image is generated on a previ-
ous render pass.

By using samples as our fundamental unit, we have made
sacri(cid:2)ces. We lose the ability to resolve complex interactions
between elements, like the type addressed in [CMSW04].
But, because the samples are calculated on a per view
frustum-basis, this issue is greatly mitigated. It is our belief
that, with a suf(cid:2)cient number of samples per ray and by tak-
ing care in assigning the individual sample values, a sample-
based method can provide good results. This approach of
choosing a representative value for a sample is reminiscent
of the clustering approach presented in [HE03], although at
a different resolution.

4. Hybrid Sampling Algorithm
In the following subsections, we give an overview of the data
management of the hybrid sampling scheme, without con-
sideration of how to infer the values of the sample points.
These subsections address how to organize the data in an
ef(cid:2)cient way for parallelization and how to store the (cid:2)eld
F without exceeding primary memory. The purpose of our

c(cid:13) The Eurographics Association 2006.

Hank Childs, Mark Duchaineau & Kwan-Liu Ma / A Scalable, Hybrid Scheme for Volume Rendering Massive Data Sets

technique is to address the load balancing issues in a dis-
tributed memory environment. In a shared memory environ-
ment, such as the one described in [DPH(cid:3)03], many of these
load balancing issues do not occur because the paralleliza-
tion across image space can be done adaptively.

The principal contribution of our data organization
scheme is obtaining good load balance for meshes with great
variation in the spatial density of their elements. For these
meshes, in the extreme, the number of elements within a re-
gion of space can differ by orders of magnitude. Schemes
that parallelize over the output image’s pixels suffer extreme
load imbalance with these meshes, because some pixels will
cover many more elements within their projection than oth-
ers. Similarly, schemes that parallelize over the input data
set’s elements suffer extreme load imbalance, because some
elements will take up disproportionately large portions of the
view frustum.

Our multi-stage algorithm, presented in the following sub-
sections, is well balanced in the amount of elements and the
portion of the view frustum processed. Our hybrid scheme
utilizes the best portions of schemes that parallelize over the
output’s image and schemes that parallelize over the output’s
elements, while avoiding their pitfalls. It does this by pro-
cessing the data in stages. In the (cid:2)rst stage, it parallelizes
across the elements of the input data set, but defers process-
ing of the large elements. In a subsequent stage, it paral-
lelizes across the output image and only then processes the
large elements. Again, this organization of the data process-
ing places hard limits on the work performed at each stage,
ensuring good parallel ef(cid:2)ciency.

The processing of meshes with great variation in the spa-
tial density of their elements is a very important special
case. The camera transformation often creates meshes of this
form. An example is when the camera is placed in the mid-
dle of the data set, which often happens during (cid:3)y-throughs
in movies. In this case, even if the input mesh has uniform-
sized elements, elements that are near the camera will oc-
cupy orders of magnitude larger portions of the view frustum
than those farther from the camera.

Our sampling algorithm contains a total of three stages,
characterized as Small-Element Sampling, Communication,
and Large-Element Sampling. Also, the algorithm is a dual
partition scheme; one partition is of the input data, the other
partition is of the rays. In the Small-Element Sampling
stage, the (cid:2)rst partition is used. The Communication stage
re-distributes between the two partitions. And the Large-
Element Sampling stage uses the second partition.

Section 4.1 discusses the two partitions, 4.2 discusses the
three phases of the algorithms, and 4.3 discusses the load
balancing.

c(cid:13) The Eurographics Association 2006.

4.1. Partitions

The partition of the input data is done by the greater
VisIt system and is guaranteed to assign approximately
equal numbers of elements to each processor. Although we
might be able to modestly reduce communicate costs by re-
partitioning the data, we do not employ this technique. First,
given the massive size of the data sets we are operating on,
it is not viable to re-partition all of the data for each render-
ing. The only viable re-partitioning scheme would be to re-
partition one time and use that for all subsequent renderings.
However, even if we did perform a one-time re-partition, it
is dif(cid:2)cult to (cid:2)nd one that will truly help with parallel ef(cid:2)-
ciency. It is often not possible to create partitionings that are
balanced in both number of elements and spatial footprint.
Further, this will not mitigate the issue when the camera is
in the middle of the data set.

The second partition is of the samples. We start by divid-
ing the image’s pixels among the processors. The division of
the samples then follows naturally. Our goal with this par-
tition is to re-assign the samples so that each processor can
composite its pixels with no further communication.

4.2. Sampling

We de(cid:2)ne (cid:147)small" elements as elements that cover a small
number of samples, for example less than one hundred. Sim-
ilarly, (cid:147)large" elements are elements that cover more than
one hundred samples. We describe how large elements are
identi(cid:2)ed later in this paper.

In the (cid:2)rst, Small-Element Sampling stage, we sample
each small element and defer sampling of large elements.
This stage has two outputs. One output is the large elements
that are not sampled. The other is the grid G and the par-
tially populated (cid:2)eld F. Because we focus on (cid:147)small" ele-
ments and we know that each processor is working on an
approximately equal sized subset of the elements, we know
that no processor will see a large number of samples. This
reasoning will be further formalized in subsection 4.3. Our
implementation of the structure that stores F is able to scale
its size based on how many samples have been encountered.
Thus, this counteracts the problem where F can exceed the
size of primary memory, because we only have to store the
samples we encounter and we will encounter only a small
number of samples.

The second, Communication stage, re-distributes the out-
put of the (cid:2)rst stage to honor the second partitioning. The
second partition is created dynamically at this point in the
algorithm. By waiting until the (cid:2)rst stage has completed,
we can assign the pixels so that the maximum number of
samples and elements remain on their processor of origin,
minimizing communication. This technique of dynamically
assigning pixels to processors to minimize total communi-
[SFLS00],
cation was also used in the hybrid scheme of

Hank Childs, Mark Duchaineau & Kwan-Liu Ma / A Scalable, Hybrid Scheme for Volume Rendering Massive Data Sets

although their application was to surface rendering, not vol-
ume rendering.

The communication stage consists of "all-to-all" commu-
nications between the processors. Sample points are com-
municated among the processors, using the partition to de-
termine their destination. When sending a large element, we
(cid:2)rst examine its bounding box, and determine which por-
tions of the image space partition the bounding box overlaps.
We then send this element to the set of processors that need
to sample it in the next stage. At the end of this stage each
processor contains all of the data (as either samples or ele-
ments) necessary to create its portion of the image with no
further communication.

Our scheme does not take advantage of the optimization
that allows contiguous samples to be pre-composited, allow-
ing a few bytes to take their place. This optimization is not
well suited to the sampling scheme in Section 6. But the need
for this optimization is greatly mitigated by the high net-
work bandwidth on modern supercomputers. The sampling
stage dominates the algorithm, making this shortcoming a
non-issue.

The third, Large Element Sampling stage samples the re-
maining elements (all of which are "large") and adds them
to the (cid:2)eld F. The large elements are sampled selectively.
Samples outside a processor’s portion of the image space
partition are not examined. If an element spans two portions
of the partition, then the element will be sampled entirely by
the corresponding two processors, but no part of it will be
sampled twice.

At the end of this stage, all elements have been sampled
and the (cid:2)eld F is fully populated. This is the output of our
sampling algorithm, which is now well suited for composit-
ing. Even though F is distributed across the processors, each
ray has all of its samples on the same processor. So com-
positing can take place with the only necessary communi-
cation being the collection of the pixel colors to the master
processor at the end of the algorithm. The entire pipeline can
be seen in Figure 1.

Figure 1: The volume rendering portion of the pipeline.

4.3. Load Balancing

Our goal is to maximize parallel ef(cid:2)ciency. In this subsec-
tion, we motivate how our three-stage approach, outlined in
the last subsection, helps to accomplish this goal.

Before we analyze the costs of each stage, consider the
cost of doing sampling, whether it is in the (cid:2)rst or third stage.
When sampling E elements, there is an overhead with the
processing of each individual element. And there is also a
cost for each of the Si sample points updated when process-
ing element Ei. If S=(cid:229)Si, then the overhead for processing
the elements is O(S + E).

How much work takes place in the (cid:2)rst stage? Because we
do not process large elements, we can easily bound this num-
ber. We do not process any elements that contain more than a
constant number of samples, a. So the work in the (cid:2)rst stage
is O(S + E) = O(a*E + E) = O(E). Of course, asymptotic
analysis can be misleading. In this case, however, it gives
us an actual result. There are strict limits on the amount of
sampling work for each processor. In addition, by modify-
ing a, we can control the amount of allowed discrepancy in
work between the processors. Note that choices of a that are
too small, however, cause a large number of elements to be
communicated, which affects performance in the next stage.

How much work takes place in the second stage? First,
consider the cost of sending a large element. When com-
municating a large element, the many samples it covers are
not being communicated. If our constant, a, is large enough,
then the cost to communicate large elements will always be
less than the cost to communicate its samples. Following this
logic, the most communication the algorithm can undergo is
when communicating only samples. Although this number
can be quite large, the bound on the amount of data commu-
nicated is a nice property in the context of extremely massive
data sets, like the 27 billion-element simulation we discuss
in the performance section.

The only work done in the third stage is the sampling of
large elements. In this stage, each processor is only respon-
sible for a limited number of samples (cid:150) those that are con-
tained within its portion of the view frustum. This bounds
how much sampling work can be performed. In addition,
each element in this stage is "large" and covers many sam-
ples. So the number of elements (E) will be much less than
the number of samples (S): E < S=a. So, in this stage, the
amount of work per processor is also bounded: O(E+S) =
O(S=a + S) = O(S).

Summarizing, for all three stages, the amount of work
per stage is bounded. In addition, most processors approach
these bounds, leading to good parallel ef(cid:2)ciency. Of course,
degenerate cases exist where some processors will be at their
theoretical bounds while other processors spin idly. In prac-
tice, however, the amount of work per processor is relatively
even.

c(cid:13) The Eurographics Association 2006.

Hank Childs, Mark Duchaineau & Kwan-Liu Ma / A Scalable, Hybrid Scheme for Volume Rendering Massive Data Sets

5. 3D Rasterization
The 3D Rasterization algorithm described in this section is
an example of a sampling algorithm from section 3. It is sim-
ilar in spirit to the 2D Rasterization algorithms employed
by graphics hardware. The key difference, of course, is that
the rasterization occurs in three dimensions (over a volume),
rather than two (over an image). This technique is highly re-
lated to the method described in [YRL(cid:3)96].

The rasterization algorithm simply operates on each ele-
ment, one at a time, updating F as it goes. For each element
E, the resampler works as follows:

1. Transform E’s coordinates from world space to screen

space

2. Calculate E’s bounding box in screen space
3. If we are deferring large elements and the bounding box
of E covers too many samples, add E to the output and
continue to the next element

4. Determine the set of integer depths, { Di }, that overlap

between E and and the output grid G

5. For each Di, slice E by Di, resulting in polygonsy
6. For each slice, employ a standard rasterization technique
on the resulting polygons, updating the portion of the
(cid:2)eld F corresponding to Di.
For clarity, consider the following example for a single

element:

The (cid:2)rst step is to transform the element to screen space
(de(cid:2)ned over Width, Height, and Depth axes). Assume the
result is a tetrahedron, T, with points (8.5, 6.5, 4.2), (12.5,
6.5, 4.2), (10.5, 11.1, 4.2) and (10.5, 7.5, 6.8). The second
step would be to calculate its bounding box: [8.5-12.5, 6.5-
11.1, 4.2-6.8]. In the third step, we determine the bounding
box that the element can contain no more than 40 (4 (cid:2)5 (cid:2)2)
samples, so this element is not "large". Then we proceed to
step 4 and determine the integer depths that overlap between
T and G: 5 and 6 (see (cid:2)gure 2).

Figure 2: Tetrahedron T, rendered transparently in cyan.
Slice D=5 is gray, D=6 is black.

We would then slice T by D=5 (see (cid:2)gure 3). This slice

y Curvilinear meshes can technically give curved polygons. We ap-
proximate these with linear polygons, similar to techniques used for
isocontouring.

c(cid:13) The Eurographics Association 2006.

results in a triangle. We then employ a standard rasteriza-
tion technique to the triangle. We would start by rasterizing
along Heights 7, 8, and 9. For Height=7, we (cid:2)nd samples at
Width=10 and Width=11. Height=8 also yields samples at
10 and 11. Height=9 yields no samples. The entire slice at
D=6 also yields no samples. In all, tetrahedron T yields 4
samples. These samples are then placed into F.

Figure 3: Slice at D=5 (left) and D=6 (right)

The 3D rasterization algorithm has many positive traits.
First, for each element, it is possible to immediately deter-
mine which samples overlap. It is not necessary to trace rays
to discover the list of cells along that ray. Second, unlike
a standard projection scheme, the ordering of the resulting
samples is preserved by the (cid:2)eld F and the grid G. Third,
this scheme is fairly general. It can accommodate struc-
tured grids, and curvilinear and unstructured meshes (but
not point clouds). For unstructured meshes, it can accommo-
date the complete (cid:2)nite element zoo and virtually any addi-
tional element type. It can operate on multiple (cid:2)elds, allow-
ing for multi-variate volume renderings. Fields can be either
element-centered (i.e. piecewise constant) or node-centered.
All of these options are incorporated into our implementa-
tion.

There are also negative aspects to the rasterization
scheme. First, the technique for sampling is prone to missing
data. If an element does not overlap with a sample point then
that element is not re(cid:3)ected in the resampling. This is a com-
mon case for extremely small elements and more discussion
can be found in [MWSC03]. We overcome this problem by
having small elements locate the nearest sample point and
attempt to affect its value. This can lead to two or more ele-
ments trying to affect the same sample. In this case, we use
an arbitrator that chooses the "best" sample, where "best" is
chosen to be the one with the highest opacity. The second
problem with this scheme is less serious. The method of ex-
amining an element’s bounding box to estimate the number
of samples it contains can lead to overestimates. We do not
attempt to correct this problem, because it does not lead to
appreciable performance degradation.

6. Kernel-Based Sampling
Our Kernel-Based Sampling algorithm is designed to have
each data point in(cid:3)uence a region around it. This is a natural
operation with element-centered variables. The data point is

Hank Childs, Mark Duchaineau & Kwan-Liu Ma / A Scalable, Hybrid Scheme for Volume Rendering Massive Data Sets

placed at the middle of an element and its region is guided
by its bounding box. For nodal variables, each node’s neigh-
boring elements must be examined to determine the correct
size for its sampling region. In our current implementation,
we operate only on element-centered variables, and we re-
center nodal variables.

The procedure to process an element E with variable value

V is:
1. Transform E’s coordinates from world space to screen

space

2. Calculate E’s bounding box in screen space
3. If we are deferring large elements and the bounding box
of E covers too many samples, add E to the output and
continue to the next element

4. Calculate a maximum radius of in(cid:3)uence for E, Rmax(E)
5. For every sample within Rmax(E) of E’s center, update

the (cid:2)eld F with V and a weight w
The size of the kernel, Rmax(E), is based on the size of
the element, allowing larger elements to have greater impact
than smaller elements. Rmax(E) is assigned to be (cid:2)fty per-
cent bigger than the distance from the center of the element’s
bounding box to one corner of the bounding box. However,
for small elements, Rmax(E) can be so small that it will not
affect any samples. To counteract this, we never let Rmax(e)
drop below the global constant, Rmin. Rmin is chosen so that
even the smallest element will affect at least one sample.

The weights, w, vary based on the distance to the element
center. Samples closest to the element center should strongly
re(cid:3)ect the element’s value. Moving away from the element
center should allow for more blending with the neighboring
element values. So we set the weight to be inversely propor-
tional to the distance to the center of the element.

The formula for weight, w, is:
w =

(Dp+e) - w0, where

1

Dp = proportional distance to center of element
and e and w0 are shape factors
For each sample, Dp = Ds

Rmax , where Ds is the distance from
the sample to the center of the element. The e term eliminates
division by zero, and determines the peak contribution an el-
ement can make, which occurs when the element center and
a sample are coincident. When the distance from a sample to
the element center is Rmax, Dp is one. Since we would like
the weight to be zero at the maximum radius, we introduce
our second shape factor, w0, and set it to

1

(1+e) .

Our (cid:229)Wi term also plays an important role in establishing
the boundary of the data set. Each data point is sampled onto
the region around it, regardless of the samples actual mem-
bership in the data set. Samples outside the boundary will
have low (cid:229)Wi values. Reducing the opacity of these sam-
ples effectively creates the boundary in an anti-aliased way.
Note that this is similar to the strategy applied in [PH89],
although we do this correctly in the post-transformed space,
where [PH89] did this in the pre-transformed space.

Figure 4: On the left, an element’s (red circle) sampling re-
gion (dotted circle) includes samples outside the data set
boundary (marked with the four-way arrow). These samples
will be updated with the element’s value, but they will not
affect the (cid:2)nal picture because their (cid:229)Wi will be low. On the
right, we see how each of the samples inside the data set are
affected by many elements, giving higher (cid:229)Wi, while those
outside the data set are affected by fewer elements.

The Kernel-Based Sampling algorithm also has many pos-
itive traits. First, like the 3D Rasterization algorithm, ele-
ments can be sampled independently and ef(cid:2)ciently. The or-
dering of the resulting samples are preserved by using the
(cid:2)eld F and the grid G. Second, this scheme is also very gen-
eral. In addition to handling all mesh-based data sets, this
scheme is ideal for rendering point clouds. Third, unlike the
3D Rasterization algorithm, this technique consistently pro-
duces high-quality pictures and more accurately represents
the entire input, including small elements.

There are also negative aspects to this scheme. First, el-
ement shapes are completely disregarded in the current im-
plementation. Samples are updated based entirely on the el-
ement’s Rmax. In the common case for large scale data, how-
ever, an element is projected to only a few samples and this is
inconsequential. Second, this algorithm processes the same
sample multiple times, one for each of the nearby elements.
This contrasts with the 3D rasterization algorithm, which
only operates on a given sample one time. This results, of
course, in higher running time.

Once each element has updated the samples, we assign the
(cid:2)nal sample value to be the weighted average. Formally, if
elements Ei update a speci(cid:2)c sample with their values Vi and
weights Wi, then the (cid:2)nal value of the sample will be (cid:229)Wi(cid:3)Vi
.
(cid:229)Wi
Also, note that this calculation does not require storing all
encountered samples. Instead, running totals can be kept for
(cid:229)Wi (cid:3)Vi and (cid:229)Wi, minimizing storage overhead.

7. Scalability
We now present the scalability of the algorithm. We per-
formed the study on a 100 million element unstructured
mesh and a 1024x1024 image with 1000 samples in depth.
For each processor count, we measured the elapsed render-
ing time with multiple options. One option was the sampling

c(cid:13) The Eurographics Association 2006.

Hank Childs, Mark Duchaineau & Kwan-Liu Ma / A Scalable, Hybrid Scheme for Volume Rendering Massive Data Sets

algorithm to use: 3D rasterization or Kernel-based. The other
option was whether the camera was located inside or outside
the data set. Table 1 shows the results.

Although we feel the algorithm has excellent scalability
in this regime of processor count, we foresee some limita-
tions as processor counts get larger. The time to create the
(cid:2)nal output image, including collecting portions from other
processors and transferring the image from the server to the
client for display, takes one tenth of a second. When more
processors are used, this constant will begin to affect scala-
bility. We do believe, however, that this algorithm will still
be effective with larger processor counts, but as a weakly
scalable algorithm. We believe the frame rate can never fall
below some constant (minimally 0.1 seconds), but, given
more and more processors, we feel that proportionally more
data can be rendered in the same amount of time.

The timings were run on gauss, a 512-processor cluster
of 2.4GHz Opterons connected by an In(cid:2)niBand network.
Gauss is currently #409 on the Top500 listing of SuperCom-
puters. For the timings, the algorithm was embedded in VisIt,
rather than run as a stand-alone application. We disabled the
mode that incorporates geometric primitives (for bounding
boxes and other annotations), however, because delays that
mode introduces are unrelated to our algorithm.

arise in response to the shock passage. The transfer function
was chosen to reveal these structures (seen toward the left
of the image as cross-hatch like patterns), as well as the un-
shocked, lower-density (cid:2)lament structure to the right (with
the red outlines).

Given there is no mesh structure for MD simulations, the
kernel-based resampling is the only choice for applying vol-
ume rendering. For solid mechanics problems like this, there
is a fairly tight distribution of inter-atomic spacings (distance
to nearest neighbor). Typically, it is appropriate to set the
resample kernel radius to be a factor of 1.5-3 times the av-
erage inter-atomic spacing, depending on whether views of
(cid:2)ne void structures or smoother averaging is desired for the
application analysis.

We visualized this data set using 256 processors. For
smaller images (400x400), each rendering takes about 8 sec-
onds. For large images (1024x1024), it takes 30 seconds.

3D Raster-

ization/
outside
12.0s
5.8s
3.0s
1.6s
0.9s

Procs

25
50
100
200
400

3D Raster- Kernel- Kernel-
Based/
inside
63.7s
30.5s
15.3s
7.6s
4.1s

ization/
inside
21.9s
12.1s
7.0s
3.6s
2.1s

Based/
outside
12.1s
5.8s
3.1s
1.3s
0.7s

Table 1: Our algorithm was strongly scalable in all of the
con(cid:2)gurations we tested.

8. Results
8.1. Shock Propagation in Nano-Porous Metal
Classical Molecular Dynamics (MD) simulations are a com-
mon means to study material properties at the fundamen-
tal level of individual atoms, including such phenomena as
plasticity, ductile failure, brittle failure, material response to
ion or micro-meteorite impacts, laser ablation and more. The
simulation we use for test purposes involved 1,013,455,626
(over a billion) atoms resulting from the study of shock wave
propagation through a metallic foam. In this case, the shock
was introduced in a high density region to the left of Fig-
ure 5, and has traveled partway through the porous solid,
which was set up to gradually decrease in density as the
shock travels to the right of the material sample. A typical
variable of interest is the local energy potential of each atom,
which can reveal dislocation and slip-plane structures that

c(cid:13) The Eurographics Association 2006.

Figure 5: A volume rendering of over a billion atoms, ren-
dered using the kernel-based resampling method. The simu-
lation was produced by Farid Abraham of LLNL on 8000
processors of the ASC Purple supercomputer. A shock is
traveling from left to right through the metallic foam, which
was designed to gradually change from high to low density
during the shock front propagation. The cross-hatch patterns
on the left show the emergence of plasticity due to disloca-
tions, while the undisturbed (cid:2)lament structure is highlighted
on the right.

8.2. Rayleigh-Taylor Instability
We next applied our algorithm to a 27 billion element recti-
linear grid simulation of a Rayleigh-Taylor Instability, where
heavy and light (cid:3)uids mix. This calculation was done on
the BG/L Supercomputer by the MIRANDA code. We used
256 processorsz and each 1Kx1K image took 3.8 seconds
to render (see (cid:2)gure 6). This data set highlights one of the
problems with our 3D rasterization scheme. When using one
thousand samples per ray, the 3D rasterization scheme can-
not represent all of the data, since there are so many more
elements than sample points.

z Machine unavailability forced us to use this smaller number of
processors.

Hank Childs, Mark Duchaineau & Kwan-Liu Ma / A Scalable, Hybrid Scheme for Volume Rendering Massive Data Sets

For rectilinear grids, our 3D rasterization scheme has been
optimized to ef(cid:2)ciently (cid:2)nd elements that overlap with sam-
ples. The purpose for transforming individual elements from
world space to screen space is to quickly identify the samples
an elements overlaps with. For rectilinear grids, this tech-
nique is not necessary, as the location of a sample point can
be directly and ef(cid:2)ciently calculated. As such, we revert to
a simpli(cid:2)ed sampling scheme for rectilinear grids that does
not transform individual elements to screen space. With this
optimization, voxels that do not overlap with samples are ig-
nored. In effect, this makes it a scheme that is indifferent to
data set size. For any size rectilinear grid, the exact same
amount of work is performed. When rendering a 1 billion el-
ement rectilinear grid, with the same number of processors,
the rendering rate improved by a factor of 2.5. We attribute
this unexpected speedup to paging through memory.

When we switched to the kernel-based sampling scheme,
performance dropped considerably because every element
had to be traversed. In this mode, it took 45 seconds to gen-
erate a picture. Because of the nature of the data set, (smooth
features that span many elements), differences between the
two pictures were not signi(cid:2)cant.

Figure 6: The mixing layer between heavy and light (cid:3)uids.
We are rendering based on vertical velocity. Yellow volumes
are moving up, purple volumes are moving down.

8.3. Blast Calculation

Our next calculation simulated an explosive blast wave as it
passed over a section of a wall consisting of reinforced con-
crete. It was calculated using the ALE3D simulation code
with Arbitrary Lagrange-Eulerian (ALE) methods on a 3D
unstructured hexahedral mesh. For this study, we subdivided
each hexahedron into (cid:2)ve tetrahedrons, for a total of 138
million, to produce an unstructured mesh with an element
count that would stress our algorithm. Because some sur-
faces were so thin, even the kernel-based sampler had prob-
lems properly re(cid:3)ecting the data. The averaging of values
within a sample’s region led to smearing. We increased the

samples per ray to 2000, which obviously led to a degrada-
tion in performance. We used only 128 processors and were
able to render a 1Kx1K frame every 35 seconds (see (cid:2)g-
ure 7). Considering we were operating on a larger data set
and had twice as many samples, this is consistent with the
scaling study we performed earlier.

Figure 7: An explosive driven blast wave passing over a
round section of reinforced concrete (1/4 symmetry)

9. Future Work
There are many performance improvements that can be
made to our algorithm. We did not partially composite sam-
ples before sending them, because a sample’s value with
the kernel-based technique can not be determined until all
of the surrounding elements have made their contribution.
We believe that, despite this issue, we can proceed with this
optimization on a restricted basis by determining situations
where samples have received their full contribution and al-
lowing those samples to be partially composited. Another
option would be to apply compression algorithms on the
samples themselves before communication. In addition, we
could further reduce communication by changing the way
we partition the image volume. We currently partition over
the pixels, which leads to long shafts in depth. An alternative
would be to create cubes by dividing the volume in depth as
well. This would increase the volume to surface area ratio,
minimizing the number of times a large element is mapped to
multiple processors. We have experimented with implemen-
tations like this, but decided not to present this scheme, be-
cause the extra steps to composite the samples would further
complicate the overall algorithm. Finally, we have consid-
ered accelerating the sampling phases by using 3D graphics

c(cid:13) The Eurographics Association 2006.

Hank Childs, Mark Duchaineau & Kwan-Liu Ma / A Scalable, Hybrid Scheme for Volume Rendering Massive Data Sets

hardware. Of course, this approach would only be viable on
clusters where graphics hardware is available.

pipelined implementation. In Proc. of Visualization 2005
Conference. 2

There are also opportunities for improvements in picture
quality. We currently have no lighting model, and we would
bene(cid:2)t from incorporating pre-integration techniques.

10. Conclusions
We have presented an algorithm that allows massive data sets
to be volume rendered at interactive speeds, given adequate
computing resources. The algorithm is sample-based, and
the overhead for processing the samples is high. As a result,
this algorithm would be a poor choice for volume rendering
small data sets with low compute power, because a dispro-
portionate amount of time is spent calculating the values of
the samples. But, again, the algorithm is ideal for massive
data sets and we have demonstrated good performance on
some of the largest data sets ever simulated.

We caution the reader against characterizing this algo-
rithm as a brute-force algorithm applied on a large machine
to achieve a result. When scaling up to large numbers of pro-
cessors, the dif(cid:2)culty comes in maintaining good parallel ef-
(cid:2)ciency. We are able to do this elegantly with our hybrid ap-
proach. By splitting processing into small and large element
sampling phases, the work performed in each phase cannot
exceed known bounds. These bounds guarantee that no pro-
cessor is tasked with a disproportionate amount of work to
perform while other processors spin idly. This hybrid algo-
rithm is the principal contribution of this paper. In addition,
we have introduced some sampling schemes that are well
suited for this general approach and allow for either quick or
accurate sampling.

11. Acknowledgments
VisIt has been developed by B-Division of Lawrence Liv-
ermore National Laboratory and the Advanced Simulation
and Computing Program (ASC). This work was performed
under the auspices of the U.S Department of Energy by Uni-
versity of California Lawrence Livermore National Labora-
tory under contract No. W-7405-Eng-48. Lawrence Liver-
more National Laboratory, P.O. Box 808, L-159, Livermore,
Ca, 94551 In addition, the contributions of Kwan-Liu Ma
have been sponsored in part by the U.S. National Science
Foundation under contracts CCF 9983641, CCF 0222991,
OCI 0325934, and IIS 0552334.

References
[CBB(cid:3)] CHILDS H., BRUGGER E., BONNELL K.,
MEREDITH J., MILLER M., WHITLOCK B., MAX N.:
A contract based system for large data visualization. In
Proc. of Visualization 2005 Conference. 1

[CMF] CAVIN X., MION C., FILBOIS A.: Cots cluster-
based sort-last rendering: Performance evaluation and

c(cid:13) The Eurographics Association 2006.

[CMSW04] COOK R., MAX N., SILVA C., WILLIAMS
P.: Image-space visibility ordering for cell project volume
rendering of unstructured data. IEEE Transactions on Vi-
sualization and Computer Graphics 10, 6 (Nov. 2004),
695(cid:150)707. 2

[DPH(cid:3)03] DEMARLE D., PARKER S., HARTNER M.,
GRIBBLE C., HANSEN C.: Distributed interactive ray
tracing for large volume visualization. In In Proceedings
of the Symposium on Parallel and Large-Data Visualiza-
tion and Graphics (2003), pp. 87(cid:150)94. 3

[GHJA] GAO J., HUANG J., JOHNSON C. R., ATCHLEY
S.: Distributed data management for large volume visual-
ization. In Proc. of Visualization 2005 Conference. 2

[HE03] HOPF M., ERTL T.: Hierarchical splatting of scat-
In Proc. of Visualization 2003 Conference

tered data.
(2003), pp. 443(cid:150)440. 2

[LM] LUM E., MA K.-L.: Hardware-accelerated paral-
lel non-photorealistic volume rendering. In Proc. NPAR
2002. 2

[MC97] MA K.-L., CROCKETT T.: A scalable paral-
lel cell-projection volume rendering algorithm for 3d un-
structured data.
In Proc. 1997 Symposium on Parallel
Rendering (1997), pp. 95(cid:150)104. 2

[MWSC03] MAX N., WILLIAMS P., SILVA C., COOK
R.: Volume rendering for curvilinear and unstructured
grids. In Computer Graphics International (2003), p. 210.
5

[PH89] PERLEN K., HOFFERT E.: Hypertexture. Com-

puter Graphics 23, 3 (July 1989), 253(cid:150)261. 6

[SFLS00] SAMANTA R., FUNKHOUSER T., LI K.,
SINGH J. P.: Hybrid sort-(cid:2)rst and sort-last parallel ren-
dering with a cluster of pcs. In 2000 SIGGRAPH / Euro-
graphics Workshop on Graphics Hardware (Aug. 2000),
pp. 97(cid:150)108. 3

[SMW(cid:3)] STRENGERT M., MAGALLON M., WEISKOPF
D., GUTHE S., ERTL T.: Hierarchical visualization and
compression of large volume datasets using gpu clusters.
In Proc. Eurographics/ACM SIGGRAPH Parallel Graph-
ics and Visualization 2004. 2

[WGS] WANG C., GAO J., SHEN H.-W.: Parallel mul-
tiresolution volume rendering of large data sets with error-
guided load balancing. In Proc. Eurographics/ACM SIG-
GRAPH Parallel Graphics and Visualization 2004. 2

[YRL(cid:3)96] YAGEL R., REED D. M., LAW A., SHIH P.,
SHAREEF N.: Hardware assisted volume rendering of un-
structured grids by incremental slicing.
In Proceedings
1996 Symposium on Volume Visualization (1996), pp. 55(cid:150)
62. 5

