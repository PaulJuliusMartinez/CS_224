A radical computer architecture implernenting a programming language and a timeshared operating system directly in hardware, Symbol remains a valuable lesson in buildling complex systems.

RR@f09eft07mffnnfbtith~NOhf4t7W$M@?

LWnguwj fl

David R. Ditzel Bell Laboratories

One of the most radical computer architectures of the last decade was the Symbol"g2 computer system, unveiled in 1971. The primary goal of the Symbol research project was to demonstrate with a full-scale working computer that a procedural general-purpose programming language and a large portion of a timeshared operating system could be implemented directly in hardware, resulting in a marked improvement in computational rates.3 Another goal was to show that such a task could be carried out by a relative-
ly small group of people in a reasonable amount of time by using appropriate design tools and construction techniques. Some features commonly provided by software were implemented directly in Symbol's hardware with sequential logic networks. These included
* Hardware compilation, * Text editing, * Timesharing supervision, * Virtual memory management, * Dynamic memory allocation, * Dynamic memory reclamation, * Dynamically variable field lengths, * Dynamically variable sized structures, * Automatic data type conversion, and * Precision controlled arithmetic processing.
The announcement and initial papers on the Symbol system occurred before the system was fully operational, as it was being moved to Iowa State University for final debugging, evaluation, and use. This article offers some parting thoughts on Symbol, based on the observations of the author and others during the last four years of its use. Evaluating Symbol turned out to be remarkably difficult for technical and administrative reasons. Part of the problem was that Symbol was so radically different from traditional computers that a controlled comparison was practically infeasible. In defense of the original designers,

however, the reader should be reminded that Symbol was intended to be a learning device rather than a commercially viable product.
Historical background. As early as 1964, a group of engineers at Fairchild's research facility in Palo Alto, California, decided that the future of VLSI technology dictated the use of hardware for traditional software functions. They also believed that existing programming languages had been influenced too heavily by the underlying hardware and that valuable programmer time was unnecessarily being spent performing functions such as memory management because of unreasonable computer architectures. A high-level language computer was seen as a way to reduce rising software costs.
Though Symbol was an experimental machine, the project was taken seriously. From the beginning there was a strong commitment to build a real and functional
system. Considerable effort was spent on techniology,
packaging, and computer-aided design tools. A new highspeed logic family, complimentary transistor logic, was developed along with the dual in-line integrated circuit package, now the industry standard. A substantial com-
puter-aided design system4'5 was written to do simulation,
placement, and wire routing, check timing and loading, and maintain a system for documenting the circuitry of more than 20,000 packages.
An initial decision was to implement Symbol entirely in hardware, primarily as an experiment to probe the limits
of the hardware/software interface. A top-down design was started with the user, the programming language, and the operating system foremost in mind. Before any hardware was constructed, a design was completed for a new
programming language, operating system, and user terminal interface. A high-level instruction set was then

July 1981

0018-9162/81/0700-0055$00.75 (L 1981 IEEE

55

designed, using multiple processors to support it and the SPL also has ON blocks, similar in many ways to ON

operating system. These processors were implemented ac- blocks in PL/I.

cording to the initial system design. Symbol remains one Many features of the Symbol architecture are a direct

of the prime examples of a completely top-down ap- result of supporting the unusual requirements imposed by

proach to computer system design.

SPL. For example, the statement

At the time that the fabrication of Symbol was com-

pleted and debugging began, the semiconductor industry

A -This is a strings;

was in a recession. A managerial decision was made not to

continue the project through a second, more commercial- may require that new storage be allocated for the variable

ly viable design that Iowa State University was to have A. The statement

received for evaluation. Instead, Iowa State University

obtained the original machine from Fairchild in 1971,

A-5 + 1;

through a grant from the National Science Foundation,

for the purpose of bringing the machine to full operation would then change the internal type of A to numeric,

so that the unique ideas of the architecture could be more though this would be of no concern to the user. Even fur-

fully documented and evaluated. The machine was brought ther, the statement

into useful operation by 1973. Work on the system soft-

ware and hardware was done by a group of about six peo-

A[500]-<1 1213>;

ple, mainly graduate students. Funding for the project

terminated in 1978. Shortly afterwards, hardware failures would change A from a scalar numeric into a structure

forced the machine to be permanently decommissioned. with 499 null elements and a 500th element that was

another structure with the three scalar elements 1, 2, and

3. Finally, the memory allocated for this large data struc-

Symbol Programming Language

ture would be automatically reclaimed if the user were to reassign it to have the value of a simple scalar. All of the

memory management, internal structure representation, Part of the initial motivation for Symbol was the belief and type information is handled automatically by Symthat existing programming languages had been unduly in- bol's hardware. fluenced by architectures not designed to support high- SPL turned out to be both a blessing and a curse. While

level languages. Therefore, a new language was designed the language was simple to learn and easy to use, it was

which was free of these machine artifacts. The Symbol difficult to convince people to convert to it. SPL also mis-

Programming Language, or SPL, was designed to be con- judged the trend toward more strongly typed languages.

cise, yet powerful, in keeping with the mainstream of The computing science community seemed to consider a

general-purpose procedural languages. In many ways, language "without declarations" as a heresy. On the

SPL can be viewed as a mixture of APL, Algol, and Lisp. other hand, programmers generally found SPL delight-

All of the features of SPL contribute directly to program ful, with its minor inadequacies leaving them room to

execution rather than to easing compilation or memory propose language extensions.10-13 Among SPL's more

management. Because the instruction set and architecture memorable features were its treatment of strings as firstof Symbol are so directly tied to the language it im- class objects, its ability to explicitly represent structures, plements, the reader may wish to consult one of the many and its powerful string operators, such as MASK and FOR-

descriptions of SPL3,6-9 for further details.

MAT.'4 However, much of SPL's power was not used in

SPL was designed for processing character-oriented typical programs. Structures rarely needed to be totally

data that could be dypamically variable in type, shape, heterogeneous. Arbitrary precision arithmetic was used

and size. Rigid type and size declarations were omitted mainly to present (admittedly) biased demonstrations of

from the language since they were seen to burden the user. one of the few things Symbol was faster at than most comConversions and space management are handled auto- puters. Call-by-name was perhaps too powerful.

matically by Symbol's hardware. Data objects in SPL are

either scalars-that is, a sequence of characters that may happen to fit the definition of a number, boolean, or

Symbol system architecture

string-or structures whose elements are scalars or other

structures. Structures are explicitly representable in the The Symbol computer system is composed of eight

language and may be of any shape representable by a tree. relatively autonomous processors the translator, the

Procedures pass parameters via call-by-name, also known central processor, the system supervisor, the input/out-

as call-by-substitution. Storage for all variables is not put processor, the memory reclaimer, the memory con-

allocated automatically upon procedure entry; instead, troller, the channel controller, and the drum controller.

storage is allocated for each variable on demand and re- These processors and the major data paths are shown in

tained upon procedure exit, as with static variables. Figure 1. Scoping rules are such that a variable is known only local- The translator15'16 is a hardware-implemented com-

ly, unless explicitly declared to be global. Control flow is piler, assembler, linker, and loader that generates an in-

accomplished with IF-THEN-ELSE-END statements and ternally executable representation of the user's source

GOTOs. Though originally proposed, no looping con- program. The execution of this internal instruction set is

structs were provided due to implementation complexity. controlled by the central processor, 17 which is composed

56 COMPUTER

of four subprocessors. The instruction sequencer is responsible for fetching instructions, executing some directly and delegating the rest to another subprocessor. The arithmetic processor'8 performs traditional arithmetic operations with precision-controlled decimal arith-

chical levels. At the lowest level, a core memory and a rotating magnetic drum constitute physical memory. Next is a paged virtual storage system consisting of 224 64-bit words, of which 4096 2K-byte pages were implemented. The memory controller, with a set of high-level memory

nmetic. The format processorl9handlescharacter-oriented operations as well as the packing and unpacking of
numbers. Lastly, the reference processor controls all scalar and structure identifier referencing.
The rest of the processors handle in hardware many functions typically found in a software operating system. The system supervisor oversees the entire system, sched-

operations, maps virtual storage on to "logical stor-
age.,20,21 The other processors can request memory only
through the memory controller with these "logical memory operations." At the highest machine level are the CPU instructions which operate on the user data structures. The user is never aware of these levels because his only interface to the machine is with the high-level SPL.

uling the memory reclaimer, input/output processor,

translator, and central processor. Page replacement for virtual memory is also handled by the system supervisor.

Symbol instruction set

The channel controller provides communication from

user terminals to the system's core I/O buffers. The in- Although the high-level SPL was implemented without

put/output processor is responsible for transferring in- software, Symbol does not execute the source program

formation between these buffers and virtual memory. In directly. Instead, much like other computers, Symbol has

addition, the input/output processor contains a hard- an internal instruction set. Unlike most computers,

wired text editor, driven from a special editing keyboard. however, the instruction set is non-von Neumann and at a

One of the more unusual aspects of Symbol is that the memory structure is not organized as a contiguous set of sequentially organized storage cells. Instead, storage is viewed by most of the processors as a limitless supply of variable-length storage strings, whose storage cells (machine words) are logically sequential but not necessarily consecutively addressed in memory. Implementation of the Symbol memory structure consists of four hierar-

very high level, with almost a one-to-one mapping between tokens in the source code and instructions in the ob-
ject code.22 A program consists of three parts: a sequence
of instructions called the object string; a set of descriptors for each procedure called name tables; and variable storage. Symbol is a stack machine. Instructions are ordered in reverse Polish notation and make use of an expression evaluation stack.

July 1981

57

Table 1. Symbol instruction set.*

89 0 INPUT BLOCKt

1 OUTPUT
2 DISABLE
3 ENABLE

4

5 GOTO

6 PAUSE 7 R7ERTUERTNURN SSYYSSTTEEMM

8 BEFORE LIMITED

9 | SAME9 SAME AABBSS

A AFTER

LTE

B NOT

GTE

A TO DATA STRING EXACT EMPIRICAL
* +

BC

D

E

NAMEt

FROM RECLAIM

TABLE

GROUP

POINTER

LINK TO SIMPLE VARIABLE

ASSIGN
GROUP
(NSERT
GROUP

LINK TO STRUCTURE

FETCH TERMINAL HEADER

LINK TO LABEL

FETCH AND FOLLOW

DIRECTt PARAMETER

LINK TO DATA IN NAME TABLE

IF FALSEt FETCH
THEN JUP REVERSE

INDIRECTt PARAMETER

LINK TO UNRESOLVED SUBSRIP

FOLLOW

AND

FETCH

~~~~~~ENDFETCH

BLOCK

DIRECT

TRANSFERt

LINK TO TEMPORARY
DATA

STORE PARAMETER

LINK TO

IN AN D

STRUCTURE

ASSIGN

REUNFIELD

~S~T~OR~~E~~~~~~OPSOONIULNRTYCEER

STIONRSEERATND IINNTEEGEERIIZEE

FILEILNDK T(ION)

STATEENMDENT DSITROERCET

NEGATE STRULCITNUKRTEO(IN)

F NUMERIC
++
NUMERIC
+-
NUMERIC
-+
NUMERIC --
NUMERIC TRUE ZERO STRING START
STRING END

C AN

LESS

LIMIT TDOELEENTDE

MFIAERLKD SUBSLITNRKUCTOTURE VBEECGTIONR

D OR D OR NNEEDQ
E JOIN GREATER

F MASK

-

-- EGQUAL ~D~~E~L~E~T~E~STRINSGUBPSECRRFIOPRTMION

STRBUECGITNURE

FORMAT

DELETE PAGE LIST

LINK TO DATA IN N. T. (IN)

END VECTOR

STORE

END

/ INTERRUPT TEHRMINEAL ADERSTUUSTRURCTURE

IRequires address field. *Reprinted from Program Measurements on a High-Level Language Computer by David R. Ditzel. Computer, Vol. 13. No. 8. Aug. 1980. p 64. 1980 IEEE.

Table 1 shows the instruction set with the internal bit representation in hexadecimal. There are approximately 50 instructions, only six of which require an address field. Addresses are 24 bits long and address 64-bit words. For hardware busing simplicity, and each word contains a maximum of two instructions, each halfword instruction consists of an eight-bit opcode, optionally followed by a 24-bit address. All operators are generic. Operand types, sizes, and lengths are determined from descriptors and type tags associated with each operand.
The translator produces a name table for each block (main program, procedure, or ON) in the SPL source. All teferences made in that block to labels, procedures, or variqbies are made through the descriptors in that block's namne table. The first word of a name table is called the "blofk control word," which contains status informa-
tion about the entire block. Following the block control

word is a succession of entries for each identifier in the block. Each entry consists of the ASCII name of the identifier, followed by a one-word data descriptor for the identifier, called the "identifier control word." The contents of the block control word and the identifier control word are shown in Tables 2 and 3.
The advantages of Symbol's instruction set would appear to be its semantic conciseness and uniform mechanism for referencing data. Perhaps more important than the benefits derived from it are the unexpected consequences from the high-level nature of the instruction set.
Code compaction. There are several problems with the high-level nature of the instruction set, only a few of which are specific to Symbol. The high-level and postfix stack orientation of the instruction set were expected to give good code compaction. However, closer examina-

58 COMPUTER

tion revealed that Symbol's code was much less compact for typical programs than that on traditional machines such as the IBM 360 or PDP-1 1.
Several factQrs account for this poor code density. A substantial fraction of the object code consisted of nonfunctional end-of-statement operations, debugging links pointing to the source program, and no ops. Code density was also lost because opcodes, which are one byte in length, could be placed only in the first or fifth bytes of the eight-byte word, thus wasting three bytes fQr each opcode not requiring an address field. The translator contributed to the problem by producing extremely poor code, at times even replicating nonfunctional instructions. The strict one-to-one correspondence between source and object code resulted in the absence of many instructions-for example, increment, set to zero, and append a character-that could have been useful in optimizing for common special cases. Symbol's unusual memory structure also hindered code compaction by prohibiting any address calculations, thus precluding space saved by using relative addressing techniques. The lesson learned is that code compaction does not necessarily result from highlevel instructions. Factors of two or three in code density can be lost without careful integration of the instruction set, compiler technology, and memory structure.
Program measurements from Symbol23 were used in the design of another Symbol-like system to see if code compaction could be considerably improved for use in a
VLSI microprocessor.24,25 The results indicated that, al-
though the instruction space could be made very compact, the use of descriptors as in Syrnbol make the final difference relatively minor with respect to more traditional computers. The expected space savings from high-level instructions was not significant due to the high frequency oflowerlevel operations typically found in modem programs.
High-level instructions and interrupt-handling. An unexpected lesson was that there are times when instructions can be at too high a level. Because of the variablelength operands and high-level operations, hundreds or even thousands of memory references could be required to execute a single instruction. This had rather severe consequences on interrupt-handling (page fault, disk servicing, user interrupt, process switch, etc.). Proper interrupthandling requires the ability to stop execution, handle the interrupt, and then resume execution of the original instruction at the point of the interrupt. For efficiency, it is important to be able to stop execution of an instruction (without completion), save all state information active in the processing of the instruction, and resume execution at or near the point of interruption-rather than restart execution of the instruction from the beginning. For a highlevel algorithm, the state information that must be saved can be rather large.
A large fraction of Symbol's design bugs resulted from the failure to save all the necessary state information. This type of bug was extremely difficult to track down because the fatal interrupt was often generated nondeterministically from combinations of disk interrupts, clock timeouts, or users pressing interrupt buttons. Another problem was the inability to save all the necessary information for particular stages of the algorithm. These oversights

were eventually fixed, sometimes at the expense of storing state information at "convenient checkpoints." Restarting at such checkpoints not only repeated needless work after task shutdowns but, even worse, caused hundreds of more state saves than were necessary, significantly degrading system performance.
Optimization. Code optimization in Symbol would be difficult to achieve because of the generalized nature of the operations. The addition of lower-level instructions could have allowed optimization of many special cases. For example, incrementing a variable on Symbol could take over a dozen memory references due to its stack

Table 2. Block control word format.

BIT POSITION 0
1
2
4t
5t 6t 7t
8-31t 37 38
40-63t OTHERS

MEANING CONTROL WORD (ALWAYS 1 FOR BCW) START OF NAME TABLE (ALWAYS 1 FOR BCW)
END OF NAME TABLE THIS BLOCK TRANSLATED IN PRIVILEGED MODE
GLOBAL LINKING DONE
LEFT ADDRESS FIELD VALID
RIGHT ADDRESS FIELD VALID FORWARD LINK IN LIST CONNECTING ALL NAME TABLES BLOCK IN USE BLOCK RECURSED BACKWARD LINK TO BCW OF ENCLOSING BLOCK
UNUSED

tThese bits are used by the translator and not by the ceniral processor.

BITS O 1 2 3-4
0-3
5 6
7 8-31
32-39
32 34 35 36 40-63
OTHERS

Table 3. Identifier control word format.
MEANING
CONTROL WORD (ALWAYS 1 FOR IDCW) START OF NAME TABLE (ALWAYS 0 FOR IDCW)
END OF NAME TABLE 00 FOR NORMAL LOCAL VARIABLES 01 FOR GLOBAL VARIABLE 10 FOR IDENTIFIERS WHICH MAY NOT BE GLOBAL 11 FOR PROCEDURES (MULTILEVEL GLOBAL) INDICATES VARIABLE WITH VALUE IN NAME TABLE WHEN
ALL FOUR BITS ARE SET. THE IDCW IS A SCALAR\VALUE (NOT ALLOWED FOR LAST IDCW IN NAME TABLE) VARIABLE WITH INITIAL VALUE IN OBJECT STRING VARIABLE IS STRUCTURE-VALUED IF 1, SCALAR-VALUED IF
0 FLAG BITS 32-39 VALID
FOYREVTAARSISAIBGLNEESD,).POFIONRTELRABTOELVOARLUPERO(CZEERDOURIEF,SPPAOCIENTNEORT
TO OBJECT STRING ENTRY POINT IF BIT 7 IS 0, TWO-DIGIT CURRENT POINTER INDEX USED
DURING SUBSCRIPTION. IF BIT 7 IS 1, THEN BITS 32-36 ARE: ON BLOCK FEATURE ENABLED IDENTIFIER IS A LABEL IDENTIFIER IS A PROCEDURE IDENTIFIER IS AN INDIRECT FORMAL PARAMETER FOR IDENTIFIERS WITH ON BLOCKS, POINTER TO ON BLOCK CODE. FOR STRUCTURES WITHOUT ON BLOCKS, CURRENT POINTER ADDRESS UNUSED

July 1981

59

mechanism and indirection through descriptors. The uniform referencing to data structures meant that a compiler could not optimize accessing for special cases; in particular, a tremendous performance penalty was paid because the memory structure made it impossible to perform traditional indexing and address calculations. Even if such indexing were possible, there would be an incompatibility because of the inability to do binary arithmetic for addressing on the decimal-only machine.
Descriptors and tags. Because Symbol was one of the few examples of a descriptor-based machine and a tagged architecture, a few comments are appropriate. Operand- and instruction-tagging were useful in catching occasional machine errors where, for a number of reasons, a memory reference returned an incorrect value. There are no instances where data could possibly be mistaken for program or vice versa. Tagging did, in fact, report many machine errors that might have gone undetected in a traditional machine. Tags were also of great benefit in debugging and in developing sophisticated software debugging tools.
Descriptors had an even stronger impact on Symbol, both positively and negatively. Descriptors were in-

valuable in efficiently implementing the dynamic typing present in the language and in providing benefits for debugging tools. On the other hand, implementing recursion in SPL was a task left to system software, and it turned out to be extremely inefficient. A simple test of recursion with Ackermann's function would show Symbol to be at least three orders of magnitude slower than traditional machines. The main problem was that the descriptors for the entire procedure had to be copied upon a recursive call if the descriptors themselves might be modified in the call-a virtual certainty in Symbol.
Need for a systems language. One of the problems with
the Symbol language and instruction set was that they
were not efficient for lower-level tasks common to sys-
tems programming. The support tools on Symbol could have been more effectively supported through a systemsoriented language such as BCPL,26 Bliss,27 or C.28 While
inefficiencies in short-lived user programs could be toler-
ated, the same cannot be said for system software. The Symbol Programming Language turned out to be inappropriate for systems programming. It is recommended that even on computers that intend to support only one

tcpdArS+heeoeh4alevSno.edityt5cecmamotreaibvr,sanioio.bsnlcalottTnotvsehd"pyentpaee,taeerlwrianat1nrmtecesi0irieti0nmnpeda0igrprelni,ra"asnvotlemyiccedsperoesi.twsusthelisoTom(ndofhwgbrcaetenkohnl(enebdfoaysatowSbriuoosytltlkieatmhelfrfeitbotndt)foyemu,,lxausssptipeotmonduaattfwrtiooreaucna9rstefmm9hredolseipa)diush,msiptptyefpylias,ilpnaingeieyscdswe,da.hrslcdioITaitfw1Bhrseo/sMedkrr0 tTAhpnEmidrehaaevdilcelmeind"hsottf-rei2lrpdo1y0oarnn0,0omcat0icpllrcevcCooosiwusrsnnie.ietowrWtretchomihacfeeeonromngdtuslohlyeoreptfsdtnhayt,mbene,aaeem1nilP'0amnss0CenofxnBdicrotinoanetdnpwmniotaaectdrrgasheoei(telrdnpeughfprfstooairerhgtndoheedorttml,eu.vafsatmaotal"rirnun(pidegg"br.haboot5ccu)fE0kegagsbs"corhsuhonoosfuriwcntxsadsaoeir)cpsg.d-.a.-
6060 CCOOMMPPUUTTEERR

user language, a significant effort should go into supporting an underlying systems language. Addition of a few lower-level instructions could have made Symbol an effective multilanguage system.
System software and the hardwired operating system
The functions of a complete timeshared operating system were implemented directly in hardware by the system supervisor,29 aided by the memory controller, memory reclaimer, channel controller, drum controller, and input/output processor. Although system software was intended by the designers to handle only certain exceptional conditions, it was actually used to a much greater extent. The research team expended substantial effort in developing loaders, text editors, improved diagnostics, debugging packages, library routines, and a file system. This software was considered to be essential in making the system/user interface tolerable. System software accounted for several thousand lines of code by the end of the project. Some of the success of this software was due to the foresight of the designers in providing

"hooks" in the hardware for software intervention, allowing the system to retain some flexibility despite its hardwired implementation.30
Symbol answers two important questions about the benefits derived from implementing major parts of an operating system in hardware. First, it would seem that the overall design costs of developing a hardware-implemented operating system are much higher than an equivalent software implementation. Thus, the desire to lessen the cost of developing an operating system was not
achieved. While software costs were reduced, overall costs
Symbol deserves as much recognition as a successful operating system machine as it does for being a high-level language machine.
were not. Traditional software bug fixes were merely exchanged for a "Request for Hardware Modification" sheet. The bound RFHMs were over four inches thickand accounted only for changes made after the "debugged" system was delivered to Iowa State University! I
The second and more positive point is that the implementation of the hardwired operating system seems to have been successful from a performance and programming standpoint. Though the inflexibility ofthe hardware often prohibited changes towards more "modern" operating system concepts, the implementation was successful in terms of the original design goals. Using hardware for heavily used functions such as process-scheduling, virtual memory management, memory allocation, and scheduling of multiple processors seems to have been a wise trade-off. It was also shown that complex hardware can be successfully interfaced to the software part of the operating system. In terms of the overall design, Symbol deserves as much recognition as a successful operating system machine as it does for being a high-level language machine.

July 1981

A tale of two processors
While hardwired implementation of high-level functions has its merits, a look at two of Symbol's processors might prove insightful. Perhaps the most striking aspect of Symbol to a user was the amazing speed at which programs were compiled-70,000 to 100,000 statements per
minute. The Symbol translator3l is probably the only example of a compiler implemented entirely with random
logic. The translator is perhaps the most amazing of Symbol's processors, not only because of its tremendous compiling speed but also simply because it worked at all. One of the benefits of this tremendous translation speed was that no object files were saved. This was an advantage in saving storage space and in ensuring that object programs always reflected the current source program.
There is no intent to imply, however, that such speeds are generally obtainable from a hardwired compiler and a high-level instruction set. The performance figures of Symbol's translator are somewhat misleading in that the

61

speed came primarily from two other factors. First, SPL6,7 had a grammar designed to be easy to parse. Nonoptimal code was generated in one pass with backpatching and without the need for building compile-time data
structures. The high translation speed could not be expected in a proper implementation of a compiler for SPL or most programming languages in use today. Second, the translator did almost nothing more than crude codegeneration and assembly. Error diagnostics were next to nonexistent, though in the majority of cases syntax errors in programs were detected. Our experience suggests that compilers should only be constructed using a high-level programming language. Compiler complexity can per-

modSuelcaornidz,insgpepcriiamli-tpiuvrepoospeerhaatridownasresoistmheaydecafnlexbieblceobny-

trolled by
in the I/Q

the software. If the sequencing of the primitives processor had been controllable by software that

was accessible by the central processor, the performance of

the software editors might have been much closer to that of

the bol

hardwired text editor. Much of the problem was that the designers thought they knew

with how

Sym-
users

would want to use the machine. Whenever the actual use of

the machine deviated even slightly from this, the hardwired

nature
locked

of the

the
user

translator, editor,
into a mold he did

and operating not want to be

system in.

haps be attacked more successfully by using modern compiler writing tools32'33 than by developing high-level instruction sets. The poor design of the translator was un-

sMtermaongreybmeadnfaelgleomwesnt: A case of

doubtedly due in large part to both the low-level im-

plementation with which the designer was forced to work One of Symbol's unique features was its mixture of vir-

and the infantile state of compiler technology in the early tual memory with the implementation of noncontiguous

1960's.

"logical storage" strings. Symbol provided direct hard-

Debugging the translator hardware was extremely difficult, because register-level flowcharts and wire lists proved to be totally inadequate forms for documenting the conceptual process of translation. In no way could the design, implemention, and debugging of the Symbol's

ware support both for a paged virtual memory and for dynamic data structures. The hardware supported the allocation, deletion, and manipulation of storage strings which were constructed by linking together eight-word groups. Linked lists of such storage strings were used to

translator have been cost-effective when compared to a compiler programmed in a high-level language. The hardware dedicated to the translator was not cost-effective, since the logic was rarely in use and a similar function could have been performed by the central processor. Perhaps a more reasonable trade-off would have been to provide the central processor with special-purpose hardware to aid with the various translation functions. This would have had the additional benefit of allowing specialpurpose hardware to be used for other functions besides translation.

represent tree structures which were accessed in SPL as heterogeneous arrays. The sizes and shapes ofthese structures were dynamically variable.
The designers of Symbol foresaw and attempted to mitigate the adverse interaction of the system's unique
combination of memory management and virtual mem-
ory. They realized that particular machine functions had characteristic memory access patterns. For example, the source code was used in program editing, but not at all during execution. In program compilation, source code and object code were scanned only once, whereas the

name tables were scanned repeatedly. Hence, the design-

Essential utilities of a system such as a text editor and compiler need the ability to

ers decided that each page should be used for a single purpose and that page lists would be maintained to segregate the pages according to their use. When memory was allo-

change and grow, both to correct bugs and to add new features.

cated, the crude usage ified by the hardware.

class This

for the needed space was specusage class determined which

page list the system would consult to find the needed

Even more than the translator, the I/O processor34 suf-

space. Symbol maintained three separate page lists-one for source code, another for object coce, and thethird for

fered from the rigidity of a hardwired implementation. all other needs. Once any space on a page was allocated,

To offload the central processor, the I/O processor contained a hardwired text editor that ran extremely quickly.

the page was inserted on
Thereafter, that page would

the appropriate page be used only for further

list. allo-

Unfortunately, the pushbutton-operated editor was so difficult to use and so primitive that all on-line editing was

cations of space of the same usage class. This scheme
worked well for program editing and for constructing

done in the central processor with software text editors. name tables and object code at compile time. However, at

The strict separation of the I/O processor and the central processor did not allow the primitives in the hardwired

execution time, all data accessing involved one page list, so there was no advantage to this scheme at that time.

text editor to be shared by the software text editors.

It would have been worthwhile to experiment with

Two lessons are evident. First, essential utilities of a system such as a text editor and compiler need the ability to change and grow, both to correct bugs and to add new features. The hardwired approach did not permit such growth. The functional division was at too gross a levelfor example, the specialized hardware in the translator provided an all-or-nothing service.

adding more page lists to Symbol-lists of pages used solely for the stack, for temporaries, or for large structures. Most likely, this would have limited the scattering of these objects by restricting them to a segregated set of pages. Unfortunately, implementation of additional page lists would have required extensive modifications through-
out the central pIrocessor. For this reason, it was never attempted.

62 COMPUTER

In Symbol, a single large structure could come to oc- Hardware. One of the questions the implementation

cupy small portions of a large number ofpages. There was of Symbol was supposed to answer was whether or not

no mechanism for compacting these structures. Modifi- exttemely complex hardware could be designed and de-

cations to the memory allocation strategy attacked the problem by preventing some of any reclaimed space on

bugged. The answer provided is that complex hardware
can be designed and debugged, but only by investing

each page from being founfd, except for expansion by objects which already occupied a portion of that page. This

tremendous effort and time. Although Symbol had been debugged by 1971 to the point where it could run simple

was known as the "space available list threshold" technique. 35 Measurements taken on Symbol programs which

programs, hardware bugs were still being found in various processors in 1978. Experience with debugging

had had significant paging activity indicated that this approach reduced the number of page faults dramatically. The greatest benefits were realized when one sixth to one

the Symbol system and more conventional software proj-
ects suggests that bugs in hardware occur in much the
same way that they do in software. However, the prob-

fourth of each page was reserved for the expansion men- lems associated with finding and removing hardware bugs

tioned above.

are far more severe.

Changes to hardware are more time-consuming than

Programs were developed that allowed the

changes to software. Modifications to Symbol had to be done with extreme care. Changes often had unexpected

user to examine in detail the state of his side effects because the conceptual details of an algorithm

program at the source program level.

were not documented as they might have been with soft-

ware. Because of this lack of conceptual documentation,

it was not uncommon to cure the symptom rather than the

Experiments were performed that reduced Symbol's page size from the built-in 2K-bytes per page to as low as 256 bytes per page. The use of smaller pages usually reduced the paging activity for a fixed main memory size. This technique worked whenever severe scattering was encountered, regardless of its origin. Unfortunately, the use

problem. Often, changes could not be made because of physical limitations, such as the number of bus pins or the number of IC packages that would fit on a board. Hardware errors and bugs were not always deterministic. Therefore, it was first necessary to ascertain whether a bug was due to an incorrect algorithm or a circuit failing

of small pages could hurt where sequential access to a large body of code or data was typical. Furthermore, the cost of the overhead associated with a large number of pages could become significant. We cannot help but speculate that the ability to request contiguous allocation of' large structures would have reduced paging considerably, even though it would have contradicted the declarationfree character of SPL.

because of a bad component.
Any similar-scale hardware project must make special efforts to provide the maximum possible effort for developing design and debugging tools. The state of the art in constructing and debugging digital systems is far behind the same technology for software systems. This is probably
connected with the limited use of high-level engineering systems such as Scald39 or Draw.40 Computer-aided debugging is a necessity. Symbol needed the ability to trace and

Debugging on Symbol

store the last several thousand operations in real time and have the trace information analyzed automatically. The

limited trace facility on Symbol perturbed the system to the

Software. An outstanding benefit from the high-level nature ofthe Symbol computer was the efficacy of the debugging tools36'37 produced for the system. Programs

tetxhhtereronmutogrtheh,ahtuwnshdoermneedaseprroroforblslienwemosucolofudlhgdeoxb-eabitwtra'apycjea*dthtreeerlnnisatbrtlaoyc,efrdie.nadFduitrnh-ge

were developed that allowed the user to examine in detail offending error often proved to be beyond human ability.

the state of his program at the source program level. For

example, at a user-generated interrupt, the programmer

could ask the inquire subsystem where the program was von Neumann realities

executing and have the statement in execution decompiled

for display. The decompilation process was remarkably
effective, and generally differed from the original source

Symbol Neumann

airs chaitcelcatsusirce.exFeaamtpulreesofth-aat dtisatkiencittlyountoonf-vtohne

program only with respect to spaces and redundant von Newmann class are the noncontiguous memory struc-

parentheses. Since Symbol was a descriptor-based and ture, automatic memory management, distinguishability
tagged architecture, the current types, names, and values of instructions from data, self-describing nature of struc-

of all identifiers in the user's program were known.

tures, and high-level instruction set. An early paper com-

There was never any need for a programmer to realize mented that

that his program was being translated into an intermediate form for execution-one of the strongest points supporting the claim that Symbol was a high-level lan-
guage computer system.38 In addition to the benefits that
the machine offered for debugging, the dynamic typechecking mechanisms in the hardware proved very valuable for detecting occasional machine errors such as

as implemented in the Symbol hardware, however, any
tvssaethsnooktruialrogdeneqasoulhriosrtoiwhnfegatdwcytaohnrneaesm/ivihdacareirrsaadtbbwrllaueerctepfuiersereylfdsfoteleraemmtnsuag.rnt3echseopgrfaotichneesolsviaennrggucaaongnde-
Experience with Symbol suggests that this is probably true, but unfortunately there were not enough tasks of

trying to use instructions as data or vice versa.

this type.

July 1981

63

Programs on Symbol, as on most computers, tended to * Discovers and reports syntax and execution errors in

do relatively simple operations. Arithmetic operations

terms of the high-level language source program,37

usually involved adding or subtracting very small inte-

and

gers-little use was made of the 99-digit precision- * Does not have any outward appearance of transfor-

controlled arithmetic. Character strings most frequently

mations from the upper programming language to

were only a single character, rarely exceeding a dozen

any internal languages.

characters in length. While some use was made of dynamically variable arrays, arrays were almost always homogeneous and, once grown, remained static. At the machine level, it hurt a great deal that the memory structure and decimal arithmetic processor precluded indexing with address arithmetic. Object code, name tables, and source files were always static objects after their creation; consequently, a better storage organization for them would perhaps have been a traditional contiguous linear store.
The moral of this story is that the traditional von Neumann computer perhaps is not so ill-suited to the

Perhaps the most crucial part of meeting this definition in any system is being able to debug a program at the source language level. The Symbol architecture facilitated this with high-level instructions that allowed object code to be easily decompiled back into source, and in the self-describing nature of all data objects that allowed the unambiguous interpretation of any data storage. A highlevel language computer system is different from and more important than just a machine with a "high-level" instruction set.

operations actually performed by typical programs. SPL

and Symbol hardware were more powerful than the average user required. Some of Symbol's more advanced

Conclusion

features could have been implemented by software on a traditional machine to achieve a more cost-effective solution to the same problems. Perhaps the conclusions would have been different in another environment, but Symbol was not as much of an advantage over the von Neumann machine as had earlier been hoped.

The existence of the working Symbol computer system clearly demonstrates that a high-level instruction set, a compiler, automatic memory management, and a major portion of a timeshared operating system can be implemented successfully in hardware. Use of the Symbol system showed to a lesser degree that the costs of building

such a system are not less than building an equivalent

Microcode

system in software; that the ability to evolve a system is perhaps more important than having a very fast func-

The hardwired nature of the Symbol machine is often criticized for its inflexibility. Microcoding has been suggested as an implementation solution that is flexible and still efficient.
During the 1960's, when technology decisions were being made, ROMs suitable for microcode lacked speed, lacked density, and were prohibitively expensive for the

tional unit that is never used; and that performance gains obtained from a hardwired implementation are easily lost. A "high-level" instruction set does not guarantee better performance, nor does it solve "the software problem." In designing a high-level language computer system, one must carefully examine the cases under which a simpler architecture might perform equally well.41

quantities required for Symbol. If one were to design the

same processors today, microcoding would obviously be superior to a random logic implementation. Part of the Symbol experiment, however, was to push the limits of a completely hardwired implementation, and microcode

Building complex hardware is prone to the same bugs and fundamental design errors that plague complex software systems.

would not have accomplished this.

This significant lessons learned from Symbol are not ones concerned with whether or not it should have been microcoded. Instead, they concern what has been learned about system complexity, refinement of complex systems, debugging of complex systems, functional division, and instruction set design. In fact, in many instances system software needs to be installation-modifiable. A microcode implementation generally would not fall into this category.

Symbol taught us a great deal about building complex systems. The top-down design approach made it necessary for the entire system to be conceived before any of it was implemented; the results show that this is dangerous. Building complex hardware is prone to the same bugs and fundamental design errors that plague complex software systems. Symbol contained many excellent and unique solutions to individual problems, but the complex interactions of all of these solutions made the entire system

cumbersome and slow. Refinement and iterative im-

Was Symbol really an HLLCS?

provement are steps that most software systems must go through before reaching acceptable levels of performance

Why Symbol is considered to be one of the few real high-level language computer systems is crucial to note. The Symbol machine with- and only with-the software
developed for it meets the HLLCS definition38 because it

and utility; this step was desperately needed with Symbol. Performance might have been improved more than an order of magnitude if many of the known inefficiencies could have been tuned or removed. Despite the constructive criticism offered in this article, the Symbol experience

* Uses a high-level language for all programming, remains a very positive first step in the design of high-level

debugging, and other user/system interactions,

language computer systems. E

64 COMPUTER

Acknowledgments
Rex Rice, William R. Smith, and the Symbol design team at Fairchild have to be commended for their innovative attempt to create a totally new architectural philosophy. Were it not for the premature cancellation of the Symbol project, the computing industry might be different today. Financial support provided by the National Science Foundation under Grant GJ33097X kept Symbol alive, enabling the author and a handful of dedicated students to probe the inner workings of this remarkable machine. Sections of this article came from works coauthored with William A. Kwinn and Robert F. Cmelik and presented at the 1980 Workshop on High-Level Language Computer Architecture.22'37'42 Their efforts are greatly appreciated. The editorial criticism of K. Kwinn on this and other articles greatly improved the author's otherwise obfuscatory writing style. P. C. Hutchison is appreciated for the many hours he spent as a data base from which the solution to any hardware or software problem could be extracted. The Symbol project at Iowa State University was administered under the direction of R. M. Stewart and R. J. Zingg.
References
1. R. Rice and W. R. Smith, "SYMBOL-A Major Departure from Classic Software Dominated von Neumann Computing Systems," AFIPS Conf. Proc., 1971 SJCC, Vol. 38, AFIPS Press, Montvale, N.J., 1971, pp. 575-587.
2. W. R. Smith et al., "SYMBOL-A Large Experimental System Exploring Major Hardware Replacement of Software," AFIPS Conf. Proc., 1971 SJCC, Vol. 38, pp. 601-616.
3. G. D. Chesley and W. R. Smith, "The Hardware-Implemented High-Level Language for SYMBOL," AFIPS Conf. Proc., 1971 SJCC, Vol. 38, pp. 563-573.
4. B. E. Cowart, R. Rice, and S. F. Lundstrom, "The Physical Attributes and Testing Aspects of the SYMBOL System," AFIPS Conf. Proc., 1971 SJCC, Vol. 38, pp. 589-600.
5. M. A. Calhoun, "SYMBOL Hardware Debugging Facilities," AFIPS Conf. Proc., 1972 SJCC, pp. 359-368.
6. H. Richards, Jr., SYMBOL IIR Programming Language Reference Manual, Report ISU-CCL-7301, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1973. NTIS accession number PB-221 378.
7. H. Richards, Jr., and C. Wright, "Introduction to the SYMBOL 2R Programming Language," Proc. ACMIEEE Symp. High-Level-Language Computer Architecture, ACM, New York, 1973, pp. 27-33. NTIS accession number PB-228 115/AS.
8. T. A. Laliotis, "Architecture of the SYMBOL Cornputer System," in High-Level Language Computer Architecture, ed. Y. Chu, Academic Press, New York, 1975.
9. G. J. Myers, Advances in Computer Architecture, John Wiley & Sons, New York, 1978.
10. P. C. Hutchison, Extensions to a Block-Structured Programming Language to Support Processing of Symbolic Data and Dynamic Arrays, Special Report ISU-CL-7705, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1977.
11. R. W. Black, Structured Programming in the SYMBOL2R Programming Language, Special Report ISU-CL-7405, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1976.

12. D. R. Ditzel, "Pattern Matching for High Level Languages," SIGPLANNotices, Vol. 13, No. 5, May 1978, pp. 46-55.
13. R. E. Wolf, SYMBOL 2-R Compatible Tree Manipulation, Special Report ISU-CL-7602, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1976.
14. D. R. Ditzel, "MASK and FORMAT: Operators for Editing and Formatting," SIGPLAN Notices, Vol. 12, No. 11, Nov. 1977, pp. 28-35.
15. J. W. Anderberg, Source Program Analysis and Object String Generation Algorithms and Their Implementation in the SYMBOL 2R Translator, Report NSF-OCAGJ33097-CL7410, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1974. NTIS accession number PB-230 614/AS.
16. J. W. Anderberg and C. L. Smith, "High-Level Language Translation in SYMBOL 2R," Proc. ACM-IEEE Symp. High-Level-Language Computer Architecture, ACM, New York, 1973. NTIS accession number PB-228 117/AS.
17. P. C. Hutchison and K. Ethington, "Program Execution in the SYMBOL 2R Computer," Proc. A CM-IEEE Symp. High-Level-Language Computer Architecture, ACM, New York, 1973. NTIS accession number PB-228 780/AS.
18. A. C. Bradley, An Algorithmic Description of the SYMBOL Arithmetic Processor, Report NSF-OCA-GJ33097CL7301, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1973. NTIS accession number PB-222 972.
19. M. C. Dakins, NonnumericProcessing in theSYMBOL-2R Computer System, Report NSF-OCA-GJ33097-CL7410, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1974.
20. H. Richards, Jr., and R. J. Zingg, "The Logical Structure of the Memory Resource in the SYMBOL-2R Computer," Proc. A CM-IEEE Symp. High-Level-Language Computer Architecture, ACM, New York, 1973. NTIS accession number PB-228 118/AS.
21. R. J. Zingg and H. Richards, Jr., "SYMBOL: A System Tailored to the Structure of Data," Proc. Nat' Electronics Conf., Vol. 27, National Electronics Conference, Inc., Oak Brook, Ill., 1972, pp. 306-311. NTIS accession number PB-221 286.
22. R. F. Cmelik and D. R. Ditzel, "The High Level Language Instruction Set of the SYMBOL Computer System," Proc. 1980 Workshop High-Level Language Computer Architecture, Ft. Lauderdale, Fla., May 1980, pp. 238-246.
23. D. R. Ditzel, "Program Measurements on a High-Level Language Computer," Computer, Vol. 13, No. 8, Aug. 1980, pp. 62-72.
24. D. R. Ditzel, "Investigation of a High Level Language Oriented Computer for X-Tree," MS thesis, University of California, Berkeley, Calif., 1979. Available as Computing Science Technical Report No. 88, Bell Laboratories, Murray Hill, N.J.
25. D. R. Ditzel, "Architectural Support for Programming Languages in the X-Tree Processor," Digest of Papers Compcon 80 Spring, pp. 335-339.*
26. M. Richards, "BCPL: A Tool for Compiler Writing and System Programming," AFIPS Conf. Proc., 1969 SJCC, Vol. 34, pp. 557-166.
27. W. A. Wulf, D. B. Russell, and A. N. Habermann, "BLISS: A Language for Systems Programming," Comm. ACM, Vol. 14, No. 12, Dec. 1971, pp. 780-790.
28. B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice-Hall, Englewood Cliffs, N.J., 1978.
29. W. R. Smith, "System Supervisor Algorithms for the SYMBOL Computer," Digest ofPapers Compcon 72, pp. 21-26.
30. H. Richards, Jr., and A. E. Oldehoeft, "Hardware-Software Interactions in SYMBOL-2R's Operating System,"

July 1981

65

Proc. Second Ann. Symp. ComputerArchitecture, 1975, pp. 113-118. NTIS accession number PB-239 220/AS.*

3i. T. A. Laliotis, "Implementation Aspects of the SYMBOL Hardware Conipiler, " Proc. First Ann. Symp. Computer Architecture, ACM, New York, 1973, pp. 111-115.

32. S. C. Johnson and M. E. Lesk, "Unix Time-Sharing System: Language Development Tools," Bell System Technical J., Vol. 57, No. 6, 1978, pp. 2155-2175.

33. B. W. Leverettet al., An Overview oftheProductionQuality Compiler-Compiler Project, Report CMU-CS-79-105, Carnegie-Mellon University, Feb. 1979.

34. W. E. Jones, The Role of the Interface Processor in the SYMBOL IIR Computer System, Special Report NSFOCA-GJ33097-CL7304, Cyclone Computer Lab., Iowa State University, Atines, Iowa, 1973. NTIS accession number PB-227 454/AS.

35. W. A. Kwinn, Memory Management Ppliciesfor a Hardware Implemented Computer Operatiqg System, Special Report MCS72-03642-CL7801, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1978.

36. D. R. Ditzel, Interactive Debugging Tools for a Block 0vSe3trr6su4ict2yt-,uCrALe7md8e0sP2,r,oICgoywrcaal,momn1i9e7n8Cg.omLpauntgeuragLea,b.,ReIpoowratStMatCeSU7n2i--

37. HdtDahi.legeRh,S.-YFLDleMiav.tBe,zelOMlL,Laa"ynCHgo1ium9ga8phg0u,etLeCpevpore.mlpS2uyL4ts7aet-nr2egA5mur5,aq.`ghP,ettopecec.btuu1rg9eg8,i0nFgtW.oTLoraokulsdsheoorp-n

38. D. R. Ditzel and D. A. Patterson, "Retrospective on HighLevel Language Computer Architecture," Proc. 7th Ann. Symp. ComputerArchitecture, 1980.*

39. T. M. McWilliams and L. C. Widdoes, Jr., SCALD: Structured Computer-Aided Logic Design, Technical Report No. 152, Digital Systems Lab., Stanford Universityi Stanford, Calif., Mar. 1978, pp. 2233-2249.

40. A. G. Fraser, "UNIX Time-Sharing System: Circuit

Design Aids," Bell System 1978, pp. 2233-2249.

Technical

J.,

Vol.

57,

No.

6,

41. D. R. Ditzel and D. A. Patterson, "The Case for the

Reduced Instruction Set
ture News, Vol. 8, No.,

Computer," 7, 1980.

Computer

Architec-

42. D. R. Ditzel and W. A. Kwinn, "Reflections on a High Level Language Computer System or Parting Thoughts on the SYMBOL Project," Proc. 1980 Workshop High-Level Language Computer Architecture, Ft. Lauderdale, Fla., May 1980, pp. 80-87.

fCJ1ooy9rn7c6el.sao,nneWI.CntoeEmr.pa,cutAtieveMriLcCarobom.pp,ruotIceoerws,asoSSrtp-aeBtcaeisaUelndiRvIeenprpsouirttty/,OIuAStmUp-euCstL,-S7yI5so0tw3ae,,m

Laliotis, T. A., "Main Memory Technology," Computer, Vol. 6, No. 9, Sept. 1973, pp. 21-27.

Organick, E. I., Proc. AFIPS Workshop

ming Languages Press, Montvale,

on Computer N.J., 1971.

Systems

Influence ofProgramArchitecture, AFIPS

Rice, R., "The Hardware Implementation of SYMBOL," Digest ofPapers Compcon 72, pp. 27-29.

Rice, R., "A Project Overview, " Digest ofPapers Compcon 72,
pp. 17-20.

Richards, H., Jr., Controlled Information Sharing in the CS1y9Y7cM6l.BonOeLC-o2mRpuCtoemrpuLtaeb.r,SyIsotweam,StSapteeciUanlivReerpsoirtyt,IASmU-eCsL,-7I6o0w1a,,

Smith, C. L., C. T. Wright, and R. J. Zingg, "Problems in the

Push-Down Stack Level Languages," 96-98.*

Approach Digest of

to the
Papers

Implementation of High Compcon 76 Spring, pp.

Zingg, R. J., and With SYMBOL,"

DHi.geRsitchoafrPdasp,erJrs.,Co"Omppecroatnio72n,alppE.xp31e-r3i5e.nce

CTohmepsuetedirgeSsotcsieatnyd,

proceedings are available from the Order Desk, IEEE 10662 Los Vaqueros Circle, Los Alamitos, CA 90720.

Additional sources on Symbol

Agrawal, O., "Applicability of Buffered Main Memory to
SYMBOL 2R Like Computing Structures," PhD dissertation,
Iowa State University, Ames, lqwa, 1974.

Alarilla, L. M., Jr., Storage Linking Techniques for the Automatic Management of Dynamically Variable Arrays, Report ISU-CL-7403, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1974.

Bretl, R. F., A Hierarchic Control Structurefor User Programs in the SYMBOL System, Special Report ISU-CL-7501, Cyclone Computer Lab., Iowa State University, Ames, Iowa, 1976.

Chu, Y., "Significance of the SYMBOL Computer System," Digest ofPapers Compcon 72, pp. 33-35.

Falk, H., "Hard-Soft Tradeoffs," No. 3, Feb. 1974, pp. 42-43.

IEEE

Spectrum,

Vol.

11,

David R. DitzeI is a member of the technical

staff at Science

Bell Laboratories' Research Center in

MuCrormapyutHiilnlg,

iNnecwludJeercseoym.puHtiesrcuarrrcehnittercteusreea,rcihnsatctrjuycittiioens

set analysis, VLSI, tools, and personal

ccoommppuutteirn-gasiydsetdem4se.siHgen

haBS in eectrical engineering and a BS in

project

for

four

csiotmy,puwtheerresciheencpearftricoimpaItoedwainSttahtee SUnyimvbeorl-
years. In 1979, he received an MS in computer

science frotn the University of California, Berkeley. Ditzel is a

member ofTau Beta Pi, Eta Kappa pa Phi, ACM, and the IEEE.

Nu,

Phi

Beta

Kappa,

Phi

Kap-

66 COMPUTER

