From: AAAI-94 Proceedings. Copyright © 1994, AAAI (www.aaai.org). All rights reserved. 

Recovering  Software  Specifications 
with  Inductive  Logic  Programming 

William  W.  Cohen 
AT&T  Bell  Laboratories 
600  Mountain  Avenue 
Murray  Hill,  NJ  07974 

wcohen@research.att.com 

Abstract 

learning 

software 

software 

inductive 

techniques 

to  reconstruct 

a  large  (more 

of  its  operation. 

type  of  database 

than  one  million 

In  a  case  study 

abstract  Datalog 

system. 
techniques 

system,  we  demonstrate 

a  large  software 
how  learning 

We  consider  using  machine 
help  understand 
ticular,  we  describe 
be  used 
tions  of  a  certain 
examples 
volving 
real-world 
off-the-shelf 
can  be  successfully 
specifically,  Grende12  can  extract 
about  one-third 
high 
scribe 
performance 
output 
which  allows 
determinations. 
enable 
two-thirds 
recall,  and  precision 

to 
In  par- 
can 
specifica- 
from 
in- 
lines  of  C) 
that 
logic  programming  methods 
recovery; 
for 
in  a  test  suite  with 
recall.  We  then  de- 
to  Grende12  which 
improve 
task:  one  which  allows  it  to 
and  another 
containing 
these  extensions 
for  nearly 
of  the  benchmark  modules  with  perfect 

rates  of  precision 
two  extensions 
on  this 

a  set  of  candidate 
it  to  output 

hypotheses, 
specifications 

used  for  specification 

to  be  extracted 

In  combination, 

of the  modules 

specifications 

specifications 

than  60%. 

of  better 

and 

Introduction 

useful 

Machine 

unknown, 

previously 

knowledge 

of  implicit, 

to  perform 

information.” 

Here  we  investigate 

learning  methods 
task-understanding 

et  al.  [1991]  define  knowledge  discovery  as  the 
and  po- 
learning  meth- 
discovery 
the  use  of  ma- 
dis- 
knowledge 
system. 
un- 
large  soft- 
that 
than  half  of  the  time 

Frawley 
“extraction 
tentially 
ods  are  often  used 
from  databases. 
chine 
covery 
This 
derstanding 
ware  systems 
for  large  software 
spent  on  maintenance 
ing  [Parikh  and  Zvegintzov, 
We  present  a  case  study 

[Corbi,  19891;  it  has  been  estimated 

is  spent  on  program  understand- 

area,  as  program 

systems,  more 

is  an  important 

for  a  different 

in  maintaining 

1983,  page 

is  a  major 

application 

involving 

software 

a  large 

task 

ix]. 

software 
learning  methods 
structing 
itself. 

system  which 

investigates 
for  specification 

specifications 

of  software 

Such  specifications 

are  useful 

a  large  real-world 
the  use  of  machine 
e.,  con- 
recovery-i 
the  software 
from 
un- 

for  program 

142 

Automated  Reasoning 

derstanding, 
software 
covering  Datalog  definitions 
routines  which 

systems.  More  specifically,  we  i nvestigate 

but  are  often  not  provided  with  existing 
re- 
views  from  C 

of  database 
these  views. 

- 
implement 

In  addition 

to  its  potential 

practical 

problem 

recovery 

language 

the  natural 

is  technical: 

of  interesting 

is  a first-order 

of  specification 

to  learn.  Another 

goal  is  not  prediction 

problem 
main)  a  number 
problem 
specifications 
hard 
the  high-level 
not  obvious  h&w  one  should  evaluate 
tem.  Despite 
that  off-the-shelf 
can  be  successfully 
this  domain.  However, 
also  be  improved 
task  at  hand. 

but  state-of-the-art 

these  difficulties, 

by  adapting 

used 

(in 

raises 

importance, 

representation 

the 
this  do- 
research  prdblems.  One 
for 
is  in  general 
as 
it  is 
sys- 

is  methodological: 
but  disco&y, 
the  learning 

that 

it  will  be  demonstrated 

learning  methods 

for  specification 

recovery 

these  off-the-shelf  methods 

them  more  closely 

in 
can 
to  the 

The  Discovery  Problem 

The  experiments 
the  “Recent  Change” 
the  5ESS1  switching 
system 
data.  As  the  database 
is  a  real-time, 
quirks;  however, 
de  regarded 

(henceforth 

RC)  subsystem 

of  this  paper  were  carried  out  with 
of 
system.  A  large  part  of  the  5ESS 
all  site-specific 
the  switch,  which 
of 
it  has  a  number 
of  this  paper, 
it  can 

system: 
for  the  purposes 

is  used  by 

encodes 

is  a  database  which 

as  a  conventional 

distributed 

several  hundred 

is  often  stored 
format.  Thus, 

the  database 

formation 
unintuitive 
cesses 
contains 
views  are  essentially 
accessed  and  updated 
tual  relations, 
terface 
each  view 
ports  a  standard 
deleting 
tuples 
complex. 

In  particular, 

to  the  underlying 

is  implemented 

“virtual 
in  much 
but  are  designed 

relational 
for  retrieval, 

database. 
and  hence 

views  into 

the  database. 

internally 
in  a  redundant 
the  switch  administrator 

in- 
and 
ac- 
the  RC  subsystem,  which 
RC 
;  they  can  be 
as  ac- 
in- 
data.  For  reasons  of  efficiency 
sup- 
and 
can  be  quite 
it  is  often 

relations” 
the  same  manner 
to  present 

as  a  C  routine  which 
such  as  reading 

a  simpler 

a  view, 

in  updating 

set  of  operations, 

in  the  view.  These  routines 

The  database 

is  optimized 

through 

‘5ESS  is  a  trademark  of AT&T. 

necessary 
tained. 
relations 

to  check  that 

integrity  constraints 

are  main- 
constraints  may  affect  many  database 

Integrity 

and  checking 

them 

is  often  non-trivial. 

The  purpose  of  our  discovery 

system 
declarative 

is  to  automat- 
specifications 

(i.e.,  Prolog  with  no  function 

construct 

high-level, 

ically 
of  these  views.  The  constructed 
Datalog 
describe  how  views  are  derived 
lations.  As  an  example, 
of  columns 
by  the  one-clause  Datalog  program 

1,3,5  and  4  of  relation 

a  view  vi  which 

specifications 

symbols), 
from  the  underlying 

are  in 
and 
re- 

is  a  projection 
r  might  be  specified 

~I(A,B,C,D) 

+  r(A,Z,B,D,C). 

Similarly, 
and  t  might  be  specified 

a  projection 

212 

of  the  join  of  two  relations 

s 

~2 (A,& CD)  +  &%B,D),  W%A, W’, C) 

a  language 

that 
in  specifying 

they  are  a useful  description 

and  how  relations 
distributed 

real-world 

that 
of  the  underlying 
such  as  integrity 

as  restricted 
soft- 
these  specifications 
code; 
con- 
are  stored 
over  sev- 

aspect  of  the  code. 
that 

in  many 

is  actually 

can  be  useful 

error  handling, 
(which 

It  may  seem  surprising 
as  Datalog 
ware  systems.  We  emphasize 
are  not  complete  descriptions 
they 
suppress  many  “details” 
straints, 
in  the  database 
eral  processors).  However, 
of  one  important 
We  conjecture 
ware  understanding 
high-level 
tions  would  be  provided 
this  would  be  the  case,  for  example, 
generated 
software 
case.  We  note 
cially 
important 
harder 
also  more 
equivalent 
quires  understanding 

that 
for  older  systems, 

likely 
functionality-an 

automatically 
systems, 

to  maintain. 

descriptions. 

along  with 

such  high-level 

can  be  facilitated 

by  such  abstract, 
descrip- 
the  source  code: 
if  the  source  were 
For  older 
to  be  the 
is  espe- 
to  be 
are  are 
to  be  replaced  by  a  newer  system  with 
re- 

from  a  specification. 
is  unlikely 
understanding 
as  they 

enterprise  which  again 

These  “legacy” 

however, 

software 

systems, 

systems 

Ideally 

large 

soft- 

tend 

this 

system. 
recovery  problem  we 
view 
spec- 
of 

is  reason 

is  to  automatically 

here 
construct 
like  the  one  above.  This  particular 

so  that  specification 

there 
specifications 

recovery  problem 
The  domain 

will  consider 
specifications 
ification 
reasons. 
ing,  as  the  implementation 
complex.  On  the  other  hand, 
enough 
in  particular, 
abstract 
views.  Another 
tem  being  studied 
C)  it  is  highly  modular; 
ior  of  this 
large  system 
moderate-sized 
population 
a  successful 
esting,  and  is  large  enough 
specification 

of  problems 
discovery 

specification 

advantage 

recovery 

is  attractive 

is  broad  enough 

for  a  number 
to  be  interest- 
of  a  view  can  be  arbitrarily 
is  constrained 
is  often  possible; 
concise 
do  indeed  exist  for  many  of  the 
the  subsys- 

the  domain 
recovery 

is  that  although 

to  believe 

that 

into 

than 
insight 

l,lOO,OOO lines  of 
the  behav- 
can  be  gained  by  solving  many 
The 
that 
inter- 
for 

tool  would  be  practically 

is  also  important 

to  form  a  useful 

problems. 

recovery 

enough 

testbed 

is  huge  (more 
hence 

techniques. 

the  existing 
the  specification 

To  summarize, 

Learning  View  Specifications 

tuples 

and  all 

(This  process 

is  sometimes 
construct 

view  specifi- 
the  code 
to 

to  recovering 
First, 
execute 

Second, 
the  materialized 

The  approach  we  propose 
cations 
is  the 
find  all  tuples 
DB. 
the  view  v.) 
all 
in 
amples, 
are 
(either 
ples.  Third, 
dataset, 
ification 
plex  one;  however 
“inductive 
logic  programs 
Muggleton 

following. 
in  a  view  v,  given  a  specific  database 
called  materializing 
in  which 
a  dataset 
ex- 
view 
exam- 
this 
as  the  spec- 
com- 
of 
learn 
1990; 

logic  programming” 
from  examples 
and  Feng,  19921). 

view  are  positive 
the  materialized 
negative 

systems  which 
(e.g.,  see  [Quinlan, 

implicitly 
learn  a  Datalog 

not 
or  explicitly) 

and  return 
of  0.  The 

learned  definition 

are  currently 

is  the  most 

of  v  from 

a  number 

definition 

learning 

tuples 

there 

step 

this 

in 

Learning  specifications  with  FOIL 
To  make 
ple  view  vi  .2  Suppose 
rived  from 
the  relation 

let  us  return 
the  materialized 
r)  is  as  follows: 

this  idea  concrete, 

to  our  exam- 
view  v1  (de- 

Materialized 

view  v1 : 

p&fgEJq 

1 rd 

921-31-3273 
42 l-43-4532 

Relation  T: 
I  fname 
I  dept 
s&s  jane 
dave 
sales 

From 
target 

the  view  one  can  derive 
relation 

vi: 

I 

I  mi 
q 
q 

I  lname 
jones 
jones 
these  examples 

of  the 

+v~  (421-4.34532,chve,jones,q) 
+VI  (921-31-327.9,  jane,  jones,  q) 

and  also  using 
inductive 

the 
[Quinlan, 

knowledge, 

these  examples, 

system  FOIL 
specification 

Using 
background 
ming 
correct 
We  say  “correct” 
actual  RC  view, 
implementation. 
scribes 
considerably  more  concise 
which 
in  this  case  contains 
C-and 

is  arguably 

hence 

the 

19901  will  produce 

the  relation  T as 

logic  program- 
the 
r(A,  E, B, D,  C). 
to  an 
de- 
is  also 

correctly 

is  isomorphic 

The  specification 

than 

the 

implementation- 

80  non-comment 

lines  of 

also  more  understandable. 

~1 (A,  B,  C, D)  + 

as  this  example 
and 

the  specification 

Note  that 

space  dramatically 
background 
Restricting 
databases 
are 
ing  the  relevant 

in  this  example  we  reduced  FOIL’s  search 
relevant 
in  DB. 
as  RC 
find- 

single 
than  all  relations 
in  this  way  is  essential, 
automatically 

by  providing 
r,  rather 

relation 
the  search 

Fortunately, 

large. 

the 

relations 

is  easy,  as  computer-readable 

2Except  when  otherwise 

paper  are  isomorphic 
fiers  have  been  changed: 
and 
etary 
information, 
as  RC  identifiers 
appear 
pedagogical 
specifications 

as  examples. 

indicated, 

the  examples 
to  real  RC  views.  However, 

of  this 
identi- 
to  avoid  divulging  propri- 
confusion, 
to  avoid  reader 
cryptic 
For 
view 

to  an  outsider. 
the  simplest 

in  part 
in  part 
rather 

reasons,  we  have  also  used 

Automated  Reasoning 

143 

documentation 
are  accessed  by  which  RC  views. 

exists  describing  which  RC  relations 

FOIL 

exploratory 
several 

on  this  small  exam- 
study 
limita- 
to 
but 
[Pazzani 
is  shared  by  GOLEM 
in- 
system.)  However,  many  of 

of  training 

examples, 

is  known 

relations 

using  real  RC  views  revealed 

Although 

FOIL’s  performance 

the  number 

an  more  detailed 

the  arity  of  background 

for  noise-free  problems, 

ple  is  encouraging, 
conducted 
tions.  First, 
scale  well  with 
poorly  with 
and  Kibler,  19921.  (This  problem 
[Muggleton 
ductive 
the  relations 
e.g.,  the  36  views  used 
used  18  relations  with  arity  greater 
than  25. 
lations  with  arity  greater 
FOIL 

in  the  RC  database 

logic  programming 

problem 

with 

have 
in  our  exploratory 

large  arities- 
experiments 

than  10  and  9  re- 

and  Feng,  19921,  another  well-known 

the  materialized 
examples. 

FOIL 
generating 

contains 
negative 

closed  world 

is 

in  principle 

second 
that 

A 
fact 
negative 
for  automatically 
the 
ing 
technique 
this 
tice 
it 
amples 
moderately 
able 
t 
examples; 
tive 
v&4B,W,WW) 

high 
to  correctly 

tuples  FOIL 

is  impractical 
to  prevent 

u(A,B,C,D),w(A,G,F,E,H) 

even  with 
learns 

stems 
view  provides 

from 

the 
no  explicit 
a  mechanism 
examples, 

over-generalization 

to  create 

assumption; 

appropriate, 
enough 

us- 
however,  while 
in  -prac- 
ex- 
of 
is  un- 
the  view  ~3 (A,&  C, D,E,F,  G) 
of  136 
nega- 

from  a  dataset 
of  360,000 

negative 
on  views 
FOIL 

For  example, 

sample 

a 
the  overgeneral 

specification 

arity. 
learn 

+  u@,B,C,D). 

and 

like, 

of  FOIL 

in  learning; 

is  that  due 

there  are  many 

A  final  disadvantage 
the 

to  coding 
conventions 
regularities 
across  view  recovery  problems  which  could  potentially 
be  exploited 
nism  for  using  such  constraints. 
it  happens 
posed  of  generative 
is  the  head  of  a  clause 
always  appears 
However,  FOIL  can  and  often  does  hypothesize 
generative 

however,  FOIL  has  no  mecha- 
As  a concrete  example, 
always  are  com- 
when  v(Xr  ,.  . . ,Xn) 
each  Xi 
in  the  body  of  the  clause. 
non- 

that  RC  view  specifications 

in  a  view  specification, 

specifications. 

clauses-i.e., 

somewhere 

our  exploratory 

to  recover  view  specifications, 

Learning  specifications  with  Grendel2 
To  summarize 
that 
were  needed 
incorporating 
tive  logic  programming 
nisms 

and  for 
induc- 
system  which  has  such  mecha- 

study,  we  concluded 
better  mechanisms 

over-generalization 

domain-specific 

for  preventing 

is  Grende12. 

constraints. 

One 

system 
the  usual 

to  Grendel 
set  of  positive 

[Cohen, 
and 
an  explicit 

takes  as  input 

Grendel2 

is  a  successor 

to 

In  addition 
examples,  Grendel 

19921. 
negative 
description 
i.e.,  the  intended 
in  a  formalism 
mar 
mars.  Grendel’s  hypotheses 
antecedents 
user. 

are  sentences 

of  the  hypothesis 

space 
bias  of  the  learning 
called  an  antecedent 

to  be  searched- 
system-written 
description 
context-free 

grum- 
gram- 
are  sets  of  clauses  whose 
by  the 

of  an  ADG  provided 

(ADG).  ADGs  are  essentially 

144 

Automated  Reasoning 

ADGs  provide 

“theory-guided” 
and  Kibler, 
certain 
biases” 
a  generalization 
has  been  proposed 
are  analogous 
and  Shapiro, 

19861. 

a  way  of  describing 
learning 

systems 

like  FOCL 

19921;  however 

they  cannot 

biases  used 

in 
[Pazzani 
easily  express 
“language 

describe 

of  ADGs 

[Cohen,  19931.  Augmented 

and  Feng,  19921 

[Muggleton 
called  “augmented  ADGs” 
ADGs 
[Sterling 

clause  grammars 

to  definite 

other  biases.  To  concisely 
like  ij-determinacy 

Grendel2 

is  an  extension 

of  Grendel 
mented  ADGs.  Like  Grendel,  Grendel2 
like 
its  hypothesis 
output 
of  which 

is  a  sentence 

is  in  general 

of  Grende12 

to  search 

technique 

that  uses  aug- 
uses  a  FOIL- 
The 
space.3 
a  set  of  clauses, 
each 

of  the  augmented  ADG. 

By  applying  Grende12 
to  exploit 
In  Grendel2’s 

we  were  able 
constraints. 
not  simply  a  tuple 
to  which  extra 
cally,  each  view  tuple 
tuples 
tags  were  obtained 
“instrumentation” 
tines.)  For  example, 

read 

datasets, 
in  the  materialized 

to  the  view  recovery  problem, 
of  domain-specific 
a  number 
each  example 
is 
view,  but  a  tuple 
specifi- 
is  tagged  with  the  list  of  database 
(These 
by  adding  additional 

has  been  attached: 

this  view 

tuple. 

automatically 
code  to  the  database 

rou- 

the  dataset 

for  01  above 

interface 
is 

in  constructing 

information 

+ trace(vl(421-43-4532, 

dave, jones,  q), 

[r-(421 -4%4532,sales, 

dave, jones,  q)]). 

+  trace(vl(921-91-327.3, 

jane,  daub,  q), 
[r-(921-313273,saIes,jane,davis,q)]) 

An  augmented 

ADG  was 

then  written  which  gen- 

types  of  view  specifications- 

types  of joins, 

certain 
which  also  encodes 

One  constraint 
the  database 
access 
traces  of  each  view 

is  that 

and  combi- 
of 
a  number 
clauses 
in 
tu- 
in  the  sense  de- 

certain 

common 

constraints. 
by 

the  ADG  must 
the 

erates 
namely,  projections, 
nations 
thereof-and 
additional 
generated 
an  order  consistent  with 
ple.  Also,  clauses  must  be  generative, 
fined  above,  and  use  only 
These  constraints 
ing  ADGs: 
the 
in  this  paper 
contains 
just 
code. 

(the  one  used 
11  rewrite 

largest  ADG  used 

relevant 

in  the  experiments 

for  Grendel/MD, 

rules  and  about 

below) 
30  lines  of 

can  be  expressed  quite  compactly 

us- 

database 

relations. 

No  negative 
by)  Grende12. 
prevent 
generality 
that  hypotheses 

examples 
Instead 

are  given 

to  (or  constructed 

of  using  negative 

examples 

to 

over-general 

hypotheses 

is  implicitly 

constrained 

from  being  produced, 
by  the  requirement 

be  sentences 

of  the  ADG. 

The  augmented  ADG  also  generates 
as  shown  on  the  left-hand 
is  convenient, 

cial  format, 
This 
format 
mnemonic 
field  name 
in  a  view  or  relation; 
added 
specification 

to  the  specification, 

on  the  right-hand 

is  associate  with  each  column 
field  names 
can  be  easily 
these 
as  is  shown  by  the  variant 
1.  (For 

side  of  Figure 

clauses 
in  a  spe- 
side  of  Figure  1. 
a 

as  in  the  RC  subsystem 

this 

is  different 

that 
in  [Cohen, 

3Note 
described 
augmented  ADGs  were  converted 
passed 

to  Grendel. 

19931, 

from 

the 

learning  method 

in  which  a  restricted 

into  simple  ADGs 

class  of 
and 

trac~(v~(A,B,C,D),[r(E,F,G,H,I)I) + 

r(&$,G,H,I), 
B=G, 
C=H, 
D=I. 

vr(Vssnum,Vfirst,Vlast,Vmi) 

+ 

Rid=Vssnum, 
r(Rid,Rdept,Rfname,Rlname,Rmi), 
Vfirst=Rfname, 
Vlast=Rlname, 
Vmi=Rmi. 

Figure 
1:  Specifications 
right,  a  more  readable 
field  names. 

generated 

by  Grende12.  On  the 

left,  a  specification 

version  of  the  specification, 

formed  by  removing 

“trace” 

as  produced 
information 

by  the 

learner.  On 

the 

and  adding  mnemonic 

removed 

readability, 
been 
grammers 
than 
more 
Addition 
ing  existing 
RC  database.4 

column 
readable 

information 

from 

this  specification.) 

prefer 

to  think 

positions,  we  believe 

associated  with 

the  traces  has 
Since  RC  pro- 
rather 
in  terms  of field  names 
format 
to  be 
the  domain. 
us- 
on  the 

this 
familiar  with 

documentation 

is  automatic, 

names 

to  persons 

of  these  mnemonic 
computer-readable 

Evaluation  of  Discovery  Systems 
evaluated 
they  produce, 

tools  are  typically 

learning 

that 

is  appropriate 

While  machine 
the  accuracy  of  the  hypotheses 
metric 
the  system 
the  methodological 
a  discovery 

is  prediction. 

question: 

only  when 

by 
this 
of 
In  this  section  we  will  address 
how  should  one  evaluate 

the  final  purpose 

system  of  the  type  described 

above? 

This  question 

is  made  more  difficult  by  the  fact  that 
in  the  RC  database. 

redundantly 

is  often  stored 

data 
To  take  a  simple 
example, 
have  the  following  view  and  relation: 

artificial 

suppose 

that  we 

Materialized 

view  214: 

Relation 

n: 

~~1 

is  an  integrity 

If  there 
field  of  relation 
then 
view  214: 

the  following 

constraint 
n  to  be  identical 

are  equally 

valid 

the 

requires 

that 
id 
to  the  Zname  field, 
of 

specifications 

v4  (First,  Last)  + 

n(Fname,  Lvaame, Login), 
First=Fname, 
Last=Lname. 

v4 (First,  Last)  + 

n(Fname,  Lname,  Logan) 
First=Fname, 
Lcbst=Login. 

It  is  not  at  all  obvious  what 
do  in  this  case.  We  will  assume  here 

the  discovery 

system  shoulld 
speci- 

that  both 

41n  passing,  we  note 

that 

the  ordering  of  the  conjuncts 

is  not  arbitrary, 

in  the  body  of  this  clause 
knowledge  about  which  view  and  relation 
Literals 
Prolog 
mimics 
an  indexed 

in  the  body  are  ordered 
evaluation 
the  operation 

the  operation 

order, 

of  the  actual  C  code 

read. 

but  is  based  on 
fields  are  indexed. 
the  usual 

of  a  specification 
in  performing 

so  that  following 

fications 
discovery 

are  of  interest 
system  would 

to  the  user,  and 
recover  both  of  them. 

that  an  ideal 

that 

the  sense 

To  be  precise, 

let  us  fix  a  specification 

language 
is  a  set  of  specifications 
can  be  considered 
legal  database, 

ic.  For  every  view  21, there 
in  L  that 
CorrectSpecsL((v) 
in 
for  every 
produce 
ment  ation  of  ZI.  Assuming 
of  the  system 
each  view, 
be  restated 
task:  given 
tions  of  view  ZI ?”  the  discovery 
ProposedSpecs( 
CorrectSpecsc 

correct 
they  will 
the  same  set  of  tuples  as  the  actual  C  imple- 
the  goal  of  the  user 
of 
can  thus 
retrieval 
specifica- 
a  set 
to 

recovery  problem 
the  specification 
quite  naturally 
as  an  information 
the  query  “what  are  the  correct 

is  to  find  all  correct 

ideally  be  identical 

system  will  return 

which  would 

specifications 

that 

(v). 

appear 

(v)  that 

of  things 

information 

the  performance 

is  the  percentage 

retrieval  measures 

If one  knew  the  actual  value  of  CorrectSpecsL 
of  a  discovery 

(v),  one 
system 
of  re- 
in 
it 
that 
in 
(w);  it 
specifica- 
for  the  learning 
discussed 
is  always 
set,  and  hence  high  recall  can  be  obtained 

could  measure 
via  the  standard 
call  and  precision.  Recall 
CorrectSpecsc 
measures 
are  proposed. 
ProposedSpecs 
measures 
tions 
algorithms 
a  singleton 
only 

the  percentage 
Precision 
that 

the  number  of  correct  z)s.  incorrect 

in  ProposedSpecs( 
specifications 

of  correct 
is  the  percentage 

above,  ProposedSpecs 

that  are  proposed. 

in  CorrectSpecsc 

if  CorrectSpecsL 

(w)  is  usually 

a  singleton 

of  things 

(Notice 

appear 

set .) 

that 

to  determine 
if  a  second 
to  s  for  all  legal  databases 

it  is  not  easy 
for  a  view  21: although 
__ 
. - 
s  by  manually 
specifica- 
requires 
enforced  by  the 
Thus, 
like 
A  routine  was 

documented. 

Unfortunately, 

in  the  RC  subsystem 

*  1 to  determine 

CorrectSpecsr.(v) 

specification 

constraints 

of  the  integrity 

j one  can  find  one  correct 
reading 
the  code, 
tion  s’  is  equivalent 
knowledge 
system,  which  are  not  completely 
to  evaluate 
approach 
written 
view  ZI and  enumerates 
fications 
ConsistentSpecsc(v, 
cation 

allowed  by  the  grammar. 
DB).  Recall 

is  by  definition 

to  evaluate 

that 

specifications. 

all  consistent 

the  system,  we  used  a  cross-validation 

takes  a  database  DB  and  a  materialized 

one-clause 

speci- 
Let  us  call  this  set 
specifi- 
the  correct 

that  a  correct 

one  that  materializes 

Automated  Reasoning 

145 

view  for  all  databases. 

Hence 

CorrectSpecsc 

(v)  E  n  ConsistentSpecsL(v, 

DBj) 

the 

index 

where 
Thus  one  can  approximate 
a  series  of  databases  D&,  DB2, 
the  rule 

j  runs  over  all  legal  databases  DBj. 
(v)  by  taking 
. . . ,  DBk  and  using 

CorrectSpecsc 

k 

CorrectSpecsc 

(v)  F3  n  ConsistentSpecs,:(v, 

DBi) 

i=l 

our 

For 

the  system 

we  collected 

using  different 

using  Equation 

experiments, 
To  estimate 

from  one  database  DB*, 

system  on  a  view  21, we  used 

recall  and  precision, 
CorrectSpecsc 

several 
the  recall  and  precision 

databases. 
discovery 
find  ProposedSpecs 
then  computed 
to  approximate 
repeated 
the  results  were  averaged.  6  This  evaluation  metric 
much 
suring 
out  data, 
100%  correct  on  a  set  of  holdout 
wards 
text:  namely, 
ability  100%  correct. 

(1) 
RC 
of  a 
to 
and 
1 
(v).”  This  process  was 
and 
is 
than  mea- 
on  hold- 
if  it  is 
re- 
con- 
that  are  with  high  prob- 

like  cross-validation; 
the  predictive 

the  hypotheses  most  valuable 

databases  DB*, 

the  hypotheses 

of  a hypothesis 

in  a  discovery 

a  hypothesis 

is  evaluated 

by  seeing 

databases. 

however, 

accuracy 

training 

rather 

This 

As  an  example, 

if  we  report 

a  precision 

of  75%  for  a 

the 

learner 

by  running 

view  V, this  means  on  average  75%  of  the  specifications 
obtained 
on  a  single  database 
were  100%  correct  on  all  the  sample  databases. 
report  a  recall  of  50%  for  w this  means 
half  of  the  specifications 
the  sample  databases 
learner  on  a  single  database. 

If  we 
that  on  average 
that  are  consistent  with  all  of 
the 

can  be  obtained 

by  running 

Experimental  Results 

is  still 

datasets, 

in  progress; 

in  this  paper 

and  improving 

that  encodes  domain-specific 

in 
in  the  process  of  collect- 
the  augmented 

The  work  reported 
particular  we  are  still  engaged 
ing  additional 
ADG 
section,  we  will  describe 
compared 
rithms. 
used  with 
ploratory 
knowkedge  of  the  views  used  as  benchmarks 
other  words, 
learning 

In  this 
in  which  we 
algo- 
the  ADGs 
the  ex- 
they  were  developed  without  any 
In 
test  of  the 

them)  were  based  only  on  data 
study; 

three  different  GrendelZbased 
these  algorithms 

knowledge. 
study 

this 
systems. 

is  a  purely 

a  controlled 

Importantly, 

prospective 

learning 

below. 

from 

(and 

thus 

5This  approximation 
all  enumerating 

is  relatively 
consistent 

expensive 
specifications  must  be 
one-clozrse 
Fortunately  many  RC  views  can  be  specified 

only  consistent 

to  compute 

thus  we  generated 

because 
enumerated; 
specifications. 
by  a  single  clause. 

‘Ideally 

the  process 

is  repeated 

using  every  possible 

for  training.  However, 

in  the  actual  experiments, 

database 
it  was  sometimes 
more  databases. 

the  case  that  a  view  was  empty 
Such  databases  were  not  used  for  training. 

in  one  of 

146 

Automated  Reasoning 

In 

up 

we  used 

containing 

and  contain 

it  is  difficult 

to  90  fields, 

implementation 

the  experiments, 

in  size  from  5.6  to  38  megabytes, 

four  RC  databases, 
and  19 bench- 
involve 
be- 
to  mea- 
of  any  single 

the  views  have  an  average  of  747  non-comment 
in  top-level  module  of  their  C  implementations, 
longest 

ranging 
mark  views.  The  views  contain  up  to  209  fields, 
relations 
tween  one  and  531  tuples.  While 
sure  the  size  of  a  complete 
view, 
lines 
the 
long,  and 
suring 
tions,  we  also  measured 
views  for  which  any  specifications 
this 
table  below 
scope.  All  of  the  learning 
section 
falls  outside 

lines 
to  mea- 
specifica- 
of  benchmark 
could  be  recovered; 
in  a  column 
labeled 
in  this 
described 
abort  with  an  error  message  when  a  problem 

top-level  C  implementation 

the  recall  and  precision 

the  percentage 

of  recovered 

their  scope. 

is  210  lines. 

the  shortest 

In  addition 

algorithms 

is  shown 

is  2904 

in  the 

it  does  succeed,  however, 

The  result  of  applying  Grende12 

and  using  an  augmented  ADG  written 

to  this  set  of  bench- 
in  the  first  line  of  Table  1.  For  this  set 
on 
to 
for  just  under  a  third  of  the  views. 
it  achieves  over  80% 

study,  Grendel2 

is  able 

is  shown 

marks 
of  problems, 
the  basis  of  our  exploratory 
learn  specifications 
When 
recall  and  precision. 
We  also  evaluated 

sions  of  Grendel’t.  To  motivate 
that  when  many  consistent 
makes  a  more  or  less  arbitrary 
useful  alternative 
return 

instead 
Unfortunately, 

the  entire 
when 

is 
there  may  be  an  enormous 

would  be  for  the  learning 

hypotheses 

choice  among 

the  performance 

the  first  extension, 

of  two  exten- 
note 
exist,  Grende12 
them.  A 
to 
system 
set  ConsistentSpecs,-((v,  DB). 
training 
there 
of  consis- 
outputting 
To  address 
for  view 
large  sets  of  spec- 
As  an  example, 

a  factored 
certain 
presented. 

insufficient 
number 
In  these  cases  directly 
is  not  desirable. 
DB) 

form 

data, 
specifications. 
tent 
ConsistentSpecsc(w, 
this  problem  we  developed 
specifications 
which  enables 
ifications 
the  factored 

to  be  compactly 

specification 

US (VBufid,  VAddr,  VLength,  VBytes) 

t 

R ICe y=  VBufid, 
p(RICey,  RLoc,  RLen,  RBytes), 
VAddr=RLoc, 
(  VLength=RLen 
(  VBytes=RLen 

;  VLength=RBytes 
;  VBytes=RBytes 

), 

). 

is  shorthand 
sible  pairing 
and  RBytes. 

for  four  specifications, 
of  the  variables 

one  for  every  pos- 
VLength,  VBytes,  RLen 

The 

row  of  Table  1  labeled  Grendel2/M 

of  Grende12 

that 

of  all  consistent 
though  Grendel2/M 

sults  for  an  extension 
representation 
tions.  Even 
clause  view  specifications, 
Grende12; 
what  suprisingly,  Grendel2/M 
precision, 
significant. 

the  recall 

however, 

although 

single-clause 
is  restricted 
the  same 

it  has 

is  now  perfect. 
also  has  slightly 

shows 

re- 
finds  a  factored 
specifica- 
to  single- 
scope  as 
Some- 
better 
statistically 

the  difference 

is  not 

The  goal  of  the  second 

extension  was 

the  scope  of  Grendel2.  Our  exploratory 
that  often  data 
copied 

is  not  simply 

to 
study 

increase 
showed 
from  a  relation 

Learner 
Grendel2 
Grendel2/M 
Grendel2/MD 

Scope 
31.6% 
31.6% 
63.1% 

Recall 
83.3% 
100.0% 
100.0% 

Precision 
83.3% 
87.5% 
61.0% 
82.2% 
52.2% 

views 

-all 
-views 
-remaining 

solved  by  Grendel2/M 

views 

Table  1:  Results 

for  Grende12  and  extensions 

instead 

to  a  view; 
formed.  For  example, 
216 is  a  copy  of  Q with  every  value  of  “0”  in  the 
column 

some  simple  conversion 
in  the  specification 

replaced  by  the  empty 

step 
is  per- 
below,  view 
third 

string. 

space  used  by  Grendel/MD; 
be  due 
the  views  requiring 
from 

the  data  provided. 

fact 

the 

to 

the  greater  part  seems 
set  of  benchmarks) 
that 
this 
determinations 
are  harder 

(in 

to  learn 

to 

v6 (VProblemCode,  VSeverity,  VHelpBufId)  + 

RPCode=  VProblemCode, 
q(RPCode,  RLevel,  RTextBufId), 
VSeverity=RLevel, 
zero%zullstr(RTextBufId, 

VHelpBBzqflc). 

zero2nuldstr(O,“). 
zero2nulls 

tr(Id,  Id)  +  Id#  0. 
on 

fails 

such 

views; 

learning 

typically 

functions 

are  performed.  We  addressed 

further- 
conversion 
like 
since  a  wide  range  of  con- 
this  problem  by 

Grendel2 
more, 
views  with 
xero2nuZZstr  is  very  difficult 
versions 
extending  Grendel2/M 
that  contain  determinations. 
two  variables  X  and  Y  is  denoted  Y  4  X,  and 
cates  that 
from 
be  specified 

view  specifications 
between 
indi- 
derived 
215 could 

the  value  of  X.  Using  determinations, 

the  value  of  Y  can  be  be  functionally 

A  determination 

to  generate 

v6 (VProbdemCode,  VSeverity,  VHeipBufId)  +- 

RPCode=  VProblemCode, 
q(RPCode,  RLevel,  RTextBufId), 
VSeverity=RLevel, 
VHedpBufId  +  RTextBufId. 
with  determinations 

the  Datalog 

Specifications 
stract 
than 
Grendel; 
rialize  a  view.  However, 
program 

understanding.7 

in  particular, 

specifications 

they  cannot 

they  are  plausibly 

generated 

are  even  more  ab- 
by 
to  mate- 
useful 
for 

be  used 

The  row  labeled  Grendel2/MD 

of  Table  1 shows  re- 

than 

Determina- 

to  more 

for  this  extension 
increase 

of  Grendel2/M.s 
learner 
to  around  60%-much 
by  Grendel2/M. 

sults 
tions 
the  scope  of  the 
60%  but  also  decreases  precision 
less  than 
However, 
the  difference 
obtains 
Grendel2/M, 
it  alone  can  solve.  Thus,  only  some  of  the  decrease 
precision 

the  87.5%  precision  obtained 
closer  examination 
than 

but  only  52%  recall  on  the  problems 

82%  recall  on 

the  problems 

also  solvable 

Grendel2/MD 

of  the  data 

to  be  due 

it  appears: 

larger  hypothesis 

appears 

to  the 

is  less 

shows 

by 
that 
in 

that 

7Note  also  that  actually  materializing 

procedure; 

hence 

using 

the  metrics 

a  view  is  not  part 
can 
and 

these  specifications 
recall, 

of  scope, 

of  the  evaluation 
also  be  evaluated 
precision. 

8The  grammar 

allows  only  determinations 

and  a  single  variable  Y,  or  between  X  and  a  constant 

between  X 
value. 

Interestingly, 

there  seems 

to  be  little  correlation 

of  the  C  implementation 

the  complexity 

the  performance 

tween 
view  and 
This 
based  on  learning  may  be  a  useful  complement 
ods  based  primarily 
on  source  code  analysis. 

learning 
systems.g 
recovery  methods 
to  meth- 

specification 

suggests 

of  the 

that 

be- 
of  a 

Related  work 

as  an 
code, 
of  all 
in  gen- 
between  our 

recovery  has  been 

frequently 

in  the  software  engineering 

community 

or  replacing 

hard-to-maintain 

a  detailed 

discussion 
Instead  we  will  discuss 

and  design 

Specification 
proposed 
aid  in  maintaining 
and  space  does  not  permit 
previous 
eral  terms 
methods 

related  work. 

differences 

the  most 
and  known 
techniques 
rely  mostly 
(For  example, 

important 
techniques. 
for  extracting 
on  deductive 
see  Biggerstaff 

from 
of 

analysis 

techniques 

and  Lano 

[1990].)  The 

[1990],  Breuer 

specifications 
Known 
static 
software 
[1989],  Kozaczyn- 
code. 
[1991],  or  Rich 
ski  and  Ning 
and  Wills 
share 
some  common  ground  with  this  previous  work;  notably, 
being  provided 
the  methods 
the  likely  form 
with  a  good  deal  of  information 
of  the  specifications 
dif- 
are  ex- 
ference  from  previous  work  is  that  specifications 
the 
tracted 
behavior 
about 

reasoning 
than  deductive 

are  also  knowledge-based, 

of  the  code,  rather 

about 
reasoning 

being  extracted. 

the  code  itself. 

of  this  paper 

The  primary 

inductive 

primarily 

about 

using 

their  main  goal  is  to  augment 

One  previous  method 
is  described 

traces 

gram 
However, 
with 
gram  such  as  timing 
rather 

information 

than 

to  reduce 

about 

Our  experimental 

specifications 
A  good  deal  of  research 
the 

problem 

related 

dynamic 

properties 

that  makes  some  use  of  pro- 
[1993]. 
by  Sneed  and  Ritsch 
static  analysis 
of  a  pro- 
and  test  set  coverage, 
of  static  analysis. 
view 
views. 
to 
logical  data  mod- 

has  also  been 

in  recovering 

devoted 

information 
the  complexity 
results  were 

of  recovering 

from  C  code  and  materialized 

‘The  C  code  for  the  views  successfully 

learned  by  Gren- 
717  non-comment 
the 
lines)  was  one  of  those  learned.  Code  for 

long, 

lines 

and 

del2/MD 
averages 
longest  view  (2904 
the  unlearnable 
significantly 
and  the  shortest  unlearnable 

views  averages 
the  average 

from 

(not  statistically 

lines 

813 
length  of  learnable 
view  is  only  354  lines. 

views) 

Automated  Reasoning 

147 

els  from  databases. 
have  been  proposed 
automated 
Premerlani 
automatic. 

However,  most  methods 

that 
task  are  only  partially 

this 

for 

[Aiken 
and  Blaha,  19931,  while  our  method 

et  al.,  1993;  Hainaut 

et  al.,  1993; 
is  fully 

using 

learning 

high-level 

to  extract 

as  an  aid 
Based  on 

concise, 
in  understanding 
the  assumption 

Conclusions 
To  summarize,  we  have  proposed 
niques 
software 
system. 
specifications 
actly 
method 
precision 
ing  this  methodology,  we  demonstrated 
can  extract 
for  about 
modules 
sion. 

tech- 
specifications 
of 
a  large  software 
the  “useful” 
ex- 
a 
recadl  and 
system.  Us- 
that  Grende12 
of  the 
from  a  test  suite  with  high  recall  and  preci- 

the 
for  estimating 
as  well  as  the  scope  of  a  learning 

that  with  high  probability 

we  outlined 
the 

implementation, 

specifications 

agree  with 

are  those 

test  data 

one-third 

from 

that 

Two  extensions 

it 

allows 

improve 

inductive 

which 
one  which 
and  another  which  allows 
cluding  determinations. 
unique 
among 
In  combination, 
to  be  extracted 
views  with  perfect 
60%.  These 
results 
they  were  obtained 
(more 
system, 
learning 

and  because 
system 

than  one  million 

for  nearly 

these 

its  performance 

of  Grende12  were  also  described 
as  a  discovery 
system: 
a  set  of  hypotheses, 

to  output 

it  to  learn  specifications 

Both  extensions 
logic  programming 

appear 

in- 
to  be 
systems. 
allow  specifications 
of  the  benchmark 

techniques 

two-thirds 

recall,  and  precision 
are  especially 
using 

test  cases  drawn 

encouraging 

lines  of  C)  real-world 
they  are  a  prospective 

of  better 

than 
because 
from  a  large 
software 
test  of  a 

still  under  development. 

These  results  have  implications 

community 

Specification 

engineering 
munity. 
tant  application 
of  this  paper 
suggest 
tions  can  be  extracted 
However, 
cation 
encountered 
It  seems  probable 
are  likely 

that 
to  raise  many 

recovery  problems 

and  the  machine 

recovery 

is  a  potentially 

learning 

both  for  the  software 
com- 
impor- 
learning. 
The  results 
classes  of  specifica- 
available  methods. 
in  specifi- 
those 
from 
tasks. 
this  area 

learning 
into 

research. 

encountered 
are  quite  different 

machine 
inquiries 
for  further 

further 
topics 

area  for  machine 
that  broad 
by  currently 

the  research  problems 

in  “mainstream” 

efforts  of  Hari  Vallanki, 

Acknowledgements 
This  research  would  have  impossible  without 
collection 
Bryan  Ewbank,  David  Ladd, 
also  grateful 
to  Jason  Catlett 
advice  on  methodology, 
Hall  for  comments 

on  a  draft  of  this  paper. 

and  to  Prem  Devanbu 

the  data- 
Sandra  Carrico, 
I  am 
for 
and  Bob 

and  Ken  Rehor. 
and  Cullen  Schaffer 

References 

P.;  Muntz,  A.;  and  Richards, 

Aiken, 
framework 
tems. 
ing.  IEEE  Computer 

for  reverse  engineering 

In  Working  Conference 

Society  Press. 

R.  1993.  A 
of  dod  legacy  sys- 
on  Reverse  Engineer- 

148 

Automated  Reasoning 

and 

editors 

on  Re- 

Gregory; 

challenge 

Research 

discovery 

knowledge 

engineering 

and  reuse. 

for  mainte- 

on  Inductive 

An  overview. 

IEEE  Computer 

recovery 
36-49. 

Piatesky-Schapiro, 

IEEE  Computer 

1991.  Knowledge 

In  Piatesky-Schapiro, 

Logic  Programming, 

from  code:  Reverse 

specifi- 
techniques. 

of  ILP 
of  the  1993 

In  Working  Conference 

of  Software  Maintenance: 

In  Proceedings 
on  Machine 

understanding: 
Journal  28(2):294-306. 

into 
of  the  Ninth  Interna- 
Learning,  Aberdeen, 

and 
in 
Gre- 
1991,  Knowledge 

Biggerstaff,  Ted  J.  1989.  Design 
nance 
Breuer,  P.  T.  and  Lano,  K.  1991.  Creating 
cations 
Journal 
Practice  3: 145-162. 
Cohen,  William  W.  1992.  Compiling 
an  explicit  bias. 
tional  Conference 
Scotland.  Morgan  Kaufmann. 
Cohen,  William  W.  1993.  Rapid  prototyping 
systems  using  explicit  bias.  In  Proceedings 
IJCAI  Workshop 
Chambery, 
France. 
Corbi,  T.  A.  1989.  Program 
for  the  1990s.  IBM  Systems 
Frawley,  William; 
Matheus,  Christopher 
databases: 
gory  and  Frawley,  William, 
in  Databases.  The  AAAI  Press. 
Discovery 
M.;  Tonneau, 
Hainaut, 
C.;  and 
J.-L.;  Chandelon, 
to  a  theory  of  database 
Joris,  M.  1993.  Contribution 
reverse  engineering. 
verse  Engineering. 
Kozaczynski,  W.  and  Ning, 
wedge  based  environment 
engineering 
ternational  Conference 
Muggleton, 
induction 
gramming.  Academic 
Parikh,  Girsh  and  Zvegintzov,  Nicholas, 
Tutorial  on  Software  Maintanance. 
Society  Press. 
Pazzani,  Michael  and  Kibler,  Dennis  1992.  The  utility 
of  knowledge 
learning.  Machine  Learning 
9(l)* 
Premerlani,  W.  J.  and  Blaha,  M.  R.  1993.  An  ap- 
proach 
In  Working  Conference 
IEEE  Computer 
Quinlan, 
from  relations.  Machine  Learning  5(3). 
Rich,  Charles 
program’s  design:  A  graph-parsing 
Software  82-89. 
Sneed,  H.  M.  and  Ritsch,  H.  1993.  Reverse  engineer- 
ing  via  dynamic 
Reverse  Engineering. 
Sterling, 
of  Prolog:  Advanced  Programming 
Press. 

J.  1990.  SRE:  A  knol- 
re- 
of  the  11th  In- 

and  Feng,  Cao  1992.  Efficient 
In  Inductive  Logic  Pro- 

In  Proceedings 
on  Software  Engineering. 

on 
Society  Press. 
1986. 
The  Art 
Techniques.  MIT 

and  Wills,  Linda  1990.  Recognizing 

of  logic  programs. 
Press. 

J.  Ross  1990.  Learning 

In  Working  Conference 

for  large  scale  software 

databases. 
Engineering. 

for  reverse  engineering 

Leon  and  Shapiro, 

logical  definitions 

IEEE  Computer 

IEEE  Computer 

Society  Press. 

Society  Press. 

editors  1983. 

a 
IEEE 

on  Reverse 

of  relational 

in  inductive 

approach. 

activities. 

analysis. 

Stephen 

Ehud 

