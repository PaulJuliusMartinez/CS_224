Symbolic Pattern Databases in Heuristic Search Planning

Stefan Edelkamp

Institut f¨ur Informatik,

Albert-Ludwigs-Universit¨at,

Georges-K¨ohler-Allee, D-79110 Freiburg

eMail: edelkamp@informatik.uni-freiburg.de

Abstract

This paper invents symbolic pattern databases (SPDB) to
combine two inﬂuencing aspects for recent progress in
domain-independent action planning, namely heuristic search
and model checking. SPDBs are off-line computed dictionar-
ies, generated in symbolic backward traversals of automati-
cally inferred planning space abstractions.
The entries of SPDBs serve as heuristic estimates to accel-
erate explicit and symbolic, approximate and optimal heuris-
tic search planners. Selected experiments highlight that the
symbolic representation yields much larger and more accu-
rate pattern databases than the ones generated with explicit
methods.

Introduction

Heuristic search is one of the most effective search tech-
niques to cope with very large problem spaces.
The
guidance for search algorithms like A* (Hart, Nilsson, &
Raphael 1968) and IDA* (Korf 1985) are estimators that ap-
proximate the remaining distance to the goal.

The additional information focuses the search into the di-
rection of the goal and its quality mainly inﬂuences the num-
ber of states to be expanded; the better the estimate, the
larger the reduction in search efforts.

Planning problems implicitly generate weighted problem
graphs by applying operator sequences to their seed states.
By changing operator costs, A* can be casted as a vari-
ant of Dijkstra’s single-source shortest path algorithm: the
new costs of the operators are set to the old ones minus the
heuristic value of the expanded state, plus the estimate of
the successor state (Edelkamp & Schr¨odl 2000). Admissible
heuristics are lower bound problem relaxations, yield opti-
mal solutions, but may introduce negative weights calling
for re-openings of already expanded states (Pearl 1985).

Pattern databases (PDBs) are dictionaries of heuristic val-
ues that have been originally applied to the Fifteen Puz-
zle (Culberson & Schaeffer 1998). In this context, PDBs are
generalizations of the Manhattan distance heuristic, that cor-
responds to subproblem solutions of moving each tile onto
its goal position. The PDB representation is a selection of
Copyright c(cid:1) 2002, American Association for Artiﬁcial Intelli-
gence (www.aaai.org). All rights reserved.

274    AIPS 2002

look-up tables memorizing the goal distances of each tile
at any board location. Since the subproblems are indepen-
dent (only one tile can move at a time), the minimum num-
bers of moves to solve the individual puzzles can be added;
still providing an admissible heuristic. Reﬁned PDBs take
not only one but a selection of interacting tiles (the pat-
tern) into account. A large hash table stores their combined
goal distances on a simpliﬁed board with all other tiles re-
moved. PDBs are generated in complete backward explo-
rations, starting from the set of abstract goals.

The PDB approach has been extended to ﬁnd ﬁrst optimal
solutions to random Rubik’s Cube problems (Korf 1985),
where a pattern corresponds to a selection of side or corner
cubies. Independence of PDBs has been exploited to solve
the 24-Puzzle (Korf & Felner 2002). In all cases the abstrac-
tions for PDB construction were hand-tailored and domain
dependent. The effectiveness of PDBs in form of a space-
time trade-off reveals that PDBs size is inversely correlated
to the resulting search effort (Holte & Hernadv¨olgyi 1999).
Steps towards the automated creation of PDB heuristics
base on local search in the space of PDBs (Hernadv¨olgyi
2000) and change the abstraction level according to the pre-
dicted search efforts. However, the approach is currently
limited to moderate state-space sizes, or restricted to easier
exploration tasks like the computation of macro operators.

Explicit PDB heuristics that have been proposed for
domain-independent action planning (Edelkamp 2001b)
share similarities with PDBs in sliding-tile puzzles and
challenge even on-line computed estimates like the FF-
heuristic (Hoffmann 2002). The rough idea is to interpret
the set propositional atoms as tiles, so that a planning pat-
tern is a selection of them. The approach ﬁrst infers groups
of mutually exclusive facts. In every reachable state exactly
one of the atoms in each group is true. The group informa-
tion is exploited to derive planning abstractions and to infer
perfect hash functions for pattern storage. Automated clus-
tering partitions the state space into a set of abstractions with
state spaces that ﬁt into main memory. Planning PDBs are
not always independent, but suitable partitions into groups,
where all operators affect only atoms in the speciﬁed set,
always yield independent PDBs.

In this paper we propose symbolic pattern databases
(SPDBs) instead of explicit ones. A SPDB is Boolean func-

tion H of tuples (v, S). For a given planning state S with
value v, formula H evaluates to true if and only if the esti-
mate of S equals v. Through an efﬁcient representation of
Boolean functions, larger PDBs and more accurate estimates
can be inferred and utilized.

The structure of the paper is as follows. First we give a
concise introduction to PDBs together with proofs of some
important properties. Then we turn the to symbolic repre-
sentation of planning states and operators. Next we intro-
duce symbolic backward exploration to generate SPDBs and
integrate this representation of the heuristic estimate into di-
rected explicit and symbolic search search engines. This al-
gorithmic treatment is followed by a discussion the inﬂuence
of SPDBs to search tree growth and exploration efforts. We
evaluate the impact of the algorithms, taking Blocks World
as a selected case study. Finally, we discuss related work,
and ﬁnish with a few concluding remarks.

Pattern Databases in AI-Planning

For the sake for simplicity, throughout the paper we consider
grounded propositional planning problems in STRIPS nota-
tion (Fikes & Nilsson 1971) and stick to sequential plan gen-
eration. However, the framework also applies to more gen-
eral planning domain description languages (Fox & Long
2001).

Grounded Propositional Planning
Most successful planners perform grounding.
Deﬁnition 1 A grounded propositional planning problem is
a ﬁnite state space problem P =< S,O,I,G >, where S ⊆
2A is the set of states, 2A is the power set of set of proposi-
tions A, I ∈ S is the initial state, G ⊆ S is the set of goal
states, and O is the set of operators that transform states into
states. Operators o = (α, β) ∈ O have propositional pre-
conditions α, and propositional effects β = (βa, βd), where
α ⊆ A is the precondition list, βa ⊆ A is the add list and
βd ⊆ A is the delete list. Given a state S with α ⊆ S then
its successor is S

(cid:1) = S ∪ βa \ βd.

Sequential plans are deﬁned as follows.
Deﬁnition 2 A sequential plan π = (O1, . . . , Ok) is an or-
dered sequence of operators Oi ∈ O, i ∈ {1, . . . , k}, that
transforms the initial state I into one of the goal states
G ∈ G, i.e.
there exists a sequence of states Si ∈ S,
i ∈ {0, . . . , k}, with S0 = I, Sk = G and Si is the out-
come of applying Oi to Si−1, i ∈ {1, . . . , k}. The length of
a plan π is k, and the minimal k is the optimal sequential
plan length δ(I).
Abstract Planning problems
based
Instead
PDB
on fact groups (Edelkamp 2001b), in this paper we prefer
a formal treatment that directly builds upon the above state
space characterization.
Deﬁnition 3 Let R ⊆ A be a set of propositional atoms.
A restriction φR is a mapping from 2A into 2A deﬁned as
φR(P ) = {a ∈ P | a ∈ R}. For φR(P ) we also write P|R.

deﬁnition

of

the

Restrictions imply planning problem abstractions.
Deﬁnition 4 An abstract planning problem P|R =
< S|R,O|R,I|R,G|R > of a grounded propositional plan-
ning problem < S,O,I,G > with respect to a set of propo-
sitional atoms R is deﬁned by
1. S|R = {φR(S) | S ∈ S},
2. I|R = φR(I),
3. G|R = {φR(G) | G ∈ G},
4. O|R = {φR(O) | O ∈ O}, with φR(O) for
O = (α, (βa, βd)) ∈ O deﬁned as φR(O) = (α|R,
(βa|R, βd|R)).
Sequential abstract plans for the abstract planning prob-
lem P|R are denoted by πR and optimal abstract sequential
plan length is denoted by δR.

Abstract operators are ﬁxed by intersecting their precon-
dition, add and delete lists with the set of non-reduced facts
in the abstraction. Restriction of operators in the original
space may yield void operators φR(O) = (∅, (∅,∅)) in the
abstract planning problem, which are discarded from the op-
erator set O|R.
The next result shows that our deﬁnition of abstraction is

i.e.,

sound.
Lemma 1 Let R be a set of propositional atoms. Re-
striction φR is solution preserving,
for any se-
quential plan π for the grounded propositional plan-
ning problem P = < S,O,I,G > there exists a sequen-
tial plan πR for the planning state abstraction P|R =
< S|R,O|R,I|R,G|R >.
Moreover, an optimal sequential abstract plan πopt
R for
P|R is always shorter than an optimal sequential plan πopt
for P, i.e. δR(S|R) ≤ δ(S), for all S ∈ S.
Proof: Let π = (O1, . . . , Ok) be a sequential plan for
< S,O,I,G >. Then π|R = (O1|R, . . . , Ok|R) is a solu-
tion for P|R = < S|R,O|R,I|R,G|R >.
Now suppose, that δR(S|R) > δ(S) for some S ∈ S
and let πopt = (O1, . . . , Ot) be the optimal sequential plan
from S to G in the original planning space P then πopt|R =
(O1|R, . . . , Ot|R) is a valid plan in P|R with plan length
less or equal to t = δ(S). This is a contradiction to our
assumption. 2
Strict inequality δR(S|R) < δ(S) is given if some oper-
ators Oi|R are void, or if there are alternative even shorter
paths in the abstract space.

Planning Pattern Databases
The above setting allows a precise characterization of plan-
ning PDBs.
Deﬁnition 5 A planning PDB PDBR with respect to a set
of propositions R and a grounded propositional planning
problem < S,O,I,G > is a collection of pairs (v, S) with
v ∈ IN and S ∈ S|R, such that v = δR(S). Therefore,

PDBR = {(δR(S), S) | S ∈ S|R}.

AIPS 2002    275  

In other words, a PDB is look-up table, addressed by the
abstract planning state providing its minimal abstract solu-
tion length.

−1
Q (O

(cid:1)) ∩ φ
(cid:1)}.

(cid:1)(cid:1) ∈ O|Q we have φ
−1
R (O
(cid:1)) = {O ∈ O | φR(O) = O

Disjoint Pattern Databases
Disjoint PDBs are important to derive admissible estimates.
Deﬁnition 6 Two planning PDBs PDBR and PDBQ with
respect to R, Q ⊆ A, R ∩ Q = ∅ are disjoint, if for all
(cid:1) ∈ O|R, O
(cid:1)(cid:1)) = ∅,
O
−1
R (O
where φ
Lemma 2 Two disjoint planning PDBs PDBR and
PDBQ for a grounded propositional planning problem
< S,O,I,G > and sets of propositions P and Q are ad-
ditive: for all S ∈ S we have δP (S|R) + δQ(S|Q) ≤ δ(S).
Proof:
Let < S|R,O|R,I|R,G|R > and < S|Q,O|Q,I|Q,G|Q >
be abstractions of P =< S,O,I,G > according to P and
Q, respectively, and let π = (O1, . . . , Ok) be an optimal
sequential plan for P. Then, the abstracted plan π|R =
(O1|R, . . . , Ok|R) is a solution for the state space problem
< S|R,O|R,I|R,G|R > and π|Q = (O1|Q, . . . , Ok|Q) is a
plan for < S|Q,O|Q,I|Q,G|Q >. We assume that all void
operators in π|Q and π|R, if any, are removed. Let kQ and
kR be the resulting respective lengths of π|Q and π|R.
Since the PDBs PDBR and PDBQ are disjoint, O
(cid:1) ∈
(cid:1)(cid:1)) = ∅.
π|R and all O
Therefore, δR(S|R) + δQ(S|Q) ≤ kR + kQ ≤ δ(S). 2

(cid:1)(cid:1) ∈ π|Q we have φ

(cid:1)) ∩ φ

−1
R (O

−1
Q (O

Figure 1: Illustration of a Planning PDB PDBR and Two
Disjoint Planning PDBs PDBR and PDBQ.

In Figure 1 we have illustrated (disjoint) planning PDBs
with respect to the given underlying set A of propositions to
encode a state.

In practice some operators remain non-void in different
abstraction. For example, in our abstractions Logistics al-
ways yields disjoint PDBs, while in Blocks World some in-
terdependent operators remain, since operators in Logistics
modify either the location of a package, a truck or an air-
plane without affecting the others, while in Blocks World a
stack operation changes both the status of the hand and the
block.

276    AIPS 2002

In order to retain admissible estimates for the latter case,
during construction conﬂicting operators can be assigned to
cost zero for all but one PDB. Nevertheless, this technique of
enforced admissibility may reduce the quality of the inferred
estimate.

Partitions and Storage
Next, we consider sets of pattern databases.
Deﬁnition 7 A partition Q = {Q1, . . . , Qk} is a collection
of propositional sets Qi, i ∈ {1, . . . , k}, with Qi ∩ Qj = ∅,
1 ≤ i < j ≤ k and
i=1 Qi = A. A planning space
partition PQ according to a partition Q is a collection of
planning problems < S|Qi,O|Qi,I|Qi,G|Qi >, Qi ⊆ Q,
i ∈ {1, . . . , k}.

(cid:1)

k

The following result is an immediate generalization of

Lemma 2.
Lemma 3 Pairwise disjoint planning PDBs according to
planning space partition PQ for a grounded propositional
planning problem < S,O,I,G > and a partition Q =
{Q1, . . . , Qk} are additive, i.e.
for all S ∈ S we have
δQ1(S|Q1) + . . . + δQk(S|Qk) ≤ δ(S).
Finding a suitable partition that leads to pairwise disjoint
or to almost pairwise disjoint planning PDBs is not trivial.
For two databases the task is a variant of the graph partition-
ing problem (GPP), which divides the vertices of a given
graph into two equally sized subsets, so that the number of
edges from one subset the other one is minimized. In our
setting, vertices correspond to atoms and edges to opera-
tors. Since GPP is NP complete and the number of atoms
is considerably large, we mimic the approach of (Edelkamp
2001b), which simpliﬁes the problem of ﬁnding a suitable
partition of the set of facts to a form of bin-packing (BPP).
For this case, interdependencies are neglected. A group can
be added to an already existing abstraction, if the combined
state space still ﬁts into main memory. BPP is NP complete
but has several efﬁcient approximation algorithms. Cur-
rently, we study how goal fact dependencies can improve
the established partition.

In explicit PDB construction, the PDBs themselves and
the transposition tables (Reinefeld & Marsland 1994) are
represented as hash tables. Therefore, the limit for PDB
construction is the number of (abstract) states that can be
hold in main memory. For improving memory consump-
tion, (Edelkamp 2001b) proposes perfect hash-tables, with
a hash function that assigns each state to a unique number.
In our simpler setting, each state S|R =
i∈I ai, for the in-
dex set I and atom list (ai)i∈I, is hashed to
i∈I 2i, for a
maximum of 2|R|

hash addresses.

(cid:2)

(cid:1)

Symbolic Pattern Databases

We abstract from the internal representation of sets of states
as binary decision diagram (BDDs) (Bryant 1992). It suf-
ﬁces to know that there BDDs are unique, space-efﬁcient
data structures for representing and manipulating Boolean
formulae.

(cid:1)
¬bij)).

Sets of states
i∈N\Ij

then its encoding is (
i∈I ai,
(cid:3)
bij) ∧ (

States and Operators
Boolean formulae may represent sets of states.
Deﬁnition 8 A symbolic representation for a state S ∈ S
with S ⊆ 2A is a set of boolean variables b1, . . . , b|A|, with
bi encoding the truth of propositional atom ai in a given
state, i ∈ N = {1, . . . ,|A|}.
(cid:1)
i∈I bi) ∧
If S =
(cid:3)
¬bi).
(
i∈N\I
j∈J Sj are encoded as
(cid:4)
(cid:3)
j∈J ((
i∈Ij
Transitions relations are Boolean expressions for opera-
tor application. They encode all valid (state, successor state)
pairs utilizing twice the number of Boolean state variables;
2 · |A| in our case. In practice, the transition relation is gen-
erated as the disjunct of the representations of all grounded
operators, which in turn are deﬁned as Boolean expressions
of their precondition, add and delete lists.
(cid:1)) of a set of op-
Deﬁnition 9 The transition relation T (b, b
(cid:4)
erators O ∈ O is the disjunct T (b, b
(cid:1)).
(cid:1)) =
O∈O TO(b, b
(cid:3)
ai∈α bi) ∧
(cid:1)) = (
For O = (α, (βa, βd)) we have TO(b, b
(cid:3)
k)∧frame(b, b
(cid:1)), where frame en-
(cid:1)
(
(cid:1)) =
codes that all other atoms are preserved, i.e. frame(b, b
(cid:3)
aj /∈α∪βa∪βb
Similarly, the relaxed transition relation T|R according
the set of proposition R is constructed with respect to the set
of operators O|R = (α|R, (βa|R, βd|R))
The image I of the state set From with respect to the tran-
(cid:1)) ∧
(cid:1)) is not
(cid:1)) =
(cid:1)) ∧
(cid:1)) can be
bypassed. Our current implementation organizes the image
computation in form of a balanced tree. Through the suc-
cess of conjunctive partitioning and reordering techniques
in hardware veriﬁcation (Meinel & Stangier 2001), reﬁned
disjunctive partitioning approaches are an apparent issue for
future research.

sition relation T is computed as I(b
From(b
required to be built explicitly, since with T (b, b
(cid:4)
TO(b, b

In this image computation, T (b, b
(cid:1)) we have I(b

Therefore, the monolithic construction of T (b, b

ak∈βd
(bj ≡ b
(cid:1)
j).

O∈O TO(b, b

(cid:3)
j)∧(
(cid:1)

O∈O(∃b

(cid:1)) = ∃b

(cid:1) (T (b, b

From(b

(cid:1))).

(cid:4)

(cid:1)) =

aj∈βa

b

(cid:1))).

¬b

(cid:3)

(cid:1)

(cid:1)

Pattern Database Construction
Complete symbolic breadth-ﬁrst search (BFS) is one form
of reachability analysis of the planning space. Let Si be the
set of planning states reachable from the initial state S in i
steps, initialized by S0 = I. An encoded state S belongs to
Si if it has a predecessor S
in the set Si−1 and there exists
an operator which transforms S
into S. All sets of states are
identiﬁed by their respective characteristic formulae.
We apply backward symbolic exploration for SPDB con-
struction as follows. The symbolic PDB PDB|R, is ini-
tialized to G|R and, as long as there are newly encountered
states, we take the current list of horizon nodes and generate
the predecessor list with respect to T|R. Then we attach the
current BFS level to the new states, merge them with the set
of already reached state states and iterate. In the following

(cid:1)

algorithm Construct Symbolic Pattern Database, Reached is
the set of visited states, Open is current search horizon, and
Pred is the set of predecessor states.

Algorithm Construct Symbolic Pattern Database
Input: Planning space abstraction
Output: Symbolic Pattern Database PDB|R

P|R = < S|R,O|R,I|R,G|R >
(cid:1)) ← G|R(b
(cid:1))

(cid:1)) ← Open(b

Open(b

(cid:1)) ← Pred(b) [b ↔ b
(cid:1)) ← Pred(b

Reached(b
i ← 0
while (Open (cid:11)≡ ∅)
Pred(b) ← ∃b
(cid:1)) ∧ T|R(b, b
(cid:1)
(cid:1))
Pred(b
(cid:1)) ∧ ¬ Reached(b
(cid:1))
Open(b
PDB|R ← PDB|R ∨ (v = i ∧ Open(b
Reached(b) ← Reached(b) ∨ Open(b)
i ← i + 1
return PDB|R
Weightening the heursitic estimate according to a factor γ

(cid:1)))

(cid:1)]

is achieved by setting (v = i) to (v = γi).

Note that beside the capability to represent large sets of
states in the exploration, symbolic PDB have one further ad-
vantage to explicit ones: fast initialization. In the deﬁnition
of most planning problems G is not given as a collection of
states, but as a smaller selection of atoms ai, i ∈ I
(cid:1) ⊂ I. In
explicit PDB construction all states G ∈ G have to be gen-
erated and to be inserted into the BFS queue, while for the
symbolic construction, initialization is immediate.

Explicit Pattern Database Search

SPDBs can easily be incorporated to any explicit heuristic
search engine, e.g. Algorithm Explicit Pattern Database
Search illustrates A* exploration with SPDBs.

Algorithm Explicit Pattern Database Search
Input: Planning space P =< S,O,I,G >,
Symbolic Pattern Database PDB|R
Output: Solution length δ(I)
Insert(Open, (I,PDB|R(I)))
while (Open (cid:11)= ∅)
S ← DeleteMin(Open)
if (S ∈ G) return g(S)
(cid:1) of S
for all successors S

(cid:1)) ← f(S) + 1 + PDB|R(S
if (f

f(S
if (Search(Open, S))
(cid:1)(S) < f(S))
DecreaseKey(Open, (S, f
(cid:1)(S))

else Insert(Open, (S, f

(cid:1)(S))

(cid:1)) − PDB|R(S)

The set of horizon nodes Open is represented as a pri-
ority queue with usual access operations DeleteMin, Insert,
and DecreaseKey. For the sake of brevity, we have omitted
re-opening and concentrate on only one PDB, since gener-
alizations to planning pattern partitions PDB|Q are easy to
obtain.

AIPS 2002    277  

For each extracted state S we have f(S) = g(S) + h(S),
where g is the actual distance to state S. The new f-value
(cid:1)) =
of a successor S
g(S) + 1 + h(S

(cid:1)
is calculated as f(S
(cid:1)) = f(S) + 1 + (h(S

(cid:1)) = g(S
(cid:1)) − h(S)).

(cid:1)) + h(S

(cid:1)

(cid:3)

Apparently, the design of explicit search algorithms with
symbolic PDB heuristics is not different to the design of
algorithms for any other incorporated estimate. The only
change is the computation of the estimate h(S) for state S
with respect to PDB|R.
To query the symbolic PDB PDB|R with state S =
i ai,
denoted as PDB|R(S), we ﬁrst compute the symbolic rep-
(cid:3)
(cid:3)
(cid:3)
resentation
i bi of S. Then we determine the conjunct of
j vj)∧ (
i bi with PDB|R. The operation yields (
i bi),
(cid:3)
where (
j vj) encodes the estimate. Last but not least,
the formula (
j vj) is converted back to an ordinary nu-
merical quantity. Since
i bi is already simple, computing
its conjunct with PDB|R is fast in practice. Conversion
would not be necessary at all, if instead of BDDs – as in
our implementation – arithmetic decision diagrams (ADDs)
were used. For this case, the heuristic estimate is deter-
mined in time linear to the encoding length. If several SPDs
Q1, . . . , Qk are addressed, we compute the estimate h(S) =
h1(S) + . . . + hk(S) with respect to h1(S) = PDB|Q1(S),
h2(S) = PDB|Q2(S), . . . , hk(S) = PDB|Qk(S).

(cid:3)

(cid:3)

Symbolic Pattern Database Search

In the symbolic version of heuristic search the algorithm de-
termines all successor states for a set of successors in one
evaluation step. The heuristic is represented as a binary re-
lation of estimate and state variables. In the exploration al-
gorithm the open list of generated nodes is represented as an
encoded set of buckets with bucket f containing all states in
open with merit f = g + h .

Algorithm Explicit Pattern Database Search starts with
the Boolean representation of the initial state, attaches its
estimate and similarly to the explicit case, it iterates state
extraction and successor set generation until the goal has
been found. However, in contrast to the setting above, we
extract sets of states Min with minimum f-value fmin and
compute their respective successor sets Succ by applying
the transition relation. To ﬁnd the f-value for the succes-
sor states we apply symbolic representation of the heuris-
tic estimator PDB|R to the pre-image and the image of
transition relation application. The correctly associated val-
ues h, h
are then quantiﬁed to yield the successor f-value
(cid:1) − h + 1). For best-ﬁrst search the formula
(f = fmin + h
simplies to f = h
The superimposed distribution PDB|R+Q of two PDBs
PDB|R and PDB|Q approximates PDB|R∪Q.
It can be
computed beforehand to be conjuncted with Min and Succ
in the algorithm. The alternative avoids the pre-computation
of PDB|R+Q and combines PDB|R and PDB|Q with Min
and Succ during the execution. Our implementation allows
both options.

(cid:1)

(cid:1)

.

278    AIPS 2002

Algorithm Symbolic Pattern Database Search
Input: Planning space P =< S,O,I,G >,
Symbolic Pattern Database PDB|R
Output: Solution length δ(I)
Open(f, b)← PDB|R(f, b) ∧ I(b)
do
fmin = min{f | f ∧ Open(f, b) (cid:11)= ∅}
Min(f) ← ∃f (Open(f, b) ∧ f = fmin)
Rest(f, b) ← Open(f, b) ∧ ¬ Min(b)
Min(h, b) ← PDB|R(h, b) ∧ Min(b)
(cid:1)) ∧ Min(h, b)
(cid:1)) ← ∃b T (b, b
Succ(h, b
Succ(h, b) ← Succ(h, b
(cid:1)) [b ↔ b
(cid:1)]
, b) ∧ Succ(h, b)
, b) ← PDB|R(h
(cid:1)
(cid:1)
Succ(h, h
, b) ∧ f = fmin
, f, b) ← Succ(h, h
(cid:1)
(cid:1)
Succ(h, h
, b) ← ∃h, h
(cid:1)
(cid:1)
Succ(f
, f, b) ∧ (f
(cid:1) − h + 1)
(cid:1) = f + h
Succ(h, h
Succ(f, b) ← Succ(f
Succ(f, b) ← Succ(f, b) ∧ ¬ Reached(b)
Open(f, b) ← Rest(f, b) ∨ Succ(f, b)
Succ(b) ← ∃f Succ(f, b)
Reached ← Reached(b) ∨ Succ(b)

, f
, b) [f ↔ f
(cid:1)

(cid:1)]

(cid:1)

while (Open ∧ G ≡ ∅)
return fmin
Given a uniform weighted problem graph and a consistent
heuristic (h(v)−h(u)+w(u, v) ≥ 0) the worst-case number
of iterations has been shown to be O(δ2(I)) (Edelkamp &
Reffel 1998).

Search Tree Prediction

Heuristic PDBs are also an efﬁcient mean for heuristic
search tree prediction, since they approximate the overall
distribution of heuristic estimates in the state space. Assum-
ing that patterns occur equally likely in the search space, the
overall probability of estimate h being less than or equal to
k is

P (h ≤ k) = |{P ∈ PDB | h(P ) ≤ k}|/|PDB|.

To predict the heuristic search tree expansion of the prob-
lem graph that is labeled with node costs f = g + h, the
main result in (Korf, Reid, & Edelkamp 2001) states that
the expected total number of tree nodes according to cost
threshold θ is approximately equal to

θ(cid:5)

d=0

n(d)P (h ≤ θ − d) ,

(1)

where n(d) is the number of states in the brute-force
search tree with depth d and P is the equilibrium distribu-
tion, deﬁned as the probability distribution of heuristic val-
ues in the limit of large depth. In the framework of spectral
analysis, n(d) can be computed in closed form (Edelkamp
2001c).

Since Equation 1 is a very good predictor for the num-
ber of nodes in IDA* and yields at least a good trend for
A*’s exploration effort, it has been used for evaluating the
effectiveness of PDBs (Hernadv¨olgyi 2000). For the sake

of simplicity we focus on the mean heuristic value h =
(cid:2)
k k · |{P ∈ PDB | h(P ) = k}|/|PDB|. In the limit
of large θ, the branching factor b, i.e. the ratio of search tree
nodes with respect to two consecutive threshold values, con-
verges (Edelkamp 2001c). The effect of the heuristic is to
reduce the search tree size from O(bd) to O(bd−c) for some
constant c ≈ h (Korf 1997).

Therefore, heuristics are best thought of as offsets to the
search depth. The higher the average heuristic value, the
smaller the effective search tree depth, i.e., the shallower
the search with respect to the brute-force search tree. The
following case study displays the effect of explicit and sym-
bolic PDBs on h.

Case Study

As a case study we chose Blocks World, since ﬁnding opti-
mal plans is still a challenge for domain-independent plan-
ners. No form of knowledge was added to the planner, we
switched off all branching cuts. Cuts signiﬁcantly speed up
exploration, but most proposed control knowledge in plan-
ning is domain-dependent or apply to certain sets of bench-
mark domains only.

Pattern Database Construction
In Tables 1 and 2 we present the results on constructing sym-
bolic PDBs in selected Blocks World problems of the AIPS-
2000 set. The total number of pattern s in the databases and
the respective averaged heuristic estimates h are shown. As
the problems size p gets larger, more and more PDBs were
generated (separated by /).

p
4
5
6
7
8
9
10
11
12
13
14
15

s
108
1,029
12,288
26,244/8
50,000/80
87,846/968
145,152/13,824
228,488/228,488
27,440/27,440/2,156
37,125/37,125/37,125
49,152/49,152/49,152/15
63,869/63,869/63,869/255

h
6.20
8.85
11.49
11.72/1.62
11.26/3.57
11.69/6.37
11.35/8.59
11.38/11.39
8.64/8.64/5.79
8.66/8.66/8.66
8.03/8.03/8.03/1.80
8.69/8.69/9.35/3.75

Table 1: Number of States s and Mean Heuristic Value h in
Blocks World PDBs according to m = 220.

The averaged heuristic estimates increase signiﬁcantly
when moving from m = 220 to m = 230, while the number
of PDBs shrinks accordingly.

Table 3 compares the growth of the symbolic representa-
tion with respect to the number of states. We took the ﬁrst
PDB in Blocks World Problem 15 with m = 230 as an ex-
ample. The predicted state space size is 410,338,673. Since
this corresponds to maximum perfect hash table capacity,
explicit exploration was no longer available.

p
4
5
6
7
8
9
10
11
12
13
14
15

s
1,08
1,029
12,288
1,777,147
3e+06
5.84e+07
1.43e+08
2.89e+07/1,690
5.27e+07/27,440
9.11e+07/506,250
1.50e+08/1.04e+07
2.41e+08/2.41e+08

h
6.20
8.85
11.49
14.14
16.80
19.47
19.55/1.72
17.05/6.47
16.29/8.05
16.89/10.93
16.56/13.77
16.59/16.56

Table 2: Number of States s and Mean Heuristic Value h in
Blocks World PDBs according to m = 230.

d
0
2
4
6
8
10
12
14
16
18
20
22

t
0.00s
0.01s
0.01s
0.03s
0.13s
0.66s
2.56s
7.60s
12.60s
10.69s
4.48s
0.45s

b
35
103
311
858
2,576
6,879
14,583
24,547
30,238
22,592
7,655
993

s
1
39
586
5,792
55,911
538,771
4.01e+06
1.87e+07
4.51e+07
4.14e+07
1.02e+07
467,551

Table 3: Node Count b and Number of States s for Con-
structng a SPDB in Blocks-World Problem 15.

Table 3 depicts the node and state counts for each itera-
tion in the construction phase. The results indicate that by
far more states are encountered than BDD nodes were nec-
essary to represent them. In this case the effect of symbolic
representation corresponds memory gains of up to about two
orders of magnitude. With m = 240, for which exploration
was still possible, the effect increases up to about four orders
of magnitude. We also observe that the peak node count for
the is also established earlier then the peak state count.

Explicit Search
Table 4 compares the CPU times1 of explicit and sym-
bolic PDB construction with the exploration time in explicit

1Most of the experiments were run on a Sun UltraSparc Work-
station with 248 MHz. Since exact running-times reﬂect too many
issues of the current implementation, for the interpretation of re-
sults we are mainly interested in comparing performance growth.
Memory was restricted as follows. The pattern databases were ei-
ther limited to m = 220 states or m = 230 states; for explicit
search we chose 2,000,000 stored states as the exploration bound.

AIPS 2002    279  

search. We took the same heuristic estimate and m = 220.
Since the qualities of the different PDBs match, the same
set of states was considered. The search algorithm we chose
was A* with weight 2 (f = g + 2h). Besides the prob-
lem number, the depth of the solution and the number of
expanded nodes, we also displayed PDB construction time
tc and explicit search time ts with respect to explicit pattern
and symbolic PDBs, subscripted by e and s.

p
4
5
6
7
8
9
10
11
12
13
14
15

d
6
12
12
24
20
32
34
38
38
-
40
-

e
7
15
13
40
1,590
34,316
47,657
7,941
34,323
-
254,769
-

tc
e
0.01s
0.05s
0.49s
1.39s
2.98s
6.18s
12.55s
0.91s
4.67s
10.55s
15.16s
21.88s

ts
e
0.00s
0.00s
0.00s
0.00s
0.10s
3.75s
5.72s
3.09s
5.31s
-
58.23s
-

tc
s
0.03s
0.04s
0.30s
0.52s
0.67s
0.81s
1.23s
1.80s
1.73s
2.45s
3.32s
5.51s

ts
s
0.00s
0.00s
0.00s
0.01s
0.40s
13.92s
16.35s
3.04s
13.24s
-
150.43s
-

Table 4: Time for PDB Construction and Explicit Search in
Blocks World.

In the result we obtain a trade-off between explicit and
symbolic search. While symbolic PDB construction is sig-
niﬁcantly faster, search time is larger. As indicated above, an
ADD implementation for the heuristic lessens the per-node
retrieval overhead for SPDBs.

Symbolic Search
In this set of experiments we measured the performance of
the symbolic search algorithm. We used forward heuristic
search with respect to the provided SPDBs, accompanied by
a symbolic backward traversal. The search direction was
chosen in favor to the exploration side that used less time
in the previous iteration. The memory bound was set to
m = 230, so at most 2 PDBs were constructed. By the
choice of dependent PDBs, the results in Table 5 were not
necessarily optimal. The headings are read as follows: p is
the problem number, d is the depth of the solution, if and ib
are the number of forward and backward iterations, tc
s is the
PDB construction time, tc
s is the symbolic search time, and
tb is time for bidirectional symbolic BFS.

The peak PDBs size at p = 11 reﬂects that the maxi-
mum number of patterns in the database is roughly equal
to the state space size. As the comparison of ts
s with tb
shows, we can obtain better results as with bi-directional
symbolic BFS, which besides SAT enumeration (Kautz &
Selman 1996), is state-of-the-art in optimal sequential plan
generation. Another observation is that in case of failure,

For symbolic exploration we allocated at most 8,000,000 BDD
nodes.

280    AIPS 2002

p
4
5
6
7
8
9
10
11
12
13
14
15

d
6
12
12
20
18
30/32
34
32/38
34/36
-
-/38
-

if
6
12
12
20
9
25
60
52
142
147
52
-

ib
0
0
0
0
11
12
12
11
15
17
11
-

tc
s
0.02s
0.04s
0.30s
3.95s
0.67s
0.81s
66.16s
1,218s
38.57s
48.88s
59.05s
time

ts
s
0.21s
0.30s
0.43s
0.76s
0.40s
13.92s
58.02s
261.76s
224.13s

tb
0.17s
0.30s
1.09s
11.34s
2.80s
38.16s
297.51s
742.14s
1,059s
time memory
150.92s memory
- memory

Table 5: CPU Performance for PDB Construction and Sym-
bolic Search in Blocks World.

symbolic heuristic search with PDBs never runs out of mem-
ory but out of time. For symbolic engines this is a very un-
usual behavior. In Problem 13 time was exceeded in explo-
ration, while for Problem 15 the time threshold was encoun-
tered when merging the two PDBs into a combined one.

PDBs have also been successfully applied to other chal-
lenging propositional planning domains (Edelkamp 2001b).
The results do transfer to the symbolic setting.
In simple
domains like Gripper, all running times (for A* and best-
ﬁrst explicit and symbolic exploration with explicit and sym-
bolic PDBs) were bounded by far less than a minute. Ta-
ble 6 displays the CPU performance of explicit search with
(S)PDBs in Logistics. In symbolic best-ﬁrst search (f = h)
we solved each problem in less than a minute, while sym-
bolic A* (f = g + h) and symbolic BFS (f = g) failed in
larger problem instances. The space bound is 220 and, once
more, the search algorithm is A* with weight 2. The sav-

p
4
5
6
7
8
9
10
12
13
14
15

d
20
27
25
37
34
36
36
44
75
66
84

e
21
33
30
48
50
43
81
79
138
143
186

tc
e
1.52s
0.70s
5.90s
27.54s
26.99s
27.62s
52.97s
53.02s
22.92s
22.99s
23.39s

ts
e
0.00s
0.01s
0.00s
0.01s
0.02s
0.01s
0.04s
0.02s
0.08s
0.09s
0.15s

tc
s
0.11s
0.08s
0.10s
0.64s
2.33s
0.91s
1.01s
1.14s
4.18s
4.42s
4.81s

ts
s
0.00s
0.02s
0.07s
0.06s
0.06s
0.08s
0.12s
0.11s
0.42s
0.36s
0.51s

Table 6: Time for PDB Construction and Explicit Search in
Logistics.

ings in explicit database search time are counter-balanced
by acorresponding increase in construction time. One inter-
esting observation in Logistics and Gripper is that through

the highly asynchronous problem structure even very small
databases lead to good accumulated estimates. Therefore,
very large problems can effectively be solved with PDB.

We have not considered metric planning problems, where
PDBs are to be constructed according to their shortest-path
distances to the goal. Since the awarded, 2002 competition
version of MIPS 2 schedules sequential plans, we integrated
(S)PDB for sequential plan generation with mixed results.

Related Work

In the Model-Based Planner, MBP, the paradigm of plan-
ning as symbolic model checking (Giunchiglia & Traverso
1999) has been implemented for non-deterministic planning
domains (Cimatti, Roveri, & Traverso 1998), which classi-
ﬁes in weak, strong, and strong-cyclic planning, with plans
that are represented as complete state-action tables. For
partial observable planning, exploration faces the space of
belief states; the power set of the original planning space.
Therefore, in contrast to the successor set generation based
on action application, observations introduce “And” nodes
into the search tree (Bertoli et al. 2001). Since the approach
is a hybrid of symbolic representation of belief states and
explicit search within the “And”-“Or” search tree, simple
heuristic have been applied to guide the search. The need
for heuristics that trade information gain for exploration ef-
fort is also apparent need in conformant planning (Bertoli,
Cimatti, & Roveri 2001). The authors label the obtained
search algorithms as a new paradigm of heuristic-symbolic
search and report savings in orders of magnitudes with re-
spect to BFS. In contrast to our approach, where Boolean
function encode perfect knowledge, the symbolic represen-
tation compensates partial knowledge of the current state.
Moreover, Bertoli et al. consider heuristics for guiding the
choice of the belief states with no symbolic heuristic esti-
mates as in our case. Since the ﬁrst estimate was rather triv-
ial – it preferred belief states with low cardinality – recent
work (Bertoli & Cimatti 2002) proposes improved heuris-
tic for belief space planning. Nevertheless, we view unpub-
lished work on abstraction (Cimatti, Giunchiglia, & Roveri
2000) closest to our approach of symbolic PDBs. It origins
in Abstrips abstractions, but lacks experimental results.

The awarded model checking integrated planning sys-
tem MIPS (Edelkamp & Helmert 2001) is a competitive
deterministic planning system based on model checking
methods. The planner incorporates symbolic, explicit and
metric heuristic planning strategies (Edelkamp 2002).
Its
type-inference mechanism and fact enumeration algorithm
groups mutually exclusive facts to infer a concise state en-
doding (Edelkamp & Helmert 1999). Heuristic symbolic
search with the (weighted) BDDA* algorithm has shown
a signiﬁcant time and space reduction for planning prob-
lems that were intractable for breadth-ﬁrst symbolic explo-
ration (Edelkamp 2001a). As a symbolic heuristic, the goal
was splitted into atoms and either a relaxed plan or the
single-atom heuristic was computed and accumulated. The
2See www.informatik.uni-freiburg.de/∼mmips.

approach could not compete with state-of-the art planners,
and, different to SPDBs, the pre-compiled symbolic esti-
mates provided no information gain to accelerate explicit
heuristic search planners.

The UMOP system parses a non-deterministic agent do-
main language that explicitly deﬁnes a controllable system
in an uncontrollable environment (Jensen & Veloso 2000).
The planner also applies BDD reﬁnement techniques such
as automated transition function partitioning. New result for
the UMOP system extends the setting of weak, strong and
strong cyclic planning to adversarial planning, in which the
environment actively inﬂuences the outcome of actions. In
fact, the proposed algorithm joins aspects of both symbolic
search and game playing. Jensen also reports some prelim-
inary and unpublished successes on planning with domain
abstractions. As one drawback, the loss of solution quality
seemed to be signiﬁcant.

With SetA*, (Jensen, Bryant, & Veloso 2002) provide an
improved implementation of the symbolic heuristic search
algorithm BDDA* (Edelkamp & Reffel 1998) and Weighted
BDDA* (Edelkamp 2001a). Based on supplied source code
the consise state encoding and the max-atom heuristic func-
tion of MIPS could be reproduced3. One major surplus is
to maintain a ﬁner granularity of the sets of states in the
search horizon kept in a matrix according to matching g-
and h- values. This contrasts the plain bucket representation
of the priority queue based on f-values. The heuristic func-
tion is implicitly encoded with value differences of grounded
actions. Since sets of states are to be evaluated and some
heuristics are state rather than operator dependent it has still
to be shown how general this approch is. As above the
considered planning benchmarks are seemingly simple for
single-state heuristic search exploration (Hoffmann 2002;
Helmert 2001). We expect better and more general results
when applying SPDBs.

Recent, yet unpublished work of Hansen, Zhou, and
Feng (Hansen, Zhou, & Feng 2002) also re-implemented
BDDA* and suggest that symbolic search heuristics and ex-
ploration schemes are probably better to be implemented
with algebraic decision diagrams (ADDs), as available in
Somenzi’s CUDD package. Although the authors achieved
no improvement to (Edelkamp & Reffel 1998) to solve
the (n2 − 1)-Puzzle,
the established generalization to
guide a symbolic version of the LAO* exploration algo-
rithm (Hansen & Zilberstein 1998) for probabilistic or
Markov decision process (MDP) planning, results in a
remarkable improvement to the state-of-the-art (Feng &
Hansen 2002). Since its input – as in our case – is a symbolic
representation of the estimate, the contributed progress in
estimate quality calls for generalizations of SPDBs to prob-
abilistic planning.

In BDD-based hardware veriﬁcation, guided search and
prioritized model checking are emerging technologies.

3In their paper, the authors compare SetA* with the implemen-
tation of BDDA* in MIPS of early 2001. While the results in Lo-
gistics seem plausible, unfortunately, we cannot reproduce the bad
behavior of our implementation in the Gripper domain.

AIPS 2002    281  

(Yang & Dill 1998) used BDD-based symbolic search based
on the Hamming distance of two states. This approach has
been improved in (Reffel & Edelkamp 1999), where the
BDD-based version of A* for the µcke model checker out-
performs symbolic BFS exploration for two scalable hard-
ware circuits. The heuristic is determined in a static anal-
ysis prior to the search taking the actual circuit layout and
the failure formula into account. The approach of sym-
bolic guided search in CTL model checking documented
in (Bloem, Ravi, & Somenzi 2000) applies ‘hints’ to avoid
sections of the search space that are difﬁcult to represent for
BDDs. This permits splitting the ﬁx-point iteration process
used in symbolic exploration into two parts yielding under-
and over-approximation of the transition relation. Bene-
ﬁts of this approach are simpliﬁcation of the transition re-
lation, avoidance of BDD blowup and a reduced amount
of exploration for complicated systems. However, in con-
trast to our approach providing ‘hints’ requires user inter-
vention. Also, this approach is not directly applicable to
explicit exploration, which is our main focus. Prioritized
traversals are also concerned for formal hardware veriﬁca-
tion at IBM (Fraer et al. 2000). The approach bases on
the work of (Cabodi, Camurati, & Quer 1996) and splits
the symbolic search frontier into parts to ease approximate
reachability.

Conclusion

This paper puts forth the idea of PDB construction to im-
prove the computed average of the admissible heuristic,
which in turn corresponds to a relative decrease in search
depth. We have also seen a sound formal treatment for
PDBs in planning for both explicit and symbolic construc-
tion. The experiments highlight that with symbolic repre-
sentation and reachability analysis, very large databases can
be constructed, for which explicit methods necessarily fail.
The approach improves one of the three major classes
of heuristics in planning, namely Plan Abstraction. The
other two are: Plan relaxation, as implemented in the FF
planner (Hoffmann & Nebel 2001), which is a informative
on-line computed estimate, and Bellman approximation, as
implemented in the max-atom and max-pair heuristics for
HSP, which also consideres groups of atoms. In contrast to
this paper Bellman approximation simpliﬁes the exploration
without simplifying the operator representation (Haslum &
Geffner 2000).

PDBs consider subproblem interactions of larger groups
and include more knowledge into the estimate than the max-
pair heuristic. On the other hand, since FF and the PDB
heuristics are very different in their characteristics, the nat-
ural question arises of how to combine the two for an even
better estimate. Even though node expansion is more time
consuming for the relaxed plan graph estimate, it yields bet-
ter information on groups that do not appear in the goal de-
scription.

Our implemented proposal is to group the number of add
atoms that match the backward plan extraction of the relaxed
plan graph in FF according to the obtained group partition-

282    AIPS 2002

ing. With respect to each planning space abstraction the bet-
ter FF or PDB, value can be selected. Since FF’s heuristic is
somewhat misguided in Blocks World, yielding very low es-
timates in states far away from the goal state, we can achieve
almost arbitrary large improvements for A*-like searches.

Our approach accelerates both explicit and symbolic
search. Explicit heuristic search planners can now access
better off-line estimates and by weighting the symbolic
heuristic search algorithm we can scale the solution quality.
Symbolic heuristic search planning – possibly better to be
implemented with ADDs – now appears as a real competi-
tor for blind symbolic breadth-ﬁrst exploration. Moreover,
the paper provides a bridge from explicit to symbolic search.
In both planning and model checking there are two distinc-
tive research branches according to the chosen representa-
tion. We have established an effective interplay between
these methods by combining state-of-the art techniques from
both ﬁelds. Future research on checking safety property will
try to consolidate these ﬁndings in model checking domains.

Acknowledgment The author thanks DFG for support in
the projects Ot 64/11-3 and Ed 74/2-1.

References

Bertoli, P., and Cimatti, A. 2002. Improving heuristics for
planning as search in belief space. In Artiﬁcial Intelligence
Planning and Scheduling (AIPS). This volume.
Bertoli, P.; Cimatti, A.; Roveri, M.; and Traverso, P. 2001.
Planning in nondeterministic domains under partial observ-
ability via symbolic model checking. In International Joint
Conference on Artiﬁcial Intelligence (IJCAI).
Bertoli, P.; Cimatti, A.; and Roveri, M. 2001. Heuris-
tic search symbolic model checking = efﬁcient conformant
planning.
In International Joint Conference on Artiﬁcial
Intelligence (IJCAI), 467–472.
Bloem, R.; Ravi, K.; and Somenzi, F. 2000. Symbolic
guided search for CTL model checking. In Conference on
Design Automation (DAC), 29–34.
Bryant, R. E. 1992. Symbolic boolean manipulation with
ordered binary-decision diagrams. ACM Computing Sur-
veys 24(3):142–170.
Cabodi, G.; Camurati, P.; and Quer, S. 1996. Improved
reachability analysis of large ﬁnite state machines.
In
Computer-Aided Design (CAD), 354–359.
Cimatti, A.; Giunchiglia, F.; and Roveri, M. 2000. Ab-
straction in planning via model checking. Technical report,
IRST.
Cimatti, A.; Roveri, M.; and Traverso, P. 1998. Auto-
matic OBDD-based generation of universal plans in non-
deterministic domains. In National Conference on Artiﬁ-
cial Intelligence (AAAI), 875–881.
Culberson, J. C., and Schaeffer, J. 1998. Pattern databases.
Computational Intelligence 14(4):318–334.
Edelkamp, S., and Helmert, M. 1999. Exhibiting knowl-
edge in planning problems to minimize state encoding

length. In European Conference on Planning (ECP), Lec-
ture Notes in Computer Science, 135–147. Springer.
Edelkamp, S., and Helmert, M. 2001. The model checking
integrated planning system MIPS. AI-Magazine 67–71.
Edelkamp, S., and Reffel, F. 1998. OBDDs in heuristic
search.
In German Conference on Artiﬁcial Intelligence
(KI), Lecture Notes in Computer Science, 81–92. Springer.
Edelkamp, S., and Schr¨odl, S. 2000. Localizing A*. In Na-
tional Conference on Artiﬁcial Intelligence (AAAI), 885–
890.
Edelkamp, S. 2001a. Directed symbolic exploration and
its application to AI-planning. In AAAI-Spring Symposium
on Model-based Validation of Intelligence, 84–92.
Edelkamp, S. 2001b. Planning with pattern databases. In
European Conference on Planning (ECP), Lecture Notes
in Computer Science. Springer. 13-24.
Edelkamp, S. 2001c. Prediction of regular search tree
growth by spectral analysis. In German Conference on Ar-
tiﬁcial Intelligence (KI), Lecture Notes in Computer Sci-
ence. Springer. 154-168.
Edelkamp, S. 2002. Mixed propositional and numerical
planning in the Model Checking Integrated Planning Sys-
tem. In The International Conference on AI Planning and
Scheduling (AIPS), Workshop on Temporal Planning.
Feng, Z., and Hansen, E. 2002. Symbolic heuristic search
for factored markov decision processes. In National Con-
ference on Artiﬁcial Intelligence (AAAI). To appear.
Fikes, R., and Nilsson, N. 1971. Strips: A new approach
to the application of theorem proving to problem solving.
Artiﬁcial Intelligence 2:189–208.
Fox, M., and Long, D. 2001. PDDL2.1: An extension to
PDDL for expressing temporal planning domains. Techni-
cal report, University of Durham, UK.
Fraer, R.; Kamhi, G.; B. Ziv, M. Y. V.; and Fix,
2000. Efﬁcient reachability analysis for veriﬁca-
L.
tion and falsiﬁcation.
IBM FV’2000 Summer Seminar.
www.haifa.il.ibm.com/ibmfv2000/abstracts/fraer.html.
Giunchiglia, F., and Traverso, P. 1999. Planning as model
checking. In European Conference on Planning (ECP), 1–
19.
Hansen, E. A., and Zilberstein, S. 1998. Heuristic search in
cyclic anc/or graphs. In National Conference on Artiﬁcial
Intelligence (AAAI), 412–418.
Hansen, E. A.; Zhou, R.; and Feng, Z. 2002. Symbolic
heuristic search using decision diagrams. submitted.
Hart, P. E.; Nilsson, N. J.; and Raphael, B. 1968. A formal
basis for heuristic determination of minimum path cost.
IEEE Transactions on on Systems Science and Cybernet-
ics 4:100–107.
Haslum, P., and Geffner, H. 2000. Admissible heuristics
for optimal planning.
In Artiﬁcial Intelligence Planning
and Scheduling (AIPS), 140–149.

Helmert, M. 2001. On the complexity of planning in
transportation domains. In European Conference on Plan-
ning (ECP), Lecture Notes in Computer Science, 349–360.
Springer.
Hernadv¨olgyi, I. T. 2000. Automatic generation of memory
based search heursitics. In National Conference on Artiﬁ-
cial Intelligence (AAAI). 1103.
Hoffmann, J., and Nebel, B. 2001. Fast plan generation
through heuristic search. Artiﬁcial Intelligence Research
14:253–302.
Hoffmann, J. 2002. Local search topology in planning
benchmarks: A theoretical analysis.
In Artiﬁcial Intelli-
gence Planning and Scheduling (AIPS). This volume.
Holte, R. C., and Hernadv¨olgyi, I. T. 1999. A space-time
tradeoff for memory-based heuristics. In National Confer-
ence on Artiﬁcial Intelligence (AAAI), 704–709.
Jensen, R. M., and Veloso, M. M.
2000. OBDD-
based universal planning for synchronized agents in non-
deterministic domains. Artiﬁcial Intelligence Research
13:189–226.
Jensen, R. M.; Bryant, R. E.; and Veloso, M. M. 2002.
SetA*: An efﬁcient BDD-based heuristic search algorithm.
In National Conference on Artiﬁcial Intelligence (AAAI).
To appear.
Kautz, H., and Selman, B. 1996. Pushing the envelope:
Planning propositional logic, and stochastic search. In Na-
tional Conference on Artiﬁcial Intelligence (AAAI), 1194–
1201.
Korf, R. E., and Felner, A. 2002. Disjoint pattern database
heuristics. Artiﬁcial Intelligence 134(1-2):9–22.
Korf, R. E.; Reid, M.; and Edelkamp, S. 2001. Time Com-
plexity of Iterative-Deepening-A*. Artiﬁcial Intelligence
129(1–2):199–218.
Korf, R. E. 1985. Depth-ﬁrst iterative-deepening: An
optimal admissible tree search.
Artiﬁcial Intelligence
27(1):97–109.
Korf, R. E. 1997. Finding optimal solutions to Rubik’s
Cube using pattern databases. In National Conference on
Artiﬁcial Intelligence (AAAI), 700–705.
Meinel, C., and Stangier, C.
2001. Hierarchical im-
age computation with dynamic conjunction scheduling. In
Conference on Computer Design (ICCD’01).
Pearl, J. 1985. Heuristics. Addison-Wesley.
Reffel, F., and Edelkamp, S. 1999. Error detection with di-
rected symbolic model checking.
In World Congress on
Formal Methods (FM), Lecture Notes in Computer Sci-
ence, 195–211. Springer.
Reinefeld, A., and Marsland, T. A.
1994. Enhanced
iterative-deepening search. IEEE Transactions on Pattern
Analysis and Machine Intelligence 16(7):701–710.
Yang, C. H., and Dill, D. L. 1998. Validation with guided
search of the state space. In Conference on Design Automa-
tion (DAC), 599–604.

AIPS 2002    283  

