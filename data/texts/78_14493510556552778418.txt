From: AAAI-86 Proceedings. Copyright ©1986, AAAI (www.aaai.org). All rights reserved. 

Knowledge  Level  Engineering:  Ontological  Analysis 

James  H.  Alexander,  Michael  J.  Freiling,  Sheryl  J.  Shulman, 

Jeffrey  L.  Staley,  Steven  Rehfuss  and  Steven  L.  Messick 

Computer  Research  Laboratory 

Tektronix  Laboratories 

ABSTRACT 

and  formulating 

(knowledge  base)  and  procedures 

suffers  from  a  lack  of  formal 
Knowledge  engineering 
tools 
domains  of  interest.  Current 
for  understanding 
practice  relies  on  an intuitive,  informal  approach  for  col- 
lecting  expert  knowledge 
it  into  a 
representation 
scheme  adequate  for  symbolic  process- 
ing.  Implicit  in this  process,  the  knowledge  engineer  for- 
mulates  a model  of  the  domain,  and  creates  formal  data 
structures 
(inference 
engine) 
to  solve  the  task  at  hand.  Newell  (1982)  has 
proposed  that  there  should  be  a knowledge  level  analysis 
to  aid  the  development  of  AI  systems 
in  general  and 
in  particular.  This 
knowledge-based 
called  ontological 
paper  describes 
analysis,  which  provides 
this  level  of  analysis.  The 
methodology  consists  of  an  analysis  tool  and  its  princi- 
ples  of  use  that  result  in  a  formal  specification  of  the 
knowledge  elements  in  a task  domain, 

expert  systems 
a  methodology, 

1.  Knowledge  Engineering  needs  a methodology. 

Traditionally,  knowledge  engineering  has  been  a  difficult  pro- 
cess.  Neophyte  knowledge  engineers  often  “don’t  know  where  to 
start.”  The  difficulty  in  getting  started  is  related  to  confusions  over 
how  to  encode  or  classify  relevant  knowledge 
items  from  the  task 
domain.  Clancey  (1985)  provides  a typical  example  from  MYCIN: 

the  most  perplexing  difficulties  we 
Perhaps  one  of 
is  distinguishing  between  subtype  and  cause, 
encounter 
and  between  state  and  process 
. . . For  example,  a physi- 
cian  might  speak  of  a  brain-tumor  as  a  kind  of  brain- 
mass  lesion.  It  is  certainly  a  kind  of  brain-mass,  but  it 
causes  a lesion  (cut);  it  is  not  a kind  of  lesion.  Thus,  the 
concept  bundles  cause  with  effect  and  location:  a lesion 
in  the  brain  caused  by  a  mass  of  some  kind  is  a brain- 
mass-lesion. 

(pg.  3 11) 

This  experience 
standings  about  the  knowledge  elements 
mature  systems  and  cause  endless  problems, 
problem  Newell 
that 
knowledge 
knowledge-based 

is  familiar  to  any  knowledge  engineer.  Misunder- 
in  a  system  often  pervade 
In  response 
to  this 
there  should  be  a 
guide 

of  domains  which  would 

(1982)  has  suggested 

systems  development. 

level  analysis 

structures.  Often,  knowledge 

In  this  paper  we  discuss  a methodology 

for  analyzing  problem 
domains  we  call  ontological  analysis.  Most  problems  encountered 
systems  derive  from  ad  hoc  design  of  the 
in  knowledge-based 
is  collected  by  writing 
knowledge 
rules  or  frames  in  a language-specific 
syntax,  without  a  systematic 
consideration  of  the  underlying  structure  of  knowledge  elements. 
of 
Ontological 
tech- 
knowledge 
is  distinctly 
niques.  An  ontological 
from 
knowledge 
representation 
in  that  it  presents  only  a high 
level  description  of  a  problem’s  knowledge  structure.  Ontological 
analysis  is  used  to  identify  and  construct  an  adequate  knowledge 
representation 

in  their  own  right,  independent  of  implementation 
different 

analysis 
languages 

for  a problem. 

elements 

attention 

on 

the 

analysis 

focuses 

2.  Ontological  Analysis. 

structures.  An  ontology 

To  philosophers,  ontology 

is  the  branch  of  metaphysics 

that  a  knowledge-based 
to  the  step-by-step 

con- 
cerned  with  the  nature  of  existence,  and  the  cataloguing  of  existent 
entities  (Quine,  1980).  The  role  of  ontology  in  AI  has  been  noted 
previously 
(Hayes,  1985;  Hobbs,  1985;  McCarthy,  J.,  1980).  We 
system  is  best 
use  the  term  to  emphasize 
designed  by  careful  attention 
composition  of 
is  a  collection  of  abstract 
knowledge 
that  represent  the  physi- 
objects,  relationships  and  transformations 
cal  and  cognitive  entities  necessary 
some  task, 
that  complex  ontologies  are  most  easily 
Our  experience 
first  on  the 
constructed 
(static)  physical  objects  and  relationships, 
then  on  the  (dynamic) 
operations 
task  world,  and  finally  on  the 
(epistemic)  knowledge  structures  that  guide  the  selection  and  use  of 
these  operations. 

in  a  three  step  process 

for  accomplishing 

that  can  change 

that  concentrates 

indicates 

the 

an  analysis,  and  informal  principles 

Any  useful  methodology  must  contain  both  formal 

tools  for 
constructing 
to 
guide  application  of  the  formal  tools.  Our  research  has  indicated 
that  several  different 
tools  are  useful  for  extracting  and 
defining  ontologies.  We  are  developing  a family  of  languages  col- 
lectively  called  SPOONS  (Specification  Of  ONtological  Structure) 
to  encompass 
tools  based  respectively  on  domain  equations,  equa- 
tional  logic,  and  semantic  grammars. 

of  practice 

formal 

2.1  Domain  Equations  in  Ontological  Analysis 

languages 

(SUPErstructure 

SPOONS),  which 

The  most  useful  and  concise  of  these 

is  SUPE- 
the 
SPOONS 
semantics 
(Gordon  1979;  Stoy 
domain  equations  of  denotational 
1977)  and  algebraic 
(Guttag  and  Horning,  1980). 
specification 
Because  of  the  rich  ontologies 
found  in  most  knowledge  engineer- 
ing  problems,  domain  equations  provide  a concise  and  reasonably 
abstract  characterization 
structures. 
they  do  not  encourage  the  knowledge  engineer  to  get 
Furthermore, 
prematurely 
involved  in details. 

of  the  necessary  knowledge 

is  based  on 

2.1.1  SUPE-SPOONS  Syntax  and  Semantics 

SUPE-SPOONS  consists  of  two  basic  statement  types: 

l  Domain  equations:  Site  = Building  x  Campus.  These  state- 

ments  define  domains,  or  types  of knowledge  structures.* 

l  Domain  element  declarations:  add-meeting:  Meeting  + 
[Meetings  +  Meetings]  These  statements  declare  the  type  of 
specific  domain  elements. 

The  right  hand  side  of  statements  can  be  composed  of  one  or  more 
domains  or  constant  elements  with  operators 
these  ele- 
ments,  Four  primitive  domains,  STRING,  BOOLEAN,  INTEGER 
and  NUMBER,  are  always  assumed  to  be  defined.  Other  primitive 
domains  can  be  defined  by  explicit  enumeration  of  their  elements, 
or  by open  assignment 

to some  collection  of  atomic  elements. 

relating 

*For  most  purposes, 
complex  semantics 
(Stoy  1977) or  with  multiple  equations. 

it  suffices  to  think  of  domains  as  sets.  A more 
is  needed 
if  domains  are  defined  recursively 

KNOWLEDGE  ACQUISITION 

I  963 

Table  1 

Static  Ontology  Fragment 

for  IEC 

Meeting  = <atomic> 
Project  = <atomic> 
Department  = <atomic> 
Person  = <atomic> 
Scheduled-Meeting  = ( Meeting  x Person  ) 
Meeting-Purpose  = 

One-Time-Meeting-Purpose 

+ Repetitive-Meeting-Purpose 

One-TimeMeeting-Purpose 
Repetitive-Meeting-Purpose 
Location-Of-Meeting 
= 

=  {discuss,  plan}  x Project 
=  {staff,  project}  x  Department 

[Meeting  -+  Location-Description] 

Time-OfMeeting 

= 

[Meeting  +  TimeDescription] 

Purpose-Of_Meeting 

= 

[Meeting  +  MeetingDescription] 

Participants-In-Meeting 

= 

[Meeting  +  Person-Description] 

Owner-of-Meeting 

= 

rScheduled_Meetinp  +  Person1 

a  Explicit  enumeration:  MeetingJioom-Accessory 

board,  screen,  . ..} 

=  {black- 

l  Open  assignment:  Meeting  = <atomic> 

The  operators  in the  domain  equations  are of  five  types: 

l  Discriminated  Union:  D  +  E.  Discriminated  union  of  two 
domains  defines  that  domain  composed  of  each  member  of  D 
and  E, where  original  domain  identity  is  preserved. 

l  Cross  Product:  D  x  E.  Cross  product  of  two  domains 
describes  a  domain  composed  of  all  ordered  pairs  whose  first 
element 
is  a 
member  of  domain  E. 

is  a  member  of  domain  D  and  second  element 

l  Domain  mapping:  D  +  E.  Mapping  of  one  domain  onto 
another  creates  a domain  consisting  of  all functions  which  map 
domain  D onto  domain  E. 

l  Collection  of 
subsets  of D. 

Sets:  2**D . Defines  the  domain  consisting  of  all 

l  Collection  of  Ordered 
ordered  sequences  of  D. 

2.2  Building  an  Ontology 

Sets:  D*.  Defines  the  domain  of  all 

in  a  semi-automated 

for  the  task  of  scheduling  meetings 

We  will  illustrate  our method  by  using  SUPE-SPOONS 

to  build 
an  ontology 
in  an  Intelligent 
Electronic  Calendar  (IEC:  Staley,  in  press).  The  task  of  the  IEC  is 
to  schedule  meetings 
fashion,  and  to  support 
the  negotiations  necessary  for  determining  who  will  meet  when  and 
where.  A  partial  ontology  for  this  task  is  found  in  Appendix  A.  It 
should  be  noted  that  the  IEC  is  in the  early  stages  of  design,  and  our 
analysis  here  is  for  expository  purposes  only.  A  complete  ontology 
for  a knowledge-based 
system  that  has  been  implemented  and  runs 
can  be  found  in Freiling  et al.  (1986). 

2.2.1  A Static  Ontology  for the IEC 

in  the  problem  domain  and  identifying 

Ontological  Analysis  begins  by  enumerating 

objects 
perties  and  relationships.  At  the  level  of  the  static  ontology, 
analysis  performed 
of  Chen  (1976). 

the  physical 
their  inherent  pro- 
the 
is  quite  similar  to  the  entity-relationship  model 

relating 

Table  1 presents  a subset  of the  IEC  static  ontology.  Only  those 
to  the  domain  Meeting  are  presented.  This 
equations 
domain  consists  of  abstract  tokens,  or  surrogates  (Codd  1979), each 
of  which 
domain, 
contains  elements  which  indicate  that  a meet- 
Scheduletieeting, 
ing  has  been  entered  on  someone’s  calendar.  A  number  of  map- 
pings  are  also  defined  that  identify 
the  salient  properties  of  meet- 
ings,suchas 

Time-Description,  Meeting-Description  and 

single  meeting. 

represents 

Another 

a 

964 

/  ENGINEERING 

Table  2 

Dynamic  Ontology  for  IEC 

State = Meetings  x Purposes  x Required-Participations 
x  [Meeting  +  Arbitrator]  x  [Meeting  +  Reviewer] 
x  [Meeting  -+  Meeting-Plan]  x  [Person  --+ Schedule] 
x  [Room  +  Schedule] 

+ Autonomous-Operation 

3peration  =  Heuristic-Operation  + Algorithmic-Operation 
} 

+  ( schedule.newmeeting 
Heuristic-Operation  =  { select-arbitrator,selectreviewer} 
Algorithmic-Operation 
Autonomous-Operation 

=  { create-newmeeting,assimilate} 
=  { signoff-or-propose, 
assent, 

arbitrate,initial-proposal} 

schedulemeeting 

= (Purpose  x Required-Participation) 

--+[ State  +  State  ] 

create-new-meeting 

: (Purposex  Required-Participation) 

+  Meeting 

select-arbitrator 
select-meeting-to-act-on 
select-reviewer 
initial-proposal 
signoff-or-propose 

: 

: Meetingx  Purpose  +  Arbitrator 

: State  +  Meeting 

: Meeting  +  [ State  +  Reviewer  ] 
: [ Arbitrator  +  MeetingJlan 

] 

[Reviewer+[Old_Meetirig-Plan-+New_Meeting_Plan] 
x New-Meeting-Plan) 

arbitrate  : (Old-Meeting-Plan 

+  (Meeting_Plan  x  Continue) 

Continuer = BOOLEAN 
assent  : MeetingJQn 
assimilate  : ((Meeting  x Meeting-Plan)  + ((Person 

+  [ (Person  + Room)  -+  Schedule  ] 

+ Room)  x  Schedule)  + (Meeting  x  Arbitrator) 
+ (Meetinp  x Reviewer))  +  r State  3  State  1 

The  domain  Meeting_Purpose  represents 
PersonDescription. 
various  reasons  why  a  meeting  should  be  held,  and  embodies 
the 
analytical  decision 
that  one  time  meetings  are  project  oriented, 
while  repetitive  meetings 
revolve  around  organizational  units  or 
departments.  This  is  a simplification  of  course,  but  what  is  impor- 
tant  is the  ease  with  which  such  decisions  can  be  expressed. 

The  IEC  static  ontology  also  addresses 

time  scales,  meeting 
in  projects  and 
room  characteristics, 
In  total  the  static 
departments  (see  Appendix  A  for  the  details). 
ontology  gives  us  a  picture  of  all  important  elements  within  the 
domain. 

and  individual  membership 

2.2.2  A Dynamic  Ontology  for the IEC. 

Problem  solving  is  often  characterized  as search  through  a state 
space  (Simon,  1981;  Newell  and  Simon,  1972).  Solution  of  a prob- 
lem  consists  of  selecting  operators  whpse  application  transforms  the 
current  state  into  another.  The  dynamic  ontology  defines  a problem 
space  in  terms  of  configurations  of  elements  from  the  static  ontol- 
ogy,  and  then  defines  problem  operators  as transformations  built  on 
the  domain  of problem  states. 

The  dynamic  ontology  defines  which  knowledge 

is  unchanged 
throughout 
the  problem  solving  process  (i.e.,  organizational  charts, 
see  Appendix  A)  and  which  knowledge  changes  as  the  problem  is 
solved  (i.e.,  schedules  and  meeting  plans). 
In  the  IEC,  the  problem 
state  includes  pending  meetings,  their  purposes  and  required  partici- 
pations,  room  schedules, 
individual  schedules,  and  state  informa- 
tion  recording  the negotiation  process. 

Table  2  shows  a  sample  dynamic  ontology 

for  the  IEC.  To 
define  the  dynamic  ontology,  we  must  commit  to  a particular  model 
for  the  negotiation  process.  Negotiation 
is  an extremely  subtle  and 
complex  problem  (Davis  and  Smith,  1981);  for  this  example,  we 
will  use  a very  simplistic  model. 

subtasks 

The  task  of  scheduling  a meeting  is  called  schedule-meeting. 
choosing 
Significant 
reviewers,  producing  proposals, 
them,  and  reserving 
space  on  calendars.  These  operations  are  divided  up  into  algo- 
rithmic  operations  (no  rules  or  heuristics  required),  heuristic  opera- 
tions  (driven  from  a rule  base  to be  specified  in the  epistemic 

an  arbitrator, 

reviewing 

choosing 

include 

Table  3 

Epistemic  Ontology  for the  IEC 

Arbitrator-Selection-Rules 

= 

2 **  (Purpose  x  Persotiescription) 

Meeting-Selection-Rules 

= 

2 ** Meeting-Plan-Pattern 

Reviewer-Selection-Rules 

2 **  (Meeting-Plan-Pattern 

= 

x PersonDescription) 

ontology),  and  autonomous  processes  (which  do  not  run  in  the  IEC 
at all, but  represent  the  behavior  of  independent  actors.) 

Our  negotiation  model  proceeds  as  follows.  First, 

the  IEC 
se  ect  arbitrator), who  proposes  an  initial 
selects  an  arbitrator  (  1 
initial-proposal).  The  meeting  plan  consists  of 
meeting  plan  ( 
proposals  about  time,  location,  and  participants  of  the  meeting,  cou- 
pled  with  signoffs  from  participants.  A plan  is  considered  complete 
when  the  signoff  list  for  each  part  of  the  plan  is  the  same  as the  list 
of participants. 

a  counter-proposal 

is  on  the  table,  a  reviewer 

Once  a  plan  for  the  meeting 

is 
selected  to  look  at the  plan  (select-reviewer)  and  either  approves 
it  or  makes 
(signoff-or  propose).  If  a 
is  made  the  arbitrator  selects  either  the  old  propo- 
counter-proposal 
sal  or  the  counter-proposal 
as  the  standing  proposal  (arbitrate) 
then  selects  a  new  reviewer  (select-reviewer).  After  each  deci- 
sion,  the  arbitrator  also  decides  whether  to  continue  the  negotiations 
(arbitrate). If negotiations  are halted,  all participants  are required 
to  accept  the  current  version  of the  plan  (assent). 
The  IEC  divides  its  time  between  coordinating 

the  negotiation 
processes  for  several  meetings. 
It makes  use  of  a heuristic  process 
(select-fneeting-to-act-on)  to  decide  which  meeting  to  work  on 
at any pomt  in time. 

2.2.3  The  Epistemic  Ontology. 

The  dynamic  ontology  defines  the  operations  available  to  the 
IEC  for  performing 
its  task.  The  epistemic  ontology  defines 
knowledge  structures  to  guide  the  selection  and  use  of  these  opera- 
tions.  Table  3 shows  the  epistemic  ontology  for the  IEC. 

The  epistemic  ontology  usually  contains  two  different 

types  of 
type  is  used  to  select  which 
knowledge  structures.  One  knowledge 
operation  should  be  performed.  The  other  knowledge 
type  controls 
the  actual  performance  of  operations.  Because  our  simple  negotia- 
tion  model  is  so  rigid,  none  of  the  former  appear,  In  fact,  the  only 
knowledge  structures  that  do  appear  are  those  needed  to  guide  the 
operations  classified  as  heuristic  operations  in  the  dynamic  ontol- 
and 
ogy: 
select-reviewer. 

select-meeting-to-act-on, 

select-arbitrator, 

For  select-arbitrator,  we  assume  that  the  purpose  of  the 
meeting  dictates  who  a likely  arbitrator  should  be  (e.g.  the  ranking 
manager  of  the  group  calling  the  meeting),  so  that  arbitrator  selec- 
tion  rules  need  only  associate  certain  purpose  patterns  with  descrip- 
tions  of likely  persons. 

Rules  to  select  meetings 

to  work  on  and  reviewers 

to  continue 
negotiation  depend  on  the  current  version  of  the  meeting  plan. 
Thus,  these  rules  require  the  definition  of  a pattern  that  can  success- 
fully  match  meeting  plans.  For  meeting  selection  rules,  all  that  is 
required  is  that  the  meeting  plan  match  the  pattern  -- that  will  make 
it  a candidate  for  selection.  For  reviewer  selection  rules,  the  meet- 
ing  pattern  must  be  associated  with  some  suggestion 
regarding  a 
reviewer. 

To  complete  the  epistemic  ontology,  the  details  of  patterns  and 
the  matching  process  need  to  be  defined  for  meeting  plans  and  pur- 
poses.  The  interested 
reader  is  referred  to  Appendix  A  for  some 
sample  definitions. 

3.  Principles  of practice 

including  a  system 

We  have  performed  ontological  analyses  on  a  wide  range  of 
troubleshooting  Tektronix  Oscillo- 
domains 
scopes  (Alexander  et  al.,  1985;  Rehfuss  et  al.,  1985; Freiling  et al., 
1986),  MYCIN’s  medical  knowledge  (Shortliffe,  1984), design  rule 
checking 
(Lob  1984),  oscilloscope  operation 
and  parts  of  the  IEC  (Staley,  in  press).  Each  analysis  has  improved 
our  understanding  of  the  problem  domain,  and  the  use  of  SUPE- 
SPOONS  to  sketch  out  designs  has  helped  us clear  up many  confus- 
ing  situations. 

for  nMOS  circuitry 

Through  this  experience  we  have  built  up  a series  of  principles 
for  constructing  ontologies  with  SUPE-SPOONS.  A  methodology 
is  more  than  just  a  formal  notation, 
it  also  requires  guidelines  of 
proper  practice.  We  have  identified  seven  guidelines  so far. 

1. Begin  with  physical  entities,  proceed  to  their  properties 
and  relationships 
from  there.  The  most  accessible  elements  of 
any  task  domain  are  usually  the  physical  objects  and  relationships 
that  must  be  manipulated.  Formalizing 
these  provides  an easy  way 
to  get  started. 

for  extracting  an  ontology 

The  recommended  procedure 

is  to 
begin  by  analyzing  a  paper  knowledge  base  (Freiling  et  al.,  1985) 
that  describes 
the  task  domain  in  English.  The  paper  knowledge 
base  may  come  from  verbal  protocols  (Ericsson  and  Simon,  1984), 
a textbook,  or  a training  manual.  The  technical  vocabulary  used  in 
the  paper  knowledge  base  provides  the  initial  elements  of  the  static 
ontology.  After  these  vocabulary  elements  have  been  defined  is  the 
time  to  examine  the  more  esoteric  dynamic  and  epistemic  realms, 

2.  The  static,  dynamic  and  epistemic  ontologies  are  not 
strict  boundaries,  use  them  loosely.  The  placement  of  ontologi- 
cal  elements 
into  categories  has  no  formal  effect  on  the  semantics 
of  the  ontology, 
framework. 
Arguing  about  whether  a  knowledge  structure  is  actually  dynamic 
or epistemic  is of little  value. 

the  levels  only  provide  a  conceptual 

they  are  intended 

3.  Clearly  establish 

what 
appear  in  an  ontology: 
class  objects  (surrogates 
not  be  individuated  by  their  properties. 
duated  by  identifying 
IEC,  meetings  are  first-class  objects: 

the  distinction  between  objects  and 
to  represent.  TWO types  of  object 
first-class  and  second-class  objects.  First- 
in  database  terminology;  Codd,  1979) can- 
they  are  indivi- 
In  the 

tokens  (<atomic> in  SUPE-SPOONS). 

Instead 

Meeting  = <atomic> 
Time-OfMeeting 

=  [ Meeting  +  TimeDescription 

] 

Properties  of  first  class  objects  are expressed  via  functions  that  map 
the  objects  into  their  property  values. 

Second-class  objects  refer  to  those  elements  of  an  ontology  that 
represent  aggregations  of  other  elements,  Second-class  objects  are 
individuated 
For 
example,  consider  the  following  second-class  object: 

solely  on  the  basis  of  common  components. 

GregorianTime-Point=YearxMonthxDayxHourx{00,15,30,45} 

Any  two  calendar  dates  are  equal  if  they  consist  of  the  same  year, 
the  same  month,  hour  and  quartile.  Only  when  their  composite 
attributes  are  identical  are the  elements  themselves 

identical. 

The  usefulness  of  this  distinction  usually  does  not  appear  until 
identity 
that  are beyond  the  scope  of 

and  has  to  do  with  issues  of  representing 

implementation, 
and  partial  knowledge  about  elements 
this  paper. 

4.  Understand  and  separate 

intensional  and  extensional 
entities.  There  are  many  cases  in  knowledge  engineering  where  it 
is  important  to  distinguish  between  representatives 
for  the  physical 
objects,  and  for  descriptions  or  viewpoints  of  those  objects.  For  the 
to  define  (extensional)  units  of  absolute  time, 
IEC,  it  is  necessary 
and  relate  them 
to  (intensional)  descriptions  of  time  units  with 
to 
respect 
represent 
and 
Showa  60 (Japanese)  refer  to  the  same  time  interval. 

to  one  calendar  or  another.  Only  then  is  it  possible 

like  1986  (Gregorian) 

that  descriptions 

the  fact 

KNOWLEDGE  ACQUISITION 

/  965 

A  common  way  to  achieve  the  distinction  between  extensional 
representatives  of  real  world  objects  and  intensional  representatives 
of  descriptions  or  classes  of  such  objects 
is  define  representatives 
for the  extensional  objects  with  only  the  bare  minimum  of  structure. 
In the  IEC,  for  instance, 

Real-Time-Point 
Real-Time-Interval 

= INTEGER 

= (Real-Time-Point 

x ReaLTimePoint) 

Here  we  define  the  primitive  points  in  time  as  integers.  We  associ- 
ate  point  0  with  12 midnight  on  l/1/1901,  by  the  Gregorian  calen- 
dar.  The  points  are  15 minutes  apart.  Intervals  of  time  can  then  be 
represented  simply  as  a pair  of  points. 
(There  is  actually  a bit  more 
complexity  for  dealing  with  unbounded  intervals,  see  Appendix  A). 
Intensional  descriptions  with  respect  to various  calendars  can be 

constructed  as necessary  from  different  parts  of the  description. 

IntensionalTimeSoint 

= 

GregoriaTimePoint 
Japanese_ImperialReign-Time-Point 

+ 

Gregorian-Time-Point 

= 

Year  x Month  x  Day  x  Hour  x  ( 00,  15,30,45  } 

Japanese_lmperialReign-Time-Point 

= 

Era  x  Year  x  Month  x Day  x Hour  x  { 00,15,30,45 
intensional 

Finally, 
descriptions  by the  use  of  various  interpretation  functions: 

can  be  related 

description 

to  extensional 

} 

interpret  : [ Intensional-Time-Point 

+  Real-Time-Point 

] 

Extensional 
defined  as  equality  of  the  image  under  the  relevant 
functions. 

identity  of  descriptions  of  varying  sorts  can  then  be 
interpretation 

5.  Build  relevant  abstractions 

through  the  use  of generali- 
zation  and  aggregation.  Generalization  and  aggregation  (Smith 
and  Smith)  arc  ,common  techniques 
for  building  large  knowledge 
structures. 
It  is  Interesting  to  note  that  generalization  and  aggrega- 
tion  steps  have  a  direct  manifestation  as  discriminated  unions  and 
Cartesian  Products: 

GENERALIZATION:  Car = (Compact  + Luxury-Car  + Truck) 
AGGREGATION:  Car-Assembly  =  (Engine  x  Chassis  x  Body 

x  Drive  _ Train) 

through 

aggregated 

An  ontology  may  also  contain  many  implicit  generalization 
and 
aggregation  relations.  Even  the  properties  of  a first  class  object  are 
implicitly 
the  fact  that  some  particular  car 
defines  values  for  each: 
Car = <atomic> 
Type  = [ Car  + 
Has-Engine  = [ Car  +  Engine  ] 
Has-Chassis  = [ Car  +  Chassis  ] 
Has-Body  =  [ Car  +  Body  ] 
HasDrive-Train 

[ Compact,  Luxury-Car,  Truck  ) ] 

= [ Car  -+  Drive-Train 

] 

Note  also  that  generalizations 
in  the  properties  of 
objects  as  well.  Instances  of  the  domain  Car,  for  example,  can  be 
decomposed 
images 
under  the  Type  function. 

into  Compacts,  etc.  on  the  basis  of  common 

are  implicit 

6.  Encode 

rules  as  simple  associations,  and  heuristic 
steps  as  mappings  between  domains.  Novices  at  Ontological 
Analysis  are tempted  to  define  rules  in  a form  like; 

type 

from  a  circuit 

Gate_Recognition-Rules 

= [ Circuit  +  Gate-Type 

] 
(from  an  Ontological  Analysis  of  RUBICC 
fragment 

(Lob 
This  mapping 
really 
1984))  to  choose  a  gate 
the  heuristic  task  that  uses  rules,  rather  than  of  the  rules 
describes 
themselves.  We  prefer 
to  analyze  rules  as  simple  aggregations, 
because  this  makes  it  easier  to  spot  multiple  uses  for  the-same  rule 
structure: 
= 2 **  (Transistor-Pattern  xGate_Type) 
Gate-Recognition-Rules 
+  [ Circuit  +  Gate-Type 
] 
mcOgnize  : GateRecognition-Rules 
synthesize 
-+  [ Gate-Type  +  Circuit  ] 
: GateRecognitionRules 
Another  advantage  of  separating  the  rules  from  the  heuristic  task  is 
that  it  focuses  explicitly  on  the  need  to  define  classes  of  patterns 
and matching  criteria. 

-_ 

966 

I  ENGINEERING 

Table  4 

Glib  Fragment 

<signal  value>  ::= ‘HIGH1 ‘LOW’ 
<signal>  ::= ‘SIGNAL-‘cintegen 
<atomic  signal  predicate>  ::= <signal>  IS <signal  value> 
<signal  predicate> 

::= <atomic  signal  predicate> 

]  <atomic  signal  medicate>  ‘when’ <atomic  signal  medicate> 

7. Ensure  the  compositionality  of  elements.  This  case  illus- 
ates vividly  the  usefulness  of  our  methodology.  We  first  encoun- 
tered  this  problem 
in  the  process  of  building  a  semantic  grammar 
(GLIB)  in  order  to  extract 
instrument 
behavior  (Freiling  et  al.,  1984). Table  4  shows  a fragment  of  GLIB 
that  can  generate  the  following  atomic  signal  predicate. 

the  ontology  of  electronic 

SIGNAL-3  IS HIGH 

that  this  signal  predicate  would  map  signals 
Initially  we  assumed 
the  semantics  of  two  such  state- 
into  Boolean  values.  However, 
ments  combined  with  the  connective 
when was  not  at  all  clear.  If 
when  was  assumed 
then  the  result 
would  be  returned  by  one  of  the  16 truth  function  of  two  Boolean 
values,  clearly  not  what  we  had  intended. 

to  produce  a  Boolean 

itself, 

SIGNAL-3  IS HIGH  when  SIGNAL-4  IS LOW 

Using  domain  equations  to  analyze  the  problem, 

Signal  = [Time  +  Value] 
Signal-Predicate  = 

[(Signal  x  Signal-Value 
= [([Time  +  Value]  x  Signal-Value)  +  BOOLEAN] 

) +  BOOLEAN] 

we  discovered 
that  our  signal  predicate  as defined  was  dropping  the 
temporal  information  and  performing  a global  comparison  with  the 
threshold  value.  This  problem  was  solved  by  creating  a  more 
appropriate  definition  for  signa~~redicate,  which  follows: 

SirmaLPredicate  = 
-  &$& 

x  Signal-Value)  +  [Time  +  BOOLEAN]  J 

= [([Time  +  Value]  x  Signal-Value) 
+  [Time  -+  BOOLEAN]] 

when:  [[[Time  +  BOOLEAN]  x  [Time  +  BOOLEAN]] 

+  [Time  +  BOOLEAN]] 

Thus,  the  comparison  made  by  the  si gnal9redicat  e is  made  at 
each  instant  of  time,  so  that  the  result  is  not  a  single  truth  value 
computed  from  the  whole  signal,  but  a  truth  value  for  every  time 
unit  of  the  signal.  This  makes  it  possible  for  when  to  preserve  its 
when  functional  character,  since  the  truth  function  (logical  and)  is 
now  applied  on  a point  by  point  basis.  The  compositional  analysis 
of  this  type  of  problem  is  common  to  researchers  familiar  with  the 
techniques  of  semantics  and  model  theory  (Allen,  1981).  Our hope 
is  that  a language  like  SUPE-SPOONS  can  make  such  techniques 
available  to practitioners  as well. 

4.  Future  Work 

There  are  a number  of  weaknesses  with  the  ontological  analysis 
technique  as  currently  defined.  Even  so,  we  have  found  the  metho- 
dology  useful  for  conceptualizing 
a  knowledge  engineering  prob- 
lem,  and  creating  a forum  for  cogent  discussion.  Consequently,  we 
actively  use  the  ontological  technique  on  a day  to  day  basis. 

Simultaneously,  we  are  defining  the  theoretical 

foundations  of 
the  methodology.  Our  goal  is  to  create  a formal  mathematical  sys- 
tem  for  ontological  analysis  of  problem  solving  domains.  Formal 
systems  allow  the  creation  of  tools  for  automatically  checking  and 
organizing 
the  resulting  analysis,  automating  the  creation  of  some 
components  of the  ontological  systems. 

We  feel 

that  SUPE-SPOONS 

tool  that 
enables  knowledge  engineers 
to  sketch  out  solutions  to  knowledge 
engineering  problems  at a fairly  high  level  of  abstraction.  The  limi- 
tations  of  domain  equations  prevent  a  premature  attention 
to  the 
low-level  details  of  a domain.  Eventually,  however,  those  details 

provides  a  valuable 

do  need  to  be  addressed.  We  feel  that  this  is  best  accomplished 
with  a  separate 
language,  and  are  actively  working  on  another 
member  of  the  SPOONS  family  (T-SPOONS)  that  uses  equational 
logic  to define  and  constrain  actual  domain  elements  beyond  simply 
naming  their  types. 

In  practice,  we  have  found  it  hard  to  get  consistent  analyses 
from  different  knowledge  engineers.  Only  experience  will  show  us 
the  proper  formulation  of  the  methodology.  Presently, 
there  is  no 
standard  concept  of  a  virtua2  machine 
to  be  assumed  when  the 
analysis 
for  example 
has  implicitly  assumed  concepts  such  as  stack  that  form  the  virtual 
machine  for  programming 
to 
establish  a standard  to  serve  as  a basis  for the  methodology. 

language  analysis.  We  are  working 

is  being  performed.  Denotational 

semantics, 

(1985) 

connections  with  Clancey’s 

Finally,  we  are  working  to  connect  our  work  with  other  theoret- 
ical  work  on  the  nature  of  the  knowledge  level.  Specifically,  we  see 
two 
of 
classification  problem  solving.  First,  his  notions  of  generalization, 
in  our 
aggregation  and  heuristics  have  a  more  formal  description 
formalism.  Second,  Clancey  suggests 
tech- 
niques  compose  to  form  larger  knowledge-based 
systems.  Ontolog- 
ical  analysis  can  provide  a means  to highlight  this  composition  pro- 
cess.  For  both  of  these  concepts,  we  hope  eventually 
to  be  able  to 
build  demonstrations 
that  connect  these  higher  level  tasks  with  the 
primitive  ontological  elements  of  the  problem  domain. 

that  problem  solving 

analysis 

recent 

5.  Summary 

We  have  presented  a  technique,  ontological  analysis,  that  has 
much  promise  as  a  knowledge  engineering  methodology.  Metho- 
dologies  of  this  type  will  release  the  discipline  from  ad  hoc  descrip- 
tions  of knowledge  and  provide  a principled  means  for  a knowledge 
engineer  and  expert  to  analyze  the  elements  of  a  problem  domain 
the  analysis  to  others.  The  abstract  level  at which 
and communicate 
domain  equations  characterize 
the  semantics  of  structures  and  pro- 
cedures,  not  specifying 

too  much  detail,  help  in this  regard. 

The  effectiveness  of  a  technique  depends  critically  on  the  for- 
to  guide  its  use.  Such  prin- 
mulation  of  more  and  better  principles 
ciples  only  come  painfully  with  much  practice.  We  invite  other 
knowledge  engineers 
to  try  this  approach,  and  relate  their  experi- 
ences. 

6.  References 

Alexander, 

J.H.,  M.J.  Freiling,  S.L.  Messick  &  S.  Rehfuss. 
Efficient  Expert  System  Development 
through  Domain-Specific 
Tools.  Fifth  International  Workshop  on  Expert  Systems  and 
their  Application,  Agence  de l’hrformatique  Etablissement  Pub- 
lic  National,  Avignon,  France,  May,  1985. 

Aids  Troub- 
Smalltalk- 
Systems  and  Software,  4,  4, 

Alexander, 

J.H.  &  M.J.  Freiling. 
leshooting  System  Development. 
April,  1985. 
J.F.  An 

Interval-Based 

Knowledge. 
bia,  Canada,  August,  1981. 

Allen, 

of  Temporal 
In  Proc.  ZJCAI-1981,  Vancouver,  British  Colum- 

Representation 

Chen,  P.P.  The  Entity-Relationship  Model  --  Toward  a  Unified 
View  of  Data.  ACM  Transactions  on  Database  Systems,  1,  1, 
March,  1976. 

Clancey,  W.J.  Heuristic  Classification.  Artificial  Intelligence, 

289-3X),1985. 

27, 

Codd,  E.F.  Extending 

the  Database  Relational  Model  to  Capture 

More  Meaning.  ACM  TODS  4 :4, December  1979,397-434. 

Davis,  R.  &  R.G.  Smith. Negotiation  as  a Metaphorfor  Distributed 
Problem  Solving.  Artificial  Intelligence  Laboratory  Memo,  624, 
MIT,  May  1981. 

Ericsson,  K.A.  &  H.A.  Simon.  Protocol  Analysis.  MIT  Press; 

Cambridge,  MA,  1984. 

Freiling,  M.J.,  J.H.  Alexander,  S.L.  Messick,  S. Rehfuss  &  S.  Shul- 
man.  Starting  a  Knowledge  Engineering  Project  -  A  Step-by- 
Step  Approach.  A.I.  Magazine,  6,3,  Fall,  1985. 

Smalltalk-80  is a registered 

trademark  of Xerox  corporation. 

Freiling,  M.J.  &  J.H.  Alexander.  Diagrams  and  Grammars:  Tools 
for  the  Mass  Production  of  Expert  Systems.  First  Conference 
IEEE  Computer  Society, 
on  Artificial  Intelligence  Applications, 
Denver,  Colorado,  December,  1984. 

Freiling,  M.J.,  J.H.  Alexander,  D.  Feucht  &  D.  Stubbs.  GLIB  -  A 
Language 
the  Behavior  of  Electronic  Devices. 
Applied  Research  Technical  Report,  CR-84-12,  April  6,  1984; 
Tektronix,  Inc.,  Beaverton,  OR. 

for  Describing 

Freiling,  M.J.,  S. Rehfuss,  J.H.  Alexander,  S.L.  Messick,  & S. Shul- 
man.  The  Ontological  Structure  of  a  Troubleshooting  System 
for  Electronic 
on 
Applications  of Artijicial  Intelligence 
to Engineering  Problems, 
Southampton  University,  U.K.,  April,  1986. 

Instruments.  First  International  Conference 

Gordon,  M.J.C.  The  Denotational  Description  of  Programming 

Languages.  Springer  Verlag;  New  York,  NY,  1979. 

Guttag,  J.  &  J.J.  Horning.  Formal  Specification  as  a  Design  Tool. 

Xerox  PARC  Technical  Report,  CSL-80-1,  January,  1980. 

Hayes,  P.J.  Naive  Physics  I:  Ontology  for  Liquids.  In J.R.  Hobbs  & 
(Eds.),  Formal  Theories  of  the  Commonsense 

R.C.  Moore 
World.  Ablex  Publishing;  Nor-wood,  NJ,  1985. 

Hobbs,  J.R.  Ontological  Promiscuity.  23rd  Annual  Meeting  of  the 

ACL,  Chicago,  July,  1985. 

Lob,  C.  RUBICC:  A  Rule-Based  Expert  System for  VLSI  Integrated 
Electronic  Research  Laboratory  Memo 

Circuit  Critique. 
UCB/ERL  M84/80,  University  of  California,  Berkeley,  1984. 

McCarthy,  J.  Circumscription 

-  A  form  of  non-monotonic 

ing.  Artificial  Intelligence,  13,  1980,27-39. 

Newell,  A.  The  Knowledge  Level.  Artificial  Intelligence, 

87-127,  1982. 

reason- 

18,  pp. 

Newell,  A.  &  H.A.  Simon.  Human  Problem  Solving.  Prentice- 

Hall;  Englewood  Cliffs,  N.J.,  1972. 

Rehfuss,  S.,  J.H.  Alexander,  M.J.  Freiling,  S.L.  Messick  &  S.J. 
Shulrnan.  A  Troubleshooting  Assistant  for  the  Tektronix  2236 
Oscilloscope.  Applied  Research  Technical  Report,  CR-85-34; 
Tektronix,  Inc.;  Beaverton,  OR;  September  25,  1985. 

Simon,  H.A.  The  Sciences  of  the  Artificial.  The  MIT  Press;  Cam- 

bridge,  MA;  1981. 

Quine,  W.V.O.  From  a Logical  Point  of  View.  Harvard  University 

Press;  Cambridge,  MA;  1980. 

Shortliffe,  E.H.  Details  of  the  Consultation  System.  Rule-based 
of  the  Stanford 
Reading, 

Expert  Systems:  The  MYCIN  Experiments 
Heuristic  Programming 
MA,  1984. 

Project,  Addison-Wesley; 

Smith,  J.M.  &  D.C.P.  Smith.  Database  Abstractions:  Aggregation 
and  Generalization.  ACM  Transactions  on  Database  Systems, 
2:2,  June,  1977. 

Staley,  J.L.  An  Intelligent  Electronic  Calendar:  A  SmalltaIk-808 
in  press,  Information  Display  Group, 

Application. 
Tektronix,  Wilsonville,  OR. 

Tekniques, 

7.  Appendix  A:  Ontology  for IEC 

Static  Ontology 

= ( Meeting  x Person  ) 

Person  = <atomic> 
Persons  = 2**Person 
Project  = <atomic> 
Department  = <atomic> 
Scheduled-Meeting 
Meeting-Room  = <atomic> 
Name  = <string> 
Group  = <atomic> 

Mee$x&RoomAccessory 
~~rAmqwnent_Type 
Meeting  = <atomic> 

={ blackboard,  screen,  projector} 
=  [conference,  classroom,  auditorium  } 

KNOWLEDGE  ACQUISITION 

/  967 

Gregorian-Point  = Year  x  Month  x  Day x  Hour  x  Quarter 
JapanesePoint 
express-as 
interpret-as 

= Era  x  Year  x Month  x  Day x  Hour  x  Quarter 
+  CalendarPoint] 
: [Calendar  +  [Real-Time-Point 
: [Calendar  +  [Calendar-Point  +  Real-Time-Point] 

+ BlockSchedule 

Event  = Scheduled-Meeting 
Events  = 2**Event 
Assignments  =  [Event  +  Real-Time-Interval] 
Schedule  = Events  x  Assignments 
BlockSchedule 

=  (read,  errand,  fill-out-form) 

x Time-Quantum 

Dynamic  Ontology 

+  Signoffs  ] 

Meeting-Plan  =  [ MeetingProposal 
Signoffs  = Persons 
Arbitrator  = Person 
Reviewer  = Person 
Participant  = Person 
Old-Meeting-Plan 
NewMeetingPlan 

= Meeting-Plan 
= Meeting-Plan 

State  = Meetings  x  Purposes  x Required-Participations 

x  [ Meeting  +  Arbitrator  ] x  [ Meeting  +  Reviewer  ] 
x  [ Meeting  +  MeetingPlan 
x  [ Room  +  Schedule  ] 

] x  [ Person  +  Schedule  ] 

Operation  =  Heuristic-Operation  + Algorithmic-Operation 
{ schedule-newmeeting 
, selectdeviewer 

Heuristic-Operation  =  { select-arbitrator 

+ Autonomous-Operation’+ 

) 

, 

selectmeeting-to-act-on 

) 

Algorithmic-Operation 
Autonomous-Operation 
initial-proposal 

) 

=  { create-new-meeting, 
=  ( signoff-or-propose 

reserve) 
, assent  , arbitrate  , 

schedule-meeting  = (Purpose  xRequired4articipation) 

createnewmeeting 
select-arbitrator 
selectmeeting-to-actn 
select-reviewer 

+[  State  +  State  ] 

: (PurposexRequiredParticipation)+Meeting 

: MeetingxPurpose  +  Arbitrator 

: State  +  Meeting 

: Meeting  +  [ State  +  Reviewer  ] 

initial-proposal 
signoff-or-propose 

: [ Arbitrator  +  MeetingPlan 

] 

: [ Reviewer  +  [ OldMeetingPlan 

+  New-Meeting-Plan 

] 

arbitrate  : (Old-Meeting-Plan 
Continue  = BOOLEAN 
assent  : Meeting-Plan  +  [ (Person  + Room)  +  Schedule  ] 
assimilate  : 

xNewMeeting_Plan) 

((Meeting  xMeeting9la.n)  + 
((Person  + Room)  xschedule)  + 
(Meeting  XArbitrator)  + 
(Meeting  xReviewer))  + 
[ State  +  State  ] ) 

Epistemic  Ontology 

Arbitrator-Selection-Rules 

= 

2 **  (Purpose  xPersonDescription) 

Meeting-Selection-Rules 

2 **  Meeting-PlariPattern 
= 

Reviewer-Selection-Rules 

= 

2 **  (Meeting_Plan-Pattern 

xPersonDescription) 

MeetingPlan-Pattern 

= 

((Time-Pattern  XSignoff-Pattem) 
(Locatiotiattem 
(Participant-Pattern  XSignoff-Pattem)) 

XSignoff-Pattem) 

Time-Pattern  = TimeDescription 
Location-Pattern  = 2 **  Location-Description 
Participant-Pattern  = 2 **  PersoUescription 
Signoff_Pattem  = 2 **  Person-Description 

+  { anytime  ) 

+  { anywhere  ) 
+  { anybody  } 

+  { anybody  ) + 

{ nobody-but-proposer 

) 

Meeting-Purpose  = One-Time-Meeting-Purpose 
+ RepetitiveMeeting-Purpose 

One-TimeMeetingPurpose 
RepetitiveMeetingPurpose 

=  {discuss,  plan,  review}  x Project 
=  (  staff,  project  } x  Department 

Meeting-Proposal  = 

Time-Proposal  + Location-Proposal  + Participant-Proposal 

Time-Proposal  = TimeDescription 
Location-Proposal  = Location-Description 
ParticipantProposal 

= Persons 

Reflection  = [Scheduled-Meeting 

+  Meeting] 

Person-Name  = [Person  *Name]  =  [Name  +  Person] 
Person-Attribute  = 

Name  +  [Name  x  Hierarchical-Link] 
+  [[rep-of}  x  Group] 
+  [ { resp-rep-of}  x  Group] 
+  [{head-of}  x  Group] 

Person-Description  = 2**Person.-Attribute 

HierarchicaLLink  =  {boss-of,  subordinate-of)  * 
Organizationrelationof4erson 

= Hierarchical-Link 

Concession-Type  =  [time,  location, 
Owes-Concession-To 
negotiating-points 
: 

. . . ) 

[(Person  x  Person  x  Concession-Type* 
x  Organization-Relation-of-Person) 

Group-Contained-By 
Member-Of-Group 
Project-Name  =  [Project  +  <string>] 

=  [Person  +  Group] 

=  [Group  +  Group] 

= [(Person  x  Person)  +  Concession-Type*] 

+  INTEGER 

Location-Description 

=  (Room-Capacity) 

x INTEGER 

x  {blackboard,  no-board) 

RoomHas  = MeetingRoom 
Room-Capacity  = MeetingRoom 
ChairArrangement-InRoom 

+  2**MeetingJioomAccessory 

+  INTEGER 

= Meeting-Room  +  Chair-Arrangement-Type 

Building  = <atomic> 
campus  = <atomic> 
Site  = Building  x Campus 
At = [Meeting-Room  +  Site] 
Quarter={OO,15,30,45) 
Hour  =  { 0..24) 
Date  =  (1..31) 
Month  =  { 1..12) 
Year  =  { -BB  . . +BB) 
Cycle  =  {-BB’  . . +BB’) 
Year’  =  {OOO, 100, . . . . 900) 
Ap =  { l.13) 
Day =  (1..28) 
Identified-Time_InteIval 
Calendar  =  [Real-Time-Interval 
Real-Time-Interval 

=  [Real-Time-Point 

+  INTEGER] 

+  Calendar-Interval] 

x  MeetingDescription 

= 
x  RealTimePoint] 
[Real-Time-Point 
+  [RealTimePoint 
x  {unbounded)] 
+  [ {unbounded)  x Real-Time-Point] 
+[{unbounded)x 

{unbounded)] 
Event-Description  = Interval-Description 
Interval-Description 

= 

[(between)  x  Calendar-Point  x  Calendar-Point] 
+  [ {before)  x  Interval-Description] 
+  [{after)  x  Interval-Description] 
+  [(before,  after,  during)  x  Event-Description] 

Calendar-Region  = <atomic> 
Calendar-Point  = Gregorian-Point  + Japanese-Point 
Calendarlnterval 
PointDescription 

= Calendar-Point  x  Calendar-Point 
= 

Calendar-Point  +  [{after)  x  Calendar-Point] 
+  [ {before)  x Calendar-Point] 
+  [{within]  x  Interval-Description] 

968 

/  ENGINEERING 

