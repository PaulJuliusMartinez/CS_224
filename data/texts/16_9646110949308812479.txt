CS 98
ALGOL W IMPLEMENTAT ION
BY H. BAUER S. BECKER S. GRAHAM
TECHNICAL REPORT NO. CS 98 MAY 20, 1968
COMPUTER SC IENCE DEPARTMENT School of Humanities and Sciences STANFORD UNIVERS llTY

ALGOL W IMPLEMENTATION*
--
H, Bauer S. Becker S. Graham
*
This research is supported in part by the National Science Foundation under grants GP-4053 and ~~-6844.

-ALGOL -W IMPLEMENTATION
Table -of.Co,n,tents
1, Introduction . . . . . . ..~.........*0.~.**.e.....*.....".....*
XI. General Organization . . . . . . . . . ..os.*..e.~*....~****.*..*.. 3
lX1. Overall Design . . . . . ..*.0~....~..~e~eo~o.e...e.....*~~.... 4
A. Principal Design Considerations . . . . . ..*......** 4 B. Run-Time Program and Data Segmentation ., ,,,... 6 C. Pass One . . . . . . . . ..~D..O......~e~~.*~.*~.....~.. 7 D. Pass Two . . . ..*..eOC~O.4....*~~..~...~..~~....~ 8
1. Description of Principles and -=. Main Tasks .*0*.*.......0~,00*..*..* 8
2. Parsing Algorithm . . . . . ...*......**.* 8 3* Error Recovery .0....~..~.~.~.,~,~~~, 9 4. Register Analysis . . . ..*.......*.... 11 L- 5* Tables *.....@.,..*......e..*.*.y...* 13 6. Output ,.......*..*0..00..0*~~..~... 13 E. Pass Three . . ..0......*....e...e..e.e........*, 16
L
l-v. Compiler Details . . . . . . . . . . ..~..~~~...~~~~.~~.....~..~... 17
A. Run-Time Organization ..~*0**~..*~...~...*~..., 17 1. Program and Data Segmentation ,,.,., 17 2. Addressing Conventions . ..*.9..*..** 20 30 Block Marks and Procedure Marks ,.., 20 4. Array Indexing Conventions . . . . . ..I.# 22 5. Base Address Table and Lirikage to System Routines . . ..****..o....*.. 23 6. Special Constants and Error Codes ,. 24
;3* Register Usage ..OI.OI.O,,..O..L,..~ 27 Record Allocation and Storage Reclamation .0.0.~.~*0*~0..~~~.**, 27 B. Pass We r....oc.o....o....o..~.*..~*.,.,.....* 33 1. Table Formats Internal to
Pass One . ..0...*ee..o...Q....*.~.* 3c 2. The Output String Representing
36an ALGOL W Program l . . . . . . . . . . . . . . 3* The Table Output of Pass One ..,, O... 39 4. Introducing Predefined Identifiers.. 41

-Table o-f Contents (cant,)

1. Register Allocation .c,oo.ca.aove,,.,,,,,,n 62

2. Block Entry .00~.000000.01.00.00..~~, 65

3* 4.

Block Exit .00~0~00~0000.0.00.0~.~~~ 69 Procedure Statements and Typed

Procedure Designators e6606a60.60. '10

50 -=. 6,

-Procedure Entry 0000000000~660*00oO. 73 ProTsdure Exit .~060000~Q.000b~bOIOO 80

Formal Parameters in Expressions
`7 l

and Assignments "0000d00a*QOledOo* 81 8, Arra.y Declaration aa.oee,,~..o.,..e.,. 83

9. Subscripted Variables ,a,~o..,o~.s,, 89

10. Passing Stibarraye as Parameters ra*a 91

11. Arithmetic Conversion "aeO**00.000.0 94 12. Arithmetic Expressions .o~*ooo*o~*o~lp~

13* Logical Expressions 00000*06*4...00 14, String Expressions oo00000.Q~.0..~~0 115 150 Bit Expressions oooooooo*oqo*.e..*.o 117 16. Record Designators OPOOOOO~C0e0.dOa 118

17. 18.

Field Designators 00000~0~0.000010P 119 Case Statements and Case

i Expressions .00000001U009.0....., 120

L 19, If Statement, If Expression, and While Statement 00.0000000000*00. 122 20. For Statement ~00000~0.0000060000.O 123 21. Goto Statement OoQO6000000*0060,,0~ 127 22. Assignment Statements .000000.90,06 130

. 23. Card Embers "00~000000..*0.00000*. 134 E. Trace Facilities 0 0 `7 40 0 0 0 6 0 0 0 a e OQ 0 0.0.0 0.0.0. 136

Appendix I Example .0~0000.0"00000.0000~~.~~~.*..~~,,*~,... 138

Appendix HI Simple Precedence Grammar *000~4**.0*....*...*.. 144

ii

;. i `i-
..
Figures
4. Example of BEOCKZIIST and NAMETABLE O.O~~O-e~aO 41
-
5. Format of NAMETABLE and field con-knts after Pass Two ..Oa0OO0~~~~0000**06~,~~*.*~.~~*.*.* 52 ff
-=.
L
6. Pass TWO htput MoCabPljl~y~OO.OOO~~~~*~.~*~.~~~ 56 ff
-
iii

I. INTRODUCTION
In writing a compiler of a new language (ALGOL W) for a new machine (IBM System/36O) we were forced to deal with many unforeseen problems in addition to the problems we expected to encounter. In a few instances, we gave in to temptation and changed the language; in many others we would have liked to have been able to change the machine. This report Qescribes the final version of the compiler, Not surprisingly, there are several things that in retrospect we would do differently,
L
both in design of the language and in design of the compiler0 We will
-=.
not discuss these after-thoughts here. The implemented language ALGOL W1) is based on the Wirth/Hoare
proposal 2) for a successor to ALGOL 60. The major differences from - that proposal are in string definition and operations and in complex
number representation. Consideration was given to including both parallelism and data file facilities in the language but both ideas were abandoned because their inclusion would have necessitated substantial changes in those parts of the compiler that had already been written,
The project was initiated and directed by Professor Niklaus Wirth, who proposed many of the ideas incorporated in the compiler and suggested L . ways to bring them about. Joseph W. Wells, Jr. and Edwin H. Satterthwaite,

1) Baueq H.R., Becker, S. and Graham, S.L. ALGOL W Language Descrip-

L.

.

tion, Report CS 89, Computer Science Department, Stanford University (March 1968).

2) Wirth, Niklaus and Hoare, CoAORe A Contribution to the Development of ALGOL. *Comm. ACM 9 (June 1966), ppO 413-431.

1

L
Jr. wrote the a~360 System in which the compiler is embedded, the
<- linkages to the compiler, and the loader. Although the authors did
the bulk of the programming for the compiler, valuable contributions ..
- were made by Larry L, Bumgarner, Jean-Paul Rossiensky, Joyce 33. Keckler,
Patricia V. Koenig, John Perine, and Elizabeth Fong. We are grateful
&l-so for the many helpful comments and suggestions made by the faculty r L- and students of the Computer Science Department. Finally, we grats-
.. fully acknowledge the support given us by the Nationti ScZience FoundaL tion under grants GP-4053 and ~~-68lc4 and the computer time made avail-
able by the Stanford Linear Accelerator Center and the Stanford Computac -=.
tion Center.

II. GENERAL ORGANIZATION
The compiler is divided into three passes, Pass One is a scanner. It reads the source program, converts the symbols to internal codes, deletes comments and blanks, converts numeric constants to internal form, builds a block-structured name-table and lists the source program. Pass Two does a complete syntactic analysis and extensive error checking. It does all static storage allocation. The output of Pass Two is the completed nametable and a binary tree representing those
-=.
parts of the program for which code is to be generated. Pass Three generates the object program in reentrant machine code. The three passes are written in ~~360 1) as separate programs. The
passes use a common data area for data shared by them. This area remains in core if sufficient room is available; otherwise the tree output of' Pass Two is written on secondary storage and read segmentby-segment by Pass Three.
The discussion is divided into two sections. Part III describes the design. of the three passes. Part IV provides information about the details of the compiler and is devoted primarily to a discussion L of the run-time organization and the object code generated by the compiler.
1) Wirth, Niklaus. "~~360, A Programming Language for the 360 Computers," Journal-ofmth-e ACM 15 (January 1968), pp* 37-74,
3

i
III0 OVERALL DESIGN
A. Principal Design Considerations ..
Following are the main features we wished to incorporate and some
of the ways they were achieved,
1. Efficient object code, All constant arithmetic (e.g. F=+a> is do3e at compile time. Global variables we accessed (at run-time) with no overhead. The intermediate language specifies nearly optimal use of the registers, resulting in a minimum of temporary saves. Optimization which involves rearrangement of the source progrm (for instance, removing computations from f-or loops) is not done.
C
2, Code generation only for syntactically and semantically correct programs. A complete syntactic check and a search for al1 errors detectable at compile time are completed before any code is generated. Pass Three is called only if no errors are found.
30 Vseful tools for numerical computatfon.O Complex arithmetic in standard mathematical notation and doubleprecision (long) arithmetic are implemented features of the language, Facilities to detect overflow and make appropriate recovery are provided, as is a set of standard functions of analysis 0
4, Fail-safe reliability.
Run-time checks on such things as array subscript bounds, substring operations and formal procedure parameters prevent loss of control (i .e. wild transfers) by the obje(% program.

.I

f -I

f---

WI .

B. Run-Time Program -an_d_DIat_a Segmentation
Program segments and data segmentm are 'both logically and physically separate, Program segment8 correspond to the structural unit "procedure" in ALGOL W. The scope of a data segment is an ALGOL W block containing declarations. Program segments are allocated stat%-tally (i.e. once only at compile-time); data segments are created dynamically (i,e. each time the block is entered at run&i&e).

L:

IL C!. P-ass On-e

i
i Pass One receives the source program as input in 80 character

I records, Its functions are to -. L
I 1, list the character string and assign it line numbers;

2. recognize basic entities of the language and :.place them in an output string with byte (8 `bit) codes;

30 convert constants to internal form;

L.

4, make a table of identifiers arranged by blocks and containing type and simple type information specified in declarations,,

The input is scanned until a symbol is recognized - ioeO a delimiter, -==.
t an %dentifier, or a literal,, In response to this symbol a code reprer
L senting the symbol is placed in the output string. New blocks are noted, and declared varia~bles are placed in the NMBTABLE which is
1 t organized by blocks, A new block is entered at each begin, at the
beginning of the formal parameter list in a procedure declaration, and

at each for statement, A BLOCKLIST table containing one entry for

each block in order of entrance points to the entries in the NWABLE

corresponding to the identifiers declared in a given block. A table

of identifier character strings is also fiM.ed for use in Pass One:

and Pass Two,

t L
Do _Pa_ss_1Tw-o

1. Description of Principles -and-.MIafn Tasks

, L

The function of pass Two i&o do a complete syntax check of the

source program, to do a thorough error analysis and generate all corn-

i pile-time error messages, to complete the IMMEMKU, to build the

constant tables, and to convert the program to an intermediate language

to be used by Pass Three for code generation. The syntax analysis

I

I I-

is done by means of a simple precedence ianaLyzer. The interpretation

rules of the grammar specLfy the other Pass Two actions. i --.
2, Parsing Algorithm

L The algorithm for syntactic analysis is essentially that used by Wirth in I3JI.B. l? Some program modifications have been made. First:,
the look-up to determine whether a string is the right part of a pro-
duction has been changed to include a check on the length of the string
and the length of the right part, Second, the full precedence matrix
is used rather than the precedence functions. This is done in order
to detect errors sooner and to provide better error recovery than is
'* possible with funct$ons. Third3 the relations found when scanning to
. the right looking for+ are stacked, Therefore, they can be easily retrievedwhen in the process of scanning to the left for 4 rather than
having to be fetched again .fYom the matrix. The matrix is packed four
elements to a byte in order to conserve space, Consequently, a fetch
i
Wtfrth, Niklaus and We'ber, Helmut0 9fEXJIIR: A Generalization of ALGOL and,its Formal Definition: Part IO" Com~v ACM 9 (January 1966), pp0 13-23, 250
8

from the matrix is slower than retrieval from a stack, However9 every time a reduction is made, the relation of the new sym'bol to the symbol below it on the parsing stack mus..t 'be fetched from the matrix and stacked. If most of the rules that are appl.ied have right parts of length one or two, there is no significant gain in speed by stack9ng the relations since few unnecessary matrix fetches would have to be done., However, there is a gain in efficiency with longer right parts.
For each syntax rule there is a corresponding interpreta-M,on rule which is executed when the reduction is made, For 'efficiency2 Interpretation -r-.ules are written dire&ly in ~~360 rather than in some metalanguage. Associated with the parsing stack is a parallel value stack containing information used by the interpretation ruJ.es.
30 Error Recovery
When simple precedence analysis is used, there are two situations in which a syntactic error can be detected - when a reducible substring ' ( Le, one delimited by 4 and*> ) is not the right part of any production and when the top of the parsing stack has no relation ( + =$ 9 ) to the incoming symbo& .
In the first situation, the statement in which the error occurred . is deleted from the program To accomplish this in ALGOL WI the stack
is backed up to <BLOCK BODED 9 <BLOCK n 9 <CASESEQ m , or the file delimiter and the input string 9s advanced to end, ";":, 'begin, or the file ,deJ.imiter. If end is erased from the stack, it becomes the incoming symbol, otherwise the next symbol O:CI the input string is taken, If a nonterminal which affects the value of the block ntiber is removed
9

from the stack, the block number is adjusted accordingly,

Special care is taken with begin's, end's and the block number so

that the block numbers conform to those assigned by Pass One, If the

block structure were to be destroyed, many spurious errors would be

generated, If Pass One had been done by syntactic analysis, these

t
special fix-ups would be unnecessary provided that Pass One and Pass

;I i.

Two recovered in the same way.

If the top of the stack has no relation to the incoming symbol, a
t
i variety of recovery actions are possible. A symbol can 'be inserted,

I the top of the stack can be deleted, a~~other symbol can replace the --.
i
top of the stack, a reduction of the stack can be forced., or the in-

! i

coming symbol can simply be stacked. The action to be taken is deter-

mined by the symbol at the top of the stack0 For each symbol in the

grammar, there is an entry in table EMCB pointing to a list of recovery

iL actions in table ERTB,
In order for a symbol to .be inserted, it must have a relation to !
the incoming symbol and the top of the stack must have a relation to it. i
If the inserted symbol is 4 the incoming symbol, the input string is Li backed up and the inserted symbol becomes the incoming symbol, Simi-

I larly a symbol replacing the top of the stack must have a relation on

i either side,

i An inserted or replacing symbol may generate another error message. L
For instance, an undefined identifier is assumed to be integer although

i it may be intended as another simple type. If the trace flag is set:,

L the error recovery action is always printed out unless the incoming
I
i symbol was stacked, A flag is set so that tihe same action will not be

L 10

tried the next time through. (e .g, If the top of the stack is <BLOCK-
I- BODY> and it has no rel,ation to the incoming symbol, a ";" my be inL serted, "<BLOCKBOD'Ib ; " reduces to <BLOCKBOD35 0 Tf the error routine
.. is called again before the input string has advanced9 it must not
L again insert a " ;I'. )
4 o Register Analysis

Two register counts are kept for each relevant position in the
Li stack - a count of the integer registers and a count of the floating

registers up to that point, The simple type of the operation determines

i the `active" set of registers. The active count resulting from a binary

operation Is determined as follows:
t L
Suppose the active counts for the two arguments are equal - both
Lt have value k. Then k registers will. be needed to calculate the first
argument. At the end of that calculation, one register will be in use,

containing the value of the first argument d That regfster remains in

use during the calculation of the second argument, Since the binary

operation uses only the register containing the first argument, the

I L

resulting count Ys k+l.

(Eslcaemtple kIi?; 7 active count for i, ki >, 0)
ii
integer a, t;; oOo a + b em*
I
i ka = kb = 00 To compute the sum it 5s necessary to load a regls-

L ter with a and add b into the register containing a. Thus

L

f L"
E&ample 2
integer a, b, cs 51; 0 0 o (.&b) - (c+d) oO.,
ka+b = kc+d z-' 1, The result (a-tb) occupies one register, This register holds the value of a+% while e+d is computed, using s,n- other register 0 Then the register for a+b is subtracted from the register for c+d, leaving the result in the register previously occupied by a+`b. Thus 9
k(,a+b) - ( cd-d) = 2 '
Suppose the active counts for the two arguments are unequal - the --.
counts are kl and k2 where kL > k2 0 Then if the argument using kl registers is computed first, that result occupies one register leaving kl$ registers to compute the second argument 0 Since kl > k29 kl z k2+l, hence kl -1 >, kg0 Therefore there are enough registers left to compute the second argument o Hence max(kljk2) is the resulting count. (If the other argument were computed first, kl+l registers would be necessary.)
Notice that the above reasoning assumes that the operators are commutative (or that appropriate reverse operators exist) 0 Adjustments must be made for some noncommutative operators, For instance DIV and REM require a minimum of two registers if the second argument L has count 0 and three integer registers if it has a non-zero count,
The resulting count of the number of 'inactive' registers is the maximum of the counts for the arguments. The counts for an if expression or a case expression are the maxima of the counts of the consti-
L-
tuent express ions D Register counts for function calls are set arbig tarily to a large number since all registers in use before a function call are saved,
12

t1'.

5. ,Tables
Pass Two completes NAMETABLE, assigning hierarchy numbers, program segment numbers and addresses fqr variables and descriptors, and inserting array dimensions, local stack origins and record information. A bit string is inserted for every reference variable, indicating positionally to which record classes it may refer. A run-time constant table and a compile-time constant pointer table are constructed for each program. Information local to Pass Two is kept in the interpretation stack rather than in tables,

6. Output=
The output of Pass Two is a string called TREE representing the linearization of a modified structural tree of the program being parsed. Each nonterminal node has either one or two subtrees.
An n-ary construction is represented as a binary tree by making the n components terminal nodes joined by a binary list operator.

Example

program fragment:

F(B, 5, C + D, GOT0 X) where F is a procedure, C is integer, D is real

Tree:

where AP, is an actual parameter list operator and AP) indicates the end of the list.

Semantic information is not included in the tree because it is contained in MAMETmLE.
-
The order in which the nodes occur in the string is shown in the following diagram:
e
It can be seen that the subtrees of a node precede the node. A nonterminal binary node contains a pointer to its left subtree; its right subtree will directly precede it. Each binary node has a switch m indicating which of its subtrees is to be processed first. Nodes are not processed until their subtrees (in most cases arguments) have 'been processed. The normal mode is to process the left subtree first, 'thereby preserving the order in which the structures occurred in the source program. The exceptions are binary arithmetic operators and the assignment operators. For these operators, the subtrees represent two operands. In order to minimize register usage, the operand using the larger number of registers is compiled first. (Such optimization

i

I

L is permissible according to the language definition, 1) which states
! that: L , "If an operator operates on. two operands, then these operands L may be evaluated in any order, or even in parallel, with the
exception of the case mentioned in 6.4.2,2.0p
i Another motivation for using the tree rather than reverse polish
was the hope that it would be a natural way to represent parallelism in
i
the language. This use of the tree was investigated but was not fully
,i. developed because it was decided not to implement the parallel. features
of the language.
--.
L A separate tree is generated for each program segment. In theory
///L the program segments (procedures) could be processed by Pass Three in any order; in practice they are processed in the order they occur.

h

-
1) Wirth, N. and Hoare, C.A,R. "A Contribution to the Development of
AMOZ", Corm. ACM. 2 (June 1966), 413-432. 15

i L-
E. -Pass Thre-e The essence of Pass Three is the algorithm for scanning the linearized trees, beginning at the root node. The switch with each binary operator indicates which branch the scan should follow. The operator nodes are not otherwise examined at this stage; code generation begins with the first terminal node encountered, i Pointers to the nonterminal nodes are stacked in STACK as they are encountered in the scan, STACK also contains a field in which information about the first subtree is kept while the second subtree is compiled. --. For each binary node there are two phases of code generation. In the first phase the operator is considered together with its first operand; in the second phase the operator and its second operand are considered . Hence there are two compilation (output-generation) rules associated with each binary node, Each unary nonterminal node has one associated rule m
16

IV COMPILER DETAILS 1 A. Run-Time Organization

1. Program -and Dat-a Segmentation

Since no compiled code is modifiable at run-time, all program
L
segments are re-entrant. Data segments are created at block and pro-

cedure entry and deleted (by resetting the stack pointer) at block

and procedure exit.

i Program segments are allocated statically at the low end of avail-

I L

able core. Data segments are then allocated dynamically, beginning --.

jwt after the program segments and proceeding toward upper core,

Segments for system routines a& their data are alloc%ted statically
i.
at the high end of available core. Record pages are allocated dyna-

mically downward beginning immediakely before the system routines and

system data. If the data stack and the record pages meet, the run is L terminated.

t/
PROGRAM SEGMENTS

DATA STACK

L

RECORD

PAGES

t

1 SYSTEM ROUTINES
L
I AND THEIR DATA

AVAILABLE CORE 17

Each block and procedure requires a data segment. When a block

occurs as the 'body of a procedure, its data segment is merged with the

procedure data segment.

..

i A diagram of a typical data segment is shown below.

,FP .

20 bytes

REFVAR

REFARY

4 /

12 The static link chain - entries hold the

local

11

bases of all currently accessible data

L-

display 1

segments. If n is the number of the re-

-*.. -- ,.-. .- --- -n---

gister holding the base of this segment:

L (13-n) * 4 bytes

DPD-dynamic

parameter

* (cf. IV.D.5)

descriptors

PV-parameter

* (Occurs only if procedure has value,

values

result, value/result, or array para-

meters. cf, IV.D.5)

local variables

and array descriptors

local stack .
.

For dumping registers and partial results.

L array

elements -

Occurs only for block which is the procedure body of a procedure with parameters.

18

Each program segment has the following form:
t
N-umber of formal parameters of the L procedure

L

SFPD's

Static formal parameter descriptors

Branch table

Litera table i --
i *Procedure entry code iI - Procedure body code
Procedure exit code

The static formal parameter descriptors (SFPD's) are one-word

L descriptors, one for each formal parameter, giving all information

needed by the system subroutine CHECK to check the formal-actual parac. meter correspondence at run-time. This type of checking is done at

I I

compile-time by Pass Two for non-formal procedure calls, but must be

c

done at ru.r+time for formal procedure caUs.

L A branch table exists in the heading of each procedure and con+
tains one branch instruction for each label in the procedure. When a G pot0 statement is executed, a branch is made to the appropriate instruc\ tion in the branch table which then branches to the labeled location. L-
The literal table is a table of all literPals (contants) used in

L the procedure. During executionp each literal is addressed by a dis-

placement relative to the base of the program segment given by R15.

L 19

f i
Only one copy of each literal is given. - The literal table is obtained from Pass Two and is placed into
the program segment at compile-t..ime by Pass Three.
2. Addressing Conventions
Because of the structure of the addressing mechanism in the IBM System 360 Computer, program segments and the statically allocated portion of data segments may not exceed 4096 bytes.
During the execution of a procedure or run-time system subroutine, R15 is a pointer to the base of the procedure or system subroutine. All branching internal to a procedure is accomplished with a displacement relative to the base in R15. Branches between procedures are
C
accomplished by first setting R15 to the base address of the procedure being branched to and then branching.
Upon entering each procedure and block, a data segment is allocated and a general register is assigned to hold the base of that data segment. All local variables, descriptors, and value and result parameters are then addressed relative to the base of the data segment via the general register. Because the base addresses of all accessible data segments are held in registers, all accessible variables are immediately addressable.
a* -Block7and P, rocedure Marks
At the base of a data segment, a $-word procedure or block mark is created and filled with all administrative data necessary for the proper usage of reference quantities in the data segment, for the
20

creation of new data segments while this data segment is active, and

for the deletion of the data segment when its corresponding block or

procedure is exited.

..

L A mark consists of five full-word fields, as shown in the follow-

ing diagram.
i

fr
L

g$ The free pointer field points to the first free byte' An the data stack. When a new array or a new data segment is allocated, this pointer indicates its base.
C
The return address field holds the return address for procedures. This field is not used in block marks but is allocated aonethdws for consistency.

L I c
L... .

The dynamic link field contains the base of the data segment which was the most recently allocated data segment before the current one. When the current data segment is deleted at an exit from the corresponding block or procedure, the stack pointer is reset to the contents of DL. By tracing backward through the chain of dynamic links, one may obtain the bases of all data segments which have been allocated and not yet deleted. These correspond to all blocks or procedures which have been entered and not yet exited.

i REFVAR: The upper two bytes of the field REFVAR contain the number of reference variables local to this block. CR eference value/result parameters are treated as local variables.) All reference variables and reference value/result parameters
21

4

REFARY :

are grouped together so that the garbage collector may process them. The lower two bytes of the field REFV'AR point to the first reference variable or value/result parameter, relative to the base of the data segment. If no reference variables are declared in the block, th.e REFVAR field is zero.
The upper two bytes of the field R,EFARY contain the number of reference arrays declared in the block, The lower two bytes point to the first reference array descriptor, relative to the base of the data segment. All reference array descriptors are contiguous in the data segment. From the array dimension contained in the first byte of each reference array descriptor, -the garbage collector is able to locate all reference array descriptors and hence all the elements in all reference arrays. If no reference arrays are declared in the block, the REFARY field is zero.

4. Array Indexing Conventions
A data segment corresponding to a block in which arrays are declared contains an array descriptor for each array. The descriptor specifies the upper and lower bounds of the indices of the array, and a pointer to the first array element. The size of the descriptor is dependent only upon the number of dimensions of the array; therefore . the portion of the data segment used by the descriptor is allocated by Pass Two, At run-time, the bounds are stored into the descriptor, the total number of bytes required for the array elements is calculated, storage is allocated in the data stack, and a pointer to the first array element is placed into the descriptor.
When an array element is referenced, the descriptor is used to calculate the actual'address of the array element.
22

5. Base Address T-able and-, Linkage to System Routines During the execution of a programs a table giving the base ad-
dresses of all the user's program segments and the base addresses of all run-time system routines resides at a fixed displacement from Rl4. The displacement for each segment base is known at compile-time, a.llowing the compilation of instru"L+Vions to load Rl5 with a segment base before branching to that segment,
The standard calling sequence from a user procedure to another procedure or system routine is

L
BALR L

15.9 dl (14) 15, 1 15, d2 (14)

where dl is the displacement of the entry in the base address table giving the base address of the called procedure or system routine and d2 is the displacement of the entry giving the base address of the calling procedure.
Because of addressibility problems, the above code sequence is modified when calling certain system routines, The first load instruction above may be preceded by

WI runtime flag, byte

and the second load instruction may be preceded by a halfword of inPormation. The relative origin withinthe system routine is then established
I- using the value of the run-time flag or the halfword of data.
The instruction BALR 15,l is replaced by BA&R 15,o for some SyS-
tern routines so that the routines majruse the parameters more effectively,

L It

6. Special Constants -and Err-or Cod-e
Certain special constants needed at run-time, as well as some runtime error check code, ie placed at specified locations based off Rl4. The inclusion of the constants makes it unnecessary to insert these L constants in the literal tables thus saving room in the program segment. Ifi The precise locations relative to R14 of the constants and various L. run-time entry points into the error checking code are known at compiletime so that the proper addresses may be compiled.

t
, i

SEVEN

Constants x.
7

used to make an address fall on a

iLt

IXIBLMASK #FFFFFFF8 >

mEE

3

double word boundary used to make an address fall on a

sr:N~ua.sK #FFFFFFFc

sfngle word boundary

L

ALL@YES #FFFFFFFF

used in bit-not operations

L NULLREF #~~FFOOOO the null reference

ALL@RR C 0,LlN

used for data allocation; return

BCR 5, 4

to point of call (BAL 4,ALLWm)

L

if LIM = (beginning of record pages \ has not been reached

L

LA 0, 5(o)

error condition

AJFuxAmRR BCR <,, 1

used for run time array bounds

checking

Xrn1Nx~R.R IL. 15:, base of ERROR error routine prints location of error = Rl. RO is parameter to
i
error routine , giving the type of error so that appropriate termination messages may be given.

24

UBliBERR

BCR 15, 15 BCR 5, 1 LA 0, 13w BC 15, MAINERR

-.

used in array declarations to be sure that upper bound> lower bound. Error condition.

7. Register Usage At run-time the following uses are made of registers:
g and g are used by the system as save and link registers for system subroutines. lkey are otherwise available for local use.
J$ are used in evaluating arithmetic expressions.
RJ - Rlz hold the run-time display pointers to all data segments which at any given time are accessible to the block being executed.
R13 always holds the base of the data segment of the main program block.
R7 - Rm1e2 are allocated statically downwards from RX.
word "statically" is emphasized since data segments are created dynamically and the size of the data stack is limited only by the physical size of available memory. Any two or more parallel blocks (or procedures) will have the same display register pointing to their data segments, since only one of those data segments may exist at any one time.
It should be remembered that the data segments for a procedure and its outermost block (if there is one) are merged into one data segment.
In the following diagram the numbers represent data segment base
25

registers. Each begin is assumed to be followed by one or more decla-

rations.

i
1
I i
i L
i
1c cII .
t i

13 begin procedure P

..

12 begin

11 begin

end

end

procedure Q

12 begin

procedure F

--. 11 be@n,

end

11 <in

10 begin L:

end

4end end

12 &in

11 begin

10 beg,in

procedure S

9 bIeg-in 8 begin

-end -en-d -end end

end

end

Those registers not in use as display registers are available for arithemetic evaluation, For example, at label L in the preceding dfa-
I
i 25

/

gram, RlO - R13 are in use as display registers, and -R2 - -Rg are available for arithmetic evaluation.
Rl4 always points to an area in memory which contains:

1. the base address table,
l- 2. special constants,
3* error codes, and
-i 4, local data for system subroutines.
Li holds the base of the program segment currently being
executed. f
L At particular points in the execution of a program when it is

E known that none of the arithmetic evaluation registers are in use i (such as at procedure entry and exit, block entry and exit, and in a

procedure call), they may be used by the run-time administration. L

I 8. Record Allocation and Storage Reclamation L

Space for records is allocated by pages beginning at the end of

core working downward. Size of the pages is a parameter of the run-

time routines. As each page is allocated, the pages are formatted so

that each record on the page is pointed to by a previous record or by

, L

the FRC (see below). Each page is dedicated to one record class.

Table RCT is prepared by Pass Three and loaded along with the

compiled program. It contains a 16 byte entry for each record class

L- declared and is indexed by record class number. No record class 0
exists. This allows RCT(0) to be used for a free record page chain.
,c- RCT contains the following information about each record class:

I 27
L

--.

Ir FIX,

FRPC,

and

PC

are

initialized

to

0,

TOP* 4

last

entry

fn

-tLhe

tgy~e ,I

is

L set to #FFIFFFFFF whenfewerth%n 15 record classes exist.

FRC fs the origin of the Free Record Chain for the gitre:r?. ::ecaord t class.

where n is the record class number and earl; list element is a record Of class n,

28

FRPC is the origin of the free record page chain. Each page on the chain is a page whose origi.n. address Es greater than at least one af the pages in use. This chain always releases as many pages as possible to free storage so that free storage may be used by either data segments or record pages as needed. A record page which was allocated and later released may then be used for data segments.
L
l-
L
A new referenue to a record class is always ObtaLned from the JCRC corresponding to that class. If the upper byte of FRC is 0, the gmbage collector is called, If the garbage collector cannot tiee . enough storage for a new reference, execution is terminated.
Storage reclamation (i.e. garbage collection) consists of three _ phases : marking used records, collecting unused records, returning `unused pages. For each call of the garbage collector all record classes are searched and the FRC of each record class is updated.
Records are marked in two steps. First, each reference variable and each reference array element is tested; for each non-null reference, the first bit of the record referenced is set to 1. The first
, byte - of each record is not allocated for fields and is available.
29

t
L.
L ,
L-
L
e
c
c

When a record is marked which .had not been previously marked, a check is made of the NR field corresponding to the record class. If this field is zero, nothing more. needs to be done. If this field is non-zero, each reference field of the record must be checked. The reference fields are checked starting with the last reference field and ending with the first reference field. Each reference field in turn is treated recursively as a reference variable. The last reference field has been processed when the marking bit of the record is encountered m This test restricts the number of record classes to at most 127.
Since-the reference fields of a record are checked when the record is marked, a backward chain must be kept so that the path may be retraced and all reference fields of each record inspected. This chain consists only of the three low order bytes of the reference. The high order byte remains unchanged. Before proceeding to inspect the fields of a new record B designated by a field of record A, the address of the record inspected previous to A replaces the reference field in A designating the new record. If the record A had been designated by a simple reference variable or a reference array element, zero replaces the reference field in A.
e.g. ure-c-ocr-d sample (-ref-ereince- (sample) one, two) reference (sample) R;
Let A, B, C, D be symbolic names for record addresses of class sample and let N be the null reference. Suppose Example 1 represents the situation when the garbage collector begins. Reference R is inspected and points to record A of class n (Le., sample). Record A is
30

marked (first bit on). The last reference field of A (two(A)) is checked

first. Two(A) points to a previously marked record, namely A. Then one(A) is tested and points to record B which is still unmarked. A
.. zero is placed in the 24 bit address field of the reference. Record
B is marked. Two(B) points to the record C which is unmarked. The

address of A replaces the address of C in two(B). The process is re-

'L- peated until record D is marked and its fields tested. Example 2 re._ presents this state. A return is made up the chain until each field of
b- each record involved is checked and until the zero field in record A is

I
L

encountered and changed, --.

At this point, the result is similar to

Example 1 except the first bit of records A, B, C and D is on.

All references in a block are scanned before following the dynamic

links to a previous data segment., When the dynamic link is zero, the

L- process is completed.

Phase On@ of the garbage collection is completed by looking at
L
each record. The second bit of each record is used to protect records

which have been created but not yet assigned to a reference location

or used in some other manner. Therefore, each record must be scanned

to inquire if this bit is on; if SO, the record is marked and its reference fields scanned as previously described.

In Phase Two, any record whose first bit is not 1 is put on the

free list for its record class. Phase Three is integrated with Phase

Two. If any record page has no used records, it is returned to the

free record page chain. Furthermore, if the page adjoins the free

space for data segments, the page is returned instead to the free space for data segments. In this case, the free record chain is checked for record pages adjoining the free space for data segments. Those i found are removed from the FRPC and given to the free space.
After all the storage reclamation is complete, the garbage colleci
tar must supply a record of the class desired. If no free record of i_ the class desired exists, a new page is allocated for this record t class and placed on the class's page chain. If no space for a new page L iS available, execution is terminated.

1 nI

Example 1
A 0n B n A P 0n D n C C00 N n D D00 N 0 N

Example 2

n A1

I
80 On 0 n A
80 On D n A
80 00 N n B
80 00 N 0 N 4

32

B. -Pa1ss11On3e
The output of the compiler's first pass is ..
1) a listing of the source program with each line numbered
beginning at 1,
2) a character string representing in detail the original
source code, 3) a nametable, having an entry for each identifier, arranged
by blocks,
4) a blocklist table which indexes the nametable by blocks,
5) a table listing the record classes to which the declared ref--.erences are bound.
L
Other tables are passed on by P,ass One but have significance only
in producing trace output in Pass Two.
Pass One makes decisions as to the size of the tables based on
`L
the size of the core available, The algorithm used is
L CB = commonbase LC = last core location available cs = common size
cs := LC u CB; If cs > = #30000 then CS := #18000 else CS :=J CS DIV 2; NAMETABLE := CB + NT#RIGJJY; IDDLISTBASE := ((cs DIY 3 + CB + JYT@RIGXN) DIV 8) * 8; REFRECBASE := IDLISTBASE + ((Cs DIV 24) DIV 8) * 8; IDDIRBASE :f; 2 * REFRECBASE - IDLISTBASE; INPOINT := IDDIRBASE + 3 * ((CS DIV 24) DIV 8) * 8; PASSTWOOVI'PUL'BASE := (ADDRESS OF END OF PASS ONE OUTPUT) DTV 8 * 8;
If the Pass Two output area is not at least twice as long as the Pass
One output area, a flag is set so that Pass Two output will be on tape.
33

L
1. Table Formats Internal t-o Pa-ss On-e
Four main tables direct the work of Pass One. Two are intialized
..
at entrance. They are the table RESERVED of the EBCDIC representations of the delimiters or reserved symbols and the table CODE containing
an entry corresponding to each reserved symbol. Two other tables are partially initialized at entry to Pass One and added to during its exe-
L
cution. They are the identifier directory IDDIR which has the EBCDIC
L representation of each identifier, and IDLIST which indexes IDDIR. The table RESERVED is divided into segments which accomodate the --.
ALGOL W symbols grouped (alphabetically) by length. Hence RESERVED1
contains all the symbols of length 1 such as :, =t (. REsmvm2 contains all symbols of length 2 such as do, go, if. This arrangement L- continues through RESERVED9 containing -procedure, reference, Once a match is found in the RESERVED table, a 2-byte entry corresponding
L to the reserved symbol is found in CODE. For example in Figure 3, the corresponding CODE entry for if is hexadecimal 6401.
In most cases, the first byte of the CODE entry represents the c one-byte output code for the ALGOL W symbol, This code corresponds to
the symbol number of the ALGOL W symbol in the syntactic productions
of Pass Two. The exception to this rule occurs with the RESERVED
entries representing the simple types such as integer, reGs 1,ogical.
These symbols are represented in the output string by the same charac-
L ter. Instead, the first byte of the CODE entry gives the simple type
nwnber (see Figure 1). In the example of if, 64 is its output string representation.

i
L
i
1 L L.-
-

The second byte of %he CODE entry is used as an index to a case statement. The hexadecimal *:ra.Lue 01 means no special processing takes place. Such is the case in the.. example ofL--irf, Any other va?'tit means that some special note must be made of this symbol such as %c enter declaration mode or to declare a control variable# These speciai. ai%uations are described ir!. %he following pages.
IDD%R is a chwacter array of al.1 identifiers predef"fned or occurring in the program %e:icg compiled. The list is arranged so that. if only the identifiers SQ,R.T, A, TILDA appeared, the IDDIR table would appear as --.SQRTATEIIA and the ir!de:lc tlo %he table would have a value equal %o the number of characters relevant - in this case, 10,
IDLIST indexes IDDIR by an array of full words with one entry corresponding to each identifier. The first half word of' each entry is ,%he lengt'h of the i3entffier minus l, The second half of the en%ry is a pointer %o the fi.:-s% character of the identifier. Hence) in Figure 4 :, the e:ntry (`4 > (5 ) corresponds to TILDA with the leng%h specification of 4 and pointer value of 5 O Also in Figure 2, note that IDLIST ENDJEX: is a pointver to IDUST = 8.

RESERVED (in EE3CDIC)

RESERVED:1 RXSERVED~

( + 46 D$ IF

. 0 "
RES~VEDg

PR$$.XDURE

CODE (in hexadecimal) CCDEl 5506 4FOl 5005 CODE2 630s 6401
CODE9 851.5

IDDIR : IDLIST :

Figure2 Identifier Tables -

SWTATILDA (3) (0) (0) (4) v-4 (5)

-*

IDDIFUXDEX = 10 IDLISTINDEX = 8

2 . The Output String m an-A_L_GO_LIW- Program

The characters of the output string representing an ALGOL W source

program are the numbers which correspond to the syntactic elements in

Pass Two. For most cases, there is a one-one correspondence between

--. the ALGOL W symbols and their codes

As an example, Figure 3 shows

that do is represented by hexadecimal 93. Some codes represent two

ALGOL W sV@bol,s. These are exponentiation, '*!, and assignment, k=ll

and %he bound pair colons, r ::' e The following list itemizes the
c-
other special si%uations requiring modifica%ion of the normal corre-

spondence between ALGOL W symbols and string representation.

The reserved words and reserved word pairs, intege,r, real, long real, eex., long complex, logical and bits receive the code for <simple type0
Each identifier is replaced by a 3 byte code. The firs% byte is a code for <iden%ifieDO The following two bytes contain tb,e unique identifier number, (Starting from 0). In Figure 4, the iden%ifier number of A would be 1.
Each number is represented by a 1 byte code for <ntiber3. followed 'by a 1 byte indication of the type of the number, followed by the number.

36
c

f, t

4, Each bit sequence (e,g.J #FAL2C (in hexadecimal)), results in a 1 byte code representing <bit sequence, followed by the 4 byte literal,

50 A coma. appearing in the identifier list of a declaration or in the record class specification of a reference declara%ion receives the code designated SPECCOMML

6. In a reference declaration, the left parenthesis preceding the record class specification is omitted from the output string .

7 *l

In. a string declaration, if the length is specified explicit-

ly, the entire length specification, (number), is omitted

-from the output string,

8. Each new card is indicated in the output string by a 3 byte code e The firs% byte specifies'new card'and the following 2 bytes give the card number.

90 The reserved word conanent and all characters up %o and including the next semicolon are omitted from the output string.

10, An identifier following the reserved symbol end is omitted from the output string.

110 A period (0) following the reserved word e4 nd is recognized aa %he end of program.

37

Figure 3 Output Cbdes

c.

70 ABS

8~

?5

GA 86

73

67 DIV

b

99 6F

7%

90 FOR

9B

68

7E REM

85

C

7F SHL

88 SPECCOLON

613

`74 SHR

89 SPFCCOMMA

9A

8.3 ASS3GWNT 9A

69 CASE 'y3

I 8~ ET&E ?A. TZTXD OF FILE 92

L

9J- F'j-2 SC EXPONENT!

88

76 GOT0 % LINEnaRK FE

8~ LONG 8c

81 NVLL 82 87 STEP gc

77 65

THEN '79

81

93 TRUE 8~

8~

78 OD

`7D GE

`7C 9'7

80 8E

9-F

9D

WI-JCIEE

72
98

i

38

3. ThYe ITaPbl-e-Output o-f Pas-s On-e
i- Three tapbles are part of the necessary output of Pass One:
I NAMETABLE, BLOCKLIST (which indexes NAMETABLE), and RCCLIST, L 'The BLOCKLIST table has a one-word entry for each block in the
I- program in the order encountered. (Each program has a predefined
L outer block ntibered 0 containing predefined srymbols such as WRITE and SQ,RT.) This full-word entry is divided into two half-word fields. The
I second field points to the first `byte of the entries in 'Ntl'METABL,E c corresponding to identifiers declared in the block. The first field
I- is equal -t-.o 1.2 times the number of identifiers declared in Z&e block ( i,e,, the length of the NAMETABLE entry for the block). If no identi-
i fiers are declared, both fields are zero. In Figure 4, the first
BL(D@KLIST entry points to WRITE and encompasses both WRITE and SQ,RT
which are predefined. The second BLOXLIST entry points to b., and
encompasses i, j declared in the outer block of the program. The third c
entry corresponds to the control variable i,
The entrance and exit to blocks are defined by the following
rules.
a> Each 'begin signifies the entrance to a block and the corre-
sponding end signifies the close of the block,
bj Each statement following a <for clause> is surrounded by a
block in which the control variable is implicitly declared.
i
4 Each procedure body is surrounded by a block in which its
L formal parameters, if any? are declared. In the NAMEIABLE all identifiers declared in a blhock are grouped
together, Theref'ore the permanent entries in the NAMETABLE cannot `be
.
made until the block closes. If viewed `by blocks, the identifiers in
39
Ic

!
i L
iIt a i i I c

the NAMETABLE are listed in order of the closing of the blocks. In Figure 4, the control variable 'block closes before the outer blcch and, hence, appears in the NmABLE f..irst.
The layout and field contents of l&%METABLE are shown in Figure 5. Pass One puts in only that information required by Pass Two to check the semantic correctness of the program Many fields are fil1eci by Pass Two. The information entered during Pass One consists of the following attributes appropriate to the variable.

IDNO
--.
SIMPLETYPE TYPE TYPEINFO
SIMTYPEINFO

- The number assigned to the identifier. This number is equal to the number of the IDLIST entry.
- block number of the formal parameters of a procedure. Simple type of the argument of a standard function. a) Value-result for formal parameter 1. if value 2. if resu'8.t 5 if value-result b) Record class number Sor record class identifiers, the re.zord class number for record ffelds, the record class ntiber.
`bj- a) for string, length -1 for a reference, a pointer to the

40

1

Figure4

Example of BLOCKLIST and IVAMETABLE
L-

f

BLOCKLIST

..

NmABLE

i

18 I C

entry for MAIN

1i

24 I 30

entry for WRITE

L-

c I 24

entry for r SQRT

!E entry for i

t entry for i

entry for j

i entry for L

1 ib,eginj integer ; j ;rz 0; for i := 1. &I j := j C 1; L: end.
i

Each entry of RCCLIST is a half-word which gives the IDNO of a record to Which the reference is bound. A zero entry signifies the end of the group. The NAMETABLE entry for a reference variable contains a pointer to the first entry of RGCUST for that variable,

4, Introducing Predefine2 Identifiers

i To introduce in the compiler new psedefined identifiers such as I standard functions or standard procedures, a series of changes must 'be
cI . made in Pass Gneo

1. The EBCDIC code of the identifier and its length must be

i L

added to array IDLSSTFLL;.

41

2, Two half-word entries corresponding to the identifier must be
added to IDIXXFILLO The first half-wbrd is the (number of
t
characters -1) in the identifiF!x. The second half-word is
I the (sum of the preceding pairs of entries tl). i.-
30 IDDIRINDEX must be initia1izc~~~~.

i 4. IDLISTINDEX must be initialized t90 be equal to the (sum of

the last pair of IDDlXFILL erkriets -tl),

ij

/ c

5. A 12 -byte entry (3 integers) must be added to NAMETIFZLas

described in the descziption of the NAMETABLE entries

(cfe nLc.5).
i
Lt For example the entry for %JUND is:

(#o) (#0000000% 1

1I c

f type or

parameter function procedure

6. BLFILL must be changed to be initialized to (#aaaaOOOC)

Ii -

where aaaa is the he.xadlecima% representation of the (number of integers -3) aekk3rea for NAMETFE,L)`* 4.

SY?4BOXNDgC must 'be initialized to the (number of integers
i
i declared for NAMJCPFILL) * 4.

i; In the initialization section of the algorithm, the initialii zation o:f IDDZE, IDLIST, and NAMETABLE must be corrected to
represent the length changes,

i

t2

C. _PaIss_T-GO

1, Storage Allocation
1 .. All static storage allocation for variables and constants is
1 done by Pass Two. For this purpose a number of counters and link tables are necessary,
1 BNC contains the current block number (cf. xV.B). BN contains
1 __ the highest block number assigned so far (necessary in order to set BNC when a new block is entered). BLOCKLIST contains static links

I fOT blocks. These are necessary to restore BNC to the current block,

t

-v. Program segment n. umbers are assigned by Pass Two. Each proce-

dure constitutes a separate program segment and is assigned a unique

number. SNC contains the current segment number; SN contains the

largest segment number already assigned, SNLIST contains static

links for program segments.

The hierarchy number represents the level of nesting of data and

in actuality is the number of the base register used to access the

data segment. HN contains the current data hierarchy number.

DRELAD contains the address of the first free byte relative to

the beginning of the current data segment, DRELSAVE is a stack used

tp save values of DRELAD while parsing actual parameter lists.

DRELPOINT contains a pointer to DRELSAVE. While a record class de-

claration is being parsed, RELAD contains the current address relative

to the beginning of the record class Layout, All addresses of variables, array descriptors, and other data are

indicated in NAMETABLE~ An address conaists of the hierarchy number

43

(base register number) plus the address relative to the beginning of the data segment (displacement). Reference variables are grouped together at the head of the data segment; other variables occur in the order in which they are declared in a block. A location is allocated for each control identifier as well,
Fields of records are given addresses relative to the origin of the record. Field addresses are first assigned to reference fields, _- then to logical and string fields, then to other fields. The first byte of the record or the two high-order bits of the first reference (if there is one) are reserved for the garbage collector.
--. The length in bytes of any record in a record class is indicated in the NAMETABLE entry for the record class. The length is always a mtitiple of 8. Labels are given an address relative to the beginning of the program segment in which they occur. The location is used for indirect transfers. The dimension of an array is inserted in NAMETABLE when the first m array designator or the declaration is encountered (whichever occurs fix&l 0 This information is subsequently used to compute the length .of the descriptor (and to check the number of dimensions each time :that array identifier occurs). Storage is allocated in the program segment of a procedure for descriptors of its formal parameters, Descriptors of actual name parameters are assigned addresses relative to the beginning of the data segment of the procedure. Space is allocated in the data segment for values of the actual value and result parameters, since they are treated like local variables while control is within the procedure
44.

-

body. Value and result parameters of simple type "reference'! ~O;;OW all others so as to be adjacent to the local reference variables.
The first free location followin.g. the variables in each data segment is the origin of the local stack (temporary storage) for the data segment. Its address is indicated in NAMETABLE for the outermost data segment of a procedure and in the associated begin output node otherwise.

2. -Value Stac-k
._
The value or interpretation stack consists of 8;-lbyte elements.
This stack works in parallel with the parsing stack.

I
, iI
Vl

I
v2q
v2

v22 a
v3

I
II

..
v4

I
II
v5

The standard uses for the fields are described below, although
the actual uses vary with the construction being parsed.
Vl Simple type information V21' Type V22 Simple type v3 Integer register count v4 Floating register count v5 Output pointer
When an identifier is looked up in NAMETABLE, a pointer to NAMETABLE
is inserted in Vl, V2 is filled, and V3 and V4 are set to zero. When a node is put in the output array TREE, the tree pointer is put in V5.

39 Interpretation Rules Associated with each syntax rule is a body of code, the interpre-
tation rule, which performs the semantic actions appropriate to the
45

f

r / `L.

syntactic construction, The interpretation rules are contained in procedures EXECUTEl, MECUTE2, and EXECUTE3 and are accessed via a case st&ement indexed by the rule num.b. er. (Three procedures rather
than one are necessary because of the addressing structure of PL360.)
The interpretation rules use the value stack for working storage, Semantic actions and value stack layouts for major constructions of the language follow:

1. Simple variable declaration
a. Layout is standard
b. Each -i-.dentifier is located in NAMETABLE, checked for multi-
ple declaration, and allocated storage, No output is generated,

2. Array declaration

a0 Layout

Vl pointer to NAMETABLE entry of first identifier

v2 current block number of block containing declaration

v3 number of identifiers

v4 dimension

1

v5 output pointer b. The identifiers are counted, the simple types of the bound

pair expressions are checked, the bound pairs are counted,

storage is allocated for the descriptors, the array dimen-

sion is inserted in NAMETABLE for all the identifiers, and . output is generated for the structure.

30 Procedure declaration a.1 Layout of procedure head Vl simple type information (if typed procedure) v21 type (i.e. code for procedure)
v22 simple type (if typed procedure)
v3 & v4 current DRELAD of procedure head (mark, descriptors, etc.)
v5 output pointer 46

a.2 Layout of procedure body

Vl simple type information of expression (if typed

procedure)

v2 0

-.

v3 & v4 DRELAD of procedure body

vs output pointer

b. The counters and pointers are stacked, storage is allocated

for the descriptors of the formal parameters, record class

masks are constructed for reference parameters (cf. lXC.4),

the relative origin of the label transfer table is computeds

- the simple types (for a typed procedure) are compared, the output for the procedure and the literal table aregenerated,

the counters and pointers are restored, and the output is

(optionally) listed.

4. Record class declaration a. Layout Vl pointer to NAMETABLE for current field v2 current RELAD v3 & v4 not used v5 pointer to NAMETABLE entry of record class identifier b. The identifiers are located in NAMETABLE and checked for multiple declaration, storage is allocated for the record class identifier, relative addresses are assigned to the fields and the number of fields is inserted in the NAMETABLE entry for the record class.

59 Substring designator a. Layout is standard b. The simple types of the simple variable, the index expression, and the length are checked, the length is checked against the length of the simple variable, and output is generated for the structure.

47

6. Field designator a. Layout is standard b. The simple type of the reference is checked, a check is made
that the reference expression can point to a record of the
record class containing the field, and output is generated for the structure.

7 Array designator

.

a. Layout (replaced by standard layout after structure is parsed),,

Vl pointer to NAME!IABLE

v21 number of *Is

v22 number of subscripts remaining, #FF if dimension

unknown

V3,V4,.V5 standard

b. The subscripts are counted (in NAMETABLE) if dimension is not

already known; otherwise the number of subscripts is checked

against the dimension The simple type of each subscript

is checked, register counts are computed, and output is gener-

ated for the structure,

8. Function designator and Procedure statement a. Layout (replaced by standard layout after structure.is parsed), Vl simple type information (if typed procedure)
v21 contains #FF if too many actual parameters, number
of parameters yet to come otherwise, v22 simple type (if typed procedure) v3 & v4 pointer to NA.?'.?'ABLE entry of current formal para-'
meter if it is actual procedure, 0 if it is formal procedure v5 output pointer b. If the procedure is not formal the number of parameters and their types are checked, output for the structure is generated.

48

9. If expression a. Layout is standard b, Simple types of then expression and else expression are checked for type compatibility, type conversion is indi-
- cated if necessary, simple type of expression in if clause is checked, output is generated.
10. Case expression a. Layout Vl simple type information v21 number of cases
i v22 simple type V3J4,V5 standard
b. Simple_.type of expression in case clause is checked, cases
L
are counted and simple types are checked for compatibility, register counts are adjusted, output is generated.
11. argument1 [=, >=, <> <=, >J and, or, +, -> *, lJ sh-r, shl-, div,
rem, *I argument2
a. Layout is standard b. Simple types of arguments are checked, type conversion is
indicated where necessary, register counts are adjusted, order of compilation is indicated, and output is generated.
l9 long, short, abs] argument1 Layout is standa; Simple type of argument is checked, output is generated0
130 Record designator a. Layout (replaced by standard layout after structure is parsed). Vl pointer to NAMETABLE entry for current field v21 number of fields v22 record class number V3J$V5 standard b, The number of fields is checked, the simple type of each field is checked, conversion is indicated if necessary, register counts are adjusted, and output is generated.
49

14, Blockbody a. Layout VI not used v2 0 if no declarations, #F if enclosing block of procedure body (with declarations), #FF otherwise v3 Be v4 DRELAD of surrounding 'block v5 output pointer b. At begin BN, BNC, and HN are stepped, V2 and DRELAD are set, storage is allocated for reference variables, and record class masks are constructed (cf. IV.B.4). At end, DREW and HN are restored. Output is generated for structure.
15 0 Label definition a. Layout is standard b. Storage is allocated for transfer, SNC and RN are inserted in NAMETABLE, output is generated.
160 Assignment statement
a. Layout is standard b, Simple types are checked for compatibility, register counts
are adjusted, order of compilation is indicated, output is generated,
17.3 Case statement
a0 Layout is same as for case expression. b. Cases are counted, output is generated.
c
18. For statement
a. Layout is standard .
b. Simple types of expressions are checked, storage is allocated for control identifier, output is generated.
19, While statement a. Layout is standard b. Simple type of expression in while clause is checked, output is generated.
50

4. Pa-ss Two- Tables
Pass Two completes NAMETABLE and creates literal tables. The information entered in NAMETABLE consists of those of the following fields appropriate to the variable, For field contents and table format, see Figure 5 l
1" IDLOCl 2. IDLOW 39 SIMTYPEINFO
a. for a record class identifier, the record length is inserted
b. for a reference, the pointer to RCCLIST (a list of record classes to which the reference may point) is replaced by a 16 bit mask in which each bit position represents a record class and is a 1 if the reference may point to records of that class.
4. TYPEINFO a0 for a label, the hierarchy number is inserted b. for an array, the dimension is inserted C. for a record class identifier, the number of fields is inserted0
,
5. TYPE a. for a formal value/result parameter, the TYPE code is replaced by the code plus 16.
Two tables to handle literals are constructed for each program L segment. The literal table contains all literals (numbers, literal
strings and bit sequences) occurring in the program segment. Atruntime it is located before the program segment code. The literal pointer
51

r`6j . i
L

table is used by Pass Three and contains the simple type, the length (if the literal is a string), and a pointer to the literal table for each literal. The integer 1 and the logical values occur in every literal table. Pass Two uses the stack CONSPOINTERSTACK to save the pointers to these tables when a nested program segment is parsed.
Figure5 FORMAT OF NM&TABLE AND FIELD CONTENTS AFTER PASS TWO
12 bytes/entry

. .-.^V
TYPE
b

--.
IDIOCl
SIMTYIEINFO
.-^---
SIMPLETYPE

IDLOC2

hierarchy ' pw3 set3

TYPINFO

dimen

.---.v--r..---.-a - __- _____.-_ _xc1 number

7

ICN0

FIELD
IDLocl
IDLoC2

-KINDOF-ENTBY
simple variable label array procedure record class identifier record field control identifier standard function formal parameter simple variable label array

CONTENTS
hierarchy number program segment number hierarchy number origin of local stack hierarchy number hierarchy number hierarchy number simtypeinfo of argument hierarchy number relative address relative address relative address of de&
scriptor

52

-- - ---

FIELD

-KIND O-F ENTR-Y

CONTENTS

record class identifier relative address

record field

address relative to ori-

._ gin of record

i

control identifier

relative address

formal parameter

relative address of descriptor or value/result

hierarchy

procedure

hierarchy number

prog seg SIM!TYPEINFO -_

procedure string reference

program segment number length -1 record class mask

record class identifier record length

TYPEINFO

label --a.
procedure (not formal)

hierarchy number
block number of formal parameters

dimen

array

dimension

rcclnumber

record class identifier record class number

vr record class identifier number of fields

formal parameter

1 if value, 2 if result, 3 if value/result

standard procedure

vr for parameters

TYPE

simple variable

0

label

1

array

2

procedure

record class

record field

control identifier

standard function

standard procedure

Y

formal name parameter

16 + TYPE number

\

L

SIMPLE TYPE

integer

1

real 2 I

long real

3

i

complex

4

53

rr&

- ------ p

FIELD

-KIND O-F ENTR-Y

CONTENTS

long complex logical string abits reference

NOTE: The SIM!TYPEINFO entry for a reference variable and the r \ TYPE entry for a formal value/result parameter are
changed from their contents at the end of Pass One.

The tables PRTB, MTB, and MATRIX: are used by the syntactic ana-
i
lyzer and are initialized upon entry to Pass Two. MATRIX contains the
simple precedence relations of the ALGOL W (simple precedence) grammar
(cf. Appendix 2) The array is packed two bits per entry. PRTB coni tains the productions of the simple precedence grammar grouped so
that all productions having the same leftmost symbol of the right part
are together. The format for a production is the following

production:

L ::= RlR2 00. Rn

l<n<_5

representation in PRTB (one byte per entry):

n-l

production number The SpQOl #FF indicates the end of a production group,
MTB is an index to PRTB. The entry for a given symbol indicates the beginning
54

i

of the group of productions of which that symbol is the leftmost symbol of the right part.
METATABLE contains the EBCDIC representation of the symbols of the simple precedence grammar and is used for printing out the parsing stack. OPTABL contains the EBCDIC representation of the Pass Two output nodes and is used for printing out the tree. Both tables are initialized upon entry to-Pass Two

5. Output -of Pa-ss Tw-o
Each element---. of the output string TREE consists of a four-byte word with the following format:

1

OP

CONV

POiJTER ,

SWITCH is on (1) if the right subtree is to be compiled first and off (0) if the left subtree is taken first. Conversion of arithmetic type may be indicated in the source program implicitly, by mixed-type exe pressions, or explicitly, by the operators long or short. In either case, the simple type to which the expression is to be converted is indicated in CONV. For a terminal node POINT.ER points to NAMETABLE or the literal pointer table; for a nonterminal it points to the last node of the first subtree.

54a

! i

Example

program fragment and tree - previous example (cf, 111.~~6)

output substring:

.SWITCH OP FIJNCID

CONV

POINTER points to table entry for F

b

0 AC

4-

'/ r

NUMBER

points to table entry for 5

c 0 Jr7

l

J-ARID

2 points to table entry for C

i

VARPD

points to table entry for D

.LAREL%D GOT0
J

pointer to table entry for X

A separate tree is generated for each program segment, with output pointers relative to that tree, The output for each program segment is of the following form:

PROCDC PCL ,

I pointer to end of tree I \

0 0

I pointer to NAMETABLE (tree for procedure body)

.

I pointer to PROCDC

Origin of literal table
Length of literal pointer table Literal pointer table Length of literal table Literal table

55

i c-

Figure 6 OUTPUT VOCABULARY

I. Binary Operators
f OPl

conversion b%ts

I pointer to lfirst argument
I

switch

Where OPl can be one of the following binary operators;

OPERATOR

CODE REMARKS

-I-

*
I
*+6
L z= A z= S :=
R :=s
$TEWNTIL DIV REM < <, > >
L := 2 A :E 2 s := 2 R := 2

4
4 5 exponentiation 6 logical assignment 7 arithmetic assignment 8 string assignment - conversion field contains
string length
9 reference assignment - no conversion
12
13 14 15 ',
16
17 conversion bits indicate length for string
18 comparison

19 20 i

22 multiple assignment

23
24
25 s

56

1c I

( pointer to i first argument I4
(left branch always processed first) (conversion field may contain-string length for string arguments)

OPERATOR API
INDX

CCDE 29
30

REFX TFEXP

31
---.
32

PCL SUBSTRING

39 40

REMARKS
Indicates end of actual parameter list. Conversion bits indicate conversion of result of function call.
Indicates subscripting operation. Conversion bits can occur only with last such operator and indicate that resulting array element must be converted.
Indica.tes computation of field (1st arg.) of record reference (2nd arg.).
Indicates tha.t label should be issued for end of if exp. and unconditional jump patched. Conversion bits indicate that resulting expression must be converted,
Indicates end of procedure declaration.

(no conversion) switch

pointer td first arg-u.m.e-nwt- -I_

OPERATOR

CODE REMARKS

SHL 35 left shift SHR 36 right shift

57

OP4 I

pointer to first argument

( no conversion: left branch always processed first)

OPERATOR -COD-E

REMARKS *.

BB 37 indicates end of declarations, beginning of blockbody.
END 38 I 41
APJ 42 for actual parameters

R, 43 for record designators

I Jw9 44 for array declarations i AR) 45 indicates end of array declaration

R) VWR

46
-G.
47

indicates end of record designator indicates @R of logical arguments

BITfiR

48 indicates #R of bit sequences

1 L&AND

49 indicates AND of logical arguments

BITAND

50 indicates AND of bit sequences

i

I

ITERST

51 indicates generation of transfer to iteration

t L

test (for WHILE st and simple F@R st)

TTE3ST2 52 indicates generation of transfer to iteration test (for F@R st with FjdR list)

F$RLIST F@R CL ENDFflRLIST US$FEXP UJ

53 54 55
56
57

CL 58

links control assignment and STEPUNTIL
indicates unconditional jump in IF exp indicates issue jump to end af case list or
IF SC,. (to be patched) indicates label should be issued for end of
CASE st and jump addresses patched

IFST 59 indicates label should be issued for end of IF statements and jump addresses patched
: : 60 array bounds COLON
LS 61

9 63 indicates N#$P (statement separator)

WILEOP

64

WHELEST

65

IFJ 66 indicates issue jump on condition false to end of IF exp, or IF st.

58

II. Unary Operators

Op5

conversion ., I bits

Where 05 can be one of:

I I I

4

67 unary minus 68 absolute value
.
. 0~6 --.
Where 0~6 can be one of:

I
I 1

4

OR%RATOR

CODE REMARKS

LJdG -I

71 negation of logicrtl value

BIT-I

72 negation of bit sequence

BN 73

BFF 74

G&g 7s

: 76 label COLON

STACKADDR

77 argument is local stack origin for implicit

m subroutine (statement parameter)

source card Inumber

tc

III. Terminal Nodes

I block no. I
..

local stack origin I
block no. and local staek origin occur only if begins data segment

I integer value

NUMBER WI

conversion bits

pointer

to

constant

table

L

I

conversion bits

I

pointer

to

NAMETABLE

Where Xl can be:

TERMINAL

CODE REMEWC3

ID 87

1

LABELID

88 no conversion

,

AlEu3KYID

89 no conversion

FUNCID

90 no conversion if proper procedure

RCCLID

91 no conversion

I I c

FIELDID

92 no conversion

CONID

93

PROCDC

95 no conversion (procedure declaration)

RCCLDC

96: no conversion (record class declaration)

SEG(9'7j

program segment number r
indicates program segment
occuring in outer segment.

60

I x2

pointer to constant table I

Where X2 can be:

TERMINU CODE

BIT STRING TRUE FALSE

98 99 100 101

.. REMRKS

*
x3
--.
Where X3 can be:

TERMINAL CODE

IF WHILE NULL NULLST A.7FwuDc AR+

111 102
103 104 105
106

REMKS

I I I I

I- -

indicates undefined reference indicates empty statement array declaration indicates dummy array subscript

I IX4

conversion bits

i
pointer tolNAMEZBB]LE I

Where 3% can be: TERMIN& B

REMARK3

`,L
t 1/ L
DD, -Pass Thre-e

t
Code generation for arithmetic operations involves the knowledge of II which registers are occupied and where each partial result is held, i
Temporary storage must be provided for dumping partial results from

i registers into main memory when either too few registe.rs are available

__ Or

a subroutine call is made. An even-odd pair of general regis-

ters is required for integer multiplication and division0

c Al.1 the -f-.loatfng registers are avai1,able for arithmetic, Some of the general registers are reserved for special purposes, The compiler

variable CLN always contains the number of the lowest-numbered base

register in the current program segment. All lower-numbered general.

registers are available for arithmetic with the exception of RO and Rig

and R2 in iterative statements.

The compiler uses two half-word arrays R and F to indicate which

registers are occupied, To each general register which is free corre-

spends a .fl.ag equal to 0 in the array R0 A non-zero flag indicates

the register is occupied, The .array F serves the same function for

the floating registers0

Partial :res-~lts are located by referring to LSTACK, Each current c partial res=u.it, whether value or address, has an entry in LSTACK,
These entries have the folllo=wing formats:

In (1>9 N2 is zero except for one case: a complex value is in the floating registers Nl and N,. Nl is the number of either a general or floating register> and bits 16-31 are interpreted as a base with displacement address. __ In general, a procedure call involves dumping all partial results, Also, one or more partial results will be moved from registers to main i memory when ashortage of registers occurs. Each quantity dumped must have its LSTACK entry changed to indicate the new location. Thus i- pointers to the LSTACK entries indicating registers are required.
1 These pointers are in two arrays,? FSTACK for general registers and FSTACK for floating registers. Each RSTACK entry consists of only the displacement field, for indexing LSTACK. Each FSTACK entry has this index and two other bits of information: bit 0 is on for type real
I
L and off for type complex, and bit 1 is on only if the quantity is not e long. Complex values are never split between a register and a memory call; either both real and imaginary parts are in registers or both -are in memory. A procedure call requiring the saving of registers causes the necessary store instructions to be generated, all corresponding LSTACK entries referenced via RSTACK and FSTACK to be updated, and RSTACK and FSTACK to 'be emptied. During Pass Three R2 always points to the next available word in RSTACK and R4 similarly for FSTACK. The pro-
63

cedures DUMPALLGENREG and DIMPALLFLREG carry out these functions.

When one or two registers are needed @or partial results and

are not availablie, one or two regi. .sters 'holding th? currently oldest partial results are stored, This involves updating at most two LSTACK

entries, The relevant RSTACK or FSTACK element(s) are eliminated,

and al.1 elements above are moved down, The currently oldest partial

results in registers are thus always referenced via the bottom entrLes

of RSTACK and FSTACK, The procedures DUMPGENREG, DUMWLREG, and

DUMWRFLREG generate the store instruction(s) and do the necessary up-

dating,

--.

When a register or pair of registers is needed, the appropriate

register request routine is called and is one of the following:

GENREG, .P.RGENREG, FLREG-, or PRFLRIEG. This routine scans the R or F

array to find, if poswi'ble, the required single register or pair., If

necessary, it will call the appropriate save procedure as described

above o Having determined or created the requested register(s), the

procedure will flag the appropriate element(s) of R or F, set up

the LSTACK entry at the top of the stack, and create the appropriate

RSTACK or FSTACK entry, A register release is performed by either

RELEASE or ZREXWE.

In certain cases of inputs to binary operations, an adjustment

must be made in the top pointer value of either RSTACK or FSTACK.

Consider the situation below just before code is to be generated for

an add operation,,

i-

RSTACK

LSTACK +

0 ADDR

L )1 N

ii t
It is only necessary to generate one ADD instruction to add the con-
7L tents of memory location ADDR to register N. Afterwards, the situa-
I _- tion must be the following.

RSTACK

LSTACK

-v.

LL

N0 a1

The pointer at the top of RSTACK must be decremented to point to the new top of LSTACK, Whenever this is necessary, procedure ADJSTACKS is called,
Procedure ASSEMBLE, though used in many parts of Pass Three, was L designed primarily with arithmetic instruction generation in mind, It : accepts as inputs registers holdin two LSTACK-format entries, one of
them also holding the second half-byte of the instruction code in bits 4-q. The third input contains the type, From these the routine can determine the first half-byte of the instruction code and build c each field of the instruction.
2, Block Entry
, There are four purposes of block-entry code: First, the data L stack pointer, a system cell called MP, must be updated. At any given
. 65

time, MP contains the base address of the most recently created data segment.
Secondly, space must be allocated in the data stack for the data segment to be created.
Thirdly, the block mark must be built and placed at the base of the data segment.
Finally, the local display must be set to reflect the accessib& lity of all variables which can be referenced within the block.
The total amount of storage to be allocated for the data segment is not known when Pass Three encounters a block. Pass Two calculates
--. the static amount of storage required for the block mark, local display, and local variables and array descriptors. This information is given to Pass Three. However, during compilation of the block body., registers L with partial resultsmay need to be dumped due to procedure calls, etc., and the amount of storage required for this purpose, called the local stack, is not known until the block is compiled. Hence at the end of compilation of the block the instruction which specifies the total amount of data storage required for the data segment is fixed up9 and at execution time the total amount of data storage needed is correctly given.
Since the display registers are allocated statically downwards from R13, the base register to be used for the data in the block being entered is nutn'bered one less than for the enclosing block. The display for the block is then identical with the display for the enclosing block with the addition of the display entry for this block.
The code for block entry is given below: n is the number of the register which will be the base of the data segment for this block.
66

L

lx 2&l

R2 = base of data segment of enclosing
block

L ow A 63=7

R6 = free pointer in enclosing data
. segment
= base of new data segment

N

6,X'FFFFFFF8'

set data segment on a double word

boundary

LA O,length(,6)

length is the total amount of static storage needed for this data segment - fixed up at block exit, RO = new FP

BAL 4,ALLOcm

see discussion of error code (Sec. IV.A.6)

LA 3J LA by STM --. 0,4,0(6)

see discussion below see discussion below RO = FP

Rl = not used in block mark

R2 = dynamic link

R3 = REFYAR

Rk = REFARY

ST 6m LR n,6 STM n&Z,. 20 (,6)

update stack pointer
R6 = Rn = base of this data segment
store local display (if n&Z, then ST 12, 20 (,6))

In the instructions
i.- LA 39x
LA by L X is the re1ative address of the first reference variable declared in
the block, and Y is the relative address of the base of the first reference array descriptor declared in the 'block, L/ After a11 code producing declarations (e,g. array declarations) : have been processed, MVI instructions are used to insert the number of L reference variables and number of reference arrays in their appropriate
67
L.

i
Blocks without declarations have the foLL1owin.g t,ree:
\ CARD /`4a""s\tatements
/ BEGZN
The pointer field p in the node BEGIN is the amount of data storage required for the block, with the e:ir-elusion o.f' the '4,o~a% stack, except __ for the outermost 'block of a procedure ~?~ose data segment is merged c with the procedure dat;a segment0 In this case, the p-field in the node BEGIN -im. s 0 and the amount of storage req~.ired. for the combined procedure-block data segment is given in the NAMETABLE entry for the procedure,
The second byte in the node BIEGIN is a pointer (by lls) to -&e BLOCICLJST table. Hence, t&e WMETABLE entries for -the! variables and arrays d.eclared in tBe block zan be scanned., and the count and starti,ng addresses of P,he reference variab,%?a UK?L array-s can 'be obtained for the fnclusion in the block mark1, - The node Cm n is explained in a following section (1-f. IV.Po23)o
L
The purpose of the code emitted for block exit is to reset MJ9 to the base of the data segment for the block tc which cmkrol is being ret:~d.n,ed. o
The tree outph of Pass Two for 'block exit is the same part of the tree used for block entry0 It is enc~ountered again after all statemen-b in. the 'block have been psocessedO C~~mpound. statement exit and

block exit are distinguishable, as 'before, by the presence or absence of the tree node BB.
Code emitted for a block exit is as follows: n is the number of the register which holds the base of the data segment corresponding to the block being exited.

L Lw,Jd ST 1,~

Rl = dynamic link (field mark block) I= base of data segment of block returning to
Reset data pointer stack

4. Procedure Statements a_nd_TyIpe-d Procedure Designators The tree output for procedure statement and function designator
parameters (n > 0) is as foU.ows:

.9 tree for

i

,

,

I

/"'\ t\ree

parameter for

#n

/ parameter # n-l

BP.9

!\
i tree for

/ parameter # 1
F&m(t)

The pointer fit-Ad t of FUN@SD is a pointer to the NIQ@3XBLE0

70

The tree for a proper procedure without parameters is:

3/ .\ / FuNcID(t)

The tree for a typed procedure without parameters looks just like

an identifier except that the terminal node is FUlKXD(t) instead of ID(t).

The code generated for a proper or typed procedure call, with or ._ without parameters, is as follows where m is the number of the regis-

ter which holds the base of the data segment corresponding to the

block in whi-=c. h the called procedure was declared:
`-

LR 5sm

R5 = base of data segment from which

, display will be updated in proL cedure entry (after parameters

are established)

L 15, base of procedure

1, 15 L 15, base of current
procedure
B SETDIS

SAPD9 s Su. broutines

(cf. W.D.5)

.. SETDPS IIM

n, 12, 20(2)

Rtset the display R2 C: dynamic link loaded at procedure
exit = base of current data segment

n is the number of the general register holding the base of the data segment for the current block. If n=l3, the LM instruction is emitted e

I i

-.

--1

-Call o-f a Fsormal-ProcPedure

The following code is emitted for the call of a formal procedure:

..

IN 4,5 ,DPD

R.4 = address o.f subroutine (cf. .IV.D.~)

LA 0, number of actual parameters

L L5g CHFCK

BALR 1.9 15
L 15, base of current
procedure

B SETDIS

SAPD'S

Su0e broutines

SETDIS L&I

n, 12, 20(2)

The CHECK routine checks actual-formal correspondence, since this checking cannot be done at compile-time, Actual parameter descriptors are obtainable via RI (the 2nd~4th byte of each SAPD). Formal parameter descriptors are in the head of the called procedure (SFPD'S). J8+ contains the address of the subroutine which will. call the procedure; therefore there is an instruction in the subroutine of the form

L 4, base of called procedure .

The CHECK routine locates this instruction (via R4), executes it and then checks actual-formal correspondence.
The CHECK routine save s Rk and R5, and ends with

72

1

tI -
5* Procedure Entry The tree pro&uzed 'by- Pass Two for pro~&ure entry is:
The purposes of procedure entr;T code are almost those of block
entry code9 and for this masoil, the codes wil.1 be quite similar.
The additional requirements of procedure entry are those of setting up dynamic formal parameter descriptors, evaluating value p-ameters, and the more ~omplica-5ed manner of setting up the dfspPlay.
At procedure call (cfo IV.D.b~)s R5 holds the base of the data segment surrounding the deCI.aration of the called proT,edure. This data erivironment is precisely that which should be valid while the
procedure is 'being exewted. *Therefore the display of this surround-
ing 'block plus the dispIa;r entry for the called procedure constitute the displqy while executing the procedurz.
73

Procedure entry code is as .fo19ows: Rn will hold the base of the

data segment to be created.

-.

L ?9m L 6dw ,921 LA O,length( ) 6)
4,B&LWERR LA 3.9x LA 4,x STM 0,4,0(6)
ST 6m

base of calling data segment

R6 = base of new data segment

add in required storage. RO - new PP.

check to see that allocation is valid

(Note 1)

_(cf eXAo6)

store procedue mark update stack pointer

1 SAPD +-DPD operations

LM n+1,%2, 20 (5) (Note 2) update the display

r

LR n, 6

t

k

STM n, 12, 20 (6)

(Note 31

r
DPD + PV operations

!

-Note -1: X is the relative address of the first reference value/ result parameter; or if there are no value/result parameters, X is the relative address of the first reference variable local to " the block whose data segment is merged with this procedure's data segment ; or if there are no reference value/result parameters and rk0 .hxl se.ference v2t.r;~ciblea or no blocks then X is 0,
Y is the reSatfve address of the first reference array descriptor in the block whose data segment is merged with the procedures data segment Ef -"b, here are no reference arrays or no Slack, then '1. is 0.
MV& i:nst.ructions are used to place the number of reference ~~aiue~resalt parameters and local reference variables, and the
74

-_ -. _.-___-- _- -

1h

number of local reference arrays:, into the fields REFVAR and REI%mY, respectively, in the procedure mark.

-Note -2: This instruction is"0mftted if n = 12.

If n = 11, the instruction becomes L

1.2, 20 (95)

Note 2: If n = 12, then th. is instruction becomes ST Notioe that 6 f n < 12 .,

12, 26 (,6)

SAPDvs - Static Actu@ Par

Descriptors eLnd Subroutines

The calls ofpro~edures without parameters haveno SAPPs or sub--
routines x.rrespsnding to them, and the reloading of R15 to the basz
of the current program segment is immediately followed by the resetting
of the display at procedure cal.11. (<:f. .IV.D.&).
For procedures with parameters,? each parameter has associated with
it one SAPD of 8 bytes. AcxoMfng to different forms of actual para-
meters, different SAPDvs are established. 111 general, an actual para-
me'Ger is represented by a subroutfnej and the SAPD gives the address
of that subroutine, If the parameter is an identifier, the SAPD con-
tains the address of the identifier. Note that addresses of subrou-
tines are given relative to the instruction

L 15) base of current program segment

imediateig fc.IIcx&ng the instruction BAU

1.915 in procedure

' call0

The I"& bits in the SAPD define the character of the actual para-

mcz:ter O :? specifies whe4Ixx a s&r~~tine eYi~4Gs or not:

75

1 !
i
I?=1 : access to parametes invc&ves a subroutine call P=O : no subroutine eaI,l
Q specifies whether the par%rr,ete!,--. may OCWY in the left pwt of m assignment statement:
Q=B : assignment is possib1e Q#p : assignment not posa;ible The type fnfsrmation field of three bytes is used only by the @HE@~ routine when a formal procedure is caLled,

identifier
czo..st8nt, expression or statement
-
procedure
i subscripted variable or field designator
formal. parameter

copy of DPD

The implicit subropLrJ.+,ines crosresponding to param&r t:nes II L (expressions and statemen-@ acid, IV create data segments of hierarchy / level. one 3,~~s tha,n at the point oT" procedure call. Tithe format of
these data segments is like those created by blocks except that for implicit subroutines, there are no local v,ax%ables.

i i

Implicit subroutines corresponding to constants are as follows:

15, base of segment

in which cmpnstant

- table lies

L ?9m

set R2 for ret~n

LA 3.9 address of c.onstant (Qj

BCR X%1

this subroutfne branched to via Rl

._ Impl.icit subroutines corresponding to proper procedures arrd all typed proce&zes are as follows:
Id 4, base of called pr~ce%w~~
-=. LR
L 5,=F'(X-C&N-+1)*4' (5) where X= hierarchy # of called procedure
C!%N = current 'nierarchy number
BCR 15315
The purpose of this subroutine is to set Rr correc~tly. Recall that R5
wf:LZ be used as the base to update the display in the entry code of
,the eall.ed procedure o R$ cannot be set corre&ly at the point of men- tion of the formal name parameter corresponding tc the procedure for
which this subroutine is set up in czertain recursive procedure call
aLt9ations O
Notice that the su'broutines given above do not set up a data seg-
ment of their own*
A.11 string routines (i.e. string procedures and implicit sub-
youtines I-eturning the results of string procedures) are exited with
the addless of the resulting string in R.3. For some string routines

the string itself may 'be in the data segment of the string ~~~1-t,ine. When the routine is exited, Dlhe d&a segment is r~e'irase~, and the PC~-. sulting string may' thus be ~5le~txoyed if another data segmeir.t is aLlocated before the string (whose address fs in 33) is usp;!&.
This situation axises foT typed ~T"OW&X~XS of types c.J-iAET t-hall stroing, but the manner of compiling expr~~ioes cf ,l;b,ese ty~cs ins-yes that the zesult of the typed p.rocedure wiL1. Se '~ksc=d <i.e. c!ithey placed en a register, added to an acxxmulating sum, c.ompe;r"ed, ete.'j befox! any nev data segment could be created.
This 5--s=. not the case for strings. Hence, to insure that the string which is the result of a string routine is not lost, ,the string must be moved to a data segment which
L.
cannot possibly be 'released, unki.1 the string is used. Ll khe case under discussion, the string must be moved into the local stack of the data segment at the point of c.a.l.1 of the string routine,
:Ln the deseCption of the DEWS (to be dlsjeussed pPeeently), the adliress and data base fields we absolute COW addresses. The data base f'ie'ld is the base of the data segment of the block in which the p.roeeduTe call occurs o This field is used as the base from which to ipciate 7;lfF! display when execuifng imp.licli.5 subrohiwzs or proceduxxs i" 07:'*c:s pmd fxg to the mention cf the corresponding fsrmai parameters.
The byte ST is -t&e simple type of the actual param&x (0 for proper pnaoeedxres and statements) and fs used for Qpe conversion. ;for '"Ja !:Jq~re 9KLLt pa.rame 4L-JAcrs 9 IQxa.I.1 that all name parameters must match exac9; l.y in type 0
`tip 1:i @i*, subroutine,s which 'have vaILu.es a~! so constructed. that the

address of the result is returned.

SAPD + DPD Operations
..
SAPD : Static Actual Parameter Descriptor
DPD : Dynamic Parameter Descriptor

The SAPD -) DPD operation consists ofanevaluation ofthe staqceesses

@.venLQeach SAPD%t procedm cay andthetransmission of the type infor-

._ mation about the actual parameter including the %wo-bit code (PQ). If the actual parameter is a formal parameter? the DPD must be copied.

Each DPD is eight bytes wide and there is a .1-Jl correspondence between

c

--.
SAPD and DPL. The possible formats for the DPDvs are given in the

section discussing the SAPD's.
L
The code for prodxing the DPD+ is as fol.lows:

'Let a E= address of DPD to be creaked (using R6 as base - see, procedure entry code)
'b = address of SAPD (using Rl- see procedure call code)

LR 4,2
Ex. O,b+li

dynamic link = data base for DPD
executes instruction in SAPD, For all types except 'V, this loads R3 with address of procedure OF implicit subroutine.
for type V, (actual parameter is formal parameter), this loads DPD of formal parameter into Ra and R&.
store DPD
establish PQ `bits
establish ST fie'ld

!

mDPD + -PV Operations
As stated in the report, each value parameter 5s evaluated and its
c value is stored in the procedure's data segment, Any further occurrent+
of the parameter uses the parameter value (PV). L-
Since, by definition, arrays are always passed by name, the DPD
is used to obtain the address of the actual descriptor, which is therrk copied into the data segment of the procedure. The DPD may or may not
I- require a subroutine call to obtain the address of the descriptor, ._ depending on whether or not a sub-array is being passed. Any further occurrence of the array parameter uses the copied descriptor, the parameter v$ue (IT), to compute the addresses of the array elements.
L
6. Procedure Ekit Because of the tree scanning mechanism in Pass Three of the com-
- piler, typed procedures with parameters and typed procedures without parameters are detected as requiring a procedure call at different
L places in Pass Three. For this reason, the mode of returning the
result is different,
L
Por typed procedures with parameters, the result of the procedure is returned in a register, depending on the type, as follows:
L

integer

R3

i-

real FO

Long real

FOP

i

complex

FO-F2

long complex

FOLF23

bitis R3

reference logical

R3
R3 (address of result)

string I

R3 (address of result)

80

-1 /:I`,/

For typed procedures without parameters (which include implicit

c subroutines which return values), the address of the result is returned

in R3,
c

._

The addresses of the actual parameters corresponding to result

parameters are evaluated and a validity check is made to be sure that

the actual parameter can be stored into, The type of the result is

converted i$" necessary and the result is stored.

The code emitted for procedure exit is as follows:

LM --.
ST BCR

wm(n)
Q@ 15.71

Rl = return address R2 = dynamic link

Notice that upon return, the display is updated from R2, set

correctly here in procedure exit.

%* Formal Parameters in Expressions and Assignments
Reference to a formal n&e parameter requires testing whether a subroutine eaL1 is necessary, or whether the descriptor (DPD) already contains the absolute address of a variable. Furthermore, a validity test is performed if an assignment is to be made to the formal paraL.. - meter0

81

t
i

The code emitted for a formal parameter in an expression is:

TM DPD(n)JP02~

test P-bit

Y B@

1,x

branch if P=l, iOe. must call subr.

L 3,DPD(n)

"no subroutine, R3 = address of id

BC 154

xL

S,DPD&(n)

R5 = data base = base to update dis-
play inside subroutine or procedure

_` f

L 15,DPD

Rl5 I= base cf subr or procedure

L BCR 15.915

L 15 ., base of current

program segment
i
I'M n,l2, 20 (2) reset display

I .sz

0

L 0 --. 0

At Z, R3 has the address of the formal parameter, and its value

is easily obtained.

c

Value parameters are referred to only once as shown above, in the

DPD + PV,operations. If the type of the value parameter is arithmetic,

a call to a system routine which converts the actual parameter if

necessaq and stores the result in the formal value location is placed

at the label Z. Tf the type is non-arithmetic no conversion is

possible and an instruction to store the value is placed,at Z. If the

*pe is string, instructions to insure that non-significant characters

of the formal parameter are set to blank are inserted before the store

inst:ru?tion.

For a formal name parameter occurring on the left of an assign-

ment statement, the code is as before except for the first ,&ion9 which is replaced by:

instruc-

82

TM DPD(n),Xv03'

test P and Q bits

BC BJ

branch if PQ bits not mixed, i.e. can store into

BAL 1,MAIlYERR

-.branch to error rou%ines Rl = loca-

i tion of error

Result parameters are referred to only once in this manner fn proL eedure exi%.
8. w Declaration

Corresponding %o the array declara%ion of n dimensions

c-

fn the head--.of a block, an array descriptor of length 121~8 bytes is built in the data segment of the block.

SIMPLE TYPE
1, integer 2. real 30 long real L. complex 50 long complex 6. logical 79 string 8. bits 90 reference

NIJ'MBEROFBYTES PERARRAYELEMEWT
4 4 8 8 16 1 declared string length 4 4

The size of the descriptor depends onXy upon %he number of dimensions of the array and hence the storage for the descriptor is aUoca%ed s%a%icaUyO The storage for the array elements themselves must .j of course, be allocated dynamically. The descriptor has the

83

following format:

P n-l A

where

Q!0 - is the base address of the array elements

a 0

-O1s

as

given

in

the

table

above

and

is

the

number

of

bytes per array element

-." 5 - the lower bound of the ith dimension

- the upper bound of the ith dimension

%

nf = hi-l - ii-1 + 1) x Aial

f = 1,2,...,n

We require that Ai, i=O,l, 000 ,n-3, fit into 15 bits so that the more *
convenient mu.ltiply halfword (MI-I) instruction may be used for the
multipU.cation. Note that no such restriction is required for An,
:wkli ch. r* epresents the total number of bytes required for the array.
92ie value of Ai i--1,2, o o 0 ,n is the number of bytes required for
the first i dimensions of the array0 The restriction that A J'J
j=O ,OOO,n-~l fit into 15 bits results in the restriction that A nbl fit
into 15 bits P for if any AJ J'=o,. .o,n-2 does not fit into 15 bits,
then Ans=.1 will not fit into , 15 bits. Therefore, the value of A
n-l
84

must be less than or equal to 3276710. Observe that for a l-dimensional
array, this restriction is automatically satisfied, The following table gives th.e_ maximum number of elements for the
first n-l dimensions of an array of the indicated simple type,

maximum number of elements

simple type of array

in first n-l dimensions

'

logical
integer, real, bits, reference
long real, complex
long-v. complex string

32767
8191 4095
2047
32767 DIV q
where q is the declared string length

For storage of the array itself upon block entry> An bytes are re-
quested and the free pointer (FP) of the data segment in which the
c
descriptor resides becomes the base of the array, after which FP is
incremented by An.

In Algo notation:

Qb := FP

FP

:=

FP+A n

In the case of reference arrays, the upper byte of the first word of

the descriptor, the r-field, gives the num'ber of dimensions so that

the garbage collector can find the next reference array descriptor.

85

The tree format for the array declaration <simple type array Xl, X2,
.0.) XIII (lo z:: po, Pl :: pl, .."> ln 1 :: pn l) is as follows:
c1 n-l
/
ARRAYDCmp The pointer field p in ARRAYDC is a pointer to the IQIMETABLE entry for Xl; m is the number of identifiers. The nodes ai and pi can be subtrees for any integer arithmetic expression.
All. left subtrees are processed first. The descriptor is built into the descriptor location of the last identifier, in this case Xm, and finally at AR) the completely built descriptor is copied into the descriptor locations for the other arrays. As each descriptor i'. s-Tbb copied, storage for that array is allocated and the base address is placed in the a0 field of the descriptor,
86

Li
L
L s
L 1 i i
\ L-
L- * /
L-
L
c

Example:

aintreger a y X,Y(O::lO,A::A*B)

L 2,=F'0'

lcrwer bound of first dimension

ST

IA number of bytes per array element

ST 2,n,
L 2,=F'lO'
ST 2,cI0 S
1,uBLEER.R

-. upper bound of first dimension

First ) dimension

see error code discussion in section ~[NJL~

LA 2,m
SLL 23 __ ST GA1
SLA 2~6

check if Al ean fit into a halfword

J

L 24
ST 29, -L 2,Al A 24 ST 2 jc'l S W,
1,uBLBERR
MH
ST

lower bound of second dimension upper bound of second dimension

Second ' dimension

0,FP

free pointer

0,THREE

see discussion of special constants
based off ~14 (cf. FLA..~)

N 0,SINGLMASK see discussion of special constants

ST wo

store base Y in descriptor Y

OJn, RO = new FP - `base of next array

set base of array to ward boundary *

4,ALL@RR see error code discussion

Mvc x(29M

move descriptor (30 bytes) :from Y to X

ST store base X in descriptor X

A (LAO

RO = new FP

4,ffiLPJCERR

ST 0,FP

store new free pointer

3t
For arrays of type 1ogicaXand string, the free pointer is not adjusted. For arrays of type long real and long complex, the free pointer is adjusted to a double word boundary. For-x-her types, the free pointer
is adjusted to a word boundary. 07

At each node ts::99g t;he lower bomd 1' s placed in the descriptor when the left sub-tree has 'been processed. After the right sub-tree has been processed, the upper bound is placed in Le desc~ip~~o~~

is calculated, and ni-p-1 is placed fnto the descriptor0 FOI- i=O Pvn-3,

a

test

is

performed

to

assure

that

n i-l-1

wikl

fit

into

a

'half-word,

For

i--O, the multiplication by no is peTformed SIy a shift for al types

except <strin@, since no wi1.l be a power of two for these types, AIT?gTS
are stored by CO~LUTUIS. At the completion of the execution of this code, x_
the desmiptors in the stack would loch like the following, assuming

A-3, B& (al.1 numbers in base lo),

--_?
x

II
Y

Lj 88

i

90 Subscripted Variables

\- Consider the following reference to a subscri,pted variab.Ee from

an array A of n dimensions:

.

where Xi may be any integer arithmetic: expression In tree .form, the above construction is represented as,:

I\
IIYDX Xn-l /\
X n-2
/ 1mx
/\
TMDX X 1
\ / xO

The address & of %he array element is given by
n-l

where the left sub-trees are always processed first. The pointer field
c of the node ARRAYID is a pointer to the NAMETABLE
I Each node Xi msy be a subtree for an arithmetic expression. The indices are evaluated in order from Xo %oXn I_1 D
I Af%er the value of Xi has been computed, it is checked against L
li and. qi (the upper and lower bounds for the i *th dimension). If
c either bounds test fails, the run is terminated with an appropriate
error message 3 If the bounds tests are successf'ul, the lower bound is
subtracted from the subscript and this quEtratity is multiplied by the
current f and added into the aecumul.atirr.g address.

As an example, consider a reference YQ3,T-27) to an array declared integer array -Y(O::lO, A::A+B), where T+, A-3, B=40 The address of the array element 2s given by

o! = a0 * (3-o) x 4 4" (y-,3) x 44 :-. cYo P .loc

where a0 is the base of array and is o'b%ainab.le from the first wcrd of the descriptor. (See descrip%o:r: given in sectfon on array declara%ions.)
The following code is genera%ed for this array reference:

L

L 3'-a j a0

R2 will be accumulating address register

L 3pP3C

firs% subscript

c --3+)

LA w(3)

sets RO %o type of error if bonds check
fails (see discussion of error checking
code [se&ion nLA.6j)

1 JARRAYERR (cf. :rv.ao6)

S 3110

B@ <~MAINERR

(ef. l-V.A.6)

SLL 382

(x0-l,) x Do

AR %3

add in%o accumulating register

L 3.J

S 3,d?'27'

second stibscript

c 3,i.y

BALI 1,ARRAYERR

S 3.95 B@ <,~INERR

m 3.7 (*p2)

AR 2.93

At this point, R2 has tiadd~ssofY(3,T-2'7% o

i

10, Passing Sub-Arrays as Parameters

The user may pass any generalized row or column, i.e, any sub-

array of dimension l,2,00.,n- i of-.an n-dimensional array as a parameter

to a procedure. Since all array parameters are passed by name, all

that is needed is to copy certain par%s or all of the array descriptor.

At this point, the reader should familiarize himself with the de-

tails concerning the building and format of array descriptors, and the

calculettion of the address of an array eleme.n% when the element is re-

ferenced,

According %o %he syntax, an asterisk (*) is placed in those posi-

tions of the actual sub-array parameter to indicate which dimensions

are to be included in the formal array.

In those positions in which * occurs in the source code, the

Pa.ss Two tree output is the node AX*

For example, the tree corre-

sponding to the actual parameter

A(*,4)

is

'IIJDX `4
\ AR* / APRAYID(A)
indicating that the firs% dimension of the two-dimensional array A is
to be unspecified and that the fourth column corresponds to the one-
dimensional formal array.
91

It should be recalled that an array descriptor consists of a

series

of

triples

{Ai+@

where -.

1. and 1

pi

are

the

lower

and

upper

bounds of the ith dimension, Ai = (pi -.l-R,L-1) ' 'i-1 (=cepM'orAo), and

khattk first entry inthe descriptor is cu,,the absol& address of the first

array element Therefore, to compose the sub-array descriptor, rules must be given on how to build the triples cni,l+} and how to cdcu-

late aoe These rules are as follows:

If Xi is the 1oth index, then for each position with
i L
xi=* : copy the descriptor triple [Ai,!i2pi]
i --_ t xi#* : omit the descriptor triple

1 To @alculate (9 the absolute address of the first formal array element:

ti n-l

CYf

=cko+

c f=l

(Z,-'.1) x A1. :,

where Zi =

& if X =*
ii 'i if Xi + *

e As an example of the use of these rules, consider the following array declaration and the layout of the array elements in core:

92

! L

I.ogixal array A(0::1,0::2,0::3)

@O e

A 0

1

PO 0

pO E1

A 1

2

R 1

0

52

A 2

6

l2 0

c12 3

24

total number of bytes in array
`-
- not used in subarray calculations or descriptors

000 0 100 1 010 2
110 3 020 4 120 /c;
001, 6 101 7 011. 8 111 9
021 PO 121 1.1 002 12
IL.02 1-3 012 14

112 15

A(*,12 >
I

022 16 122 17
303 18

103 19

313 20

Lx3 2x

323 22

123 23
I

L .A(++&*)
, e

c1 0

1
L
6

0
L Y 3P

93

f i

The calculation of the addresses of sub-array elements is the same as for ordinary array elementso
The implicit subroutine corresponding to an actual sub-array parameter builds the sub-array descriptor in thelocal. stack of its data segment and returns the address of this descriptor. During the DPD + PV operations, this descriptor is copied into the procedure9
': P,
L data segment,

i 110 Arithmetic Conversion
Type conversion in ALGOL W is implicit in a number of cases, However 9 real to integer, or complex or long comp.lex to real or integer
c must be specified by transfer functions, 10 Integer to real or long real
/
c A quantity of type integer is converted to long real by means of
a subroutine. The linkage code is:

LA L BAIlR E

1,.X9rii9 15> base of segment 57 O,L5 15, current segment base

The quantity placed in register 1 is a parameter to the conversion

. routine. i specifies the register which contains the quantity to be converted and r specifies the destination floating point register,

Therefore, the same conversion routine is called for integer to real

conversion as for integer to long real conversion. Likewise, the same routine is used to obtain the real part in conversion from integer to

complex and long complex, The imaginary part is attained by the in-

94

, i

struction

SDR r2J r2
The routine to do the conversion stores the absolute value of register i in the lower half of a double word whose upper half is #4EOOOOOO. This quantity is loaded into register r to which zero is added to normalize the number. Register r is negated if register i contained a negative number. The execute instruction is used to mainpulate register i and register r. II. Real @long real, complex or long complex
A quantity of type real is converted to long real by two methods. a) If the value V is not in a floating-point register, the sequence of instructions used to load V into register r is

SDR r19 Ipl i LE 1r9v
b) If the value is in register r, the sequence of instructions
used to convert V is

STE r,TEMP

SDR

r9T"

LE r,TEMP

A quantity of type real is converted to complex by subtracting the second of the pair of floating-point registers from itself.. If the conversion is to long complex, the real value is first converted to long real. and then the subtract register instruction is emitted.

95

III. Conversion from long real No instructions are used to convert to real. A conversion to
either complex or long complex is.. done by subtracting the register representing the imMinary part from itself0 Iv. Conversion from complex
A complex value is converted to long complex by applying the rules for converting from real to long real to both the real and imaginary -- parts of the complex value.
L
V. Conversion from long complex No inst,ructions are emitted to convert long complex values to
i
complex values.

The indication for conversion is made in Pass Two by placing the
destination type in the conversion bits (8-15) of the node to which the conversion is applied. (cf. IV.C.5) If the node is a terminal node,
( iOe, variable, constant), the conversion takes place before the value is used. If the node is a non-terminal node, the Conversion takes place after the operation the node specifies is completed, 1Example

INTEGE8 I; REAL R;
R o(I-- L
A z=
A
Rm

,L ?9I L l,=X9022S
L 15, base of seg 52 BAL 0915 L 15, curreg base
STE 0,R

96

Example 2

LONG COMPLEX C; REAL R;

C := R + R;

..

LE O9R AE O9R STE 0,TEMP

C +(5)
/\ RR

SDR

090

LE 0,TEMP

'
SDRP

292

L

STD

09c

STD 2,~+8

12. Arithmetic Expressions
--.
ADDITION The tree produced by Pass Two for addition is
Li .
+ /\ xY
Since the addition operator is commutative, the code produced
does not depend on the order in which the subtrees are processed. Let
i- X be the first subtree and Y the second.
-
Case I0 The result of processing X is not dumped while processing Y.
If Y is in core:

Register(s) holding the result of first subtree:
Code generated:

Integer
R2 A 2,Y

Real
FO
AE 0,Y

Long Real
FOl
AD 0,Y

Complex
FO,F2
AE 0,Y AE 2,Yt-4

Long Complex
~01~~23 AD 09Y AD 2,~+8

If the processing,of Y is in a register(s) then the following code

97

1 ! L-

sequence is emitted. Assume the register(s) holding the result

of processing X is as shown above.

..
Integer Real

Long Real

Long Complex Complex

Register(s) holding

result of second

subtree:

R3

F2 F23 F&F6 F45 9 F67

Code generated:

AR 293 AER O,2 ADR 092 AER 0,4 ADR 0,4

L AER 2,6 ADR 2,6

Case II. The result of processing X is stored in TEMP while processing Y. Then the result of the second subtree must be in a register(s).

Integer Real

Long R,eal

Comp,lex

Long Complex

Register(s)

holding result

of second

subtree:

R2"

FO

F01 FO,F2 FOl,F23

Code , \ generated: A 2,TEMP AE 0,TEMP AD 0,TEMP AE 0,TEMP AD C,TEMP

AE 2,TEMP+4 AD O,TEMP+8

MULTIPLICATION The tree produced by Pass Two for multiplication is
* /\ xY
Since the code needed for complex and long complex multiplication is lengthy, a run-time subroutine is called for multiplication of these types. A discussion of the linkage and parameter conventions 5s / found elsewhere in this section.
For integer, real, and longreal, the situations and corresponding
l
98

codes are identical with those for addition except for the following substitutions in the code sequences:

Addition ..
A AR AE AER AD ADR

Multiplication M -MB ME
MD MDR

All integer multiplications are follmed by SLDA r932 where r
L.- specifies the even register of the result. This instruction detects
i an overflow if it occurred during the multiplication.
i-
SUEQRACTION

The tree produced by Pass Two for subtraction is

xI\Y

There are four situations which can arise while processing the

tree9 as in the case of arithmetic assignment (cf. IV.D.22).

Case I. Process X first.

A,. The register(s) holding the result of the left subtree X is

not dumped while processing Y.

Integer Real

Register(s) holding X: R2

FO

Code generated:

s 2,Y SE 09Y

.

Long; Real
FOl
SD 09Y

Complex FO,F2 SE 0,Y SE O,Y+4

Long Complex
~01, ~23
SD 09Y
SD 09~+8

99

i

B. The register(s) holding X is dumped at TEMP while processing YO The result of processing Y must then bein a register(s).

Integer Real

Long Real

Complex

Long Complex

Register(s) holding X: R2

FO

FOl

FO,F2

~01~~23

Code generated:

L 39TJQQ LE 2,TEM.P

LD 2,TEMP LE k,TEMP

LD 4,TEMP

SR 392

SER 2,o

SDR 2,O

LE 6,~EMp+4 LD ~,TEMP-+~

Em? 4 9 0

SDR 4,O

i --.

SER 6,2

SDR 692

Case II, Process Y first.
i A, The register(s) holding Y is not dumped while processing X.

X is then loaded into a register(s) and the appropriate

register-to-register instruction is generated.

BQ The register(s) holding Y is stored in TEMP while processing

X. The result of X is then loaded into a register and the

appropriate subtract f!rom storage (TEMP) is generated0

DllY1S10N

The tree produced by Pass Two for division is

B

/\ Y

As in multiplication, complex and long complex division is performed in a run-time subroutine and is discussed elsewhere in this section.

100

Integer division is accomplished using DIV and REM and is also discussed elsewhere in this section. For real and long real, the
c
situations and corresponding code-. sequences are identical with those for subtraction except for the following substitutions in the code sequences.

Subtraction

Division

SE SER L SD SDR
--.
L
DIV AND REM

DE DER DD DDR

The trees produced by Pass Two for DIV and REM are

DlY /\ xY

REM
/\ xY

The code sequences for both are identical, After the division, the result of DIV is in the odd register of the even-odd pair required for integer division, and the result of REM is in the even register.
No matter which subtree is processed first:, the dividend is evenL_ tually placed in the even register of an even-odd register pair. This
register pair is then shifted right-double-arithmetic 3210 bit positions in order to place the dividend in the odd register The division is then performed with the divisor in a register if it has been placed there or from storage if the divisor is simply a single variable or if it has been dumped into storage while processing the dividend subtree.

101

As an example, consider

A DIV Al(l)
. where Al is a l-dimensional integer array. Assume the subscripting
has been accomplished leaving Al(l) in R2. Then

L SRDA DR

49A 4232 492

The result is then in R5.
If an even-odd register pair is not available, then the fewest number of registers are dumped (maximum of two).inorder to secure the even-odd pair.
As another example, consider

Al(l) DIV A .

As before, Al(l) will be processed first - assume Al(l) is left
in R2 with R3 already occupied.

LR SRDA D

492 4932 ?9A

CO~WLEX ?X?LTIPLICATION AND COMPLEX DIVISION
Complex multiplication and division are carried out by means of a subroutine.
For multiplication, one multiplier must be in the pair of floating point registers FOl and F23, and the second in storage. If necessary., one multiplier will be stored in a temporary location. Separate
102

routines exist for complex and long complex multiplication. The calling sequence when one multiplier is in location TEMP is:

LA L MVI BALE3 X'OOOl' L

19TEMP -. I& base of segment 62 FLAG,X'O2'
0915
15r base of current segment

For division, the numerator must be in the pair of floating point registers F01 and F23; the denominator must be in storage. If necessary, the denominator will be stored in a temporary location. Separate routines exist for complex and long complex division. The calling sequence when the denominator is in location TEMP is:

LA
L
MVI BALR
x ' 0003'
L

1,TEMP 15, base of segment 62 FLAG,X'CP
0915
15, base of current segment

The algorithm used for complex multiplication X := A*B is

e+if := (v -+ iw) * (x + iy)

r :z Y*w e := v*x-r;

S z= Y*v f := w*xxs;

103

The algorithm used for complex division X := A/B is: e + if := (v + iw) / (x + iy)

r := a-bs x; S : = a.bs y; if r > = s then

begin r := y/x;

S :Z y*r+x;

,' ..

t :=(r*w+v)/s; e +v*r;

c

f :2(w - e)/so9

e .'=: t;

end else

i

gi;;l;: :-- x/y;

S :=r *x +y;

1 --_ t := (I" *v + w&k; f :zz (w *r - v)/s*9 end;

1 uNARYMIlKJs

The tree produced by Pass Two for unary minus is

The result of processing the subtree is loaded into a register(s).

Integer peal

Register(s) holding result of processing gubtree:

R2

FO

Long Real F01

Long Complex Complex

3'0, I?2

FOl,F23

Code
generated:

LCR 23 LCER 090 LCDR 0,O LCEX 0,o LCDR 0,O

LCER 2,2 LCDR 2,2

EXPONEIVTIATION

The tree produced by Pass Two for exponentiation is
*++ II xY
Since the code needed for exponentiation is lengthy, exponentia-
tion for all types of bases is accomplished with run-time routines. Rec
call that all powers must be of simple type integer.
One run-time routine 9 EXPON, handles bases of simple type integer,
i
L real and long real, converting the base to long real before exponentiating. Input to the routine is the type of the base, the register
I holding the base, and the register holding the power. The result of the exponentiation is left in the register of the base if the base is
of simple type real or long real. If the base is of simple type integer, the result is left in FOL
Another run-time routine, CEXPON, handles the bases of simple
type complex and long complex, converting the base to long complex before exponentiating. Input to the routine is the simple type of the base:, the base in FO, F2 (or FOl_, F23), and the register holding the power. The result of the exponentiation is left in FOl, F23.
. Consider X * Y, where X is real and in F4 and Y is in R3, Then
the calling sequence for EXPON is

LA
MVI L BALR x*0001' L

0,Xr243'

simple type of base, reg. of base, reg. of power

FIAG,X'Ol'

15, base of standard functions

1915 .

15, base of current segment 105

Now consider X * Y where X is long complex (in FOl, F23) and Y

is in R2. Then the calling sequence for CEXPON is -.
LA o,x'502f
MVI FLAG,X'Ol' L 15> base of standard functions
1915
X'OOO2'
L 15, base of current segment
__
The algorithm for real exponentiation is given in the form of an

Algol W procedure,
-.e_
i
LONG REAL PR~CEDUEU~ EXPON (LONG REAL vffiuE RASE; INTEGER vmn3 POWER);

BEGIN
i
1 LONG REAL X; BITS A; LCMCAL NEGATIVE3 NEGATIVE := FALSE;
IFP0WER<OTREN

Ii BEGIN POWER := -PCMER; NEGATIVE := TRUE

`EN-R A := BITSTRING(P0WER); X := 1L;

L: -

B ,"= A; A :== A SHR 1; IF (B AID #l) = #l THEN X := X * BASE;

IFA-v#OTBEN

BEGIN

BASE :=BASE*BASE; G0TOL END;

IUKEGATbCrEl THENIL,% ELSEX

END EXPON;

,

The algorithm for CEXPON is the same as for EKPON except all long real's abo-fe become long complex%,

106

ABSOLUTE VALUE
The a& operator has an argument of any arithmetic simple type. ..
For the simple types integer, real and long real, the quantity must first be placed in a register r corresponding to its type, if it is not already there, and one of the following instructions executed:

Izl? LPW LPDR

T".9* r,r r,r

for integer for real for long real

For the -.t-. ypes complex and long complex, a subroutine is called to obtain the absolute value, which is a real or long real number. The argznent of the operator must be placed in the floating point register pair Fol, ~23. The result is returned in register FOL Separate routines exist within the subroutine for complex absolute value and long complex absolute value. The calling sequence for the routine is:

E MKI _ BALI3 xvooolc' L

15, base of segment 62 FLAG,XvOlv 145
J-5, base of current segment

The algorithm for the complex absolute value is:
a zzz 1 x -e fy 1 X y :z abs y a := if x = 0 t@enTel-se if- y = 0 then x else if x > y a x * sqrt (I + (y/x) 9636 2) else y * sqrt (1 + (x/y) %+ 2)

107

130 Logical Expressions The philosophy of implementation of logical expressions was guided
by two principles. First, only those parts o f the expression needed to determine the truth value of the whole expression need be evaluated, For instance, in the expression A or (B and Cj3 if A is true the whole expression is true. Therefore, neither B nor C requires evaluation if A is true, Analogous.ly, if A evaluates to be false, B must be evalu-m i ated. If B is false, C need not be evaluated since the whole expres-
c
1 sion is false. A, B9 and @ are all evaluated only if A is false and B is true, The second princsfple followed in implementation required that EUJ.
IiL explicit logical result be created in a register only when necessary, For example, the ILogical expression of the conditional statement, if A E B then S, need not have a logical value created for the expression A or B. Oily a 'branch is required 'based on the condition code set by the evaluated expression. As succeeding examples will i$lustrate, the principle involving explicit evaluation is carried to its ultimate in logical conditional expressions and conditional ease expressions with at most one extraneous branch instruction being emftted after the
,
1.08

1. logical A,B,C C :=AzBandC

/L :=h

C LOGOR

v\

A LOGAND

Bfl

\ C

CL1 A,X'Ol' BC =JT CL1 B,X'Ol' BC + 2 CL1 C,X'Ol'

BC #,F

T LA

291

c B STORE

F LA

w

--_

STORE STC

%C

20 Al,oBg,iCcal C :=AzlB

CL1
BC CL1 BC LA B T LA STORE STC

A9X'01' =>T B,X'Ol'
#J 220 STORE 24 2,@

109

30 &oAg,iBc,@l

C

if A pr B then S else S -11 2

T
NEXT

CL1 BC CL1 BC
% B
s2

A,X'Ol' =? T
B,X'Ol' f ,F
NEXT

LI 4. lmogiCai --. A , & , C
1 C := if A or B then A and B else_ 7 B;

1 I.
ii
I

CL1

BC

CL1

BC Tl CL1

BC

CL1

BC

B F1 CL1

BC T2 LA

F2 STORE

B LA STC

A,x'o~/ =,Tl B,X'ol' f >F1, A,X'ol' 792 B,X'Ol'
fm T2 ,B,X'Ol' =,F2
221
STORE
290 W

110

Al,oBg,iCc;al C := 1 (case I of (AVB, 1 B) >

L :=
/% C LOGNOT
I
CL

..

--.

L LA CR BAL LTR Bc SLA B Ll CLS BC CL1 BC B L2 CL1 B LAST B B B TB LA B F LA STORE STC

231 1.9 2 291 1,mmRR 292 <_~MAI~ 292 IJQm2) A,X'Ol' =,T B$X'Ol'
f ,F T B,X'Ol' =>F T Ll L2
w 230 STORE
2,1 2,C

RELATIONAL OPERATORS

Relational expressions give_logical results and hence are treated

the same as logical expressions in that an explicit value is not

created unless necessary. In the case of the equivalence or nonequi-

valence of logical expressions a truth value for one side of the ex-

pression must be explicitly generated and the address of the resulting

truth value placed in a register0

__
iI

Zn the case of string expressions, efforts have been made to

L use the CLC instruction as efficiently as possible in analogy to the 2. use of MVC instructions in string assignments.

1, Arithmetic relations rlogicael A,Ba; l X,Y
A := (X<Y) OiJ-
A/L :\=\;\ LOGOR J/ \ B V<\
X2

LE CE BC CL1 BC F LA B T LA STORE ATC

2,x 2,Y GT B,X'Ol'
# IF 230
STORE 291
24

112

2. Complex relation

complex Cl,C2; logical A;

A := Cl = c2

.

A/L :=p

LE %=(cl)

LE 2,IMAG(Cl)
-_
V\ LE ~,~W

Cl c2

LE 6,mG(~2)

C CER 0

BC # .vF

CER 692

BC =,T

F LA

2.90

L

B STORE

T LA

291

L

STORE STC

%A

30 Logical relations a0 logical A,B,C C := A=B
L zz c/ \h=
V\ AB

IC N IC N CR BC IA B T LA STORE STC

?A
29=F'l'
39B
3,=F'l'
32 =,T 290
STORE
291 2,@

113

b. logical A,B,C C := (A or" B) = (C AND B)

/3
C

CL1 C,X'Ol' BC #3 .Fl

-

J/=\

@%I B,X'Ol'

LOGOR LOGAND

BC #>Fl

Y AB

Tl LA

291

`L-

@B

B NEXT

FL LA

2.90

L

NEXT CL%

C,XVO1'

BC -,T2

L CL1 B,X'OI'

BC -,T2

4- LA 390 B COMP

COMP
T2

LA CR BC LA. B

3.91 3`92 =J3 290 STORE

T3 LA STORE STC

24 2.A

4. String relation

i string (5) S,T; logical A;

/ A :=Sl=T

L-

z= CLC S(%T

i

A/L \`u1=

B #J

fl\
ST

LA 2,0 B STORE

T LA

291

STORE STC 114

W

5. Reference relation logical A; reference (R) Rl,R2;

n/L kE= V=\

L 2,Rl C 2,R2 BC 'gT

I t

Rl R2

:LA 2,o

B STORE

z_
t
L 14. String Expressions

T LA STORE STC

291 24

t The substring operator forms a string valued expression of the
Y form V(ElN) where V is a simple variable, an array variable or record field, E is an integer ex.pression and N is an integer number. The
result of the expression is an address of the string in a general
- register. The restriction that 0 5 E <, (length of VI -N is checked. If E is an tfnteger constant, the restriction may 'be checked
at compile-time and the run-time code shortened.

I-----

r---

I---- -

r-_ /.

r- - - -

f ---

r --

r- - -

r-' --. r-

r-- -- 1 r----

r- -- --

cn .--Y
6-l

A VI V

H \r.

15 0 Bit Expressions
Bit sequences may be ANDed, ORed or shifted, For the shift operations, the absolute value of the shift expression is loaded, No distinction is made between constant and nonconstant shift expressions0 The compile-time procedures involved are SHI..AMOUNT, BITSSHIFTARG2, and BITSAJYDORARG2.
As an example, consider the following:
A:=B shr 3 and (A and B) shl (I-3) or 7 (B shr 12 or #J?F) and 7 B;

--_ ;z

A

/\N
BITOR

L
L SR

LPR

L

N

ALL

L

LPR

L

L
SRL

I

BITOR

NR

iL

LPR ci L

SRL

OR.

XOR

.Ll

XOR

NR.

OR

ST

16. DReecosrid g n a t o r s
ALGOL W permits records to be created in two ways, First2 the name of the record class may sttid alone. Se?oad, the name of the record class may be followed by a list of the 'initial values of the fields. Both record creations are reference expressions.
RECORD A(IMTEGER IJ); REFERENCE(A) R; '
R :z A;
LA 3> address of Aqs free record
chain (FRC) R
L 159 base of record creator BA.323 1.915 L 15g current segment base
ST 33
R := A(SJ8); .

RR'.

;=
'\RI

R,1c/\ 8

J /

'5

RCCLID A

LA 3> address of A's 3RC L 15, base of record creator BALEI w-5 L 15, current segment base L 4,=F'5'
ST 4A,3) L 4,==~!8'

ST ?94(,3) i ST 3rR

118

17 * Field Designators
Since a reference points to a record with fields of any of the nine simple types, field designators of the form
F(R)
where F is a field name and R a reference expression select the desired field of the simple~~decktedti F, Throughoutthe compiler, the loading of the reference value into a register is analogous to the address resulting from a subscript calculation This address is then used as a base to index the proper element of the record while the displacement is the relative displacement of field F within the record,

riecornd A t(refeerengce (eA) X,r Y;

Ji;nteger

reference (A) R;

I);

J := I(R);

L 24 L W(2)
ST %J

I(Y(R)) := J;

L %J L 39 L 3,4(3) ST ?98(3)

119

18. Case Statements vand -Case Expressions
The purpaseof the case construction is to select the statement or expression given by the value of the expression following case, When beginning case expressions all registers except the for-variable register are stored, This occurs immediately before the unconditional branch selecting the appropriate expression.
1. case I of begin
sl;
s2;

/""\ ITUIILST
/""\
UJ S2
/\ UJ sl /
CASE(O) (3) I
I

L 291 LA 193 CR 291
1,ARRAyERR LTR 292 BC <_,MAmERR SLA 292 B ~Tca

LZ: sl B J!XEXT

L2: S2 B NXXT

LAST L3 B

NEXT

B Ll
i
B L2

B L3

NEXT

120

)I H

\ /

19. g Statement, Tf Expression, While Statement The while statement has the following interpretation,

WHILE C DO Sl s

L`; IFCTHEN BEGIN Sl; END

GO TO L

All registers except the control variable register must be dumped before entering the if expression. They are dumped before the evaluation of the conditional expression,

1. Alogica-l-. ; -if A t-hen S1

IFST Y\ IFJ sl

NEXT

CLI A,X'Ol' BC #d=T sl

2. If A then Sl else S2

IFST

u\ UJ s2

.

v\ IFJ sl

/I/ \

IF A

CLI A,X'Ol' BC f JJ
sl B NEXT

'122

L C C
I i
i i
i
t-
I c
I i

30 while A do S
WHILEST 'I/ \ WHILEOP S WHILvE \ A

LOOP NEXT

CLI A/01' BC #JEXT S B LOOP

20. For Statement
The two kinds of for statements will be designated here - the step-until statement and the for-list statement
--. A, The control identifier
Both the step-until and for-list statements have control identifiers, The implementation treats this identifier essentially the same in both cases. R2, designated symbolically as FORREGS is generally used to hold its value. Each control identifier is also assigned by Pass Two a relative location in a data segment, into which the value is stored when a transfer of control to a closed subroutine is to OGGUT or R2 is needed for some other purpose, At compile-time GETADDRESS will deliver the correct register or location for a reference to a control identifier, The occurrence of the control identifier immediately after for causes the initial processing of this identifier; this is done by lWME3ICALASSIGN.
At compile-time a 20-word stack @STACK and a location LASTFORLOC are used to keep track of the locations of the various control identifiers that may be active at a given time, At any time LASTFORLOC holds the address assigned by Pass Two to the innermost control identifier
123

for the text being compiled. @STACK is a stack of pointers to the entries in LSTACK which are control identifier locations. The pointer for CSTACK itself is a memory location called CPOINTER.
The routines DUMPFORREG and RESTOREFORREG generate instructions to move the value of a control identifier to and from memory as required. B. Step-until statement
In addition to the memory location for the control identifier, three other locations are used for each statement af this type.
-v. These are assigned by Pass Three and are called "incr", "mask", and
! "1 ih.P ; they hold the increment value, the mask used by anexecute
instruction in the test, and the limit value, respectively. The
example below illustrates their use,
i
i
i
Li
c 124

c

i i

i L FORST

/ FORCL

\ A

:Ezz

i

\

-.

I

/ s

\+

L

/ STEPUNTIL
A ~1 J\ / \+

A ;r 1

1 P+

/\ q1

r/. \1

for i := p step q-+1 until r-43 do s :- s+l

L 2,P

f
L

L -v.

3.9Q

A 3$one (one contains 1 )

I LTR 323

i ST 39incr

LA 3,const (const contains 2016 )
Ii BC ?,*a

S&L 3, one

i i

ST 3,mask (=OOlO 0000 or 0100 0000),

L 39

A 3, one

ST 3Jrfm
B -8

L- L A 2,incr

C 2,lim

i L &mask

Ex 324

I; 3`9s

AR 332

ST 3,s
t
BL

M BC 0J ,-4

125

Ewl \
-/
"\*/

21, SGottoa t e m e n t
A branch table is built in the head of each program segment, and each label in the procedure is represented by a branch instruction in the branch table,
The Pass Two tree format for a labeled statement
Stat 1; L: Stat 2;
Stat 3;
is as foPloWs:
--.

/
CARD Y\ / Stat 3
9

\
Stat 2
/

/`\ CARDX :

3/

I
LlLBELID(L)

\ / Stat 1

where I; is a porinter to the NAMETABLE Since the left sub-trees are always processed first9 the label declaration is encountered just before the compilation of Stat 2.
When the node LABELID is encountered, as above, the NAMEZABLE entry for L enables Pass Three to calculate the address of the branch instruction corresponding to the label L in the branch table in the head of the procedure. The current value of the instruction counter is then placed in the *displacement field of the branch instructions
127

The Pass Two tree format for the statement goto L is as follows:
where L is a pointer to the NAMETABLE. With the NAMETABLE entry for L, Pass Three looks up the address of the branch instruction in the branch table corresponding to the label L. If this address (relative to the base of the program segment is cy, then the code
--.
B 415 > is emitted,
By the end of compilation of the procedure, all labels have been encountered and all branch instructions in the branch table have their correct form,
If the label occurs in a different program segment, code is emitted for procedure exit, for loading R15 with the base of the program segment being branched to, and for a branch to the appropriate instruction in the branch table of the target program segment,
The following is the code generated for the statement goto L where n is the number of the register which gives the base of the data segment where the label L is defined, and CY is the displacement of the instruction in the branch table corresponding to the label LO The label IL is in a procedure different from the procedure where the goto statement occurs,
128

t,", * i ! \ L
I L-
;i lLI -
i LI
M
L
L

ST nd@

reset data stack pointer

XL

15, base of program segment in which label resides

B 415 >

Notice that precisely the same code is emitted for a branch(xout of
a block, e,g.
begin integer A; 00 begin integer B; 0d gL;ot0

end;
. 0
L1 "J iend;
In this case, the load instruction at X above is superfluous and
is not compiledo

GOT0 STATEMENTS AND LABELS INSIDE FOR-LOOPS Because of the manner in which the control identifier is manipu-
lated inside a for-loop and the desire to keep the innermost control identifier in a register whenever possible, special code is emitted for goto statements and labels which are inside the scope of a for-loop,
As explained more fully in the section on for-loops (cfO IV.D.20), Pass Two allocates one word in the data stack for each control identi-: fier, In the event that a control identifier must be dumped, it is dumped into its special location rather than into the local stack.

129

L
1L
1 i i
! c
it L
iL
i i
iL
L
\ L
r*
L
t L
/ i L iLI

Since only the innermost control identifier is kept in a register, the compiler always has a variable LASTFORLOC which contains the relative address of the word in the data stack into which the control identifier is dumped when necessary and from which it is reloaded. 1) For a goto statement inside the scope of a for-loop,, the control
identifier is first dumped into LASTFORLOC:

ST 2JASTFORLOC(n)

B 415 1

branch to branch table

2) At the definition of a label L, a branch is made around the in-
structl'on to which transfer is controlled by the branch instruction in the branch table, At the label, the control identifier is reloaded, i.e.:

BC LL NEXT

NEXT 2,LASTFORLOC(n)

This allows transfers within a for-loop and from an inner forloop into an outer for-loop.

%Lzo Assignment Statements
AEtITmIC ASSIGIWENTS
/" g=\The tree produced by Pass Two for arithmetic assignments is XY Since the discussion concerning implicit conversion between the arfthmetic types occurss elsewhere in this report (cf. N.D.11)5 this
130

ti

section will deal only with arithmetic assignments of identical type, Four situations may occur in processing an arithmetic assignment
since either the right or left subtree may be processed first, and for each of these cases, the register(s) holding the result of the subtree processed first may be dumped while processing the second subtree.

IO Process right subtree first Ao The register(s) holding Y is not dumped wh%le processing the left subtree.

--_ Integer Real

Long Real

Complex

Long Complex

Register(s)

holding X:

R2

FO

FOP FO,F2 FOl,F23

L
Code

generated:

ST 2,X STE 0,x STD 0,X STE 0,X

STD 0,x

STE 2@+ STD 2,x+8

a
B, The register(s) holding Y is dumped while processing the left

subtree.

This situation may occur when the left subtree contains

a procedure caJ.1. For example

X(P) := Y

where X is .a l-d5mensional array and P 5s an integer procedure with no arguments.
Assume the register(s) hol$ing the results? of the right subtree have been dumped at TEMP, and that general register.2 holds the address of X(P).

131

Code generated:

Integer

Real

L &TEMP ST 3,0(e)

LE 0,TEMP STE 0,0(2)

Long Real
LD WT.~ STD 0,0(2)

Complex
LE 0,TEMP LE 2,TEMP4+ STE O,O(2) STE 2,4(2)

Long Complex
L'D 0,TEMP LD ~,TEMP+~ STD 0,0(2)
STD 2,8(2)

Xl-". Process left subtree first.

Assume the processing of the left subtree results in an ad-

dress in general register 2.

A0 R2 is not dumped while processing the right subtree.

- --.

.

B Real

Long Real

Complex

Long Complex

L Register

holding 'Y': R3

FO

FOl

FO,F2

FOl,F23

Code generated: ST &O(2) STE 0,0(2) STD 0,0(E) STE 0,0(2) STD 0,0(a)

STE 2,4(2) STD 2,8(2)

B0 R2 is dumped at TEMP while processing the right subtree. The code sequences are then identical to those given in
IIOA except that each code sequenze is prefixed by
.. L 2,TEMP

For logical assignmmts, a truth value must be generated, 1 represent,s true and 0 represents false. This value is placed in an L .'in+:rge.r register and stored by an STC instruction, Examples of this aysigament may be seen in the section concerning logical expressions,
L
132

STRING ASSIGNMENTS
The assignment of string variables is defined so that the assfgnment takes place left to right, character by character. If the assigned
i
string is shorter than the destination string, the remaining characters are ffPled with blanks. The WC instruction is used for the assignment and some combination of MVI and MVC instructions used for the insertion of blanks0 The length of the assignment appears in the conversion bits of the S:= operator and the length of the string appears
in the node immediately to the left of the S:= node.

- STRING(5) S,T; S:=T

-

s:-(5) /*

8 (5) T

Mvc S(5LT

STRING(5) S; STRING(k) T; S:=T

s:=(4)

/ Y3

S (5)

T

MJTC MY-1

P-KING(5) S; STRING(3) T; S:==T
/s:=(3)\a s(g 1 T

?Nc S(3)J Ml-1 W3,X'40 MY1 s+49x'40v

133

STRING(T) S; STRING(l) T; S:=!r
.
S:=(l) 1\ S(5) T

WC S(O,T
MVI s+l,x'40'
MVC s+2(3),s+i

REFERENCE ASSIGFMENTS Reference assignments are handled just as integer assignments are
handled in the integer registers. Examples of reference assignments rn%$ be seen--.in the section on field designators (cf. IV.D.16).

I 23, Card Numbers i-
In srder to give the user a meaningful message if an error occurs
L during Pass Three or at run-time, a unary card node having the form

1 CARD 1

I SOURCE CARD NUMBER I

L

is placed in various places in the tree, as described in the documen-
tation of Pass Two0 With this information, Pass Three always has
available the current (or almost current) user card number If an
error ocmxrs during Pass Three, the current card number is printed out i . along with an appropriate message. I / In addition, to prepare for possible errors at run-time, Pass L
Three bu$lds one table for each user procedure (including the main
LI block) associating a card number with a relative location in the user's , procedure. i If no errox are detected during Pass Three, the card tables are

i
written out onto the ssme device used to hold the user's compiled procedures prior to their loading and execution. The card tables are written out only after all the user v s procedures have been written out, L and associating each card table with a procedure, the card tables are i written out in order of ascending (procedure) number, beginning at 1.
L
If an error is detected at run-time, the absolute location of the error is available to a run-time error routine, This routine detertines the number of the user procedure in which the error occurred by scanning the program reference table which contains the base addresses of all user--,procedures . In addition, the relative location of the error within that procedure is determined. The appropriate card table is then read in, and with the relative location available, the card nmber is retrieved,
135

L

L
E. Trace Facilities
c-
An optional trace card of the form $TRACExy beginning in column 1
c
of the card allows the user to trace certain features of the compila-
tion and execution of his job,
x and y are integers which may take on the following values, with C the associated results:

X Action

2 or greater Complete map of all compiler passes is printed.

L

b --_

All actions of garbage collector are printed.

4 or greater

In case of run error, dump of absolute location

of error, contents of general registers, data

area9 and record and run-time data area are

printed.

0 or blank

None of the above.

L Different values of y will cause printing of different parts of the output of Pass Two and Pass Three of the compiler, The following abbreviations will be used:

NT nametable

BL blocklist

TREE

tree

I_st compiled code before certain addresses are fixed

up -listed as procedure is being compiled.

final

final version of compiled code which will be exe-

cuted - listed at end of procedure compilation, L ret3 contents of general registers at end of compiling

a procedure.

L

L 136
L

.z Actions
4-
reg, final lst, reg, final NT, BL NT, BL, reg, final NT9 BL, lst, reg, final TREE, NT, BL TREE, NT, BL, reg, final TREE, NT, BL, lst, reg, final no action
c
The trace card $STACK has the same effect as $CRACE03, -.m.
L- 137
L

APPENDIX I EXAMPLF: OF ALGOL W COMPILER OUTPUT

XALGOL
0001 0002
0003 GO04 0005 GOG6 3GO7 0008 0009
i.xlG
OGil GOli 0013
Q014

SOURCE LISTING

8EGIN R E A L X ,SlJMX#MEANX; I N T E G E R N,li\
I 0; SUNG := MEAMX %= 0 ;
READ(N); ~~RI'TE(NI; L:RE40ClN(XL-;
I := I + 1; su `4 x : = SCJMX + X ;
MEANX := SUMX / I;
~RITE(I,X,SUMX,HEANX~; IF I = N T H E N WRITE("FINISHED"1 END.

ELSE GO TO L;

PASS ONE OUTPUT

F E 0 0 0 1 9 7 PENO2b-D ci5002066 b3002966

C

65002A70 C5650029

F~+.ijoGddO 9A65002A

65002866
9A770100

65002C70 00000070

FE000463 FE000665

002C9Af7 00106A65

01000000
00286770

OOlOFEOO FE000765

0 0 0 16A65 o+za 770 F E 0 0 0 8 6 5 002Q9965

OOUMA.65 0 0 2 8 6 7 7 0 F E 0 0 0 9 6 5 002C9A65

ii02C7E77 oloo B0 0 0 017OFEOO OA650029

' 9A650029

7 6 6 5 0 0 2 8 tOFE'0006 65002A9A

65CC2983

65!002C70

FEOOOC65

00016A65

002C6965 0 0 2 8 6 9 6 5 0 0 2 9 6 9 6 5 002A6770

FEOOaD78

65002C90

65002879

650,b016A

8107CbC9 DSC9E2CB CSC4677A 9 4 6 5 0 0 2 0

7OF EC)OOE

~F92000.0

00000000

00000000

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00000000 OOOOOOO'i

PASS TWO OUTRJ!.C TREE

LOC GGGG
0004 0008
oooc
0010 0014
0018 GOlc
0020 0024
0028 GOZC
GCj 30 0034
Go'38 --_ GG3C
GC4O
GO44 GO48
GG4C OG5O
cc 54 GO58 GG5C
GO60
OGb4 0068
006C 0 0 70
co74
GO78
G@7c 0080
3084
GC88 008C GG9G 0094 OG98
OC9C
GOAC( OCA4
GOAR OOAC OCHO
OO)i34 0088
GOBC
OOCQ
OGC4 0GCR
oocc OGOO
GOD4 GOD8
OGDC GOEO

"LAG QPCf?DE
1 r'i: ::c, DC 0 CARu 0BEGIN 0CARD `3 NULLST 3 66 3 NULCST 0 CARD 0 ID i3 N U M B E R 1 A:= 0 0 ;ARO
3 IO
0 ID
0 NUMBER 1 A:=2
1 A:=
0 0 ;ARD
3 STPROCIO
0 ID
J AP) 3 0 ;ARD 3 STPRflCiD 0 IO 3 AF') 0 0 HARD
0 ID
0:
3
I) ;TPROCID 3 ID 0 AP) 0 0 EARD 9 ID 0 ID 0 NUMRER 1+
1 4:=
0 3 ;ARD
G ID
-J ID 3 IO 1+
1 A:=
3 3 ;ARD
3 10
3 , 10 3 ID
1/

C O N V PDINTER 3153 cc-p;3
: :? Qj!
1 0001)
0002 OCPO
GO10
QCOO
0004
0210 OCGC GO24 0020 GCOS OLEC OlF8 2 30OC OG3C 0638 GO34 OCO6 ooco O204 co54 oc50
0007 3CGC
0204 0068 0064 NOR OZLC OCGO
GO78 3120 01EO 0C88 OG84 OCG9 0219 0210 QCGO i)CAO 009c UC9R OGOA
OlEC
0 1fC
OlEO ocf3c 0CtJ8 OCB4 0008 01F8
OlEC
2 f21O GCOR

'

1-39

L

Qc`k4 OGEB

1. b : =

9T!24 GC 110

GOkC

; :Aw o

4coc

GCFC

`J STPROCID

;?Or,C

OGF4

3 ID

c213

OCF8 SOFC

APv
1,' ID

CCF0 OlEG

-

0100

0 API

IjCF8

3104

3 ID

GlEC

Cl08

3 Apt

0'100

01x

0 10

OlF8

0110

3 API

31,s

0114

3

OGEC

OLlR

3 ;AR"

GCOD

GllC

0 ID

3210

-

i) I D 1=

0204
GllC

3 12G 124 128

3 IF

ocoo

G12C

1 IFJ

0124

--. 013Q 0 STPKOCID

OQQC *

0134

0 STRING

0010

0138

0 API

0130

C13C

0 UJ

0 12c

0140

0 LABELID

021c

0144

3 GOT0

OGOO

0148

0 I FST

013c

G14C

0

0118

0150

3 EAR0

GOOE

0154

0 END

OC18

0158

0 PCL

0008

LI'TERAL ORIGIN - GOOC

LITERAL POINTER TABLE

LOC LENGTH TYPE POINTER

0000

1 0000

GGQ4

6 0000

0008

6 0003

GGOC

1 0004

0010

7 7 GO08

LITERAL TABLE
0 5 0 1 0 8 OGOO300 1

OGOOOOQO

CbC9D5C9

E2C8C5C4

ELAPSE0 T I M E I S GG:mG1:58

TOTAL TREE LENGTH `IS

0 1'5c

T O T A L O U T P U T L E N G T H IS 018C

140

L

NAMETABLE

LOC IIILlJC.1

IDLOC2 SIMfYPE I N F O

T Y P E I N F O T Y P E SIMTYPE I D

(HEX)

HN SFG

-.VR

RCCLNO

(HEX)

GO 1

0 03

*MAIN

L OGGO 1 GO WRITE

GO00

0 0 ADUMP

OCOG

1 07

6 flDD

0060

1 07

8 BITSTRING

UOCCJ

8 07

1 NUMBER

O@CG

7 07

1 DECODE

OGCO

0

1 07

7 CODE

COG0

2 07

1 TRUNCATE

oooc

2 07

1 ROUND

0000

2 07

1 ENTIER

ooco

4 G7

2 REALPART

L

0 00 0 a CG

4 07 5 07

2 IMAGPART 3 LONGREALPART

00~00

5 07

3 LUNGIMAGPART

OGCO

3 07

3 LONGSQRT

-=.

oocc r,GOO

2 00 R E A D

2 07

2 SQRT

iJCCG

2 07

2 EXP

0000

2 07

2 LN

@c1QO

2 07

2 LOG

OCCG

2 07

2 SIN

OCCO

2 07

2 cos

OOGG

2 07

2 ARCTAN

occo 2 00 READON

0000

3 07

3 LONGEXP

O/j00

3 07

3 LONGLN

OGCO

3 07

3 LONGLOG

OCOO

3 07

3 LONGSIN

hGCO

3 07

3 LONGCOS

OOCG

3 07

3 LONGARCTAN

OOCG

2 07

4 IMAG

0000

3 07

5 LONGIMAG

OQCO

4 07

4 COf"PLEXSQRT

L

O(!OO

5 37

5 LONGCOMPLEXSORT

0000

1 07

1 MSGLEVEL

9GCO

1 07

1 TIME

3260

00 1 INTFIFLOSIZE

`- QZA"

00 6 UNOERFLOW

U2AE

00 6 O V E R F L O W

or\14 0018

GO 2 x 00 2 SUMX

L CClC

00 -2 MEANX

0020

00 1 k

0024

00 1 I

OOC8

13 01

e

i

L c NC? ti 1104 Sb48

POINTER OCOC
CIlE@, -

141

!) `-J ,:: 1

-.`;c)i pJ

RC

/, JC `FP2i

ooc 4

; .: i; 3 0 0

GcrC 8 c: 3 c c

4 ?i-`iIFC96 00.3 3

OOOE

GG30

1010

00000301

GO14 CO18

00 3OOOQC
CbC9D5C9

GOlC

E2C8CSC4

0391 0001

0020
GO24

L 582/3E17C L 586020QO

!I'30 1

uG2R

A SA6i)E194

0301

002c

N 5460El98

3001

CO30

LA 41006028

0!3Ql

io34

B A L 4540ElTA

0301

Gt-73 8

L A 41300000

03Gl

co3c

L A 4 14'30000

--b.

0301 0001

0040 GO44

STM 90046OQO 8 ST 5060E170

Ob)O 1

CC48

L R 1806

0004

oc44

L 582OFOL4

0004

C04E

ST 502ODO24

oil05 0005

0052 0056

L 582OFO34 LA 41100022

0005

OOSA

L 58FOEOE4

0305

OOSE

BALR

c5oi

0005

OC60

L 58FOEOQ4

0005

CC?64

S T E 7COODOlC

3005

0068

STE 7 0 0 3 0 0 1 8

0306

CO6C

M V I 92FFE1'/9

0006 0006

co7c) 0074

L A 41203100
LA 41300020

0006

0078

1. 58FOEQOC

0006

007c

B A L R Q5lF

0006

007E

L 58FOE004

0307

0092

LA 41200001

0007

GO86

L 5833D020

0307

0084

L 58FOEOF4

3007 0037 0007 0308

008E 0090 oc92 0 96

BALR ****
L LA

OSlF
0001
58FOfO04 41200200

0008

0x9 4

L A 413ODO14

0008

01)9E

L 58F3EODC

0108

OOA2

B A L R c151F

03138 0009
0009

OOA4 OOA8
OOAC

L 5 8FtIE 034
L 582OFOlO
A SA2i)D024

rI009

CO BO

ST 5 0 2 0 0 0 2 4

0310

oon4

LE 78000014

0010

COti8

A E 7A030018

0310 0311

OOBC coca

S T E 7OOODOlB
L 58200024

0311 0311

ooc4 OOCR

L A 411Oi3022
L 58FOEOE4

0911

oocc

B A L R O5OF

I:' .

e'lC E

L ~BFOE!.IC'J~

OUD 2

LE 78200018

L

uGD6

DER 3D20

OODR

S T E 7'32ODOlC

OODC

LA 41200001

OOEO

1 58390024

i

OOE4

L 58FI)EOE8

OOE8

B A L R 051F

crOEA

L 58FOEO04

OOEE

LA

4120G002

3OF2

L E 78000'314

GOF6

L 58FOE3E8

GOFA

B A L R OSlF

OOFC

L 58FCE004

GlOO

L A 4 12cIooo2

0104

L E 789iID018

0108

L 58FOEOE8

OlOC

B A L R GSlF

OlOE

L 58FOEb04

0112

LA 4 1 2 0 0 9 0 2

0116

L E 78OODOlC

OllA

L 58FOEOF4

OllE Ll120

BALR ****

OSlF
0001

0122

L 58FOE004

0126

L 58200020

012A

c 59200024

012E

BC 477OF152

0132

LA 4 1 2 0 0 0 0 7

0136

S L A 8823001Q

013A

LA 41202007

-

013E

L A 413OFg18

0142

L 58FOEOF4

0146

BALR 05lF

0148

**se 0001

014A

L 58FOE004

014E

BC 47FOF 1 5 6

0152

BC 47FOFOO8

0156

1.M 9 8 1 2 0 0 0 4

OlSA

S T SOZOEl70

QlSE

BCR 07Fl

Ol6Q

ly++*

0000

,

0162

h#* 0 0 0 0

c

OUTPUT

FROM EXECU?'.ICA'l

OF COMP'ILFJI PROGRAM

FINISHED

3 1 1.000000'+00
2 2.OCCOOO'+OG 3 3.OOOOOO'+OG

1.000000'+00
3,00cnfxv+oo
6.000GQ3 +%O

1.000000'+00
1.500000'+00
2.000000'+00

Ii

ii

APPENDIX

II

SIMPLE

PRECEDENCE

GRAMMAR

FOR

ALGOL W

1 CT V A R ID> t::= <ID7
2 < L A B E L I D > :t= <CD> ' =.+

3 <T A R R A Y ID>i P:= C I D >

L 4 <T F U N C IO> :t= <ID7

5

C R C C L ;I37

t:= <ID>

6 <T F L D I D 7 ::= <ID>

7 <CON I D > :t= <ID>

L 8 < S T F U N C ID7 ::= <ID>

9 < S T P H O C I D > ::* < I D >

10 <SI V A R D C > :t= <SI V A R DC+7 c

i

11 <St V A R DC*> ::= <SI TVPE> CID>
1 2 <SI V A R D C * 7 9) <ID>

13

<SI TVPE>

ts= <REF TVPE>` 1

14

<REF TYPE>

:t= R E F E R E N C E < I D >

15 <REF TVPE7 1) <ID>

i

16

<ARRAY DC7

:t= <RN0 L S T YD> <T EXP> :: CT EXP> !

17

CARRAV HD>

:t= CSI TYPE> A R R A V < ID7

18 <ARHAV HO7 qq <ID>

i

19 20

<--B. ND

LST

HI-l> t:= <ARRAV HO7 (
<RhD LST HO>

<f EXP> ::

<T EXP> 9

21 <P'IflC DECL> ?:= <T P R H E A D 7 < S T A T E M E N T * >
22 <T P R H E A D >

/ L

23 C T P R H E A D > <T P R BODY>
2 4 C? PK BIlDY> ts= <T EXP>

2 s <BLOCKBODY <T EXP7 E N D

2 6 <T PR HEAD> t := <T PR HEAD*> :

2 7 <T P R H E A D + 7 : : = <PROCEDURE7

2 8 <PRO.CFDlJRE> <FPAR H E A D > D

L 2 9 < P R O C E D U R E > t := P R O C E D U R E <ID,

3c) <SI TVPE> P R O C E D U R E <ID>

31 <FPAk H E A D > ?:= <FPAR HEAD*>

3 2 <FBND L I S T 7

L-

33

CFPAR H E A D * > ?:= f <SI

TYPE7

<ID>

34

( <SI TYPE7

VALUE

<ID>

3 5 f <SI TVPE7 R E S U L T < I 07

3 6 ( <SI TVPE7 V A L U E R E S U L T < I D >

3 7 t <SI TVPE7 P R O C E D U R E C I D >

38 ( P R O C E D U R E C I D >

3 9 <FPAR HE4D-7 <SI T Y P E 7 < I D >

4 0 <FPAR H E A D - 7 <SI TVPE7 V A L U E < I D >

4 1 <EPAR HEAD'-> <SI TYPE> R E S U L T < I D 7

4 2 CFPAR HEAD-7 <SI T Y P E 7 PROtEOURE CID>

4 3 <FdAR HEAd> <SI `TYPE> V A L U E R E S U L T < I D >

4 4 <FPAR H E A D - > P R O C E D U R E <IO> ,

L . 4s

<Fk'AR HEAD*> 9) <IO>

4 6 <FPAR H E A D - > : t= <FPAR H E A D > ;

4 7' <fRND L I S T d

4 8 <FBND L I S T > t:= <fBND H E A D 7 f )

4 9 <FBND H E A D > : : = <F A R R A Y HD> 4

L 50

<FRND H E A D > *

5 1 <; ARRAY f-ID7 ::= ( <SI TVPE7 ARiAV <XD>

5 2 <FPAR H E A D - 7 CSI TVPF7 ARq A Y <ID>

L

5 3 < F A R R A Y HO7 ,, <ID)

54

<KC CL I?C> ::= <RC

HEAD>

1

5 5 <RC H E A D > ::= < R E C O R D > 4 <SI TVPE7 <ID7

56

<RC H E A D 7

<ID>

5 7 <SC HEAD*7 `;SI TVPE> <ID>

59

<RC H E A D * >

:t= <RC H E A D > ;

.

144

5 9 <RECORD> : : = R E C O R D < I D 9

6 0 <T VAR9

::= <SI T VAR9

6 1 <T A R R A Y I D 9

6 2 <$TRs S E L H O 9 ti EXP9 < L E N G T H 9 1

6 3 CSTH S E L YD> ::= <SI T VAR9 (

64 <LENGTH>

::= I <T NUMBER>

65

<SI 1 VAR9

::= CT V A R ID>

6 6 <T FL0 HO> <T EXP9 1

6 7 <T ARRAY HO> <T EXP9 1

60 CT ARRAY HO9 * 1

69

CT FL0 HO>

::= CT FLD ID9 (

7 0 <T A R R A Y H O > ::= <T ARRAY ID9 1

7 1 <T ARRAY HO9 <T EXP9 v

7 2 <T ARRAY HO9 * t 7 3 <T F U N C D E S > ::m <T F U N C ID9

7 4 <APAR H E A D > <T EXP9 1

7 5 CAPAR H E A D > <STATEMENT9 b

7 6 <APAR H E A D > 1 7 7 <AkAR HEAD9 ::= CT FUNC ID9 (

70 <APAR H E A D > <T EXP>

i

79 80

--.

<APAR H E A D 9 <STATEMEN;> 9 <APAR H E A D 9 v

8 1 C T EXP>

::= <T EXP*>

8 2 CT EXP*9 ::= <SI T EXP>

83 < I F C L 9 < T R U E EXP9 <T EXP*>

c

04
8 5 <If CL9

< C A S E H E A D 9 <T EXP9 1 3:s IF <T EXP9 T H E N

86

< T R U E EXP9

3 := <T EXP> E L S E

8 7 *CASE HEAD9 :t= <CbSE C L > C

8 8 < C A S E HEaD, <T EXP> 9

89

<CASE C L 9

:t= CASE ct ~XB~

OF

9G

CSI t EXP>

f:= CSI T EXP**>

91 <SI T FXP*9 <EQL CIP>, ($1 T EXP**>

92 ($1 T EXP*> <REL OP> <$I T EXP**9 .

93 <SI T EYPf> IS <RC CL IO9 94 <SI T EXP**9 g:= <SI T EXP*S
<SI T EXP*9 : := <T TER!`!>

;p" + < T T E R M 9

L $7

- <T TERY9

d3 <SI T EXP*9 + <T T E R M 9

9 <SI T EXP*t) - <T T E R M 9

1 0 CSI T EXP*9 O R <t T E R M 9

1i <RC C L 1 0 9 t 2 CRC DES\ HO9 CT EXP9 1 12e3 <STRING9

104

NlJLL

'

l/o5 CT T E R M > ::= CT T E R M * >

t";

<T TERM*9

tti <T F A C T 9

<T T E R M 9 * <T F A C T >

1:8 <T TERs$*> / <T FACT9

ice 9 <T T E R M * > DfV < T F A C T >

L
blC

<T T E R M * > R E M <T F A C T 9

111 <T TERM*> A N D <T F A C T >
1 1 2 KT F A C T > : := C T SECON9

4 113

-, <T F A C T 9

i

114

<T SECON9

::= <T P R I M 9

1 1 5 <T SECON> <SHL O R I*> <T PRIM>

116 117

CT PRIM>

<T SECON9 S Y R <T P R I M 9 : := <T VAR9

118 <T FUNC DES9

t

1 1 9 < S T F U N C ID>

1 2 0 < L E F T PAR> <T FXP> 1 121 TKUF

1 2 2 F4LSF -.

123

<r,fJt\l ID9

1 2 4 L O N G <T P R I M >

1 2 5 SHORT <T PKIM>

1 2 6 ASS <T PKIH>

1 2 7 <T NUMRF?>

128 129 1 3t;

<REL OP9

< B I T SEOr : := <
<=

131
132 > =
1 3 3 <EQL OP> ::r = 1.34 - =

135

<l.EdT PAR9

t:= (

1 3 6 <ST FUNC ID> f

1.37 <RC \DES Hr)9 :t= CRC CL II>> l

L-3 8 <RC DES HO> <T EXP> 9

13') < P R O G R A M 9 ::= . <BLUCto l
14 1% TSTATEMENT9 : := < S T A T E M E N T * >

14 1 <STATEMENT*9 ::= < S T S T >

143 <FOR C L 9 D'1

143 < F O R C L > DO < S T A T E M E N T * > 144 < W H I L E C L > D O

145 <NJHI LE CL> D O <STATEMENT*9

1 4h < I F CL,

1411 (IF C L > <ST4TCMEYT*> l -tti < I F C L 9 <TRUF P A R T >

144, <IF CL9 <TRUE PART9 < S T A T E M E N T * 9

155

1911 ;2;1

<SI ST>

1514 1% l'jh, 157' <CLIICK> I54

< C A S E SEQ> END < C A S E SEQ, < S T A T E M E N T > E N D ::r <YLf-lCK>
<T A S S S T 9
<T FUNC D E S > GUTO <LIZHEL I D > <ST PROC HO> <T EXP9 1 ::= <RLOCKBrlDY > END <`)LClCKRfJ~1Y> C ST ATEMENT9 END

159;

<SLflCKBODY> : 3 = <HLOCKHEAf.l>

1 bcJl 1 11 12 113 ;gi

<PLrlCKHEAD9

<YLOCKH'lDY> ;

<8CtlCKRc3DY> < S T A T E M E N T > ;

<UCOCKB?DY > < L A B E L DEF9

: t = `ECIN

]

9RLUCKHEAD9 <SI'VAR D C > ;

fBLOCKHf40> < A R R A Y D C > ;

@L~CKHEA 9 <PRoC oEc~9 ;

1617 168

<LABFL DE!=9

::=

;(HLflCKHE $I)> < K C <ID> :

CL

D C >:

L

1'@9 1,710

< T A S SI S T >

::= <T VAR> := <T EXP*> <T V A R > := CT A S S S T >

1 7 1 <TRUE P A R T > 2:s <SI S T 9 E L S E

172 ELSE

L

173

< C A S E SEQ>

::= <CASE Cl> B E G I N

1.74 < C A S E SEQ> < S T A T E M E N T > :

1 7 5 < C A S E SEQ> :

1 7 6 < F O R C L > :: = <FOR H E A D > <STEPUNTIL> <T EXP9

1 7 7 <FOR H E A D >

176 <FC)H L I S T > <T EXP9

146

..l* l... II II

.... ....
II Ii

.... ....
II II

