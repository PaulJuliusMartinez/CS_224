Point-Based Computer Graphics 

Eurographics 2003 Tutorial T1 

Carsten Dachsbacher 

Universität Erlangen-Nürnberg 

 

 
 
 
 

 

 

 
 

 

 

 

 

 

Organizers 

Markus Gross 
ETH Zürich 

Hanspeter Pfister 
MERL, Cambridge 

Presenters 

Marc Alexa 
TU Darmstadt 

Markus Gross 
ETH Zürich 

Mark Pauly 
ETH Zürich 

Jeroen van Baar 
MERL, Cambridge 

Matthias Zwicker 

ETH Zürich 

Contents 

Tutorial Schedule ................................................................................................2 
Presenters and Organizers Contact Information .................................................3  
References ...........................................................................................................4 
Project Pages .......................................................................................................5 

 
 
Tutorial Schedule 

Introduction (Markus Gross) 
Acquisition of Point-Sampled Geometry and Appearance (Jeroen van Baar) 
Point-Based Surface Representations (Marc Alexa) 
Point-Based Rendering (Matthias Zwicker) 
 
Lunch 
 
Sequential Point Trees (Carsten Dachsbacher) 
Efficient Simplification of Point-Sampled Geometry (Mark Pauly) 
Spectral Processing of Point-Sampled Geometry (Markus Gross) 
Pointshop3D: A Framework for Interactive Editing of Point-Sampled Surfaces 
(Markus Gross) 
Shape Modeling (Mark Pauly) 
Pointshop3D Demo (Mark Pauly) 
Discussion (all) 

 

2

  

 
 
Presenters and Organizers Contact Information 

Dr. Markus Gross 
Professor 
Department of Computer Science 
Swiss Federal Institute of Technology (ETH) 
CH 8092 Zürich 
Switzerland 
Phone: +41 1 632 7114 
FAX: +41 1 632 1596 
grossm@inf.ethz.ch 
http://graphics.ethz.ch 

Dr. Hanspeter Pfister 
Associate Director 
MERL - A Mitsubishi Electric Research Lab 
201 Broadway 
Cambridge, MA 02139 
USA 
Phone: (617) 621-7566 
Fax: (617) 621-7550 
pfister@merl.com 
http://www.merl.com/people/pfister/ 
 
Jeroen van Baar 
MERL - A Mitsubishi Electric Research Lab 
201 Broadway 
Cambridge, MA 02139 
USA 
Phone: (617) 621-7577 
Fax: (617) 621-7550 
jeroen@merl.com 
http://www.merl.com/people/jeroen/ 
 
Matthias Zwicker 
Department of Computer Science 
Swiss Federal Institute of Technology (ETH) 
CH 8092 Zürich 
Switzerland 
Phone: +41 1 632 7437 
FAX: +41 1 632 1596 
zwicker@inf.ethz.ch 
http://graphics.ethz.ch 

Mark Pauly 
Department of Computer Science 
Swiss Federal Institute of Technology (ETH) 
CH 8092 Zürich 

 

 

 

3

Switzerland 
Phone: +41 1 632 0906 
FAX: +41 1 632 1596 
pauly@inf.ethz.ch 
http://graphics.ethz.ch 

Dr. Marc Stamminger 
Universität Erlangen-Nürnberg 
Am Weichselgarten 9 
91058 Erlangen 
Germany 
Phone: +49 9131 852 9919 
FAX: +49 9131 852 9931 
Marc.Stamminger@informatik.uni-erlangen.de 

Carsten Dachsbacher 
Universität Erlangen-Nürnberg 
Am Weichselgarten 9 
91058 Erlangen 
Germany 
Phone: +49 9131 852 9925 
FAX: +49 9131 852 9931 
dachsbacher@informatik.uni-erlangen.de 

 

 

 

Dr. Marc Alexa 
Interactive Graphics Systems Group 
Technische Universität Darmstadt 
Fraunhoferstr. 5 
64283 Darmstadt 
Germany 
Phone: +49 6151 155 674 
FAX: +49 6151 155 669 
alexa@gris.informatik.tu-darmstadt.de 
http://www.dgm.informatik.tu-darmstadt.de/staff/alexa/   

 
 
References 

M. Alexa, J. Behr, D. Cohen-Or, S. Fleishman, D. Levin, C. Silva. 
Point set surfaces. Proceedings of IEEE Visualization 2001, p. 21-28, San Diego, 
CA, October 2001. 
 
C. Dachsbacher, C. Vogelsang, M. Stamminger, Sequential point trees. 
Proceedings of SIGGRAPH 2003, to appear, San Diego, CA, July 2003. 
 
O. Deussen, C. Colditz, M. Stamminger, G. Drettakis, Interactive visualization of 
complex plant ecosystems. Proceedings of IEEE Visualization 2002, Boston, MA, 
October 2002. 
 

 

4

 

W. Matusik, H. Pfister, P. Beardsley, A. Ngan, R. Ziegler, L. McMillan, Image-
based 3D photography using opacity hulls. Proceedings of SIGGRAPH 2002, San 
Antonio, TX, July 2002. 
 
W. Matusik, H. Pfister, A. Ngan, R. Ziegler, L. McMillan, Acquisition and 
rendering of transparent and refractive objects. Thirteenth Eurographics Workshop 
on Rendering, Pisa, Italy, June 2002. 
 
M. Pauly, R. Keiser, L. Kobbelt, M. Gross, Shape modelling with point-sampled 
geometry, to appear, Proceedings of SIGGRAPH 2003, San Diego, CA, July 2003. 

M. Pauly, M. Gross, Spectral processing of point-sampled geometry. Proceedings 
of SIGGRAPH 2001, p. 379-386, Los Angeles, CA, August 2001. 
 
M. Pauly, M. Gross, Efficient Simplification of Point-Sampled Surfaces. IEEE 
Proceedings of Visualization 2002, Boston, MA, October 2002. 
 
H. Pfister, M. Zwicker, J. van Baar, M. Gross, Surfels - surface 
elements as rendering primitives. Proceedings of SIGGRAPH 
2000, p. 335-342, New Orleans, LS, July 2000. 
 
M. Stamminger, G. Drettakis, Interactive sampling and rendering for 
complex and procedural geometry, Rendering Techniques 2001, 
Proceedings of the Eurographics Workshop on Rendering 2001, June 2001. 
 
L. Ren, H. Pfister, M. Zwicker, Object space EWA splatting: a hardware 
accelerated approach to high quality point rendering. Proceedings of the 
Eurographics 2002, to appear, Saarbrücken, Germany, September 2002. 
 
M. Zwicker, H. Pfister, J. van Baar, M. Gross, EWA volume splatting. 
Proceedings of IEEE Visualization 2001, p. 29-36, San Diego, CA, October 2001. 
 
M. Zwicker, H. Pfister, J. van Baar, M. Gross, Surface splatting. 
Proceedings of SIGGRAPH 2001, p. 371-378, Los Angeles, CA, August 2001. 
 
M. Zwicker, H. Pfister, J. van Baar, M. Gross, EWA splatting. IEEE Transactions 
on Visualization and Computer Graphics. 
 
M. Zwicker, M. Pauly, O. Knoll, M. Gross, Pointshop 3D: an interactive system 
for point-based surface editing. Proceedings of SIGGRAPH 2002, San Antonio, 
TX, July 2002 
 

 
Project Pages 
•  Rendering 

http://graphics.ethz.ch/surfels 

•  Acquisition 

http://www.merl.com/projects/3Dimages/ 

 

5

•  Sequential point trees 

http://www9.informatik.uni-erlangen.de/Persons/Stamminger/Research 

•  Modeling, processing, sampling and filtering 

http://graphics.ethz.ch/points 

•  Pointshop3D 

http://www.pointshop3d.com 

 
 

 

6

Point-Based Computer Graphics

Tutorial T1

Marc Alexa, Carsten Dachsbacher, 

Markus Gross, Mark Pauly, 

Hanspeter Pfister, Marc Stamminger, 
Jeroen Van Baar, Matthias Zwicker

Surf. Reps. for Graphics

Raise degree

Mesh processing

methods

Subdivision schemes

Hierarchical splines

Wavelets

Discrete (point based) 
representations

Add operators

Add connectivity

Triangle meshes

Point-Based Computer Graphics

Markus Gross

2

Polynomials...

(cid:57) Rigorous mathematical concept
(cid:57) Robust evaluation of geometric entities
(cid:57) Shape control for smooth shapes
(cid:57) Advanced physically-based modeling
(cid:50) Require parameterization
(cid:50) Discontinuity modeling
(cid:50) Topological flexibility

Refineh rather thanp !

Polynomials -> Triangles

• Piecewise linear approximations
• Irregular sampling of the surface
• Forget about parameterization

Triangle meshes

• Multiresolution modeling
• Compression
• Geometric signal processing

Point-Based Computer Graphics

Markus Gross

3

Point-Based Computer Graphics

Markus Gross

4

Triangles...

(cid:57) Simple and efficient representation 
(cid:57) Hardware pipelines support ∆
(cid:57) Advanced geometric processing is being in sight
(cid:57) The widely accepted queen of graphics primitives
(cid:50) Sophisticated modeling is difficult
(cid:50) (Local) parameterizations still needed
(cid:50) Complex LOD management
(cid:50) Compression and streaming is highly non-trivial

Remove connectivity!

Triangles -> Points

• From piecewise linear functions to 

Delta distributions

• Forget about connectivity

Point clouds

• Points are natural representations within 
3D acquisition systems
• Meshes provide an articifical enhancement 
of the acquired point samples

Point-Based Computer Graphics

Markus Gross

5

Point-Based Computer Graphics

Markus Gross

6

1

History of Points in Graphics

The Purpose of our Course is …

• Particle systems [Reeves 1983]
• Points as a display primitive [Whitted, Levoy 1985]
• Oriented particles [Szeliski, Tonnesen 1992]
• Particles and implicit surfaces [Witkin, Heckbert 1994]
• Digital Michelangelo [Levoy et al. 2000]
• Image based visual hulls [Matusik 2000]
• Surfels [Pfister et al. 2000]
• QSplat [Rusinkiewicz, Levoy 2000]
• Point set surfaces [Alexa et al. 2001]
• Radial basis functions [Carr et al. 2001]
• Surface splatting [Zwicker et al. 2001]
• Randomized z-buffer [Wand et al. 2001]
• Sampling [Stamminger, Drettakis 2001]
• Opacity hulls [Matusik et al. 2002]
• Pointshop3D [Zwicker, Pauly, Knoll, Gross 2002]...?

I) …to introduce points as a versatile and 

powerful graphics primitive

II) …to present state of the art concepts 

for acquisition, representation, 
processing and rendering of point 
sampled geometry

III) …to stimulate YOU to help us to 

further develop Point Based Graphics

Point-Based Computer Graphics

Markus Gross

7

Point-Based Computer Graphics

Markus Gross

8

Taxonomy

Morning Schedule

Rendering
(Zwicker)

Acquisition

(Pfister, Stamminger)

Point-Based Graphics

Representation

(Alexa)

Processing &

Editing

(Gross, Pauly)

• Introduction (Markus Gross)
• Acquisition of Point-Sampled Geometry and 

Apprearance (Jeroen van Baar)

• Point-Based Surface Representations (Marc 

Alexa)

• Point-Based Rendering (Matthias Zwicker)

Point-Based Computer Graphics

Markus Gross

9

Point-Based Computer Graphics

Markus Gross

10

Afternoon Schedule

• Sequential point trees (Carsten Dachsbacher)
• Efficient simplification of point-sampled geometry 

(Mark Pauly)

• Spectral processing of point-sampled geometry 

(Markus Gross)

• Pointshop3D: A framework for interactive editing 

of point-sampled surfaces (Markus Gross)

• Shape modeling (Mark Pauly)
• Pointshop3D demo (Mark Pauly)
• Discussion (all)

Point-Based Computer Graphics

Markus Gross

11

2

Acquisition of Point-Sampled 
Geometry and Appearance 

Jeroen van Baar and Hanspeter Pfister, MERL

[jeroen,pfister]@merl.com

The Goal: To Capture Reality

• Fully-automated 3D model creation of real 

objects. 

• Faithful representation of appearance for 

these objects.

Wojciech Matusik, MIT

Addy Ngan, MIT

Paul Beardsley, MERL
Remo Ziegler, MERL
Leonard McMillan, MIT

Point-Based Computer Graphics

Hanspeter Pfister, MERL

1

Point-Based Computer Graphics

Hanspeter Pfister, MERL

2

Image-Based 3D Photography

Previous Work

• An image-based 3D scanning system.

• Handles fuzzy, refractive, transparent objects.
• Robust, automatic
• Point-sampled geometry based on the visual hull.
• Objects can be rendered in novel environments. 

• Active and passive 3D scanners

• Work best for diffuse materials.
• Fuzzy, transparent, and refractive objects are difficult.

• BRDF estimation, inverse rendering
• Image based modeling and rendering

• Reflectance fields [Debevec et al. 00]

• Light Stage system to capture reflectance fields
• Fixed viewpoint, no geometry

• Environment matting [Zongker et al. 99, Chuang et al. 00]

• Capture reflections and refractions
• Fixed viewpoint, no geometry

Point-Based Computer Graphics

Hanspeter Pfister, MERL

3

Point-Based Computer Graphics

Hanspeter Pfister, MERL

4

Outline

• Overview
(cid:190) System
• Geometry
• Reflectance
• Refraction & Transparency

Acquisition System

Light Array

r
o
t
i
n
o
M

 
r
o
l
o
C

-
i
t
l
u
M

Cameras

Rotating Platform

Point-Based Computer Graphics

Hanspeter Pfister, MERL

5

Point-Based Computer Graphics

Hanspeter Pfister, MERL

6

Acquisition Process

Acquisition Process

Alpha 
Mattes

Visual
Hull

Alpha 
Mattes

Visual
Hull

Surface Lightfield

Surface Reflectance Fields

Surface Lightfield

Surface Reflectance Fields

Point-Based Computer Graphics

Hanspeter Pfister, MERL

7

Point-Based Computer Graphics

Hanspeter Pfister, MERL

8

Acquisition Process

Acquisition Process

Alpha 
Mattes

Visual
Hull

Alpha 
Mattes

Visual
Hull

Surface Lightfield

Surface Reflectance Fields

Surface Lightfield

Surface Reflectance Fields

Point-Based Computer Graphics

Hanspeter Pfister, MERL

9

Point-Based Computer Graphics

Hanspeter Pfister, MERL

10

Outline

• Overview
• System
(cid:190) Geometry
• Reflectance
• Refraction & Transparency

Acquisition

• For each viewpoint ( 6 cameras x 72 

positions )
• Alpha mattes

• Use multiple backgrounds [Smith and Blinn 96]

• Reflectance images

• Pictures of the object under different 

lighting 
(4 lights x 11 positions)

• Environment mattes

• Use similar techniques as [Chuang et al. 2000]

Point-Based Computer Graphics

Hanspeter Pfister, MERL

11

Point-Based Computer Graphics

Hanspeter Pfister, MERL

12

Geometry – Opacity Hull

Geometry Example

• Visual hull: The maximal object consistent 

with a  given set of silhouettes.

Point-Based Computer Graphics

Hanspeter Pfister, MERL

13

Point-Based Computer Graphics

Hanspeter Pfister, MERL

14

Approximate Geometry

Surface Light Fields

• The approximate visual hull is augmented by 

radiance data to render concavities, 
reflections, and transparency.

• A surface light field is a function that 

assigns a color to each ray originating on a 
surface. [Wood et al., 2000]

Point-Based Computer Graphics

Hanspeter Pfister, MERL

15

Point-Based Computer Graphics

Hanspeter Pfister, MERL

16

Shading Algorithm

Color Blending

• A view-dependent strategy.

• Blend colors based on angle between virtual 

camera and stored colors.

• Unstructured Lumigraph Rendering

[Buehler et al., SIGGRAPH 2001]

• View-Dependent Texture Mapping

[Debevec, EGRW 98]

Point-Based Computer Graphics

Hanspeter Pfister, MERL

17

Point-Based Computer Graphics

Hanspeter Pfister, MERL

18

Point-Based Rendering

Geometry – Opacity Hull

• Point-based rendering using LDC tree, 

visibility splatting, and view-dependent 
shading.

• Store the opacity of each observation at 
each point on the visual hull [Matusik et al. 
SIG2002].

Point-Based Computer Graphics

Hanspeter Pfister, MERL

19

Point-Based Computer Graphics

Hanspeter Pfister, MERL

20

Geometry – Opacity Hull

Example

• Assign view-dependent opacity to each ray 

originating on a point of the visual hull. 

B

C

A

(θ,φ)

φ

Red = invisible
White = opaque
Black = transparent

A B C
θ

Photo

Point-Based Computer Graphics

Hanspeter Pfister, MERL

21

Point-Based Computer Graphics

Hanspeter Pfister, MERL

22

Example

Photo

Visual Hull

Example

Photo

Visual Hull

Opacity

Hull

Point-Based Computer Graphics

Hanspeter Pfister, MERL

23

Point-Based Computer Graphics

Hanspeter Pfister, MERL

24

Example

Photo

Visual Hull

Surface
Light Field

Opacity

Hull

Results

• Point-based rendering using EWA splatting, 

A-buffer blending, and edge antialiasing.

Point-Based Computer Graphics

Hanspeter Pfister, MERL

25

Point-Based Computer Graphics

Hanspeter Pfister, MERL

26

Results Video

Results Video

Point-Based Computer Graphics

Hanspeter Pfister, MERL

27

Point-Based Computer Graphics

Hanspeter Pfister, MERL

28

Results Video

Results Video

Point-Based Computer Graphics

Hanspeter Pfister, MERL

29

Point-Based Computer Graphics

Hanspeter Pfister, MERL

30

Opacity Hull - Discussion

Point-Based Models

• View dependent opacity vs. geometry 

trade-off.

• Sometimes acquiring the geometry is not 

possible.

• Sometimes representing true geometry 

would be very inefficient.

• Opacity hull stores the “macro” effect.

• No need to establish topology or 

connectivity.

• No need for a consistent surface 

parameterization for texture mapping.

• Represent organic models (feather, tree) 
much more readily than polygon models.

• Easy to represent view-dependent opacity 

and radiance per surface point. 

Point-Based Computer Graphics

Hanspeter Pfister, MERL

31

Point-Based Computer Graphics

Hanspeter Pfister, MERL

32

Outline

• Overview
• Previous Works
• Geometry
(cid:190) Reflectance
• Refraction & Transparency

Light Transport Model

• Assume illumination originates from 

infinity.

• The light arriving at a camera pixel can be 

described as:
yxC
,(

EW

ωωω d
(

)

(

)

=

)

∫

Ω

Point-Based Computer Graphics

Hanspeter Pfister, MERL

33

Point-Based Computer Graphics

Hanspeter Pfister, MERL

34

C(x,y) 
E
W

- the pixel value
- the environment
- the reflectance field

Surface Reflectance Fields

Reflectance Functions

• 6D function:(cid:31)i
(cid:31)i

PW

(

,

ωω
r

,

i

=

)

vuW
,

(

r

r

θθ
;
r
i

Φ

;

,

i

Φ

,

)

r

• For each viewpoint, 4D function:
Φ
θ
,
;
i

yxW

ω
)
(
i

,(

W

=

xy

)

i

P

(cid:31)r

(θi,φi)

φi

θi

Point-Based Computer Graphics

Hanspeter Pfister, MERL

35

Point-Based Computer Graphics

Hanspeter Pfister, MERL

36

Relighting

Compression

New 

Illumination

Down-
sample

Surface reflectance 
field

x

=

V0

V1

V2

… Vn

• Subdivide images into 8 x 8 pixel blocks.
• Keep blocks containing the object (avg. 

compression 1:7)

• PCA compression (avg. compression 1:10)

PCA

a0

a1

a2

a3

a4

a5

Point-Based Computer Graphics

Hanspeter Pfister, MERL

37

Point-Based Computer Graphics

Hanspeter Pfister, MERL

38

Results

The Library

Point-Based Computer Graphics

Hanspeter Pfister, MERL

39

Point-Based Computer Graphics

Hanspeter Pfister, MERL

40

Surface Reflectance Fields

Outline

• Work without accurate geometry
• Surface normals are not necessary
• Capture more than reflectance

• Inter-reflections
• Subsurface scattering
• Refraction
• Dispersion
• Non-uniform material variations

• Simplified version of the BSSRDF

• Overview
• Previous Works
• Geometry
• Reflectance
(cid:190) Refraction & Transparency

Point-Based Computer Graphics

Hanspeter Pfister, MERL

41

Point-Based Computer Graphics

Hanspeter Pfister, MERL

42

Acquisition

Acquisition

• We separate the hemisphere into high 

resolution (cid:31)h and low resolution (cid:31)l.

Wh
T

Wl

yxC
,(

)

=

TW

ξξξ
+
)()(

d

h

∫

Ω

h

L((cid:31)
)
ωωω
W
(
l

L
()

d

)

i

i

∫

Ω

l

• For each viewpoint ( 6 cameras x 72 

positions )
• Alpha mattes

• Use multiple backgrounds [Smith and Blinn 96]

• Reflectance images

Low resolution
• Pictures of the object under different 

lighting 
(4 lights x 11 positions)

• Environment mattes

High resolution

• Use similar techniques as [Chuang et al. 2000]

Point-Based Computer Graphics

Hanspeter Pfister, MERL

43

Point-Based Computer Graphics

Hanspeter Pfister, MERL

44

Low-Resolution Reflectance Field

High-Resolution Reflectance Field

yxC
,(

=)

TW

ξξξ
)()(

d

h

+

∫

Ω

h

W
l

∫

Ω

l

ωωω
(

L
()

d

)

i

i

yxC
,(

=)

TW

ξξξ
)()(

d

h

+

∫

Ω

h

W
l

∫

Ω

l

ωωω
(

L
()

d

)

i

i

• Use techniques of environment matting 

[Chuang et al., SIGGRAPH 00].

iLW
i

for n lights

ωωω
(

L
()

d

)

i

i

≈ n
∑

=
1

i

W
l

∫

Ω

l

Point-Based Computer Graphics

Hanspeter Pfister, MERL

45

Point-Based Computer Graphics

Hanspeter Pfister, MERL

46

High-Resolution Reflectance Field

Reproject (cid:31)h

• Approximate Wh by a sum of up to two

Gaussians:
• Reflective G1.
• Refractive G2.

Wh

=ξ
)(

N

GaGa
2
1

2

1

+

G1

G2

• Project environment mattes onto the new 

environment.
• Environment mattes acquired was 

parameterized on plane T (the plasma display).

• We need to project the Gaussians to the new 
environment map, producing new Gaussians. 

Wh
T

Point-Based Computer Graphics

Hanspeter Pfister, MERL

47

Point-Based Computer Graphics

Hanspeter Pfister, MERL

48

View Interpolation

Results

• Render low-resolution reflectance field.
• High-resolution reflectance field:

• Match reflected and refracted Gaussians.

V1

V2

N

~
G1r
~
G2r

~
G2t
~
G1t

• Interpolate direction vectors, not colors.
• Determine new color along interpolated direction.

• Performance for 6x72 = 432 viewpoints
• 337,824 images taken in total !!

• Acquisition (47 hours)

• Alpha mattes – 1 hour
• Environment mattes – 18 hours
• Reflectance images – 28 hours

• Processing

• Opacity hull ~ 30 minutes
• PCA Compression ~ 20 hours (MATLAB, unoptimized)

• Rendering ~ 5 minutes per frame
• Size

• Opacity hull ~ 30 - 50 MB
• Environment mattes ~ 0.5 - 2 GB
• Reflectance images ~ Raw 370 GB / Compressed 2 - 4 GB

Point-Based Computer Graphics

Hanspeter Pfister, MERL

49

Point-Based Computer Graphics

Hanspeter Pfister, MERL

50

Results

High-resolution

hΩ

Low-resolution

lΩ

Combined

Results

Point-Based Computer Graphics

Hanspeter Pfister, MERL

51

Point-Based Computer Graphics

Hanspeter Pfister, MERL

52

Results

Results – Ωh

Point-Based Computer Graphics

Hanspeter Pfister, MERL

53

Point-Based Computer Graphics

Hanspeter Pfister, MERL

54

Results – Ωl

Results – Combined

Point-Based Computer Graphics

Hanspeter Pfister, MERL

55

Point-Based Computer Graphics

Hanspeter Pfister, MERL

56

Results

Results

Point-Based Computer Graphics

Hanspeter Pfister, MERL

57

Point-Based Computer Graphics

Hanspeter Pfister, MERL

58

Conclusions

• Data driven modeling is able to capture 

and render any type of object.

• Opacity hulls provide realistic 3D 

graphics models.

• Our models can be seamlessly inserted 

into new environments.

• Point-based rendering offers high image-

quality for display of acquired models.

Future Directions

• Real-time rendering 

• Done! [Vlasic et al., I3D 2003]
• Better environment matting

• More than two Gaussians

• Better compression
• MPEG-4 / JPEG 2000

Point-Based Computer Graphics

Hanspeter Pfister, MERL

59

Point-Based Computer Graphics

Hanspeter Pfister, MERL

60

Acknowledgements

• Colleagues:

• MIT: Chris Buehler, Tom Buehler
• MERL: Bill Yerazunis, Darren Leigh, Michael 

Stern

• Thanks to:

• David Tames, Jennifer Roderick Pfister

• NSF grants CCR-9975859 and EIA-9802220
• Papers available at:

http://www.merl.com/people/pfister/

Point-Based Computer Graphics

Hanspeter Pfister, MERL

61

Point-based Surface Reps

• Marc Alexa
• Discrete Geometric Modeling Group
• Darmstadt University of Technology
• alexa@informatik.tu-darmstadt.de

Overview

• Introduction & Basics
• Fitting Implicit Surfaces
• Projection-based Surfaces

Point-Based Computer Graphics

Marc Alexa, Carsten Dachsbacher, 

Markus Gross, Mark Pauly, 

Hanspeter Pfister, Marc Stamminger, 

Matthias Zwicker

Motivation

• Many applications need a definition of 

surface based on point samples
• Reduction
• Up-sampling
• Interrogation (e.g. ray tracing)
• Desirable surface properties

• Manifold
• Smooth
• Local (efficient computation)

3

Introduction & Basics

Terms: Regular/Irregular

• Regular (on a grid) or irregular (scattered)
• Neighborhood (topology) is unclear for 

irregular data

• Terms

• Regular/Irregular, Approximation/Interpolation, 

Global/Local

• Standard interpolation/approximation 

techniques
• Triangulation, Voronoi-Interpolation, Least 
Squares (LS), Radial Basis Functions (RBF), 
Moving LS

• Problems

• Sharp edges, feature size/noise

• Functional -> Manifold

5

2

4

6

1

Terms: 
Approximation/Interpolation
• Noisy data -> Approximation

• Perfect data -> Interpolation

Terms: Global/Local

• Global approximation

• Local approximation

• Locality comes at the expense of 

smoothness

7

Triangulation

• Exploit the topology in a triangulation 

(e.g. Delaunay) of the data

• Interpolate the data points on the 

triangles
• Piecewise linear (cid:198) C0
• Piecewise quadratic (cid:198) C1?
• …

9

Triangulation: Piecewise 
linear
• Barycentric interpolation on simplices

(triangles)
• given d+1 points xi with values fi and a
point x inside the simplex defined by xi
• Compute αi  from

x = Σi αi ·xi and Σi αi  = 1

• Then

f = Σi αi ·fi

Voronoi Interpolation

Voronoi Interpolation

• compute Voronoi diagram
• for any point x in space
• add x to Voronoi diagram
• Voronoi cell τaround x intersects original cells

τi of natural neighbors ni

• interpolate

∑

i

λ
i

(x)

f(x)

=

with

λ
i

(x)

=

ττ
∩
i
⋅
τ
−
xx

(

−

xx

i

)
)

(
⋅∇+⋅
f
f
T
i
i
∑
(x)

λ
i

i

i

11

τ2

n2

τ3

n3

n1

τ1
τ
x

τ4

n4

τ5

n5

8

10

12

2

Voronoi Interpolation

Least Squares

Properties of Voronoi Interpolation:
• linear Precision
• local
• for d = 1 (cid:198) f(x) piecewise cubic
• f(x)∈C1  on domain
• f(x,x1,...,xn ) is continuous in xi

Least Squares - Example

• Primitive is a polynomial

=
(

(
xx
,1
,
(
−
,1
(
pp
i
i

p
i

y

j
x

y

xg
)(
∑
∑
2

i

i

2

T

)
c⋅
,...
p
2
i
x

,

x

p
i
(
,1

−

)
c
,...

2

T

)
)
c
,...

⇒
)

T

p
i

x

,

p
2
i
x

•

min

=

0

• Linear system of equations

Radial Basis Functions

• Represent interpolant as
• Sum of radial functions r
• Centered at the data points pi
(
)
prw
x
i
i

( )
xf

−

=

∑

i

13

15

17

• Fits a primitive to the data
• Minimizes squared distances between 

the pi’s and primitive g

xg
)(

+=

a

bx

+

2

cx

(

min
g

∑ −

p
i

y

i

)
)

2

(
pg
i

x

Least Squares - Example
• Resulting system (

(
pp
i
i

)
c
,...

p
i

,1

−

2

0

,

p
2
i
x

j
x

x

y

)

T

⇔

i

= ∑
1
x
x
2
Μ

x
x
2
x

3









2

3

4

x
x
x

Κ

c
0
c
1
c






2
ΜΟ
















=








y
yx
yx
2
Μ








14

16

Radial Basis Functions
)

(
prw
i
i

• Solve

−

=

p

p

j

j

x

x

y

∑

i

r

to compute weights wi
(
pr
(
0
pr
1
x
r

• Linear system of equations 
)

(
)


pr
(
1

pr




( )
0
−
p
0
−
p
Μ

(
pr
(
pr

−
p
−
p
( )
0

−
( )
0
−

)
)

)
)

p
1

0
r

p
1

2

0

2

2

2

x

x

x

x

x

x

x

x

x

x

x

Λ

w

0

w

1

w

2
ΜΟ
















=








y

p
0
p
1
p
2
Μ

y

y








18

3

Radial Basis Functions

Function Spaces!

•

d

log2=

• Solvability depends on radial function
• Several choices assure solvability
(thin plate spline)

( )
dr
( )
dr
• h is a data parameter
• h reflects the feature size or anticipated 

(Gaussian)

−=
de

2 / h

d

•

2

spacing among points

19

21

23

Function Spaces?

• Problems

• Many points lead to large linear systems
• Evaluation requires global solutions

• Solutions

• RBF with compact support

• Matrix is sparse
• Still: solution depends on every data point, 
though drop-off is exponential with distance

• Local approximation approaches

Shepard Interpolation
• f(x) is a convex combination of φi, 

because all φi(Rd)⊆[0,1] and Σi φi(x) ≡1.
(cid:206)f(x) is contained in the convex hull of data 

points

• for p>1 f(p)∈C∞and ∇xφi(xi) = 0

(cid:206)Data points are saddles

• global interpolation 

(cid:206)every f(x) depends on all data points

• Only constant precision, i.e. only constant 

functions are reproduced exactly

• Monomial, Lagrange, RBF share the 

same principle:
• Choose basis of a function space
• Find weight vector for base elements by 

solving linear system defined by data 
points

• Compute values as linear combinations

• Properties

• One costly preprocessing step
• Simple evaluation of function in any point

Shepard Interpolation
• Approach for Rd: f(x)= Σi φi(x) fi
−
i
xx

∑
• define f(xi ) := fi = limx(cid:198)xif(x)

with basis functions

xx
−

(x)φ
i

=

j

−

p

−

p

j

Shepard Interpolation

Localization:
• Set 

with

f(x)= Σi µi(x)·φi(x)·fi
−
iRixx
=
(x)
sonst

für

−
xx
R
i
0

(

1




)

<

−

ν

i

µ
i

for reasonable Ri and ν>1
(cid:206)no constant precision because of 

possible holes in the data

20

22

24

4

Spatial subdivisions

Spatial subdivisions

• Subdivide parameter domain into 

overlapping cells τi with centroids ci

• Compute Shepard weights
(x)φ
i

=

−

p

−
cx
i
−
cx

−

p

j

∑

j

and localize them using the radius of the 
cell

• Interpolate/approximate data points in 

each cell by an arbitrary function fi
• The interpolant is given as f(x)= Σi 
µi(x)·φi(x)·fi

25

26

Moving Least Squares

Moving Least Squares

• Compute a local LS approximation at t
• Weight data points based on distance 

to t

=

• The set
)
)
( )
tf
(
θ
is a smooth curve, iff θ is smooth

gtg
t

(
pg
i

min
g

∑

p
i

(

),

−

2

:

t

i

x

y

(

min

−∑

p
i

y

i

+=

a

bx

+

2

cx

(
pg
i

x

)
)

2

t
θ

(

−

t

p
i

x

xg
)(

)

Moving Least Squares
• Typical choices for θ:

•
•

( )
d
( )
d

θ
θ

−=
rd
−=
2 /
de
= θ
θ

(

2

h

)

• Note:                           is fixed
i
• For each t

t −

p
xi

• Standard weighted LS problem
• Linear iff corresponding LS is linear

27

29

Typical Problems

• Sharp corners/edges

• Noise vs. feature size

(

−

t

p
i

x

)

28

30

5

Functional -> Manifold

Implicits

• Standard techniques are applicable

if data represents a function

• Manifolds are more general

• No parameter domain
• No knowledge about neighbors, Delaunay 

triangulation connects non-neighbors

• Each orientable n-manifold can be 

embedded in n+1 – space 

• Idea: Represent n-manifold as zero-

set of a scalar function in n+1 – space 
• Inside:
• On the manifold:
• Outside: 

( ) 0<xf
( ) 0=xf
( ) 0>xf

Implicits - Illustration

• Image courtesy Greg Turk

31

33

Implicits from point samples

• Function should be 
zero in data points
•

) 0=i
• Use standard 

(
f p

approximation 
techniques to find f

0=f
• Trivial solution:
• Additional constraints 

are needed

Implicits from point samples

Implicits from point samples

• Constraints define 
inside and outside
• Simple approach 

(Turk, O’Brien)
• Sprinkle additional 

information manually

• Make additional 
information soft 
constraints

+

+

+

+

−
−

−

−

−

−

+

+

+

35

• Use normal 
information 

• Normals could be 

computed from scan

• Or, normals have to be 

estimated

0

32

34

36

6

Estimating normals

Estimating normals

• Normal orientation

(Implicits are signed)
• Use inside/outside

information from scan

n

q

• Normal direction

by fitting a tangent
• LS fit to nearest neighbors
• Weighted LS fit
• MLS fit

Estimating normals

• The constrained minimization problem

min
=
n
1

∑ −

npq
,

i

i

2

θ

i

is solved by the eigenvector corresponding 
to the smallest eigenvalue of

(
q
(
q
(
q

−

−

−

x

y

z

p
i
p
i

x

x

p
i

x

)
)
)

2

2

2










i

∑
∑
∑

i

i

θ

i

θ

i

θ

i

i

∑
∑
∑

i

i

(
q
(
q
(
q

−

−

−

x

y

z

p
i
p
i

y

y

p
i

y

2

2

)
)
)

2

θ

i

θ

i

θ

i

i

∑
∑
∑

i

i

(
q
(
q
(
q

−

−

−

x

y

z

p
i
p
i

z

z

p
i

z

)
)
)

2

2

2

θ

i

θ

i

θ

i










• General fitting problem
(
pq
,θ
min
=
n
1

∑ −

npq
,

2

i

i

i

• Problem is non-linear

because n is constrained
to unit sphere

)

n

q

37

39

Implicits from point samples

+1

+1

• Compute non-zero 

anchors in the 
distance field

• Use normal 

+1

+1

information directly 
as constraints
) 1=

(
p

+ i
n

f

i

+1

+1

+1

+1

Implicits from point samples

Computing Implicits

• Compute non-zero 

anchors in the 
distance field

• Compute distances 

at specific points
• Vertices, mid-points, 

+1

etc. in a spatial 
subdivision

−2.5

+2.5

+0.5

+2

+0.5

+1.5

i np ,
• Given N points and normals         
i
(
)
c
f

and constraints

(
p

,0

=

)

f

i

=

d

i

i

p

=+

c

i

Ni

• Let 
• An RBF approximation
irw

( )
x

=

f

∑

i

(

−

x

p

i

)

leads to a system of linear equations

+1

+2

41

38

+1

+1

+1

+1

40

42

7

Computing Implicits
• Practical problems: N > 10000
• Matrix solution becomes difficult
• Two solutions

• Sparse matrices allow iterative solution
• Smaller number of RBFs

Computing Implicits

• Sparse matrices

• Needed: 

d


r

(

pr
(
1

pr



→>

c

0

)
)

(
pr
0
r
(
pr
=

( )
0
−
p
−
p
Μ
dr
,0)(

0

2

)
)

−
p
1
( )
0
−

p
1

2

2

(
−
p
pr
(
0
−
p
pr
1
( )
r
0
=

cr
0)('

c

• Compactly supported RBFs

c

43

Computing Implicits

• Smaller number of RBFs
• Greedy approach (Carr et al.)
• Start with random small subset
• Add RBFs where approximation quality is 

not sufficient

RBF Implicits - Results

• Images courtesy Greg Turk

RBF Implicits - Results

• Images courtesy Greg Turk

45

47

Hoppe’s approach

• Use linear distance

field per point
• Direction is 

defined by normal

• In every point in

space use the
distance field of
the closest point

)
)

Λ

Ο









44

46

48

8

Hoppe’s approach - smoother

• Direction fields are 
interpolated using 
Voronoi 
interpolation

PuO Implicits

• Construct a spatial 

subdivision

• Compute local 
distance field 
approximations
• e.g. Quadrics

• Blend them with

local Shepard 
weights

+2

+0.5

+1.5

+1

−2.5

+2.5

+0.5

+1

+2

PuO Implicits: Sharp features

Corner
Corner
function
function

Edge 
Edge 
function
function

Local analysis of 
Local analysis of 
points and normals
normals
points and

Piecewise quadric 

functions

Standard 
Standard 
quadric
quadric

Multi-level PuO Implicits

• Local computations

• Insensitive to number of 

points

• Local adaptation to shape 

complexity

• Sensitive to output 

complexity

49

51

53

Multi-level PuO Implicits

• Subdivide cells based on local error

Multi-level PuO Implicits

• Aproximation at arbitrary accuracy

50

52

54

9

Implicits - Conclusions

Projection

• Scalar field is underconstrained

• Constraints only define where the field is 

zero, not where it is non-zero

• Additional constraints are needed

• Signed fields restrict surfaces to be 

unbounded
• All implicit surfaces define solids

• Idea: Map space to surface
• Surface is defined as fixpoints of 

mapping

r

r’

55

57

Surface definition

• Projection procedure (Levin)
• Local polyonmial approximation
• Inspired by differential geometry

• “Implicit” surface definition

r

r’

• Infinitely smooth &
• Manifold surface

Local Reference Plane

•

=
H r
−
npq
,

nq,
2
θ

•Find plane
∑
i
de=

min
=
nq
1
,
( )
dθ
• h is feature size/

•

i

2 /

h

2

+
D
−
pq

(

n

)

i

r

point spacing

• Hr is independent

of r’s distance

• Manifold property

Weight function 

based on distance to 

q, not r

Hr

q

59

Surface Definition

• Constructive definition

• Input point r
• Compute a local
reference plane
Hr=<q,n>

• Compute a local
polynomial over
the plane Gr

• Project point r’=Gr(0)
• Estimate normal

n

r

Hr

q

Local Reference Plane

•Computing reference plane

• Non-linear optimization problem

•Minimize independent 
variables:

• Over n for fixed distance

qr −

n

r

Hr

q

n

r

• Along n for fixed direction n

• q changes -> the weights change
• Only iterative solutions possible

56

Gr

58

H
r

q

60

10

Local Reference Plane

•Practical computation

• Minimize over n for fixed q

n

r

• Eigenvalue problem
• Translate q so that
nqr
• Effectively changes
• Minimize along n for

−+=

qr

fixed direction n
• Exploit partial derivative

qr −

n

r

Spatial data structure
• Regular grid based on support of θ

• Each point influences only 8 cells

• Each cell is

an octree
• Distant octree cells

are approximated
by one point in
center of mass

r

Hr

q

Projecting the Point
(
• MLS polyonomial over Hr
p
Hi

npq
,

∑

min
Π∈
G

(

−

G

•

−

i

d

i

)
)

2

(

θ

r

)

−

pq

i

H
r

q

61

63

• LS problem
• r’=Gr(0) 

• Estimate normal

n

r

Hr

q

Gr

Conclusions

• Projection-based surface definition

• Surface is smooth and manifold
• Surface may be bounded
• Representation error mainly depends on 

point density

• Adjustable feature size h allows to 

smooth out noise

62

64

11

Point-Based Rendering

Matthias Zwicker

Computer Graphics Lab

ETH Zürich

Point-Based Rendering

• Introduction and motivation
• Surface elements
• Rendering
• Antialiasing
• Hardware Acceleration
• Conclusions

Motivation 1

Motivation 1

• Performance of 3D hardware has exploded
(e.g., GeForce4: 136 million vertices per 
second)

• Projected triangles are very small (i.e., 

cover only a few pixels)

• Overhead for triangle setup increases

(initialization of texture filtering, 
rasterization)

A simpler, more efficient rendering
primitive than triangles?

Points as Rendering
Primitives
• Point clouds instead of triangle meshes [Levoy and 

Whitted 1985]

• 2D vector versus pixel graphics

4 million pts.
[Levoy et al. 2000]

5

triangle mesh (with 

textures)

point cloud

Quake 2, 1998
10k triangles

Nvidia, 2002 

millions of triangles

3

Motivation 2

• Modern 3D scanning devices
(e.g., laser range scanners) 
acquire huge point clouds

• Generating consistent triangle 
meshes is time consuming and 
difficult

A rendering primitive for
direct visualization of point
clouds, without the need to
generate triangle meshes?

2

4

6

1

Point-Based Surface 
Representation

• Points are samples of the surface
• The point cloud describes:
• 3D geometry of the surface
• Surface reflectance properties (e.g., 

diffuse color, etc.)

• There is no additional information, 

such as
• connectivity (i.e., explicit 

neighborhood information between 
points)

• texture maps, bump maps, etc.

7

9

Surfels

• How to represent the surface between the 

points?

holes between 

the points

• Surfels need to interpolate the surface 
• A certain surface area is associated with 

between the points
each surfel

Surfels

• Surfels store essential information for 

rendering

• Surfels are primarily designed as a 

point rendering primitive

• They do not provide a mathematically 
smooth surface definition (see [Alexa 
2001], point set surfaces)

Surface Elements - Surfels

• Each point corresponds to a surface 

element, or surfel, describing the surface in 
a small neighborhood

• Basic surfels:

BasicSurfel {

position;
color; 

}

y

position
color

z

x

8

Surfels

• Surfels can be extended by storing additional 

attributes

• This allows for higher quality rendering or 

advanced shading effects

ExtendedSurfel {

position;
color; 
normal;
radius;
etc... 

}

radius

color
surfel disc

normal
position

10

Model Acquisition

• 3D scanning of physical objects

• See Pfister, acquisition
• Direct rendering of acquired point clouds
• No mesh reconstruction necessary

11

[Matusik et al. 2002]

12

2

Model Acquisition

Model Acquisition

• Sampling synthetic objects

• Efficient rendering of complex models
• Dynamic sampling of procedural objects
and animated scenes (see Stamminger, 
dynamic sampling)

[Zwicker et al. 2001]

[Stamminger et al. 2001]

Point Rendering Pipeline

Point
Cloud

Projection

Shading

Visibility

Frame-
buffer

Image

Reconstruction

• Simple, pure forward mapping pipeline
• Surfels carry all information through the pipeline

(„surfel stream“)

• No texture look-ups
• Framebuffer stores RGB, alpha, and Z

Point Rendering Pipeline

Projection

Shading

Visibility

Image

Reconstruction

• Per-point shading
• Conventional models for shading

(Phong, Torrance-Sparrow, 
reflections, etc.)

13

15

17

• Processing and editing of point-sampled 

geometry

spectral processing
[Pauly, Gross 2002]

(see Gross, spectral processing)

point-based surface editing

[Zwicker et al. 2002]

(see Pauly, Pointshop3D)

14

Point Rendering Pipeline

Projection

Shading

Visibility

Image

Reconstruction

• Perspective projection of each point in 

the point cloud

• Analogous to projection of triangle 

vertices
• homogeneous matrix-vector product
• perspective division

16

Point Rendering Pipeline

Projection

Shading

Visibility

Image

Reconstruction

• Visibility and image reconstruction is tightly 

coupled
• Discard points that are occluded from the 

current viewpoint

• Reconstruct continuous surfaces from 

projected points (antialiasing)

18

3

Visibility and Image 
Reconstruction

without visibility and 
image reconstruction

with visibility and 
image reconstruction

foreground point

occluded background point

surface discontinuity 
(“hole”)

19

Quad Rendering Primitive

• Rasterize a colored quad centered at the projected

point, use z-buffering

• The quad side length is h, where h = 2 * r * s
• The scaling factor s given  by perspective 

projection and viewport transformation

• Hardware implementation: OpenGL GL_POINTS

colored quad

projected 

point

y

screen space

}h

x

Projected Disc Rendering 
Primitive

• Project surfel discs from object to screen space
• Projecting discs results in ellipses in screen space
• Ellipses adapt to the surface orientation

screen space

object space

normal

surfel disc

y

y

x

projected surfel disc

z

x

21

23

Visibility and Image 
Reconstruction

• Goal: avoid holes and 

discard occluded surfels

• Use surfel discs with 

radius r to cover 
surface completely

• Apply z-buffer to 

discard invisible surfels

3D object space

normal

radius r

surfel disc

Visibility: Z-Buffering

• No blending of rendering primitives

framebuffer

pixel

z1  > z2{

z1

z2

y

z

x

Discussion

• Quad and projected disc primitive

• Simple, efficient
• Hardware support
• Low image quality
• Suitable for preview renderers (e.g. 

Qsplat [Rusinkiewicz et al. 2000] )

• Problem: no blending of primitives

20

22

24

4

Splatting

Splatting

• A splat primitive consists of a colored point 

primitive and an alpha mask

• The final color c(x,y) is computed by additive 

alpha blending, i.e., by computing the weighted 
sum

color of splat i

alpha of splat i at position (x,y)

yxc
,(

)

yxwc
,(
)
i
i
yxw
)
,(
i

∑=
∑

i

i

y

*

y

=

y

x

colored point 
primitive c

x

alpha mask 

w(x,y)

(often a 2D 

Gauss function)

x

splat primitive

c * w(x,y)

25

• Normalization is necessary, because the weights do 
not sum up to one with irregular point distributions

∑i

yxw
,(
i

≠
1)

Splatting

Splatting

without normalization

with normalization

• Extended z-buffering

surface 1

surface 2

varying brightness 
because of irregular 

point distribution

no artifacts

z-buffer pixel

surfel disc

z

discard splats

z-threshold
accumulate 

splats

Extended Z-Buffering

DepthTest(x,y) {

if (abs(splat z – z(x,y)) < threshold) {

c(x,y) = c(x,y) + splat color

w(x,y) = w(x,y) + splat w(x,y)

} else if (splat z < z(x,y)) {

z(x,y) = splat z

c(x,y) = splat color

w(x,y) = splat w(x,y)

}

}

27

29

Splatting Comparison

elliptical

splats

circular splats
with min. radius

surface
splatting

minif.

magnif. 128 x 192

128 x 192

128 x 192

26

28

30

5

High Quality Splatting

Aliasing in Computer Graphics

• High quality splatting requires careful 

analysis of aliasing issues
• Review of signal processing theory
• Application to point rendering
• Surface splatting [Zwicker et al. 2001]

• Aliasing = Sampling of continuous functions 

below the Nyquist frequency
• To avoid aliasing, sampling rate must be twice as 

high as the maximum frequency in the signal

• Aliasing effects:

• Loss of detail
• Moire patterns, jagged edges
• Disintegration of objects or patterns

• Aliasing in Computer Graphics

• Texture Mapping
• Scan conversion of geometry

31

32

Aliasing in Computer 
Graphics
• Aliasing: high frequencies in the input signal 

appear as low frequencies in the 
reconstructed signal

Occurrence of Aliasing

Spatial Domain Frequency Domain

Spatial Domain Frequency Domain

33

34

Aliasing-Free Reconstruction

Spatial Domain Frequency Domain Spatial Domain Frequency Domain

Antialiasing

• Prefiltering

• Band-limit the continuous signal before 

sampling

• Eliminates all aliasing (with an ideal low-pass 

filter)

• Closed form solution not available in general

• Supersampling

• Raise sampling rate
• Reduces, but does not eliminate all aliasing 

artifacts (in practice, many signals have infinite 
frequencies)

• Simple implementation (hardware)

35

36

6

Resampling

discrete input signal

discrete output signal

warp

1.

resampling

4.

2.

3.

Resampling Filters

Object Space

color

position

irregular spacing

reconstructed input
reconstruction kernels

Resampling Filters
Object Space

Screen Space

p
r
a
W

 
.
2

Screen Space

Screen Space

3. Filter

Resampling

• Resampling in the context of surface 

rendering
• Discrete input function = surface texture

(discrete 2D function)

• Warping = projecting surfaces to the

image plane (2D to 2D projective 
mapping)

37

39

41

Resampling Filters

Object Space

Screen Space
sum of resampling filters

e
l
p
m
a
S
 
.
4

p
r
a
W

 
.
2

Screen Space
warped reconstruction 

kernel

Screen Space

resampling filters

low-pass filter

convolution

3. Filter

38

e
l
p
m
a
S
 
.
4

40

2D Reconstruction Kernels

• 2D reconstruction kernels are given by surfel discs 

with alpha masks

• Warping is equivalent to projecting the kernel from 

object to screen space

screen space

object space

y

y

x

warped reconstruction kernel

z

x

normal

surfel disc with 
alpha mask = 
reconstruction 
kernel

42

7

Resampling Filters
• A resampling filter is a convolution of a 

warped reconstruction filter and a low-pass 
filter

screen space 
pixel grid

convolution

“no information falls 
inbetween the pixel 
grid”

warped 

reconstruction 

kernel

low-pass filter 
(determined by 

pixel grid)

resampling filter

(“blurred reconstruction 

kernel”)

Gaussian Resampling Filters

• Gaussians are closed under linear 

warping and convolution

• With Gaussian reconstruction kernels
and low-pass filters, the resampling 
filter is a Gaussian, too

• Efficient rendering algorithms

(surface splatting [Zwicker et al. 
2001])

Mathematical Formulation

yxc
,(

)

=

⊗

yxh
,(

)

(

k

−
1

))

yxmrc
,(
kk

∑
∑=
Gaussian resampling filter

yxGc
,(
k

)

k

k

43

45

47

Mathematical Formulation

yxc
,(

)

=

∑

k

resampling filter
⊗
yxmrc
,(
kk

))

−
1

(

yxh
,(

)

pixel color

warping function

low pass filter

reconstruction kernel

reconstruction kernel color

44

Mathematical Formulation

yxc
,(

)

=

∑

k

−
1

yxmrc
,(
(
kk
Gaussian

⊗

))

yxh
,(
)
Gaussian

reconstruction kernel

low-pass filter

screen space

screen space

Algorithm

for each point P {

project P to screen space;
shade P;
determine resampling kernel G;
splat G;

}
for each pixel {

normalize;

}

46

48

8

Properties of 2D Resampling
Filters
warped recon-
struction kernel

low-pass

filter

resampling

filter

Results

minification

• High quality reconstruction and filtering

magnification

49

200k points

4783k points

50

Results

transparent surfaces

scanned objects

Hardware Implementation

• Based on the object space formulation of 

EWA filtering

• Implemented using textured triangles
• All calculations are performed in the 

programmable hardware (extensive use of 
vertex shaders)

• Presented at EG 2002 ([Ren et al. 2002])

987k points

[MERL/MIT Matusik et al.]

51

52

Surface Splatting 
Performance
• Software implementation

• 500 000 splats/sec on 866 MHz PIII
• 1 000 000 splats/sec on 2 GHz P4

• Hardware implementation [Ren et al. 2002]
• Uses texture mapping and vertex shaders
• 3 000 000 splats/sec on GeForce4 Ti 4400

Conclusions

• Points are an efficient rendering primitive for highly complex 

surfaces

• Points allow the direct visualization of real world data 

acquired with 3D scanning devices

• High performance, low quality point rendering is supported 

by 3D hardware (tens of millions points per second)

• High quality point rendering with anisotropic texture filtering 

is available 
• 3 million points per second with hardware support
• 1 million points per second in software

• Antialiasing technique has been extended to volume 

rendering

53

54

9

Applications

Future Work

• Direct visualization of point clouds
• Real-time 3D reconstruction and rendering 

for virtual reality applications

• Hybrid point and polygon rendering systems
• Rendering animated scenes
• Interactive display of huge meshes
• On the fly sampling and rendering of 

procedural objects

• Dedicated rendering hardware
• Efficient approximations of exact EWA 

splatting

• Rendering architecture for on the fly 

sampling and rendering

55

56

Acknowledgments

References

• Hanspeter Pfister, Jeroen van Baar

(MERL, Cambridge MA)

• Markus Gross, Mark Pauly, CGL
• Liu Ren

http://graphics.ethz.ch/surfels
http://graphics.ethz.ch/pointshop3d

• [Levoy and Whitted 1985] The use of points as a display primitive, 
technical report, University of North Carolina at Chapel Hill, 1985

• [Heckbert 1986] Fundamentals of texture mapping and image warping, 

Master‘s Thesis, 1986

• [Grossman and Dally 1998] Point sample rendering, Eurographics 

workshop on rendering, 1998

• [Levoy et al. 2000] The digital Michelangelo project, SIGGRAPH 2000
• [Rusinkiewicz et al. 2000] Qsplat, SIGGRAPH 2000
• [Pfister et al. 2000] Surfels: Surface elements as rendering primitives, 

SIGGRAPH 2000

• [Zwicker et al. 2001] Surface splatting, SIGGRAPH 2001
• [Zwicker et al. 2002] EWA Splatting, to appear, IEEE TVCG 2002
• [Ren et al. 2002] Object space EWA splatting: A hardware accelerated 

approach to high quality point rendering, Eurographics 2002

57

58

10

Point-Based Computer Graphics

Marc Alexa, Carsten Dachsbacher, 

Markus Gross, Mark Pauly, 

Hanspeter Pfister, Marc Stamminger, 

Matthias Zwicker

Introduction

• how render the points?

• project point to pixel, set pixel color
• hardware solution (Radeon 9700 Pro)

• ~80 mio. points per second
• no hole filling

• software solution

• ~8 mio. points per second
• hole filling

• hardware != software

Introduction

• what we want:

• sequential processing and
• adaptive point densities

→ precomputed point lists
→ render continuous segments only

rendered segment

point list

3

5

Introduction

• point rendering

• how adapt point densities?

• for a given viewing position, how can we get

n points that suffice for that viewer?

• how render the points?

• given n points, how can we render an image 

from them ?

Introduction

• even with hardware:

• for (int i = 0; i < N; i++)

renderPointWithNormalAndColor
→ 10 mio points per second

(x[i],y[i],z[i],nx[i],ny[i],nz[i],…);

• for (int i = 0; i < N; i++)

renderPoint(x[i],y[i],z[i]);
→ 20 mio points per second

• float *p = {...}
renderPoints(p);
→ 80 mio points per second

• → best performance with sequential

processing of large chunks !

2

4

Hierarchical Processing

• Q-Splat

• Rusinkiewicz et al., Siggraph 2000
• hierarchical point rendering

based on Bounding Sphere Hierarchy

© S. Rusinkiewicz

6

1

Hierarchical Processing

• Q-Splat hierarchy

R

R

R

R

R

R

R

Hierarchical Processing

• not sequential
• no array, but tree structure
• most work on CPU
• CPU is bottleneck: ~8 mio points per second

→ sequential version ?

7

9

Hierarchical Processing

• Q-Splat recursive rendering

render( Node n ) {

// compute screen size of node
s = n.R / distanceToCamera( n );
// screen size too big?
if ( s > threshold )

// → render children
forall children c

render( c );

else

// else draw node
renderPoint( n.xyz );

}

8

Sequential Point Trees

• store with node dmin = n.R / 1 Pixel

• render( Node n ) {

// node too close?
if ( distanceToCamera( n ) < n.dmin )

// → render children
forall children c

render( c );

else

// else draw node
renderPoint( n.xyz );

}

Sequential Point Trees

Sequential Point Trees

• node n is rendered if:
• n is not too close and
• parent is not rendered

• or

• distToCam( n ) < n.dmin
• distToCam( n.parent ) ≥ n.parent.dmin

• parent is too close, but node is far 

enough

11

• assume

• distToCam(n) ≈ distToCam(n.parent)

• store with n

• n.dmax = n.parent.dmin

• then a node is rendered if

• n.dmin ≤ distToCam(n) < n.dmax

10

12

2

Sequential Point Trees

Sequential Point Trees

• example tree

Sequential Point Trees

• sort nodes by

dmax

e
e
r
t
 
t
n
i
o
p

l
a
i
t
n
e
u
q
e
s

e
e
r
t
 
t
n
i
o
p

Sequential Point Trees

• account for d ≠ d(parent):

• dmax = dmin(parent) + distance to parent
• partially parent and some children

selected

• no visible artifacts from this

13

15

17

• sequential version

• foreach tree node n

if ( n.dmin < distToCam(n) &&

distToCam(n) < n.dmax )

renderPoint(n);

• how enumerate nodes?

14

Sequential Point Trees

• compute lower bound dbmin on 

distToCam(n) with bounding volume

• all elements with dmax < dbmin can be skipped
• only prefix must be considered

imax

imax

imax

16

Sequential Point Trees

• culling by GPU necessary, because d is not constant

over object

18

3

Sequential Point Trees

Sequential Point Trees

• CPU does per frame:

• compute dbmin
• search last node imax with dmax>dbmin
• send first imax points to GPU

• GPU then does for every node n

• compute d = distToCam(n)
• if n.dmin ≤ d ≤ n.dmax

• render node

• CPU does first interval selection by dbmin
• GPU does fine granularity selection

sequential point tree

prefix with dbmin < dmax

culled because d < n.dmin

rendered

culled because d > n.dmax

Sequential Point Trees

• Result

• culling by GPU: only 10 - 40%
• on a 2,4 GHz Pentium with Radeon 9700:
• CPU-Load < 20% (usually much less)
• > 50 Mio points after culling

Sequential Point Trees

• geometric

• perpendicular

error

• tangential

error

19

21

23

Sequential Point Trees

• better error measurement

• in flat regions

• increase dmin, dmax
• render larger points

Sequential Point Trees

• example

20

22

24

4

Sequential Point Trees

Sequential Point Trees

• also add texture criterion
• necessary for flat textured regions

Sequential Point Trees

• perpendicular, tangential, texture

error

• scale with 1/(view distance)

• fits into sequential point trees

Sequential Point Trees

• can be combined with polygons

25

27

29

• if significant color variation in child

nodes:
• modify tangential error
• increase error to node diameter

• prevents washed out colors in flat

regions

Sequential Point Trees

• combine errors

• perpendicular ep
• tangential et
• texture etex

• ecom = 

r

if texture variation

e +
2
p

e
2
t

else

• => screen error = ecom / viewDistance

Sequential Point Trees

• combine with polygonal rendering

• for every triangle

• compute dmax (longest side / dmax = ε)
• remove all points from triangle with smaller dmax

• sort triangles for dmax
• during rendering

• for every object, compute upper bound dbmax on 

distance

• send triangles with dmax < dbmax to GPU
• on the GPU (vertex program)

• test d < dmax
• cull by alpha-test

26

28

30

5

Sequential Point Trees

• pros

• very simple!
• CPU-load low
• most work moved to GPU
• GPU runs at maximum efficiency

• cons

• no view frustum culling
• currently: bad splatting support by GPU

31

6

Efficient Simplification of 
Point-sampled Surfaces

Overview

• Introduction
• Local surface analysis
• Simplification methods
• Error measurement
• Comparison

Point-Based Computer Graphics

Mark Pauly

1

Point-Based Computer Graphics

Mark Pauly

2

Introduction

Introduction

• Point-based models are often sampled very densely
• Many applications require coarser approximations, 

e.g. for efficient

• Example: Level-of-detail (LOD) rendering

• Storage
• Transmission
• Processing
• Rendering

(cid:214) We need simplification methods for reducing the 

complexity of point-based surfaces

10k

20k

60k

200k

2000k

Point-Based Computer Graphics

Mark Pauly

3

Point-Based Computer Graphics

Mark Pauly

4

Introduction

• We transfer different simplification methods from 

triangle meshes to point clouds:

• Hierarchical clustering
• Iterative simplification
• Particle simulation

• Depending on the intended use, each method has 

its pros and cons (see comparison)

Local Surface Analysis

• Cloud of point samples describes underlying 

(manifold) surface

• We need:

• Mechanisms for locally approximating the 

surface (cid:214) MLS approach

• Fast estimation of tangent plane and curvature 

(cid:214) principal component analysis of local 
neighborhood

Point-Based Computer Graphics

Mark Pauly

5

Point-Based Computer Graphics

Mark Pauly

6

1

Neighborhood

Neighborhood

• No explicit connectivity between samples (as with 

• K-nearest neighbors

triangle meshes)

• Replace geodesic proximity with spatial proximity 

(requires sufficiently high sampling density!)

• Compute neighborhood according to Euclidean 

distance

Point-Based Computer Graphics

Mark Pauly

7

Point-Based Computer Graphics

Mark Pauly

8

• Can be quickly computed using spatial data-

structures (e.g. kd-tree, octree, bsp-tree)

• Requires isotropic point distribution

Neighborhood

Neighborhood

• Improvement: Angle criterion (Linsen)

• Local Delaunay triangulation (Floater)

• Project points onto tangent plane
• Sort neighbors according to angle
• Include more points if angle between 

subsequent points is above some threshold

• Project points into tangent plane
• Compute local Voronoi diagram

Point-Based Computer Graphics

Mark Pauly

9

Point-Based Computer Graphics

Mark Pauly

10

Covariance Analysis

Covariance Analysis

• Covariance matrix of local neighborhood N:

• Consider the eigenproblem:

=

C

p





p


i
1

−
Λ
−

i

n

T

p

p







⋅

p





p


i
1

−
Λ
−

i

n

• with centroid

=

p

1
N

p

i

∑

∈
Ni

p

p







,

∈

N

i j

⋅
vC

l

=

⋅
λ
l

v

l

,

∈

l

}2,1,0{

• C is a 3x3, positive semi-definite matrix

(cid:214) All eigenvalues are real-valued
(cid:214) The eigenvector with smallest eigenvalue defines the 

least-squares plane through the points in the 
neighborhood, i.e. approximates the surface normal

Point-Based Computer Graphics

Mark Pauly

11

Point-Based Computer Graphics

Mark Pauly

12

2

Covariance Analysis

• Covariance ellipsoid spanned by the eigenvectors 

scaled with corresponding eigenvalue

Covariance Analysis

• The total variation is given as:

−∑
i p

p

∈Ni

2

=

+

λλλ +
0
2

1

• We define surface variation as:

=pn
σ
)(

λ
0

,

λλλ
2
0

≤

≤

1

+

λλλ
2
0

+

1

Point-Based Computer Graphics

Mark Pauly

13

Point-Based Computer Graphics

Mark Pauly

14

• Measures the fraction of variation along the surface 

normal, i.e. quantifies how strong the surface deviates 
from the tangent plane (cid:214) estimate for curvature

Covariance Analysis

• Comparison with curvature:

Surface Simplification

• Hierarchical clustering
• Iterative simplification
• Particle simulation

original

mean curvature

variation n=20

variation n=50

Point-Based Computer Graphics

Mark Pauly

15

Point-Based Computer Graphics

Mark Pauly

16

Hierarchical Clustering

Hierarchical Clustering

• Top-down approach using binary space partition:
• Split the point cloud if:

• Size is larger than user-specified maximum or
• Surface variation is above maximum threshold

• Split plane defined by centroid and axis of greatest 
variation (= eigenvector of covariance matrix with 
largest associated eigenvector)

• Leaf nodes of the tree correspond to clusters
• Replace clusters by centroid

• 2D example

root

covariance 
ellipsoid

split plane

centroid

Point-Based Computer Graphics

Mark Pauly

17

Point-Based Computer Graphics

Mark Pauly

18

3

Hierarchical Clustering

Hierarchical Clustering

• 2D example

• 2D example

Point-Based Computer Graphics

Mark Pauly

19

Point-Based Computer Graphics

Mark Pauly

20

Hierarchical Clustering

Hierarchical Clustering

• 2D example

Point-Based Computer Graphics

Mark Pauly

21

Point-Based Computer Graphics

Mark Pauly

22

43 Clusters

436 Clusters

4,280 Clusters

Hierarchical Clustering

Iterative Simplification

• Adaptive Clustering

• Iteratively contracts point pairs

(cid:214) Each contraction reduces the number of points by one

• Contractions are arranged in priority queue 

according to quadric error metric (Garland and 
Heckbert)

• Quadric measures cost of contraction and 

determines optimal position for contracted sample

• Equivalent to QSlim except for definition of 

approximating planes

Point-Based Computer Graphics

Mark Pauly

23

Point-Based Computer Graphics

Mark Pauly

24

4

Iterative Simplification

Iterative Simplification

• Quadric measures the squared distance to a set of 

planes defined over edges of neighborhood
• plane spanned by vectors                   and

p

−

e

2

e
1

= i
p

×= 1
ne

n

p

2e

1e

ip

• 2D example

• Compute initial point-pair 

contraction candidates

• Compute fundamental 

quadrics

• Compute edge costs

Point-Based Computer Graphics

Mark Pauly

25

Point-Based Computer Graphics

Mark Pauly

26

Iterative Simplification

Iterative Simplification

• 2D example

priority queue
edge      cost

6
2
14
5
9
1
13
3
11
10
7
4

0.02
0.03
0.04
0.04
0.09
0.11
0.13
0.22
0.27
0.36
0.44
0.56

• 2D example

priority queue
edge      cost

6
2
14
5
9
1
13
3
11
10
7
4

0.02
0.03
0.04
0.04
0.09
0.11
0.13
0.22
0.27
0.36
0.44
0.56

Point-Based Computer Graphics

Mark Pauly

27

Point-Based Computer Graphics

Mark Pauly

28

Iterative Simplification

Iterative Simplification

• 2D example

priority queue
edge      cost

6
2
14
5
9
1
13
3
11
10
7
4

0.02
0.03
0.04
0.06
0.09
0.11
0.13
0.23
0.27
0.36
0.49
0.56

• 2D example

priority queue
edge      cost

2
14
5
9
1
13
3
11
10
7
4

0.03
0.04
0.06
0.09
0.11
0.13
0.23
0.27
0.36
0.49
0.56

Point-Based Computer Graphics

Mark Pauly

29

Point-Based Computer Graphics

Mark Pauly

30

5

Iterative Simplification

Iterative Simplification

• 2D example

priority queue
edge      cost

2
14
5
9
1
13
3
11
10
7
4

0.03
0.04
0.06
0.09
0.11
0.13
0.23
0.27
0.36
0.49
0.56

• 2D example

priority queue
edge      cost

14
5
9
1
13
3
11
10
7
4

0.04
0.06
0.09
0.11
0.13
0.23
0.27
0.36
0.49
0.56

Point-Based Computer Graphics

Mark Pauly

31

Point-Based Computer Graphics

Mark Pauly

32

Iterative Simplification

Iterative Simplification

• 2D example

priority queue
edge      cost

11
10
7
4

0.27
0.36
0.49
0.56

Point-Based Computer Graphics

Mark Pauly

33

Point-Based Computer Graphics

Mark Pauly

34

original model 
(296,850 points)

simplified model 

(2,000 points)

remaining point pair 
contraction candidates

Particle Simulation

• Resample surface by distributing particles 

on the surface

• Particles move on surface according to 

inter-particle repelling forces

• Particle relaxation terminates when 

equilibrium is reached (requires damping)

• Can also be used for up-sampling!

Particle Simulation

• Initialization

• Randomly spread particles

• Repulsion

pp
• Linear repulsion force                                      
i
(cid:214)only need to consider neighborhood of radius r

pp

rk
(

F
i

p
)(

)

−

⋅
()

i

−

=

−

• Projection

• Keep particles on surface by projecting onto 

tangent plane of closest point

• Apply full MLS projection at end of simulation

Point-Based Computer Graphics

Mark Pauly

35

Point-Based Computer Graphics

Mark Pauly

36

6

Particle Simulation

• 2D example

Particle Simulation

• 2D example

• Initialization

• randomly spread particles

Point-Based Computer Graphics

Mark Pauly

37

Point-Based Computer Graphics

Mark Pauly

38

Particle Simulation

• 2D example

Particle Simulation

• 2D example

• Initialization

• randomly spread particles

• Repulsion

• linear repulsion force          

F
i

p
)(

=

rk
(

−

−

pp

i

⋅
()

−

pp

)

i

• Initialization

• randomly spread particles

• Repulsion

• linear repulsion force          

F
i

p
)(

=

rk
(

−

−

pp

i

⋅
()

−

pp

)

i

Point-Based Computer Graphics

Mark Pauly

39

Point-Based Computer Graphics

Mark Pauly

40

Particle Simulation

• 2D example

Particle Simulation

• 2D example

• Initialization

• randomly spread particles

• Repulsion

• linear repulsion force          

F
i

p
)(

=

rk
(

−

−

pp

i

⋅
()

−

pp

)

i

• Projection

• project particles onto 

surface                               

• Initialization

• randomly spread particles

• Repulsion

• linear repulsion force          

F
i

p
)(

=

rk
(

−

−

pp

i

⋅
()

−

pp

)

i

• Projection

• project particles onto 

surface                               

Point-Based Computer Graphics

Mark Pauly

41

Point-Based Computer Graphics

Mark Pauly

42

7

Particle Simulation

Particle Simulation

• Adaptive simulation

• Adjust repulsion radius according to surface variation     

(cid:214) more samples in regions of high variation

• User-controlled simulation

• Adjust repulsion radius according to user input

variation 
estimation

simplified model 

(3,000 points)

uniform

original

selective

Point-Based Computer Graphics

Mark Pauly

43

Point-Based Computer Graphics

Mark Pauly

44

Measuring Error

Measuring Error

• Measure the distance between two point-sampled 

surfaces using a sampling approach
max

• Maximum error: 

=′
)

∆

d

q
,(

S

′
)

∈
q
Q

SS
,(max
(cid:214) Two-sided Hausdorff distance
1
Q

SS
,(

=′
)

∆

avg

• Mean error:

d

q
,(

S

′
)

∑

∈
q
Q

•

′q
,( S
)

d
surface      using the MLS projection operator with 
linear basis functions

measures the distance of point     to 
S′

q

(cid:214) Area-weighted integral of point-to-surface distances
Q
describes the surface

is an up-sampled version of the point cloud that 

S

•

Point-Based Computer Graphics

Mark Pauly

45

Point-Based Computer Graphics

Mark Pauly

46

Measuring Error

Comparison

• Error estimate for Michelangelo’s David simplified 

from 2,000,000 points to 5,000 points

original

simplified

upsampled

error

Point-Based Computer Graphics

Mark Pauly

47

Point-Based Computer Graphics

Mark Pauly

48

8

Comparison

Comparison

• Execution time as a function of input model 

size (reduction to 1%)

• Execution time as a function of target 

model size (input: dragon, 535,545 points)

hierarchical clustering

iterative simplification

particle simulation

time 
(sec)

500
450
400
350
300
250
200
150
100
50
0

0

500

1000

1500

2000

2500

3000

3500

input size

time 
(sec)

70

60

50

40

30

20

10

0
180

hierarchical clustering

iterative simplification

particle simulation

160

140

120

100

80

60

40

20

0

target size

Point-Based Computer Graphics

Mark Pauly

49

Point-Based Computer Graphics

Mark Pauly

50

Comparison

• Summary

Efficiency

Surface 
Error

Control

Implementation

Hierarchical 
Clustering
Iterative 
Simplification
Particle 
Simulation

+

-

o

-

+

+

-

o

+

+

o

-

Point-based vs. Mesh 
Simplification

point-based simplification with 
subsequent mesh reconstruction

mesh reconstruction with subsequent 

mesh simplification (QSlim)

(cid:214) point-based simplification saves an expensive 

surface reconstruction on the dense point cloud!

Point-Based Computer Graphics

Mark Pauly

51

Point-Based Computer Graphics

Mark Pauly

52

References

• Pauly, Gross: Efficient Simplification of Point-

sampled Surfaces, IEEE Visualization 2002

• Shaffer, Garland: Efficient Adaptive Simplification 

of Massive Meshes, IEEE Visualization 2001

• Garland, Heckbert: Surface Simplification using 

Quadric Error Metrics, SIGGRAPH 1997

• Turk: Re-Tiling Polygonal Surfaces, SIGGRAPH 1992
• Alexa et al. Point Set Surfaces, IEEE Visualization 

2001

Point-Based Computer Graphics

Mark Pauly

53

9

Spectral Processing of Point-

Sampled Geometry

Markus Gross

Overview

• Introduction
• Fourier transform
• Spectral processing pipeline
• Applications

• Spectral filtering
• Adaptive subsampling

• Summary

Point-Based Computer Graphics

Markus Gross

2

Introduction

• Idea: Extend the Fourier transform to 

manifold geometry

(cid:214) Spectral representation of point-based objects
(cid:214) Powerful methods for digital geometry processing

Introduction

• Applications:

• Spectral filtering:

• Noise removal 
• Microstructure analysis
• Enhancement

• Adaptive resampling:
• Complexity reduction
• Continuous LOD

Point-Based Computer Graphics

Markus Gross

3

Point-Based Computer Graphics

Markus Gross

4

Fourier Transform

Fourier Transform

• 1D example:

X

n

= N
∑

k

=
1

output signal

• Benefits:

−

j

2π

nk
N

ex
k

input signal

spectral basis function

• Sound concept of frequency
• Extensive theory
• Fast algorithms

• Requirements:

• Fourier transform defined on Euclidean domain

(cid:214)we need a global parameterization

• Basis functions are eigenfunctions of Laplacian 

operator
(cid:214)requires regular sampling pattern so that basis 

functions can be expressed in analytical form (fast 
evaluation)
• Limitations:

• Basis functions are globally defined 

(cid:214)Lack of local control

Point-Based Computer Graphics

Markus Gross

5

Point-Based Computer Graphics

Markus Gross

6

1

Approach

Spectral Pipeline

• Split model into patches that:

• are parameterized over the unit-square

(cid:214) mapping must be continuous and should minimize        

distortion

• are re-sampled onto a regular grid

(cid:214) adjust sampling rate to minimize information loss

• provide sufficient granularity for intended 

application (local analysis)

(cid:214)process each patch individually and blend 

processed patches

Point-Based Computer Graphics

Markus Gross

7

Point-Based Computer Graphics

Markus Gross

8

Patch Layout Creation

Clustering    (cid:214) Optimization

Samples      (cid:214) Clusters      (cid:214)

Patches

Patch Layout Creation

• Iterative, local optimization method

• Merge patches according to quality metric:

Φ⋅Φ⋅Φ⋅Φ=Φ

S

NC

B

Reg

(cid:214) patch Size

(cid:214) curvature

(cid:214) patch boundary

SΦ
NCΦ
BΦ
RegΦ

(cid:214) spring energy regularization

Point-Based Computer Graphics

Markus Gross

9

Point-Based Computer Graphics

Markus Gross

10

Patch Layout Creation

Patch Resampling

• Parameterize patches by orthogonal projection 

onto base plane

• Bound normal cone to control distortion of 

mapping using smallest enclosing sphere

• Patches are irregularly sampled:

Point-Based Computer Graphics

Markus Gross

11

Point-Based Computer Graphics

Markus Gross

12

2

Patch Resampling

Spectral Analysis

• Resample patch onto regular grid using hierarchical 

push-pull filter (scattered data approximation)

• 2D discrete Fourier transform (DFT)

(cid:214) Direct manipulation of spectral coefficients

• Filtering as convolution:

=⊗

y

)

xF
(

yFxF
)(

)(

⋅

Point-Based Computer Graphics

Markus Gross

13

Point-Based Computer Graphics

Markus Gross

14

(cid:214) Convolution: O(N2) (cid:214) multiplication: O(N)

• Inverse Fourier transform

(cid:214) Filtered patch surface 

Spectral Filters

• Smoothing filters

ideal low-pass       Gaussian low-pass           original

Spectral Filters

• Microstructure analysis and enhancement

transfer function: spectral domain

transfer function: spatial domain

Point-Based Computer Graphics

Markus Gross

15

Point-Based Computer Graphics

Markus Gross

16

Spectral Resampling

Reconstruction

• Low-pass filtering

(cid:214) Band-limitation

• Regular Resampling

(cid:214) Optimal sampling rate   

(sampling theorem)

(cid:214) Error control 

(Parseval’s theorem)

Power Spectrum

• Filtering can lead to discontinuities at 

patch boundaries
(cid:214) Create patch overlap, blend adjacent patches

region of overlap

Sampling rates

Point positions

Normals

Point-Based Computer Graphics

Markus Gross

17

Point-Based Computer Graphics

Markus Gross

18

3

Reconstruction

• Blending the sampling rate

Timings

blended sampling 
rate in region of 
patch overlap

discretized
sampling rate       
on regular grid

pre-computed 
sampling patterns

Clustering

9%

Time

Patch
Merging

SDA

Analysis

38%

23%

4%

Reconstruction

26%

Point-Based Computer Graphics

Markus Gross

19

Point-Based Computer Graphics

Markus Gross

20

Applications

• Surface Restoration

Applications

• Interactive filtering

Original           Gaussian low-pass     Wiener filter           Patch layout

Point-Based Computer Graphics

Markus Gross

21

Point-Based Computer Graphics

Markus Gross

22

Applications

• Adaptive Subsampling

Summary

• Versatile spectral decomposition of point-

based models

• Effective filtering

• Adaptive resampling
• Efficient processing of large point-sampled 

models

4,128,614 pts. = 100%

287,163 pts. = 6.9%

Point-Based Computer Graphics

Markus Gross

23

Point-Based Computer Graphics

Markus Gross

24

4

Reference

• Pauly, Gross: Spectral Processing of Point-sampled 

Geometry, SIGGRAPH 2001

Point-Based Computer Graphics

Markus Gross

25

5

An Interactive System for Point-based 

Surface Editing

Overview

• Introduction
• Pointshop3D System Components

• Point Cloud Parameterization
• Resampling Scheme
• Editing Operators

• Summary

Point-Based Computer Graphics

Markus Gross

2

PointShop3D

• Interactive system for point-based surface 

editing

• Generalizes 2D photo editing concepts and 
functionality to 3D point-sampled surfaces
• Uses 3D surface pixels (surfels) as versatile 

display and modeling primitive

Concept

Parameterization

Point-Based Computer Graphics

Markus Gross

3

Point-Based Computer Graphics

Markus Gross

4

v

u

Resampling

Editing Operator

Key Components

• Point cloud parameterization

Φ

• brings surface and brush into common reference frame

• Dynamic resampling

Ψ

Parameterization

• Constrained minimum distortion 
parameterization of point clouds

• creates one-to-one correspondence of surface and brush 

samples

• Editing operator

Ω

(

• combines surface and brush samples
Ψ
(
)),
original surface

ΦΨΩ=′

modified surface

S

(

S

∈

u

]1,0[
2

⇒

X

u
)(

=

u
x
)(
u
y
)(
u
z
)(













(

B
))
brush

⊂∈=

RP

x

3

Point-Based Computer Graphics

Markus Gross

5

Point-Based Computer Graphics

Markus Gross

6

1

Parameterization

Parameterization

• Find mapping X that minimizes objective 

function:

brush points

surface points

contraints = matching 

of feature points

minimum distortion = 
maximum smoothness

fitting constraints

XC

(

)

=

−
{∑
)

p
(

X

(

j

∈
Mj

x

2

)

j

+

uu
d
)(

γε
∫
{
P
distortion

Point-Based Computer Graphics

Markus Gross

7

Point-Based Computer Graphics

Markus Gross

8

Parameterization

• Measuring distortion

γ
u
)(

=

∂
2
∂
r

2

∫




θ

X

u

θ
r
),(

θ
d

2





θ

r

u

• Integrates squared curvature using local polar 

re-parameterization

X

u

θ
r
),(

=

X

u





+
r



cos(
sin(

θ
)
θ
)









Parameterization

• Discrete formulation:

(~
UC

)

=

p
(

j

−

u

2

)

j

+

∑

∈
Mj

n

ε
∑ ∑
i

= ∈
1

Nj

i

∂
U
(
∂
v






x

i

)

j

∂−
U
(
~
∂
v

x

i

)

j

2






• Approximation: mapping is piecewise linear

Point-Based Computer Graphics

Markus Gross

9

Point-Based Computer Graphics

Markus Gross

10

Parameterization

Parameterization

• Directional derivatives as extension of divided 

differences based on k-nearest neighbors

• Multigrid solver for efficient computation of 
resulting sparse linear least squares problem

(~
UC

)

= ∑

j





−

b

j

n

∑

=
1

i

a

u

i

ij
,

2


=


−

b

A

u

2

Point-Based Computer Graphics

Markus Gross

11

Point-Based Computer Graphics

Markus Gross

12

2

Reconstruction

• Parameterized scattered data approximation

Reconstruction

fitting functions

X

u
)(

=

u
u
)()(

i

∑Φ
∑

i

i

r
i
u
)(

r
i

weight functions

normalization factor

• Fitting functions

• Compute local fitting functions using local 

parameterizations

• Map to global parameterization using global parameter 

coordinates of neighboring points

reconstruction with 
linear fitting functions

weight functions in 
parameter space

Point-Based Computer Graphics

Markus Gross

13

Point-Based Computer Graphics

Markus Gross

14

Reconstruction

Sampling

• Reconstruction with linear fitting functions is 

equivalent to surface splatting!
(cid:214) we can use the surface splatting renderer to reconstruct 

our surface function (see chapter on rendering)

• This provides:

• Fast evaluation
• Anti-aliasing (Band-limit the weight functions before 

sampling using Gaussian low-pass filter)

• Distortions of splats due to parameterization can be 

computed efficiently using local affine mappings

• Three sampling strategies:

• Resample the brush, i.e., sample at the original 

surface points

• Resample the surface, i.e., sample at the brush 

points

• Adaptive resampling, i.e., sample at surface or 

brush points depending on the respective 
sampling density

Point-Based Computer Graphics

Markus Gross

15

Point-Based Computer Graphics

Markus Gross

16

Editing Operators

• Painting

• Texture, material properties, transparency

Editing Operators

• Sculpting

• Carving, normal displacement

Point-Based Computer Graphics

Markus Gross

17

Point-Based Computer Graphics

Markus Gross

18

texture map

displacement maps

carved and texture mapped 

point-sampled surface

3

Editing Operators

• Filtering

• Scalar attributes, geometry

Summary

• Pointshop3D provides sophisticated editing 

operations on point-sampled surfaces
(cid:214)points are a versatile and powerful modeling 

primitive

• Limitation: only works on “clean” models

• sufficiently high sampling density
• no outliers
• little noise
(cid:214)requires model cleaning (integrated or as pre-

process)

Point-Based Computer Graphics

Markus Gross

19

Point-Based Computer Graphics

Markus Gross

20

Reference

• Zwicker, Pauly, Knoll, Gross: Pointshop3D: An 

interactive system for Point-based Surface Editing, 
SIGGRAPH 2002

• check out:

www.pointshop3D.com

Point-Based Computer Graphics

Markus Gross

21

4

Shape Modeling

Motivation

• 3D content creation pipeline

Mark Pauly

Point-Based Computer Graphics

Mark Pauly

2

Motivation

Motivation

• Surface representations

• Surface representations

• Implicit surfaces

• Level sets
• Radial basis functions
• Algebraic surfaces

• Parametric surfaces

• Polygonal meshes
• Subdivision surfaces
• NURBS

+ Extreme deformations
+ Changes of topology

+ Sharp features
+ Efficient rendering
+ Intuitive Editing

• Implicit surfaces

• Level sets
• Radial basis functions
• Algebraic surfaces

• Parametric surfaces

• Polygonal meshes
• Subdivision surfaces
• Nurbs

Hybrid Representation
• Explicit cloud of point 

samples

• Implicit dynamic 

surface model

Point-Based Computer Graphics

Mark Pauly

3

Point-Based Computer Graphics

Mark Pauly

4

Motivation

• Point cloud representation

• Minimal consistency requirements for extreme 

deformations (dynamic re-sampling)

• Fast inside/outside classification for boolean 

operations and collision detection

• Explicit modeling and rendering of sharp feature 

curves

• Integrated, intuitive editing of shape and 

appearance

Interactive Modeling

• Interactive design and editing of 

point-sampled models
• Shape Modeling

• Boolean operations
• Free-form deformation
• Appearance Modeling

• Painting & texturing
• Embossing & engraving

Point-Based Computer Graphics

Mark Pauly

5

Point-Based Computer Graphics

Mark Pauly

6

1

Boolean Operations

Boolean Operations

+

-

-

• Create new shapes by combining existing 

models using union, intersection, or 
difference operations

• Powerful and flexible editing paradigm 

mostly used in industrial design applications 
(CAD/CAM)

Point-Based Computer Graphics

Mark Pauly

7

Point-Based Computer Graphics

Mark Pauly

8

Boolean Operations

• Easily performed on implicit 

representations
• Requires simple computations on the 

distance function

• Difficult for parametric surfaces

• Requires surface-surface intersection
• Topological complexity of resulting 

surface depends on geometric 
complexity of input models

Boolean Operations

• Point-Sampled Geometry

• Classification

• Inside-outside test using signed distance 

function induced by MLS projection

• Sampling

• Compute exact intersection of two MLS 

surfaces to sample the intersection curve

• Rendering

• Accurate depiction of sharp corners and 

creases using point-based rendering

Point-Based Computer Graphics

Mark Pauly

9

Point-Based Computer Graphics

Mark Pauly

10

Boolean Operations

• Classification:

• given a smooth, closed 

surface S and point p. Is p 
inside or outside of the 
volume V bounded by S?

S

p

V

Boolean Operations

• Classification:

• given a smooth, closed 

surface S and point p. Is p 
inside or outside of the 
volume V bounded by S?
1.find closest point q on S

S

p

V

q

Point-Based Computer Graphics

Mark Pauly

11

Point-Based Computer Graphics

Mark Pauly

12

2

Boolean Operations

• Classification:

Boolean Operations

• Classification:

• given a smooth, closed 

surface S and point p. Is p 
inside or outside of the 
volume V bounded by S?
1.find closest point q on S
2.d=(p-q)·n defines signed 

distance of p to S

S

V

p

n

q

• given a smooth, closed 

surface S and point p. Is p 
inside or outside of the 
volume V bounded by S?
1.find closest point q on S
2.d=(p-q)·n defines signed 

distance of p to S 

S

V

p

n

q

Point-Based Computer Graphics

Mark Pauly

13

Point-Based Computer Graphics

Mark Pauly

14

3.classify p as

– inside V, if d < 0
– outside V, if d > 0

Boolean Operations

• Classification:

• represent smooth surface S

by point cloud P
m

S

P

V

Boolean Operations

• Classification:

• represent smooth surface S

by point cloud P
m

1.find closest point q in P

S

P

p

V

n

q

Point-Based Computer Graphics

Mark Pauly

15

Point-Based Computer Graphics

Mark Pauly

16

Boolean Operations

• Classification:

• represent smooth surface S

by point cloud P
m

1.find closest point q in P
2.classify p as

– inside V, if (p-q)·n < 0
– outside V, if (p-q)·n > 0

S

P

p

V

n

q

Boolean Operations

• Classification:

• apply full MLS projection for points close 

to the surface

p

q

(pPΨ

)

n

Point-Based Computer Graphics

Mark Pauly

17

Point-Based Computer Graphics

Mark Pauly

18

3

Boolean Operations

• Sampling the intersection curve

Boolean Operations

• Newton scheme:

1.identify pairs of closest points

Point-Based Computer Graphics

Mark Pauly

19

Point-Based Computer Graphics

Mark Pauly

20

Boolean Operations

• Newton scheme:

1.identify pairs of closest points

Boolean Operations

• Newton scheme:

identify pairs of closest points

1.
2. compute closest point on intersection of 

tangent spaces

1q

2q

r

1q

2q

Point-Based Computer Graphics

Mark Pauly

21

Point-Based Computer Graphics

Mark Pauly

22

Boolean Operations

• Newton scheme:

identify pairs of closest points

1.
2. compute closest point on intersection of 

tangent spaces
re-project point on both surfaces

3.

1q′

2q′

r

1q

2q

Boolean Operations

• Newton scheme:

identify pairs of closest points

1.
2. compute closest point on intersection of 

tangent spaces
re-project point on both surfaces
iterate

3.
4.

1q′

r ′

2q′

Point-Based Computer Graphics

Mark Pauly

23

Point-Based Computer Graphics

Mark Pauly

24

4

Boolean Operations

• Rendering sharp creases

• represent points on intersection curve with 

two surfels that mutually clip each other

Boolean Operations

• Rendering sharp creases

Point-Based Computer Graphics

Mark Pauly

25

Point-Based Computer Graphics

Mark Pauly

26

Boolean Operations

Boolean Operations

• Rendering sharp creases

• easily extended to handle corners by 

allowing multiple clipping

• Boolean operations can create intricate 

shapes with complex topology

BA +

BA −

BA ⋅

AB −

Point-Based Computer Graphics

Mark Pauly

27

Point-Based Computer Graphics

Mark Pauly

28

Boolean Operations

Boolean Operations

• Singularities lead to numerical instabilities 

(intersection of almost parallel planes)

• Sharp creases can be blended using 

oriented particles (Szeliski, Tonnesen)

Point-Based Computer Graphics

Mark Pauly

29

Point-Based Computer Graphics

Mark Pauly

30

5

Free-form Deformation

Free-form Deformation
• Smooth deformation field F:R3→R3 that 

warps 3D space

• Can be applied directly to point samples

Point-Based Computer Graphics

Mark Pauly

31

Point-Based Computer Graphics

Mark Pauly

32

Free-form Deformation

Free-form Deformation

• How to define the deformation field?

(cid:214) Painting metaphor

• How to detect and handle self-

intersections?
(cid:214) Point-based collision detection, boolean 

union, particle-based blending

• How the handle strong distortions?

(cid:214) Dynamic re-sampling

• Intuitive editing paradigm using 

painting metaphor
• Define rigid surface part (zero-region) 

and handle (one-region) using interactive 
painting tool

• Displace handle using combination of 

translation and rotation

• Create smooth blend towards zero-region

Point-Based Computer Graphics

Mark Pauly

33

Point-Based Computer Graphics

Mark Pauly

34

Free-form Deformation

Free-form Deformation

• Definition of deformation field:

zero-region

one-region

original
surface

deformed
surface

x

d0

d1

• Continuous scale parameter tx

• tx = β(d0 / (d0 + d1))
• d0 : distance of x to zero-region
• d1 : distance of x to one-region
• Blending function               

• β: [0,1] → [0,1]
• β∈C0, β(0) = 0, β(1) = 1
• tx = 0 if x in zero-region
• tx = 1 if x in one-region

Point-Based Computer Graphics

Mark Pauly

35

Point-Based Computer Graphics

Mark Pauly

36

6

Free-form Deformation

• Definition of deformation field:

• Deformation function

• F (x) = FT (x) + FR (x) 

• Translation

• FT (x) = x + tx · v

• Rotation

• FR (x) = M(tx) · x

x

d0

d1

Free-form Deformation

• Translation for three different blending functions

blending
function

deformed
surface

Point-Based Computer Graphics

Mark Pauly

37

Point-Based Computer Graphics

Mark Pauly

38

Free-form Deformation

Free-form Deformation

• Rotational deformation along two different 

rotation axes

• Embossing effect

bitmap
image

original
surface

color-coded

scale parameter

deformed
surface

zero- and
one-regions

deformed
surface

Point-Based Computer Graphics

Mark Pauly

39

Point-Based Computer Graphics

Mark Pauly

40

Collision Detection

• Deformations can lead to self-

intersections

• Apply boolean inside/outside 

classification to detect collisions
• Restricted to collisions between 

deformable region and zero-region to 
ensure efficient computations

Collision Detection

• Exploiting temporal coherence

Point-Based Computer Graphics

Mark Pauly

41

Point-Based Computer Graphics

Mark Pauly

42

7

Collision Detection

• Interactive modeling session

collision
detected

Dynamic Sampling

• Large model deformations can lead to 

strong surface distortions

• Requires adaptation of the sampling 

density

• Dynamic insertion and deletion of 

point samples

boolean union

performed

particle-based

blending

Point-Based Computer Graphics

Mark Pauly

43

Point-Based Computer Graphics

Mark Pauly

44

Dynamic Sampling

• Surface distortion varies locally

Dynamic Sampling

1. Measure local surface stretch from first 

fundamental form

2. Split samples that exceed stretch 

threshold 

3. Regularize distribution by relaxation
4. Interpolate scalar attributes

color-coded

surface stretch

surface after

dynamic re-sampling

Point-Based Computer Graphics

Mark Pauly

45

Point-Based Computer Graphics

Mark Pauly

46

Dynamic Sampling

• 2D illustration

Free-form Deformation

• Interactive modeling session with dynamic sampling

original surface
with zero- and

one-regions

intermediate steps

of deformation

final

surface

Point-Based Computer Graphics

Mark Pauly

47

Point-Based Computer Graphics

Mark Pauly

48

8

Results

Results

• 3D shape modeling functionality has been 

integrated into Pointshop3D to create a 
complete system for point-based shape and 
appearance modeling
• Boolean operations
• Free-form deformation
• Painting & texturing
• Sculpting
• Filtering
• Etc.

• Ab-initio design of an Octopus

• Free-form deformation with dynamic sampling 

from 69,706 to 295,222 points

Point-Based Computer Graphics

Mark Pauly

49

Point-Based Computer Graphics

Mark Pauly

50

Results

Results

• Modeling with synthetic and scanned data

• Combination of free-form deformation with 

collision detection, boolean operations, 
particle-based blending, embossing and 
texturing

• Boolean operations on scanned data

• Irregular sampling pattern, low resolution 

models

Point-Based Computer Graphics

Mark Pauly

51

Point-Based Computer Graphics

Mark Pauly

52

Results

Conclusion

• Interactive modeling with scanned data

• noise removal, free-form deformation, cut-and-

paste editing, interactive texture mapping

• Points are a versatile shape modeling 

primitive
• Combines advantages of implicit and 

parametric surfaces

• Integrates boolean operations and free-

form deformation

• Dynamic restructuring
• Time and space efficient 

implementations

Point-Based Computer Graphics

Mark Pauly

53

Point-Based Computer Graphics

Mark Pauly

54

9

Conclusion

References

• Complete and versatile point-based 
3D shape and appearance modeling 
system
• Directly applicable to scanned data 
• Suitable for low-cost 3D content creation 

and rapid proto-typing

• Pauly: Point Primitives for Interactive Modeling and 

Processing of 3D Geometry, PhD Thesis, ETH Zurich, 2003
• Pauly, Keiser, Kobbelt, Gross: Shape Modeling with Point-

sampled Geometry, SIGGRAPH 03

• Pauly, Kobbelt, Gross: Multiresolution Modeling with Point-

sampled Geometry, ETH Technical Report, 2002

• Zwicker, Pauly, Knoll, Gross: Pointshop3D: An Interactive 

System for Point-based Surface Editing, SIGGRAPH 02

• Adams, Dutre: Boolean Operations on Surfel-Bounded Solids, 

SIGGRAPH 03

• Szeliski, Tonnesen: Surface Modeling with Oriented Particle 

Systems, SIGGRAPH 92
• www.pointshop3d.com

Point-Based Computer Graphics

Mark Pauly

55

Point-Based Computer Graphics

Mark Pauly

56

10

